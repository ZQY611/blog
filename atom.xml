<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人博客</title>
  
  <subtitle>BCH</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.bochunhao.cn/"/>
  <updated>2019-03-26T09:12:51.652Z</updated>
  <id>http://blog.bochunhao.cn/</id>
  
  <author>
    <name>BCH</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>css</title>
    <link href="http://blog.bochunhao.cn/2019/03/26/css/"/>
    <id>http://blog.bochunhao.cn/2019/03/26/css/</id>
    <published>2019-03-26T08:51:16.000Z</published>
    <updated>2019-03-26T09:12:51.652Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-介绍一下标准的-CSS-的盒子模型？与低版本-IE-的盒子模型有什么不同的？"><a href="#1-介绍一下标准的-CSS-的盒子模型？与低版本-IE-的盒子模型有什么不同的？" class="headerlink" title="1 介绍一下标准的 CSS 的盒子模型？与低版本 IE 的盒子模型有什么不同的？"></a>1 介绍一下标准的 CSS 的盒子模型？与低版本 IE 的盒子模型有什么不同的？</h4><p>标准盒子模型：宽度=内容的宽度（content）+ border + padding + margin<br>低版本 IE 盒子模型：宽度=内容宽度（content+border+padding）+ margin</p><h4 id="2-box-sizing-属性？"><a href="#2-box-sizing-属性？" class="headerlink" title="2 box-sizing 属性？"></a>2 box-sizing 属性？</h4><p>用来控制元素的盒子模型的解析模式，默认为 content-box<br>context-box：W3C 的标准盒子模型，设置元素的 height/width 属性指的是 content 部分的高/宽<br>border-box：IE 传统盒子模型。设置元素的 height/width 属性指的是 border + padding + content 部分的高/宽</p><h4 id="3-CSS-选择器有哪些？哪些属性可以继承？"><a href="#3-CSS-选择器有哪些？哪些属性可以继承？" class="headerlink" title="3 CSS 选择器有哪些？哪些属性可以继承？"></a>3 CSS 选择器有哪些？哪些属性可以继承？</h4><p>CSS 选择符：id 选择器(#myid)、类选择器(.myclassname)、标签选择器(div, h1, p)、相邻选择器(h1 + p)、子选择器（ul &gt; li）、后代选择器（li a）、通配符选择器（*）、属性选择器（a[rel=”external”]）、伪类选择器（a:hover, li:nth-child）<br>可继承的属性：font-size, font-family, color<br>不可继承的样式：border, padding, margin, width, height<br>优先级（就近原则）：!important &gt; [ id &gt; class &gt; tag ]<br>!important 比内联优先级高</p><h4 id="4-CSS-优先级算法如何计算？"><a href="#4-CSS-优先级算法如何计算？" class="headerlink" title="4 CSS 优先级算法如何计算？"></a>4 CSS 优先级算法如何计算？</h4><p>元素选择符： 1<br>class 选择符： 10<br>id 选择符：100<br>元素标签：1000<br>!important 声明的样式优先级最高，如果冲突再进行计算。<br>如果优先级相同，则选择最后出现的样式。<br>继承得到的样式的优先级最低。</p><h4 id="5-CSS3-新增伪类有那些"><a href="#5-CSS3-新增伪类有那些" class="headerlink" title="5 CSS3 新增伪类有那些?"></a>5 CSS3 新增伪类有那些?</h4><p>p:first-of-type 选择属于其父元素的首个元素<br>p:last-of-type 选择属于其父元素的最后元素<br>p:only-of-type 选择属于其父元素唯一的元素<br>p:only-child 选择属于其父元素的唯一子元素<br>p:nth-child(2) 选择属于其父元素的第二个子元素<br>:enabled :disabled 表单控件的禁用状态。<br>:checked 单选框或复选框被选中。</p><h4 id="6-如何居中-div？如何居中一个浮动元素？如何让绝对定位的-div-居中？"><a href="#6-如何居中-div？如何居中一个浮动元素？如何让绝对定位的-div-居中？" class="headerlink" title="6 如何居中 div？如何居中一个浮动元素？如何让绝对定位的 div 居中？"></a>6 如何居中 div？如何居中一个浮动元素？如何让绝对定位的 div 居中？</h4><p>div：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">border: 1px solid red;</span><br><span class="line">margin: 0 auto;</span><br><span class="line">height: 50px;</span><br><span class="line">width: 80px;</span><br></pre></td></tr></table></figure><p>浮动元素的上下左右居中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">border: 1px solid red;</span><br><span class="line"><span class="built_in">float</span>: left;</span><br><span class="line">position: absolute;</span><br><span class="line">width: 200px;</span><br><span class="line">height: 100px;</span><br><span class="line">left: 50%;</span><br><span class="line">top: 50%;</span><br><span class="line">margin: -50px 0 0 -100px;</span><br></pre></td></tr></table></figure><p>绝对定位的左右居中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">border: 1px solid black;</span><br><span class="line">position: absolute;</span><br><span class="line">width: 200px;</span><br><span class="line">height: 100px;</span><br><span class="line">margin: 0 auto;</span><br><span class="line">left: 0;</span><br><span class="line">right: 0;</span><br></pre></td></tr></table></figure><p>还有更加优雅的居中方式就是用 flexbox，我以后会做整理。</p><h4 id="7-display-有哪些值？说明他们的作用"><a href="#7-display-有哪些值？说明他们的作用" class="headerlink" title="7 display 有哪些值？说明他们的作用?"></a>7 display 有哪些值？说明他们的作用?</h4><p>inline（默认）–内联<br>none–隐藏<br>block–块显示<br>table–表格显示<br>list-item–项目列表<br>inline-block</p><h4 id="8-position-的值？"><a href="#8-position-的值？" class="headerlink" title="8 position 的值？"></a>8 position 的值？</h4><p>static（默认）：按照正常文档流进行排列；<br>relative（相对定位）：不脱离文档流，参考自身静态位置通过 top, bottom, left, right 定位；<br>absolute(绝对定位)：参考距其最近一个不为 static 的父级元素通过 top, bottom, left, right 定位；<br>fixed(固定定位)：所固定的参照对像是可视窗口。</p><h4 id="9-CSS3-有哪些新特性？"><a href="#9-CSS3-有哪些新特性？" class="headerlink" title="9 CSS3 有哪些新特性？"></a>9 CSS3 有哪些新特性？</h4><p>RGBA 和透明度<br>background-image background-origin(content-box/padding-box/border-box) background-size background-repeat<br>word-wrap（对长的不可分割单词换行）word-wrap：break-word<br>文字阴影：text-shadow： 5px 5px 5px #FF0000;（水平阴影，垂直阴影，模糊距离，阴影颜色）<br>font-face 属性：定义自己的字体<br>圆角（边框半径）：border-radius 属性用于创建圆角<br>边框图片：border-image: url(border.png) 30 30 round<br>盒阴影：box-shadow: 10px 10px 5px #888888<br>媒体查询：定义两套 css，当浏览器的尺寸变化时会采用不同的属性</p><h4 id="10-请解释一下-CSS3-的-flexbox（弹性盒布局模型）-以及适用场景？"><a href="#10-请解释一下-CSS3-的-flexbox（弹性盒布局模型）-以及适用场景？" class="headerlink" title="10 请解释一下 CSS3 的 flexbox（弹性盒布局模型）,以及适用场景？"></a>10 请解释一下 CSS3 的 flexbox（弹性盒布局模型）,以及适用场景？</h4><p>该布局模型的目的是提供一种更加高效的方式来对容器中的条目进行布局、对齐和分配空间。在传统的布局方式中，block 布局是把块在垂直方向从上到下依次排列的；而 inline 布局则是在水平方向来排列。弹性盒布局并没有这样内在的方向限制，可以由开发人员自由操作。<br>试用场景：弹性布局适合于移动前端开发，在 Android 和 ios 上也完美支持。</p><h4 id="11-用纯-CSS-创建一个三角形的原理是什么？"><a href="#11-用纯-CSS-创建一个三角形的原理是什么？" class="headerlink" title="11 用纯 CSS 创建一个三角形的原理是什么？"></a>11 用纯 CSS 创建一个三角形的原理是什么？</h4><p>首先，需要把元素的宽度、高度设为 0。然后设置边框样式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">width: 0;</span><br><span class="line">height: 0;</span><br><span class="line">border-top: 40px solid transparent;</span><br><span class="line">border-left: 40px solid transparent;</span><br><span class="line">border-right: 40px solid transparent;</span><br><span class="line">border-bottom: 40px solid <span class="comment">#ff0000;</span></span><br></pre></td></tr></table></figure><h4 id="12-一个满屏品字布局如何设计"><a href="#12-一个满屏品字布局如何设计" class="headerlink" title="12 一个满屏品字布局如何设计?"></a>12 一个满屏品字布局如何设计?</h4><p>第一种真正的品字：<br>三块高宽是确定的；<br>上面那块用 margin: 0 auto;居中；<br>下面两块用 float 或者 inline-block 不换行；<br>用 margin 调整位置使他们居中。<br>第二种全屏的品字布局:<br>上面的 div 设置成 100%，下面的 div 分别宽 50%，然后使用 float 或者 inline 使其不换行。</p><h4 id="13-常见的兼容性问题？"><a href="#13-常见的兼容性问题？" class="headerlink" title="13 常见的兼容性问题？"></a>13 常见的兼容性问题？</h4><p>不同浏览器的标签默认的 margin 和 padding 不一样。*{margin:0;padding:0;}</p><h5 id="IE6-双边距-bug：块属性标签-float-后，又有横行的-margin-情况下，在-IE6-显示-margin-比设置的大。"><a href="#IE6-双边距-bug：块属性标签-float-后，又有横行的-margin-情况下，在-IE6-显示-margin-比设置的大。" class="headerlink" title="IE6 双边距 bug：块属性标签 float 后，又有横行的 margin 情况下，在 IE6 显示 margin 比设置的大。"></a>IE6 双边距 bug：块属性标签 float 后，又有横行的 margin 情况下，在 IE6 显示 margin 比设置的大。</h5><p>hack：display:inline;将其转化为行内属性。<br>渐进识别的方式，从总体中逐渐排除局部。首先，巧妙的使用“9”这一标记，将 IE 浏览器从所有情况中分离出来。接着，再次使用“+”将 IE8 和 IE7、IE6 分离开来，这样 IE8 已经独立识别。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">background-color:<span class="comment">#f1ee18;/*所有识别*/</span></span><br><span class="line">.background-color:<span class="comment">#00deff\9; /*IE6、7、8识别*/</span></span><br><span class="line">+background-color:<span class="comment">#a200ff;/*IE6、7识别*/</span></span><br><span class="line">_background-color:<span class="comment">#1e0bd1;/*IE6识别*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置较小高度标签（一般小于 10px），在 IE6，IE7 中高度超出自己设置高度。hack：给超出高度的标签设置 overflow:hidden;或者设置行高 line-height 小于你设置的高度。<br>IE 下，可以使用获取常规属性的方法来获取自定义属性,也可以使用 getAttribute()获取自定义属性；Firefox 下，只能使用 getAttribute()获取自定义属性。解决方法:统一通过 getAttribute()获取自定义属性。<br>Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决。<br>超链接访问过后 hover 样式就不出现了，被点击访问过的超链接样式不再具有 hover 和 active 了。解决方法是改变 CSS 属性的排列顺序:L-V-H-A ( love hate ): a:link {} a:visited {} a:hover {} a:active {}</p><h4 id="14-为什么要初始化-CSS-样式"><a href="#14-为什么要初始化-CSS-样式" class="headerlink" title="14 为什么要初始化 CSS 样式"></a>14 为什么要初始化 CSS 样式</h4><p>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对 CSS 初始化往往会出现浏览器之间的页面显示差异。</p><h4 id="15-absolute-的-containing-block-计算方式跟正常流有什么不同？"><a href="#15-absolute-的-containing-block-计算方式跟正常流有什么不同？" class="headerlink" title="15 absolute 的 containing block 计算方式跟正常流有什么不同？"></a>15 absolute 的 containing block 计算方式跟正常流有什么不同？</h4><p>无论属于哪种，都要先找到其祖先元素中最近的 position 值不为 static 的元素，然后再判断：<br>若此元素为 inline 元素，则 containing block 为能够包含这个元素生成的第一个和最后一个 inline box 的 padding box (除 margin, border 外的区域) 的最小矩形；<br>否则,则由这个祖先元素的 padding box 构成。<br>如果都找不到，则为 initial containing block。<br>补充：<br>static(默认的)/relative：简单说就是它的父元素的内容框（即去掉 padding 的部分）<br>absolute: 向上找最近的定位为 absolute/relative 的元素<br>fixed: 它的 containing block 一律为根元素(html/body)</p><h4 id="16-CSS-里的-visibility-属性有个-collapse-属性值？在不同浏览器下以后什么区别？"><a href="#16-CSS-里的-visibility-属性有个-collapse-属性值？在不同浏览器下以后什么区别？" class="headerlink" title="16 CSS 里的 visibility 属性有个 collapse 属性值？在不同浏览器下以后什么区别？"></a>16 CSS 里的 visibility 属性有个 collapse 属性值？在不同浏览器下以后什么区别？</h4><p>当一个元素的 visibility 属性被设置成 collapse 值后，对于一般的元素，它的表现跟 hidden 是一样的。<br>chrome 中，使用 collapse 值和使用 hidden 没有区别。<br>firefox，opera 和 IE，使用 collapse 值和使用 display：none 没有什么区别。</p><h4 id="17-display-none-与-visibility：hidden-的区别？"><a href="#17-display-none-与-visibility：hidden-的区别？" class="headerlink" title="17 display:none 与 visibility：hidden 的区别？"></a>17 display:none 与 visibility：hidden 的区别？</h4><p>display：none 不显示对应的元素，在文档布局中不再分配空间（回流+重绘）<br>visibility：hidden 隐藏对应元素，在文档布局中仍保留原来的空间（重绘）</p><h4 id="18-position-跟-display、overflow、float-这些特性相互叠加后会怎么样？"><a href="#18-position-跟-display、overflow、float-这些特性相互叠加后会怎么样？" class="headerlink" title="18 position 跟 display、overflow、float 这些特性相互叠加后会怎么样？"></a>18 position 跟 display、overflow、float 这些特性相互叠加后会怎么样？</h4><p>display 属性规定元素应该生成的框的类型；position 属性规定元素的定位类型；float 属性是一种布局方式，定义元素在哪个方向浮动。<br>类似于优先级机制：position：absolute/fixed 优先级最高，有他们在时，float 不起作用，display 值需要调整。float 或者 absolute 定位的元素，只能是块元素或表格。</p><h4 id="19-对-BFC-规范-块级格式化上下文：block-formatting-context-的理解？"><a href="#19-对-BFC-规范-块级格式化上下文：block-formatting-context-的理解？" class="headerlink" title="19 对 BFC 规范(块级格式化上下文：block formatting context)的理解？"></a>19 对 BFC 规范(块级格式化上下文：block formatting context)的理解？</h4><p>BFC 规定了内部的 Block Box 如何布局。<br>定位方案：<br>内部的 Box 会在垂直方向上一个接一个放置。<br>Box 垂直方向的距离由 margin 决定，属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠。<br>每个元素的 margin box 的左边，与包含块 border box 的左边相接触。<br>BFC 的区域不会与 float box 重叠。<br>BFC 是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。<br>计算 BFC 的高度时，浮动元素也会参与计算。<br>满足下列条件之一就可触发 BFC<br>根元素，即 html<br>float 的值不为 none（默认）<br>overflow 的值不为 visible（默认）<br>display 的值为 inline-block、table-cell、table-caption<br>position 的值为 absolute 或 fixed</p><h4 id="20-为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？"><a href="#20-为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？" class="headerlink" title="20 为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？"></a>20 为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？</h4><p>浮动元素碰到包含它的边框或者浮动元素的边框停留。由于浮动元素不在文档流中，所以文档流的块框表现得就像浮动框不存在一样。浮动元素会漂浮在文档流的块框上。</p><h5 id="浮动带来的问题："><a href="#浮动带来的问题：" class="headerlink" title="浮动带来的问题："></a>浮动带来的问题：</h5><p>父元素的高度无法被撑开，影响与父元素同级的元素<br>与浮动元素同级的非浮动元素（内联元素）会跟随其后<br>若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构。</p><h5 id="清除浮动的方式："><a href="#清除浮动的方式：" class="headerlink" title="清除浮动的方式："></a>清除浮动的方式：</h5><p>父级 div 定义 height<br>最后一个浮动元素后加空 div 标签 并添加样式 clear:both。<br>包含浮动元素的父标签添加样式 overflow 为 hidden 或 auto。<br>父级 div 定义 zoom</p><h4 id="21-上下-margin-重合的问题"><a href="#21-上下-margin-重合的问题" class="headerlink" title="21 上下 margin 重合的问题"></a>21 上下 margin 重合的问题</h4><p>在重合元素外包裹一层容器，并触发该容器生成一个 BFC。<br>例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">"aside"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=<span class="string">"text"</span>&gt;</span><br><span class="line">    &lt;div class=<span class="string">"main"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--下面是css代码--&gt;</span><br><span class="line">.aside &#123;</span><br><span class="line">    margin-bottom: 100px;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 150px;</span><br><span class="line">    background: <span class="comment">#f66;</span></span><br><span class="line">&#125;</span><br><span class="line">.main &#123;</span><br><span class="line">    margin-top: 100px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    background: <span class="comment">#fcc;</span></span><br><span class="line">&#125;</span><br><span class="line">.text&#123;</span><br><span class="line">    /*盒子main的外面包一个div，通过改变此div的属性使两个盒子分属于两个不同的BFC，以此来阻止margin重叠*/</span><br><span class="line">    overflow: hidden;  //此时已经触发了BFC属性。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="22-设置元素浮动后，该元素的-display-值是多少？"><a href="#22-设置元素浮动后，该元素的-display-值是多少？" class="headerlink" title="22 设置元素浮动后，该元素的 display 值是多少？"></a>22 设置元素浮动后，该元素的 display 值是多少？</h4><p>自动变成 display:block</p><h4 id="23-移动端的布局用过媒体查询吗？"><a href="#23-移动端的布局用过媒体查询吗？" class="headerlink" title="23 移动端的布局用过媒体查询吗？"></a>23 移动端的布局用过媒体查询吗？</h4><p>通过媒体查询可以为不同大小和尺寸的媒体定义不同的 css，适应相应的设备的显示。<br>head 里边</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> <span class="built_in">type</span>=<span class="string">"text/css"</span> href=<span class="string">"xxx.css"</span></span><br><span class="line">      media=<span class="string">"only screen and (max-device-width:480px)"</span>&gt;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CSS : @media only screen and (max-device-width:480px) &#123;/css样式/&#125;</span><br></pre></td></tr></table></figure><h4 id="24-使用-CSS-预处理器吗？"><a href="#24-使用-CSS-预处理器吗？" class="headerlink" title="24 使用 CSS 预处理器吗？"></a>24 使用 CSS 预处理器吗？</h4><p>Less sass</p><h4 id="25-CSS-优化、提高性能的方法有哪些？"><a href="#25-CSS-优化、提高性能的方法有哪些？" class="headerlink" title="25 CSS 优化、提高性能的方法有哪些？"></a>25 CSS 优化、提高性能的方法有哪些？</h4><pre>避免过度约束避免后代选择符避免链式选择符使用紧凑的语法避免不必要的命名空间避免不必要的重复最好使用表示语义的名字。一个好的类名应该是描述他是什么而不是像什么避免！important，可以选择其他选择器尽可能的精简规则，你可以合并不同类里的重复规则</pre><h4 id="26-浏览器是怎样解析-CSS-选择器的？"><a href="#26-浏览器是怎样解析-CSS-选择器的？" class="headerlink" title="26 浏览器是怎样解析 CSS 选择器的？"></a>26 浏览器是怎样解析 CSS 选择器的？</h4><p>CSS 选择器的解析是从右向左解析的。若从左向右的匹配，发现不符合规则，需要进行回溯，会损失很多性能。若从右向左匹配，先找到所有的最右节点，对于每一个节点，向上寻找其父节点直到找到根元素或满足条件的匹配规则，则结束这个分支的遍历。两种匹配规则的性能差别很大，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点（叶子节点），而从左向右的匹配规则的性能都浪费在了失败的查找上面。<br>而在 CSS 解析完毕后，需要将解析的结果与 DOM Tree 的内容一起进行分析建立一棵 Render Tree，最终用来进行绘图。在建立 Render Tree 时（WebKit 中的「Attachment」过程），浏览器就要为每个 DOM Tree 中的元素根据 CSS 的解析结果（Style Rules）来确定生成怎样的 Render Tree。</p><h4 id="27-在网页中的应该使用奇数还是偶数的字体？为什么呢？"><a href="#27-在网页中的应该使用奇数还是偶数的字体？为什么呢？" class="headerlink" title="27 在网页中的应该使用奇数还是偶数的字体？为什么呢？"></a>27 在网页中的应该使用奇数还是偶数的字体？为什么呢？</h4><p>使用偶数字体。偶数字号相对更容易和 web 设计的其他部分构成比例关系。Windows 自带的点阵宋体（中易宋体）从 Vista 开始只提供 12、14、16 px 这三个大小的点阵，而 13、15、17 px 时用的是小一号的点。（即每个字占的空间大了 1 px，但点阵没变），于是略显稀疏。</p><h4 id="28-margin-和-padding-分别适合什么场景使用？"><a href="#28-margin-和-padding-分别适合什么场景使用？" class="headerlink" title="28 margin 和 padding 分别适合什么场景使用？"></a>28 margin 和 padding 分别适合什么场景使用？</h4><h5 id="何时使用-margin："><a href="#何时使用-margin：" class="headerlink" title="何时使用 margin："></a>何时使用 margin：</h5><p>需要在 border 外侧添加空白<br>空白处不需要背景色<br>上下相连的两个盒子之间的空白，需要相互抵消时。</p><h5 id="何时使用-padding："><a href="#何时使用-padding：" class="headerlink" title="何时使用 padding："></a>何时使用 padding：</h5><p>需要在 border 内侧添加空白<br>空白处需要背景颜色<br>上下相连的两个盒子的空白，希望为两者之和。 #####兼容性的问题：<br>在 IE5 IE6 中，为 float 的盒子指定 margin 时，左侧的 margin 可能会变成两倍的宽度。通过改变 padding 或者指定盒子的 display：inline 解决。</p><h4 id="29-元素竖向的百分比设定是相对于容器的高度吗？"><a href="#29-元素竖向的百分比设定是相对于容器的高度吗？" class="headerlink" title="29 元素竖向的百分比设定是相对于容器的高度吗？"></a>29 元素竖向的百分比设定是相对于容器的高度吗？</h4><p>当按百分比设定一个元素的宽度时，它是相对于父容器的宽度计算的，但是，对于一些表示竖向距离的属性，例如 padding-top , padding-bottom , margin-top , margin-bottom 等，当按百分比设定它们时，依据的也是父容器的宽度，而不是高度。</p><h4 id="30-全屏滚动的原理是什么？用到了-CSS-的哪些属性？"><a href="#30-全屏滚动的原理是什么？用到了-CSS-的哪些属性？" class="headerlink" title="30 全屏滚动的原理是什么？用到了 CSS 的哪些属性？"></a>30 全屏滚动的原理是什么？用到了 CSS 的哪些属性？</h4><p>原理：有点类似于轮播，整体的元素一直排列下去，假设有 5 个需要展示的全屏页面，那么高度是 500%，只是展示 100%，剩下的可以通过 transform 进行 y 轴定位，也可以通过 margin-top 实现</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">overflow：hidden;transition：all 1000ms ease;</span><br></pre></td></tr></table></figure><h4 id="31-什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的-IE？"><a href="#31-什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的-IE？" class="headerlink" title="31 什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的 IE？"></a>31 什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的 IE？</h4><p>响应式网站设计(Responsive Web design)是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。<br>基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理。<br>页面头部必须有 meta 声明的 viewport。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=<span class="string">"viewport"</span></span><br><span class="line">      content=<span class="string">"width=device-width, initial-scale=1. maximum-scale=1,user-scalable=no"</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="32-视差滚动效果？"><a href="#32-视差滚动效果？" class="headerlink" title="32 视差滚动效果？"></a>32 视差滚动效果？</h4><p>视差滚动（Parallax Scrolling）通过在网页向下滚动的时候，控制背景的移动速度比前景的移动速度慢来创建出令人惊叹的 3D 效果。</p><h5 id="CSS3-实现"><a href="#CSS3-实现" class="headerlink" title="CSS3 实现"></a>CSS3 实现</h5><p>优点：开发时间短、性能和开发效率比较好，缺点是不能兼容到低版本的浏览器</p><h5 id="jQuery-实现"><a href="#jQuery-实现" class="headerlink" title="jQuery 实现"></a>jQuery 实现</h5><p>通过控制不同层滚动速度，计算每一层的时间，控制滚动效果。<br>优点：能兼容到各个版本的，效果可控性好<br>缺点：开发起来对制作者要求高<br>插件实现方式<br>例如：parallax-scrolling，兼容性十分好</p><h4 id="33-before-和-after-中双冒号和单冒号有什么区别？解释一下这-2-个伪元素的作用"><a href="#33-before-和-after-中双冒号和单冒号有什么区别？解释一下这-2-个伪元素的作用" class="headerlink" title="33 ::before 和 :after 中双冒号和单冒号有什么区别？解释一下这 2 个伪元素的作用"></a>33 ::before 和 :after 中双冒号和单冒号有什么区别？解释一下这 2 个伪元素的作用</h4><p>单冒号(:)用于 CSS3 伪类，双冒号(::)用于 CSS3 伪元素。<br>::before 就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于 dom 之中，只存在在页面之中。<br>:before 和 :after 这两个伪元素，是在 CSS2.1 里新出现的。起初，伪元素的前缀使用的是单冒号语法，但随着 Web 的进化，在 CSS3 的规范里，伪元素的语法被修改成使用双冒号，成为::before ::after</p><h4 id="34-你对-line-height-是如何理解的？"><a href="#34-你对-line-height-是如何理解的？" class="headerlink" title="34 你对 line-height 是如何理解的？"></a>34 你对 line-height 是如何理解的？</h4><p>行高是指一行文字的高度，具体说是两行文字间基线的距离。CSS 中起高度作用的是 height 和 line-height，没有定义 height 属性，最终其表现作用一定是 line-height。<br>单行文本垂直居中：把 line-height 值设置为 height 一样大小的值可以实现单行文字的垂直居中，其实也可以把 height 删除。<br>多行文本垂直居中：需要设置 display 属性为 inline-block。</p><h4 id="35-怎么让-Chrome-支持小于-12px-的文字？"><a href="#35-怎么让-Chrome-支持小于-12px-的文字？" class="headerlink" title="35 怎么让 Chrome 支持小于 12px 的文字？"></a>35 怎么让 Chrome 支持小于 12px 的文字？</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p&#123;font-size:10px;-webkit-transform:scale(0.8);&#125; //0.8是缩放比例</span><br></pre></td></tr></table></figure><h4 id="36-让页面里的字体变清晰，变细用-CSS-怎么做？"><a href="#36-让页面里的字体变清晰，变细用-CSS-怎么做？" class="headerlink" title="36 让页面里的字体变清晰，变细用 CSS 怎么做？"></a>36 让页面里的字体变清晰，变细用 CSS 怎么做？</h4><p>-webkit-font-smoothing 在 window 系统下没有起作用，但是在 IOS 设备上起作用-webkit-font-smoothing：antialiased 是最佳的，灰度平滑。</p><h4 id="37-position-fixed-在-android-下无效怎么处理？"><a href="#37-position-fixed-在-android-下无效怎么处理？" class="headerlink" title="37 position:fixed;在 android 下无效怎么处理？"></a>37 position:fixed;在 android 下无效怎么处理？</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=<span class="string">"viewport"</span></span><br><span class="line">      content=<span class="string">"width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0,</span></span><br><span class="line"><span class="string">      user-scalable=no"</span>/&gt;</span><br></pre></td></tr></table></figure><h4 id="38-如果需要手动写动画，你认为最小时间间隔是多久，为什么？"><a href="#38-如果需要手动写动画，你认为最小时间间隔是多久，为什么？" class="headerlink" title="38 如果需要手动写动画，你认为最小时间间隔是多久，为什么？"></a>38 如果需要手动写动画，你认为最小时间间隔是多久，为什么？</h4><p>多数显示器默认频率是 60Hz，即 1 秒刷新 60 次，所以理论上最小间隔为 1/60＊1000ms ＝ 16.7ms。</p><h4 id="39-li-与-li-之间有看不见的空白间隔是什么原因引起的？有什么解决办法？"><a href="#39-li-与-li-之间有看不见的空白间隔是什么原因引起的？有什么解决办法？" class="headerlink" title="39 li 与 li 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？"></a>39 li 与 li 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</h4><p>行框的排列会受到中间空白（回车空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为 0，就没有空格了。<br>解决方法：</p><pre>可以将li代码全部写在一排浮动li中float：left在ul中用font-size：0（谷歌不支持）；可以使用letter-space：-3px</pre><h4 id="40-display-inline-block-什么时候会显示间隙？"><a href="#40-display-inline-block-什么时候会显示间隙？" class="headerlink" title="40 display:inline-block 什么时候会显示间隙？"></a>40 display:inline-block 什么时候会显示间隙？</h4><p>有空格时候会有间隙 解决：移除空格<br>margin 正值的时候 解决：margin 使用负值<br>使用 font-size 时候 解决：font-size:0、letter-spacing、word-spacing</p><h4 id="41-有一个高度自适应的-div，里面有两个-div，一个高度-100px，希望另一个填满剩下的高度"><a href="#41-有一个高度自适应的-div，里面有两个-div，一个高度-100px，希望另一个填满剩下的高度" class="headerlink" title="41 有一个高度自适应的 div，里面有两个 div，一个高度 100px，希望另一个填满剩下的高度"></a>41 有一个高度自适应的 div，里面有两个 div，一个高度 100px，希望另一个填满剩下的高度</h4><p>外层 div 使用 position：relative；高度要求自适应的 div 使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">position: absolute; top: 100px; bottom: 0; left: 0</span><br></pre></td></tr></table></figure><h4 id="42-png、jpg、gif-这些图片格式解释一下，分别什么时候用。有没有了解过-webp？"><a href="#42-png、jpg、gif-这些图片格式解释一下，分别什么时候用。有没有了解过-webp？" class="headerlink" title="42 png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过 webp？"></a>42 png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过 webp？</h4><p>png 是便携式网络图片（Portable Network Graphics）是一种无损数据压缩位图文件格式.优点是：压缩比高，色彩好。 大多数地方都可以用。<br>jpg 是一种针对相片使用的一种失真压缩方法，是一种破坏性的压缩，在色调及颜色平滑变化做的不错。在 www 上，被用来储存和传输照片的格式。<br>gif 是一种位图文件格式，以 8 位色重现真色彩的图像。可以实现动画效果.<br>webp 格式是谷歌在 2010 年推出的图片格式，压缩率只有 jpg 的 2/3，大小比 png 小了 45%。缺点是压缩的时间更久了，兼容性不好，目前谷歌和 opera 支持。</p><h4 id="43-style-标签写在-body-后与-body-前有什么区别？"><a href="#43-style-标签写在-body-后与-body-前有什么区别？" class="headerlink" title="43 style 标签写在 body 后与 body 前有什么区别？"></a>43 style 标签写在 body 后与 body 前有什么区别？</h4><p>页面加载自上而下 当然是先加载样式。<br>写在 body 标签后由于浏览器以逐行方式对 HTML 文档进行解析，当解析到写在尾部的样式表（外联或写在 style 标签）会导致浏览器停止之前的渲染，等待加载且解析样式表完成之后重新渲染，在 windows 的 IE 下可能会出现 FOUC 现象（即样式失效导致的页面闪烁问题）</p><h4 id="44-CSS-属性-overflow-属性定义溢出元素内容区的内容会如何处理"><a href="#44-CSS-属性-overflow-属性定义溢出元素内容区的内容会如何处理" class="headerlink" title="44 CSS 属性 overflow 属性定义溢出元素内容区的内容会如何处理?"></a>44 CSS 属性 overflow 属性定义溢出元素内容区的内容会如何处理?</h4><p>参数是 scroll 时候，必会出现滚动条。<br>参数是 auto 时候，子元素内容大于父元素时出现滚动条。<br>参数是 visible 时候，溢出的内容出现在父元素之外。<br>参数是 hidden 时候，溢出隐藏。</p><h4 id="45-阐述一下-CSS-Sprites"><a href="#45-阐述一下-CSS-Sprites" class="headerlink" title="45 阐述一下 CSS Sprites"></a>45 阐述一下 CSS Sprites</h4><p>将一个页面涉及到的所有图片都包含到一张大图中去，然后利用 CSS 的 background-image，background- repeat，background-position 的组合进行背景定位。利用 CSS Sprites 能很好地减少网页的 http 请求，从而大大的提高页面的性能；CSS Sprites 能减少图片的字节。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-介绍一下标准的-CSS-的盒子模型？与低版本-IE-的盒子模型有什么不同的？&quot;&gt;&lt;a href=&quot;#1-介绍一下标准的-CSS-的盒子模型？与低版本-IE-的盒子模型有什么不同的？&quot; class=&quot;headerlink&quot; title=&quot;1 介绍一下标准的 CS
      
    
    </summary>
    
    
      <category term="css" scheme="http://blog.bochunhao.cn/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>mvvm</title>
    <link href="http://blog.bochunhao.cn/2018/10/26/mvvm/"/>
    <id>http://blog.bochunhao.cn/2018/10/26/mvvm/</id>
    <published>2018-10-26T13:59:31.000Z</published>
    <updated>2019-03-26T08:38:26.020Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><pre>涉及面试题：什么是 MVVM？比之 MVC 有什么区别？</pre><p>首先先申明一点，不管是 React 还是 Vue，它们都不是 MVVM 框架，只是有借鉴 MVVM 的思路。文中拿 Vue 举例也是为了更好地理解 MVVM 的概念。</p><p>接下来先说下 View 和 Model：</p><pre>View 很简单，就是用户看到的视图Model 同样很简单，一般就是本地数据和数据库中的数据</pre><p>基本上，我们写的产品就是通过接口从数据库中读取数据，然后将数据经过处理展现到用户看到的视图上。当然我们还可以从视图上读取用户的输入，然后又将用户的输入通过接口写入到数据库中。但是，如何将数据展示到视图上，然后又如何将用户的输入写入到数据中，不同的人就产生了不同的看法，从此出现了很多种架构设计。</p><p>传统的 MVC 架构通常是使用控制器更新模型，视图从模型中获取数据去渲染。当用户有输入时，会通过控制器去更新模型，并且通知视图进行更新。</p><p>但是 MVC 有一个巨大的缺陷就是控制器承担的责任太大了，随着项目愈加复杂，控制器中的代码会越来越臃肿，导致出现不利于维护的情况。</p><p>在 MVVM 架构中，引入了  ViewModel  的概念。ViewModel 只关心数据和业务的处理，不关心 View 如何处理数据，在这种情况下，View 和 Model 都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可复用的逻辑放在一个 ViewModel 中，让多个 View 复用这个 ViewModel。</p><p>以 Vue 框架来举例:</p><pre>ViewModel 就是组件的实例。View 就是模板。Model 的话在引入 Vuex 的情况下是完全可以和组件分离的。</pre><p>除了以上三个部分，其实在 MVVM 中还引入了一个隐式的 Binder 层，实现了 View 和 ViewModel 的绑定。</p><p>同样以 Vue 框架来举例，这个隐式的 Binder 层就是 Vue 通过解析模板中的插值和指令从而实现 View 与 ViewModel 的绑定。</p><p>对于 MVVM 来说，其实最重要的并不是通过双向绑定或者其他的方式将 View 与 ViewModel 绑定起来，而是通过 ViewModel 将视图中的状态和用户的行为分离出一个抽象，这才是 MVVM 的精髓。</p><h4 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h4><pre>涉及面试题：什么是 Virtual DOM？为什么 Virtual DOM 比原生 DOM 快？</pre><p>大家都知道操作 DOM 是很慢的，为什么慢的原因已经在「浏览器渲染原理」章节中说过，这里就不再赘述了。<br>那么相较于 DOM 来说，操作 JS 对象会快很多，并且我们也可以通过 JS 来模拟 DOM</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const ul = &#123;</span><br><span class="line">  tag: <span class="string">'ul'</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    class: <span class="string">'list'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  children: &#123;</span><br><span class="line">    tag: <span class="string">'li'</span>,</span><br><span class="line">    children: <span class="string">'1'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码对应的 DOM 就是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul class=<span class="string">'list'</span>&gt;</span><br><span class="line">  &lt;li&gt;1&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>那么既然 DOM 可以通过 JS 对象来模拟，反之也可以通过 JS 对象来渲染出对应的 DOM。当然了，通过 JS 来模拟 DOM 并且渲染对应的 DOM 只是第一步，难点在于如何判断新旧两个 JS 对象的最小差异并且实现局部更新  DOM。<br>首先 DOM 是一个多叉树的结构，如果需要完整的对比两颗树的差异，那么需要的时间复杂度会是 O(n ^ 3)，这个复杂度肯定是不能接受的。于是 React 团队优化了算法，实现了 O(n) 的复杂度来对比差异。 实现 O(n) 复杂度的关键就是只对比同层的节点，而不是跨层对比，这也是考虑到在实际业务中很少会去跨层的移动 DOM 元素。 所以判断差异的算法就分为了两步<br>首先从上至下，从左往右遍历对象，也就是树的深度遍历，这一步中会给每个节点添加索引，便于最后渲染差异<br>一旦节点有子元素，就去判断子元素是否有不同<br>在第一步算法中我们需要判断新旧节点的  tagName  是否相同，如果不相同的话就代表节点被替换了。如果没有更改  tagName  的话，就需要判断是否有子元素，有的话就进行第二步算法。<br>在第二步算法中，我们需要判断原本的列表中是否有节点被移除，在新的列表中需要判断是否有新的节点加入，还需要判断节点是否有移动。<br>举个例子来说，假设页面中只有一个列表，我们对列表中的元素进行了变更</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 假设这里模拟一个 ul，其中包含了 5 个 li</span><br><span class="line">[1, 2, 3, 4, 5]</span><br><span class="line">// 这里替换上面的 li</span><br><span class="line">[1, 2, 5, 4]</span><br></pre></td></tr></table></figure><p>从上述例子中，我们一眼就可以看出先前的  ul  中的第三个  li  被移除了，四五替换了位置。<br>那么在实际的算法中，我们如何去识别改动的是哪个节点呢？这就引入了  key  这个属性，想必大家在 Vue 或者 React 的列表中都用过这个属性。这个属性是用来给每一个节点打标志的，用于判断是否是同一个节点。<br>当然在判断以上差异的过程中，我们还需要判断节点的属性是否有变化等等。<br>当我们判断出以上的差异后，就可以把这些差异记录下来。当对比完两棵树以后，就可以通过差异去局部更新 DOM，实现性能的最优化。<br>另外再来回答「为什么 Virtual DOM 比原生 DOM 快」这个问题。首先这个问题得分场景来说，如果无脑替换所有的 DOM 这种场景来说，Virtual DOM 的局部更新肯定要来的快。但是如果你可以人肉也同样去局部替换 DOM，那么 Virtual DOM 必然没有你直接操作 DOM 来的快，毕竟还有一层 diff 算法的损耗。<br>当然了 Virtual DOM 提高性能是其中一个优势，其实最大的优势还是在于：</p><pre>将 Virtual DOM 作为一个兼容层，让我们还能对接非 Web 端的系统，实现跨端开发。同样的，通过 Virtual DOM 我们可以渲染到其他的平台，比如实现 SSR、同构渲染等等。实现组件的高度抽象化</pre><h4 id="路由原理"><a href="#路由原理" class="headerlink" title="路由原理"></a>路由原理</h4><pre>涉及面试题：前端路由原理？两种实现方式有什么区别？</pre><p>前端路由实现起来其实很简单，本质就是监听 URL 的变化，然后匹配路由规则，显示相应的页面，并且无须刷新页面。目前前端使用的路由就只有两种实现方式</p><pre>Hash 模式History 模式</pre><h5 id="Hash-模式"><a href="#Hash-模式" class="headerlink" title="Hash 模式"></a>Hash 模式</h5><p><a href="http://www.test.com/#/" target="_blank" rel="noopener">www.test.com/#/</a>  就是 Hash URL，当  #  后面的哈希值发生变化时，可以通过  hashchange  事件来监听到 URL 的变化，从而进行跳转页面，并且无论哈希值如何变化，服务端接收到的 URL 请求永远是  <a href="http://www.test.com。" target="_blank" rel="noopener">www.test.com。</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(<span class="string">'hashchange'</span>, () =&gt; &#123;</span><br><span class="line">  // ... 具体逻辑</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Hash 模式相对来说更简单，并且兼容性也更好。</p><h5 id="History-模式"><a href="#History-模式" class="headerlink" title="History 模式"></a>History 模式</h5><p>History 模式是 HTML5 新推出的功能，主要使用  history.pushState  和  history.replaceState  改变 URL。<br>通过 History 模式改变 URL 同样不会引起页面的刷新，只会更新浏览器的历史记录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 新增历史记录</span><br><span class="line">history.pushState(stateObject, title, URL)</span><br><span class="line">// 替换当前历史记录</span><br><span class="line">history.replaceState(stateObject, title, URL)</span><br><span class="line">当用户做出浏览器动作时，比如点击后退按钮时会触发 popState 事件</span><br><span class="line">window.addEventListener(<span class="string">'popstate'</span>, e =&gt; &#123;</span><br><span class="line">  // e.state 就是 pushState(stateObject) 中的 stateObject</span><br><span class="line">  console.log(e.state)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h6 id="两种模式对比"><a href="#两种模式对比" class="headerlink" title="两种模式对比"></a>两种模式对比</h6><pre>Hash 模式只可以更改  #  后面的内容，History 模式可以通过 API 设置任意的同源 URLHistory 模式可以通过 API 添加任意类型的数据到历史记录中，Hash 模式只能更改哈希值，也就是字符串Hash 模式无需后端配置，并且兼容性好。History 模式在用户手动输入地址或者刷新页面的时候会发起 URL 请求，        后端需要配置  index.html  页面用于匹配不到静态资源的时候</pre><h4 id="Vue-和-React-之间的区别"><a href="#Vue-和-React-之间的区别" class="headerlink" title="Vue 和 React 之间的区别"></a>Vue 和 React 之间的区别</h4><p>Vue 的表单可以使用  v-model  支持双向绑定，相比于 React 来说开发上更加方便，当然了  v-model 其实就是个语法糖，本质上和 React 写表单的方式没什么区别。<br>改变数据方式不同，Vue 修改状态相比来说要简单许多，React 需要使用  setState  来改变状态，并且使用这个 API 也有一些坑点。并且 Vue 的底层使用了依赖追踪，页面更新渲染已经是最优的了，但是 React 还是需要用户手动去优化这方面的问题。<br>React 16 以后，有些钩子函数会执行多次，这是因为引入 Fiber 的原因，这在后续的章节中会讲到。<br>React 需要使用 JSX，有一定的上手成本，并且需要一整套的工具链支持，但是完全可以通过 JS 来控制页面，更加的灵活。Vue 使用了模板语法，相比于 JSX 来说没有那么灵活，但是完全可以脱离工具链，通过直接编写  render  函数就能在浏览器中运行。<br>在生态上来说，两者其实没多大的差距，当然 React 的用户是远远高于 Vue 的。<br>在上手成本上来说，Vue 一开始的定位就是尽可能的降低前端开发的门槛，然而 React 更多的是去改变用户去接受它的概念和思想，相较于 Vue 来说上手成本略高。</p><h4 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h4><p>Vue 内部使用了  Object.defineProperty()  来实现数据响应式，通过这个函数可以监听到  set  和  get  的事件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">var data = &#123; name: <span class="string">'yck'</span> &#125;</span><br><span class="line">observe(data)</span><br><span class="line"><span class="built_in">let</span> name = data.name // -&gt; get value</span><br><span class="line">data.name = <span class="string">'yyy'</span> // -&gt; change value</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> observe(obj) &#123;</span><br><span class="line">  // 判断类型</span><br><span class="line">  <span class="keyword">if</span> (!obj || typeof obj !== <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="built_in">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  Object.keys(obj).forEach(key =&gt; &#123;</span><br><span class="line">    defineReactive(obj, key, obj[key])</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> defineReactive(obj, key, val) &#123;</span><br><span class="line">  // 递归子属性</span><br><span class="line">  observe(val)</span><br><span class="line">  Object.defineProperty(obj, key, &#123;</span><br><span class="line">    // 可枚举</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    // 可配置</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    // 自定义函数</span><br><span class="line">    get: <span class="keyword">function</span> <span class="function"><span class="title">reactiveGetter</span></span>() &#123;</span><br><span class="line">      console.log(<span class="string">'get value'</span>)</span><br><span class="line">      <span class="built_in">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">set</span>: <span class="keyword">function</span> reactiveSetter(newVal) &#123;</span><br><span class="line">      console.log(<span class="string">'change value'</span>)</span><br><span class="line">      val = newVal</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码简单的实现了如何监听数据的  set  和  get  的事件，但是仅仅如此是不够的，因为自定义的函数一开始是不会执行的。只有先执行了依赖收集，才能在属性更新的时候派发更新，所以接下来我们需要先触发依赖收集。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;&#123;name&#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>在解析如上模板代码时，遇到    就会进行依赖收集。<br>接下来我们先来实现一个  Dep  类，用于解耦属性的依赖收集和派发更新操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 通过 Dep 解耦属性的依赖和更新操作</span><br><span class="line">class Dep &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    this.subs = []</span><br><span class="line">  &#125;</span><br><span class="line">  // 添加依赖</span><br><span class="line">  addSub(sub) &#123;</span><br><span class="line">    this.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line">  // 更新</span><br><span class="line">  <span class="function"><span class="title">notify</span></span>() &#123;</span><br><span class="line">    this.subs.forEach(sub =&gt; &#123;</span><br><span class="line">      sub.update()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 全局属性，通过该属性配置 Watcher</span><br><span class="line">Dep.target = null</span><br></pre></td></tr></table></figure><p>以上的代码实现很简单，当需要依赖收集的时候调用  addSub，当需要派发更新的时候调用  notify。</p><h4 id="Vue-组件挂载时添加响应式的过程。"><a href="#Vue-组件挂载时添加响应式的过程。" class="headerlink" title="Vue 组件挂载时添加响应式的过程。"></a>Vue 组件挂载时添加响应式的过程。</h4><p>在组件挂载时，会先对所有需要的属性调用  Object.defineProperty()，然后实例化  Watcher，传入组件更新的回调。在实例化过程中，会对模板中的属性进行求值，触发依赖收集。<br>因为这一小节主要目的是学习响应式原理的细节，所以接下来的代码会简略的表达触发依赖收集时的操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Watcher &#123;</span><br><span class="line">  constructor(obj, key, cb) &#123;</span><br><span class="line">    // 将 Dep.target 指向自己</span><br><span class="line">    // 然后触发属性的 getter 添加监听</span><br><span class="line">    // 最后将 Dep.target 置空</span><br><span class="line">    Dep.target = this</span><br><span class="line">    this.cb = cb</span><br><span class="line">    this.obj = obj</span><br><span class="line">    this.key = key</span><br><span class="line">    this.value = obj[key]</span><br><span class="line">    Dep.target = null</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">update</span></span>() &#123;</span><br><span class="line">    // 获得新值</span><br><span class="line">    this.value = this.obj[this.key]</span><br><span class="line">    // 调用 update 方法更新 Dom</span><br><span class="line">    this.cb(this.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是  Watcher  的简单实现，在执行构造函数的时候将  Dep.target  指向自身，从而使得收集到了对应的  Watcher，在派发更新的时候取出对应的  Watcher  然后执行  update  函数。<br>接下来，需要对  defineReactive  函数进行改造，在自定义函数中添加依赖收集和派发更新相关的代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> defineReactive(obj, key, val) &#123;</span><br><span class="line">  // 递归子属性</span><br><span class="line">  observe(val)</span><br><span class="line">  <span class="built_in">let</span> dp = new Dep()</span><br><span class="line">  Object.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    get: <span class="keyword">function</span> <span class="function"><span class="title">reactiveGetter</span></span>() &#123;</span><br><span class="line">      console.log(<span class="string">'get value'</span>)</span><br><span class="line">      // 将 Watcher 添加到订阅</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        dp.addSub(Dep.target)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">set</span>: <span class="keyword">function</span> reactiveSetter(newVal) &#123;</span><br><span class="line">      console.log(<span class="string">'change value'</span>)</span><br><span class="line">      val = newVal</span><br><span class="line">      // 执行 watcher 的 update 方法</span><br><span class="line">      dp.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上所有代码实现了一个简易的数据响应式，核心思路就是手动触发一次属性的 getter 来实现依赖收集。<br>现在我们就来测试下代码的效果，只需要把所有的代码复制到浏览器中执行，就会发现页面的内容全部被替换了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var data = &#123; name: <span class="string">'yck'</span> &#125;</span><br><span class="line">observe(data)</span><br><span class="line"><span class="keyword">function</span> update(value) &#123;</span><br><span class="line">  document.querySelector(<span class="string">'div'</span>).innerText = value</span><br><span class="line">&#125;</span><br><span class="line">// 模拟解析到 `&#123;&#123;name&#125;&#125;` 触发的操作</span><br><span class="line">new Watcher(data, <span class="string">'name'</span>, update)</span><br><span class="line">// update Dom innerText</span><br><span class="line">data.name = <span class="string">'yyy'</span></span><br></pre></td></tr></table></figure><h4 id="Object-defineProperty-的缺陷"><a href="#Object-defineProperty-的缺陷" class="headerlink" title="Object.defineProperty 的缺陷"></a>Object.defineProperty 的缺陷</h4><p>以上已经分析完了 Vue 的响应式原理，接下来说一点  Object.defineProperty  中的缺陷。<br>如果通过下标方式修改数组数据或者给对象新增属性并不会触发组件的重新渲染，因为  Object.defineProperty  不能拦截到这些操作，更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过重写函数的方式解决了这个问题。<br>对于第一个问题，Vue 提供了一个 API 解决</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> <span class="built_in">set</span> (target: Array&lt;any&gt; | Object, key: any, val: any): any &#123;</span><br><span class="line">  // 判断是否为数组且下标是否有效</span><br><span class="line">  <span class="keyword">if</span> (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123;</span><br><span class="line">    // 调用 splice 函数触发派发更新</span><br><span class="line">    // 该函数已被重写</span><br><span class="line">    target.length = Math.max(target.length, key)</span><br><span class="line">    target.splice(key, 1, val)</span><br><span class="line">    <span class="built_in">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  // 判断 key 是否已经存在</span><br><span class="line">  <span class="keyword">if</span> (key <span class="keyword">in</span> target &amp;&amp; !(key <span class="keyword">in</span> Object.prototype)) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    <span class="built_in">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  const ob = (target: any).__ob__</span><br><span class="line">  // 如果对象不是响应式对象，就赋值返回</span><br><span class="line">  <span class="keyword">if</span> (!ob) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    <span class="built_in">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  // 进行双向绑定</span><br><span class="line">  defineReactive(ob.value, key, val)</span><br><span class="line">  // 手动派发更新</span><br><span class="line">  ob.dep.notify()</span><br><span class="line">  <span class="built_in">return</span> val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于数组而言，Vue 内部重写了以下函数实现派发更新</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 获得数组原型</span><br><span class="line">const arrayProto = Array.prototype</span><br><span class="line"><span class="built_in">export</span> const arrayMethods = Object.create(arrayProto)</span><br><span class="line">// 重写以下函数</span><br><span class="line">const methodsToPatch = [ <span class="string">'push'</span>, <span class="string">'pop'</span>, <span class="string">'shift'</span>, <span class="string">'unshift'</span>, <span class="string">'splice'</span>, <span class="string">'sort'</span>, <span class="string">'reverse'</span> ]</span><br><span class="line">methodsToPatch.forEach(<span class="keyword">function</span> (method) &#123;</span><br><span class="line">  // 缓存原生函数 const original = arrayProto[method]</span><br><span class="line">  // 重写函数</span><br><span class="line">  def(arrayMethods, method, <span class="keyword">function</span> mutator (...args) &#123;</span><br><span class="line">    // 先调用原生函数获得结果</span><br><span class="line">    const result = original.apply(this, args) const ob = this.__ob__ <span class="built_in">let</span> inserted</span><br><span class="line">    // 调用以下几个函数时，监听新数据</span><br><span class="line">    switch (method) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'push'</span>: <span class="keyword">case</span> <span class="string">'unshift'</span>: inserted = args <span class="built_in">break</span> <span class="keyword">case</span> <span class="string">'splice'</span>: inserted = args.slice(2) <span class="built_in">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inserted) ob.observeArray(inserted)</span><br><span class="line">    // 手动派发更新</span><br><span class="line">    ob.dep.notify() <span class="built_in">return</span> result</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h4><p>想必大家在使用 Vue 开发的过程中，基本都是使用模板的方式。那么你有过「模板是怎么在浏览器中运行的」这种疑虑嘛？<br>首先直接把模板丢到浏览器中肯定是不能运行的，模板只是为了方便开发者进行开发。Vue 会通过编译器将模板通过几个阶段最终编译为  render  函数，然后通过执行  render  函数生成 Virtual DOM 最终映射为真实 DOM。<br>接下来我们就来学习这个编译的过程，了解这个过程中大概发生了什么事情。这个过程其中又分为三个阶段，分别为：<br>将模板解析为 AST</p><h5 id="优化-AST"><a href="#优化-AST" class="headerlink" title="优化 AST"></a>优化 AST</h5><p>将 AST 转换为  render  函数<br>在第一个阶段中，最主要的事情还是通过各种各样的正则表达式去匹配模板中的内容，然后将内容提取出来做各种逻辑操作，接下来会生成一个最基本的 AST 对象</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // 类型</span><br><span class="line">    <span class="built_in">type</span>: 1,</span><br><span class="line">    // 标签</span><br><span class="line">    tag,</span><br><span class="line">    // 属性列表</span><br><span class="line">    attrsList: attrs,</span><br><span class="line">    // 属性映射</span><br><span class="line">    attrsMap: makeAttrsMap(attrs),</span><br><span class="line">    // 父节点</span><br><span class="line">    parent,</span><br><span class="line">    // 子节点</span><br><span class="line">    children: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后会根据这个最基本的 AST 对象中的属性，进一步扩展 AST。<br>当然在这一阶段中，还会进行其他的一些判断逻辑。比如说对比前后开闭标签是否一致，判断根组件是否只存在一个，判断是否符合 HTML5 Content Model  规范等等问题。<br>接下来就是优化 AST 的阶段。在当前版本下，Vue 进行的优化内容其实还是不多的。只是对节点进行了静态内容提取，也就是将永远不会变动的节点提取了出来，实现复用 Virtual DOM，跳过对比算法的功能。在下一个大版本中，Vue 会在优化 AST 的阶段继续发力，实现更多的优化功能，尽可能的在编译阶段压榨更多的性能，比如说提取静态的属性等等优化行为。<br>最后一个阶段就是通过 AST 生成  render  函数了。其实这一阶段虽然分支有很多，但是最主要的目的就是遍历整个 AST，根据不同的条件生成不同的代码罢了。</p><h5 id="NextTick-原理分析"><a href="#NextTick-原理分析" class="headerlink" title="NextTick 原理分析"></a>NextTick 原理分析</h5><p>nextTick  可以让我们在下次 DOM 更新循环结束之后执行延迟回调，用于获得更新后的 DOM。<br>在 Vue 2.4 之前都是使用的 microtasks，但是 microtasks 的优先级过高，在某些情况下可能会出现比事件冒泡更快的情况，但如果都使用 macrotasks 又可能会出现渲染的性能问题。所以在新版本中，会默认使用 microtasks，但在特殊情况下会使用 macrotasks，比如 v-on。<br>对于实现 macrotasks ，会先判断是否能使用  setImmediate ，不能的话降级为  MessageChannel ，以上都不行的话就使用  setTimeout</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (typeof setImmediate !== <span class="string">'undefined'</span> &amp;&amp; isNative(setImmediate)) &#123;</span><br><span class="line">  macroTimerFunc = () =&gt; &#123;</span><br><span class="line">    setImmediate(flushCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">  typeof MessageChannel !== <span class="string">'undefined'</span> &amp;&amp;</span><br><span class="line">  (isNative(MessageChannel) ||</span><br><span class="line">    // PhantomJS</span><br><span class="line">    MessageChannel.toString() === <span class="string">'[object MessageChannelConstructor]'</span>)</span><br><span class="line">) &#123;</span><br><span class="line">  const channel = new MessageChannel()</span><br><span class="line">  const port = channel.port2</span><br><span class="line">  channel.port1.onmessage = flushCallbacks</span><br><span class="line">  macroTimerFunc = () =&gt; &#123;</span><br><span class="line">    port.postMessage(1)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  macroTimerFunc = () =&gt; &#123;</span><br><span class="line">    setTimeout(flushCallbacks, 0)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码很简单，就是判断能不能使用相应的 API。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;MVVM&quot;&gt;&lt;a href=&quot;#MVVM&quot; class=&quot;headerlink&quot; title=&quot;MVVM&quot;&gt;&lt;/a&gt;MVVM&lt;/h3&gt;&lt;pre&gt;涉及面试题：什么是 MVVM？比之 MVC 有什么区别？&lt;/pre&gt;

&lt;p&gt;首先先申明一点，不管是 React 还是 
      
    
    </summary>
    
    
      <category term="mvvm" scheme="http://blog.bochunhao.cn/tags/mvvm/"/>
    
  </entry>
  
  <entry>
    <title>webpack</title>
    <link href="http://blog.bochunhao.cn/2018/10/03/webpack/"/>
    <id>http://blog.bochunhao.cn/2018/10/03/webpack/</id>
    <published>2018-10-03T06:45:23.000Z</published>
    <updated>2019-03-26T08:38:59.134Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Webpack-性能优化"><a href="#Webpack-性能优化" class="headerlink" title="Webpack 性能优化"></a>Webpack 性能优化</h3><pre>有哪些方式可以减少 Webpack 的打包时间有哪些方式可以让 Webpack 打出来的包更小</pre><h4 id="减少-Webpack-打包时间"><a href="#减少-Webpack-打包时间" class="headerlink" title="减少 Webpack 打包时间"></a>减少 Webpack 打包时间</h4><h5 id="优化-Loader"><a href="#优化-Loader" class="headerlink" title="优化 Loader"></a>优化 Loader</h5><p>对于 Loader 来说，影响打包效率首当其冲必属 Babel 了。因为 Babel 会将代码转为字符串生成 AST，然后对 AST 继续进行转变最后再生成新的代码，项目越大，转换代码越多，效率就越低。当然了，我们是有办法优化的。</p><h6 id="首先我们可以优化-Loader-的文件搜索范围"><a href="#首先我们可以优化-Loader-的文件搜索范围" class="headerlink" title="首先我们可以优化 Loader 的文件搜索范围"></a>首先我们可以优化 Loader 的文件搜索范围</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        // js 文件才使用 babel</span><br><span class="line">        <span class="built_in">test</span>: /\.js\$/,</span><br><span class="line">        loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">        // 只在 src 文件夹下查找</span><br><span class="line">        include: [resolve(<span class="string">'src'</span>)],</span><br><span class="line">        // 不会去查找的路径</span><br><span class="line">        exclude: /node_modules/</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="对于-Babel-来说，我们肯定是希望只作用在-JS-代码上的，然后-node-modules-中使用的代码都是编译过的，所以我们也完全没有必要再去处理一遍。"><a href="#对于-Babel-来说，我们肯定是希望只作用在-JS-代码上的，然后-node-modules-中使用的代码都是编译过的，所以我们也完全没有必要再去处理一遍。" class="headerlink" title="对于 Babel 来说，我们肯定是希望只作用在 JS 代码上的，然后 node_modules 中使用的代码都是编译过的，所以我们也完全没有必要再去处理一遍。"></a>对于 Babel 来说，我们肯定是希望只作用在 JS 代码上的，然后 node_modules 中使用的代码都是编译过的，所以我们也完全没有必要再去处理一遍。</h6><h6 id="当然这样做还不够，我们还可以将-Babel-编译过的文件缓存起来，下次只需要编译更改过的代码文件即可，这样可以大幅度加快打包时间"><a href="#当然这样做还不够，我们还可以将-Babel-编译过的文件缓存起来，下次只需要编译更改过的代码文件即可，这样可以大幅度加快打包时间" class="headerlink" title="当然这样做还不够，我们还可以将 Babel 编译过的文件缓存起来，下次只需要编译更改过的代码文件即可，这样可以大幅度加快打包时间"></a>当然这样做还不够，我们还可以将 Babel 编译过的文件缓存起来，下次只需要编译更改过的代码文件即可，这样可以大幅度加快打包时间</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loader: <span class="string">'babel-loader?cacheDirectory=true'</span></span><br></pre></td></tr></table></figure><h3 id="HappyPack"><a href="#HappyPack" class="headerlink" title="HappyPack"></a>HappyPack</h3><p>受限于 Node 是单线程运行的，所以 Webpack 在打包的过程中也是单线程的，特别是在执行 Loader 的时候，长时间编译的任务很多，这样就会导致等待的情况。</p><h6 id="HappyPack-可以将-Loader-的同步执行转换为并行的，这样就能充分利用系统资源来加快打包效率了"><a href="#HappyPack-可以将-Loader-的同步执行转换为并行的，这样就能充分利用系统资源来加快打包效率了" class="headerlink" title="HappyPack 可以将 Loader 的同步执行转换为并行的，这样就能充分利用系统资源来加快打包效率了"></a>HappyPack 可以将 Loader 的同步执行转换为并行的，这样就能充分利用系统资源来加快打包效率了</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">  loaders: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">test</span>: /\.js\$/,</span><br><span class="line">      include: [resolve(<span class="string">'src'</span>)],</span><br><span class="line">      exclude: /node_modules/,</span><br><span class="line">      // id 后面的内容对应下面</span><br><span class="line">      loader: <span class="string">'happypack/loader?id=happybabel'</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br><span class="line">plugins: [</span><br><span class="line">  new HappyPack(&#123;</span><br><span class="line">    id: <span class="string">'happybabel'</span>,</span><br><span class="line">    loaders: [<span class="string">'babel-loader?cacheDirectory'</span>],</span><br><span class="line">    // 开启 4 个线程</span><br><span class="line">    threads: 4</span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="DllPlugin"><a href="#DllPlugin" class="headerlink" title="DllPlugin"></a>DllPlugin</h3><h5 id="DllPlugin-可以将特定的类库提前打包然后引入。这种方式可以极大的减少打包类库的次数，只有当类库更新版本才有需要重新打包，并且也实现了将公共代码抽离成单独文件的优化方案。"><a href="#DllPlugin-可以将特定的类库提前打包然后引入。这种方式可以极大的减少打包类库的次数，只有当类库更新版本才有需要重新打包，并且也实现了将公共代码抽离成单独文件的优化方案。" class="headerlink" title="DllPlugin 可以将特定的类库提前打包然后引入。这种方式可以极大的减少打包类库的次数，只有当类库更新版本才有需要重新打包，并且也实现了将公共代码抽离成单独文件的优化方案。"></a>DllPlugin 可以将特定的类库提前打包然后引入。这种方式可以极大的减少打包类库的次数，只有当类库更新版本才有需要重新打包，并且也实现了将公共代码抽离成单独文件的优化方案。</h5><h6 id="接下来我们就来学习如何使用-DllPlugin"><a href="#接下来我们就来学习如何使用-DllPlugin" class="headerlink" title="接下来我们就来学习如何使用 DllPlugin"></a>接下来我们就来学习如何使用 DllPlugin</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 单独配置在一个文件中</span><br><span class="line">// webpack.dll.conf.js</span><br><span class="line">const path = require(<span class="string">'path'</span>)</span><br><span class="line">const webpack = require(<span class="string">'webpack'</span>)</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">  // 想统一打包的类库</span><br><span class="line">  vendor: [<span class="string">'react'</span>]</span><br><span class="line">&#125;,</span><br><span class="line">output: &#123;</span><br><span class="line">  path: path.join(**dirname, <span class="string">'dist'</span>),</span><br><span class="line">  filename: <span class="string">'[name].dll.js'</span>,</span><br><span class="line">  library: <span class="string">'[name]-[hash]'</span></span><br><span class="line">&#125;,</span><br><span class="line">plugins: [</span><br><span class="line">  new webpack.DllPlugin(&#123;</span><br><span class="line">    // name 必须和 output.library 一致</span><br><span class="line">    name: <span class="string">'[name]-[hash]'</span>,</span><br><span class="line">    // 该属性需要与 DllReferencePlugin 中一致</span><br><span class="line">    context: **dirname,</span><br><span class="line">    path: path.join(\_\_dirname, <span class="string">'dist'</span>, <span class="string">'[name]-manifest.json'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="然后我们需要执行这个配置文件生成依赖文件，接下来我们需要使用-DllReferencePlugin-将依赖文件引入项目中"><a href="#然后我们需要执行这个配置文件生成依赖文件，接下来我们需要使用-DllReferencePlugin-将依赖文件引入项目中" class="headerlink" title="然后我们需要执行这个配置文件生成依赖文件，接下来我们需要使用 DllReferencePlugin 将依赖文件引入项目中"></a>然后我们需要执行这个配置文件生成依赖文件，接下来我们需要使用 DllReferencePlugin 将依赖文件引入项目中</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// webpack.conf.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  // ...省略其他配置</span><br><span class="line">  plugins: [</span><br><span class="line">    new webpack.DllReferencePlugin(&#123;</span><br><span class="line">      context: __dirname,</span><br><span class="line">      // manifest 就是之前打包出来的 json 文件</span><br><span class="line">      manifest: require(<span class="string">'./dist/vendor-manifest.json'</span>),</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码压缩"><a href="#代码压缩" class="headerlink" title="代码压缩"></a>代码压缩</h4><p>在 Webpack3 中，我们一般使用 UglifyJS 来压缩代码，但是这个是单线程运行的，为了加快效率，我们可以使用 webpack-parallel-uglify-plugin 来并行运行 UglifyJS，从而提高效率。</p><p>在 Webpack4 中，我们就不需要以上这些操作了，只需要将 mode 设置为 production 就可以默认开启以上功能。代码压缩也是我们必做的性能优化方案，当然我们不止可以压缩 JS 代码，还可以压缩 HTML、CSS 代码，并且在压缩 JS 代码的过程中，我们还可以通过配置实现比如删除 console.log 这类代码的功能。</p><h4 id="一些小的优化点"><a href="#一些小的优化点" class="headerlink" title="一些小的优化点"></a>一些小的优化点</h4><p>我们还可以通过一些小的优化点来加快打包速度</p><h5 id="resolve-extensions："><a href="#resolve-extensions：" class="headerlink" title="resolve.extensions："></a>resolve.extensions：</h5><p>用来表明文件后缀列表，默认查找顺序是 [‘.js’, ‘.json’]，如果你的导入文件没有添加后缀就会按照这个顺序查找文件。我们应该尽可能减少后缀列表长度，然后将出现频率高的后缀排在前面</p><h5 id="resolve-alias："><a href="#resolve-alias：" class="headerlink" title="resolve.alias："></a>resolve.alias：</h5><p>可以通过别名的方式来映射一个路径，能让 Webpack 更快找到路径</p><h5 id="module-noParse："><a href="#module-noParse：" class="headerlink" title="module.noParse："></a>module.noParse：</h5><p>如果你确定一个文件下没有其他依赖，就可以使用该属性让 Webpack 不扫描该文件，这种方式对于大型的类库很有帮助</p><h4 id="减少-Webpack-打包后的文件体积"><a href="#减少-Webpack-打包后的文件体积" class="headerlink" title="减少 Webpack 打包后的文件体积"></a>减少 Webpack 打包后的文件体积</h4><p>注意：该内容也属于性能优化领域。</p><h4 id="按需加载"><a href="#按需加载" class="headerlink" title="按需加载"></a>按需加载</h4><p>想必大家在开发 SPA 项目的时候，项目中都会存在十几甚至更多的路由页面。如果我们将这些页面全部打包进一个 JS 文件的话，虽然将多个请求合并了，但是同样也加载了很多并不需要的代码，耗费了更长的时间。那么为了首页能更快地呈现给用户，我们肯定是希望首页能加载的文件体积越小越好，这时候我们就可以使用按需加载，将每个路由页面单独打包为一个文件。当然不仅仅路由可以按需加载，对于 loadash 这种大型类库同样可以使用这个功能。</p><pre>按需加载的代码实现这里就不详细展开了，因为鉴于用的框架不同，实现起来都是不一样的。当然了，虽然他们的用法可能不同，但是底层的机制都是一样的。都是当使用的时候再去下载对应文件，返回一个 Promise，当 Promise 成功以后去执行回调。</pre><h5 id="Scope-Hoisting"><a href="#Scope-Hoisting" class="headerlink" title="Scope Hoisting"></a>Scope Hoisting</h5><p>Scope Hoisting 会分析出模块之间的依赖关系，尽可能的把打包出来的模块合并到一个函数中去。</p><p>比如我们希望打包两个文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// test.js</span><br><span class="line"><span class="built_in">export</span> const a = 1</span><br><span class="line">// index.js</span><br><span class="line">import &#123; a &#125; from <span class="string">'./test.js'</span></span><br></pre></td></tr></table></figure><p>对于这种情况，我们打包出来的代码会类似这样</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  /* 0 */</span><br><span class="line">  <span class="keyword">function</span> (module, exports, require) &#123;</span><br><span class="line">    //...</span><br><span class="line">  &#125;,</span><br><span class="line">  /* 1 */</span><br><span class="line">  <span class="keyword">function</span> (module, exports, require) &#123;</span><br><span class="line">    //...</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>但是如果我们使用 Scope Hoisting 的话，代码就会尽可能的合并到一个函数中去，也就变成了这样的类似代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  /* 0 */</span><br><span class="line">  <span class="keyword">function</span> (module, exports, require) &#123;</span><br><span class="line">    //...</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这样的打包方式生成的代码明显比之前的少多了。如果在 Webpack4 中你希望开启这个功能，只需要启用 optimization.concatenateModules 就可以了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    concatenateModules: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Tree-Shaking"><a href="#Tree-Shaking" class="headerlink" title="Tree Shaking"></a>Tree Shaking</h4><p>Tree Shaking 可以实现删除项目中未被引用的代码，比如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// test.js</span><br><span class="line"><span class="built_in">export</span> const a = 1</span><br><span class="line"><span class="built_in">export</span> const b = 2</span><br><span class="line">// index.js</span><br><span class="line">import &#123; a &#125; from <span class="string">'./test.js'</span></span><br></pre></td></tr></table></figure><p>对于以上情况，test 文件中的变量 b 如果没有在项目中使用到的话，就不会被打包到文件中。</p><p>如果你使用 Webpack 4 的话，开启生产环境就会自动启动这个优化功能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Webpack-性能优化&quot;&gt;&lt;a href=&quot;#Webpack-性能优化&quot; class=&quot;headerlink&quot; title=&quot;Webpack 性能优化&quot;&gt;&lt;/a&gt;Webpack 性能优化&lt;/h3&gt;&lt;pre&gt;有哪些方式可以减少 Webpack 的打包时间

有哪些
      
    
    </summary>
    
    
      <category term="webpack" scheme="http://blog.bochunhao.cn/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>vue_data</title>
    <link href="http://blog.bochunhao.cn/2018/09/11/vue-data/"/>
    <id>http://blog.bochunhao.cn/2018/09/11/vue-data/</id>
    <published>2018-09-11T11:50:03.000Z</published>
    <updated>2019-03-26T08:35:52.082Z</updated>
    
    <content type="html"><![CDATA[<h3 id="组件中-data-什么时候可以使用对象"><a href="#组件中-data-什么时候可以使用对象" class="headerlink" title="组件中 data 什么时候可以使用对象"></a>组件中 data 什么时候可以使用对象</h3><p>组件复用时所有组件实例都会共享  data，如果  data  是对象的话，就会造成一个组件修改  data  以后会影响到其他所有组件，所以需要将  data  写成函数，每次用到就调用一次函数获得新的数据。</p><p>当我们使用  new Vue()  的方式的时候，无论我们将  data  设置为对象还是函数都是可以的，因为  new Vue()  的方式是生成一个根组件，该组件不会复用，也就不存在共享  data  的情况了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;组件中-data-什么时候可以使用对象&quot;&gt;&lt;a href=&quot;#组件中-data-什么时候可以使用对象&quot; class=&quot;headerlink&quot; title=&quot;组件中 data 什么时候可以使用对象&quot;&gt;&lt;/a&gt;组件中 data 什么时候可以使用对象&lt;/h3&gt;&lt;p&gt;组件
      
    
    </summary>
    
    
      <category term="vue" scheme="http://blog.bochunhao.cn/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue_keep-alive</title>
    <link href="http://blog.bochunhao.cn/2018/06/16/vue-keep-alive/"/>
    <id>http://blog.bochunhao.cn/2018/06/16/vue-keep-alive/</id>
    <published>2018-06-16T11:35:08.000Z</published>
    <updated>2019-03-26T08:36:02.604Z</updated>
    
    <content type="html"><![CDATA[<h3 id="keep-alive-组件有什么作用"><a href="#keep-alive-组件有什么作用" class="headerlink" title="keep-alive 组件有什么作用"></a>keep-alive 组件有什么作用</h3><p>如果你需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用  keep-alive  组件包裹需要保存的组件。</p><p>对于  keep-alive  组件来说，它拥有两个独有的生命周期钩子函数，分别为  activated  和  deactivated 。用  keep-alive  包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行  deactivated  钩子函数，命中缓存渲染后会执行  actived  钩子函数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;keep-alive-组件有什么作用&quot;&gt;&lt;a href=&quot;#keep-alive-组件有什么作用&quot; class=&quot;headerlink&quot; title=&quot;keep-alive 组件有什么作用&quot;&gt;&lt;/a&gt;keep-alive 组件有什么作用&lt;/h3&gt;&lt;p&gt;如果你需要在
      
    
    </summary>
    
    
      <category term="vue" scheme="http://blog.bochunhao.cn/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue_v-show_v-if</title>
    <link href="http://blog.bochunhao.cn/2018/06/02/vue-v-show-v-if/"/>
    <id>http://blog.bochunhao.cn/2018/06/02/vue-v-show-v-if/</id>
    <published>2018-06-02T13:23:24.000Z</published>
    <updated>2019-03-26T08:37:15.837Z</updated>
    
    <content type="html"><![CDATA[<h3 id="v-show-与-v-if-区别"><a href="#v-show-与-v-if-区别" class="headerlink" title="v-show 与 v-if 区别"></a>v-show 与 v-if 区别</h3><h4 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h4><p>v-show 只是在  display: none  和  display: block  之间切换。无论初始条件是什么都会被渲染出来，后面只需要切换 CSS，DOM 还是一直保留着的。所以总的来说  v-show  在初始渲染时有更高的开销，但是切换开销很小，更适合于频繁切换的场景。</p><h4 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h4><p>v-if 的话就得说到 Vue 底层的编译了。当属性初始为  false  时，组件就不会被渲染，直到条件为  true，并且切换条件时会触发销毁/挂载组件，所以总的来说在切换时开销更高，更适合不经常切换的场景。</p><p>并且基于  v-if  的这种惰性渲染机制，可以在必要的时候才去渲染组件，减少整个页面的初始渲染开销。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;v-show-与-v-if-区别&quot;&gt;&lt;a href=&quot;#v-show-与-v-if-区别&quot; class=&quot;headerlink&quot; title=&quot;v-show 与 v-if 区别&quot;&gt;&lt;/a&gt;v-show 与 v-if 区别&lt;/h3&gt;&lt;h4 id=&quot;v-show&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="vue" scheme="http://blog.bochunhao.cn/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue_computed_watch</title>
    <link href="http://blog.bochunhao.cn/2018/05/10/vue-computed-watch/"/>
    <id>http://blog.bochunhao.cn/2018/05/10/vue-computed-watch/</id>
    <published>2018-05-10T12:17:10.000Z</published>
    <updated>2019-03-26T08:35:42.784Z</updated>
    
    <content type="html"><![CDATA[<h3 id="computed-和-watch-区别"><a href="#computed-和-watch-区别" class="headerlink" title="computed 和 watch 区别"></a>computed 和 watch 区别</h3><pre>computed  是计算属性，依赖其他属性计算值，并且  computed  的值有缓存，只有当计算值变化才会返回内容。watch  监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。</pre><p>所以一般来说需要依赖别的属性来动态获得值的时候可以使用  computed，对于监听到值的变化需要做一些复杂业务逻辑的情况可以使用  watch。</p><p>另外  computed  和  watch  还都支持对象的写法，这种方式知道的人并不多。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vm.<span class="variable">$watch</span>(<span class="string">'obj'</span>, &#123;</span><br><span class="line">    // 深度遍历</span><br><span class="line">    deep: <span class="literal">true</span>,</span><br><span class="line">    // 立即触发</span><br><span class="line">    immediate: <span class="literal">true</span>,</span><br><span class="line">    // 执行的函数</span><br><span class="line">    handler: <span class="keyword">function</span>(val, oldVal) &#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  data: &#123; a: 1 &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    aPlus: &#123;</span><br><span class="line">      // this.aPlus 时触发</span><br><span class="line">      get: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        <span class="built_in">return</span> this.a + 1</span><br><span class="line">      &#125;,</span><br><span class="line">      // this.aPlus = 1 时触发</span><br><span class="line">      <span class="built_in">set</span>: <span class="keyword">function</span> (v) &#123;</span><br><span class="line">        this.a = v - 1</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;computed-和-watch-区别&quot;&gt;&lt;a href=&quot;#computed-和-watch-区别&quot; class=&quot;headerlink&quot; title=&quot;computed 和 watch 区别&quot;&gt;&lt;/a&gt;computed 和 watch 区别&lt;/h3&gt;&lt;pre&gt;
      
    
    </summary>
    
    
      <category term="vue" scheme="http://blog.bochunhao.cn/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue_communication</title>
    <link href="http://blog.bochunhao.cn/2018/04/08/vue-communication/"/>
    <id>http://blog.bochunhao.cn/2018/04/08/vue-communication/</id>
    <published>2018-04-08T05:51:48.000Z</published>
    <updated>2019-03-26T08:35:12.518Z</updated>
    
    <content type="html"><![CDATA[<h3 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h3><p>组件通信一般分为以下几种情况：</p><pre>父子组件通信兄弟组件通信跨多层级组件通信任意组件</pre><p>对于以上每种情况都有多种方式去实现，接下来就来学习下如何实现。</p><h4 id="父子通信"><a href="#父子通信" class="headerlink" title="父子通信"></a>父子通信</h4><p>父组件通过  props  传递数据给子组件，子组件通过  emit  发送事件传递数据给父组件，这两种方式是最常用的父子通信实现办法。</p><p>这种父子通信方式也就是典型的单向数据流，父组件通过  props  传递数据，子组件不能直接修改  props， 而是必须通过发送事件的方式告知父组件修改数据。</p><p>另外这两种方式还可以使用语法糖  v-model  来直接实现，因为  v-model  默认会解析成名为  value  的  prop  和名为  input  的事件。这种语法糖的方式是典型的双向绑定，常用于 UI 控件上，但是究其根本，还是通过事件的方法让父组件修改数据。</p><p>当然我们还可以通过访问  $parent 或者 $children  对象来访问组件实例中的方法和数据。</p><p>另外如果你使用 Vue 2.3 及以上版本的话还可以使用  \$listeners  和  .sync  这两个属性。</p><pre>$listeners 属性会将父组件中的 (不含 .native 修饰器的) v-on 事件监听器传递给子组件，     子组件可以通过访问 $listeners  来自定义监听器。.sync  属性是个语法糖，可以很简单的实现子组件与父组件通信</pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--父组件中--&gt;</span><br><span class="line">&lt;input :value.sync=<span class="string">"value"</span> /&gt;</span><br><span class="line">&lt;!--以上写法等同于--&gt;</span><br><span class="line">&lt;input :value=<span class="string">"value"</span> @update:value=<span class="string">"v =&gt; value = v"</span>&gt;&lt;/comp&gt;</span><br><span class="line">&lt;!--子组件中--&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  this.<span class="variable">$emit</span>(<span class="string">'update:value'</span>, 1)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="兄弟组件通信"><a href="#兄弟组件通信" class="headerlink" title="兄弟组件通信"></a>兄弟组件通信</h4><p>对于这种情况可以通过查找父组件中的子组件实现，也就是  this.$parent.$children，在  \$children 中可以通过组件  name  查询到需要的组件实例，然后进行通信。</p><h4 id="跨多层次组件通信"><a href="#跨多层次组件通信" class="headerlink" title="跨多层次组件通信"></a>跨多层次组件通信</h4><p>对于这种情况可以使用 Vue 2.2 新增的 API provide / inject，虽然文档中不推荐直接使用在业务中，但是如果用得好的话还是很有用的。</p><p>假设有父组件 A，然后有一个跨多层级的子组件 B</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 父组件 A</span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  provide: &#123;</span><br><span class="line">    data: 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 子组件 B</span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  inject: [<span class="string">'data'</span>],</span><br><span class="line">  <span class="function"><span class="title">mounted</span></span>() &#123;</span><br><span class="line">    // 无论跨几层都能获得父组件的 data 属性</span><br><span class="line">    console.log(this.data) // =&gt; 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="任意组件"><a href="#任意组件" class="headerlink" title="任意组件"></a>任意组件</h4><p>这种方式可以通过 Vuex 或者 Event Bus 解决，另外如果你不怕麻烦的话，可以使用这种方式解决上述所有的通信情况</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;组件通信&quot;&gt;&lt;a href=&quot;#组件通信&quot; class=&quot;headerlink&quot; title=&quot;组件通信&quot;&gt;&lt;/a&gt;组件通信&lt;/h3&gt;&lt;p&gt;组件通信一般分为以下几种情况：&lt;/p&gt;
&lt;pre&gt;
父子组件通信
兄弟组件通信
跨多层级组件通信
任意组件
&lt;/pre&gt;


      
    
    </summary>
    
    
      <category term="vue" scheme="http://blog.bochunhao.cn/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue_mixin_mixins</title>
    <link href="http://blog.bochunhao.cn/2018/04/02/vue-mixin-mixins/"/>
    <id>http://blog.bochunhao.cn/2018/04/02/vue-mixin-mixins/</id>
    <published>2018-04-02T06:06:29.000Z</published>
    <updated>2019-03-26T08:36:58.307Z</updated>
    
    <content type="html"><![CDATA[<h3 id="mixin-和-mixins-区别"><a href="#mixin-和-mixins-区别" class="headerlink" title="mixin 和 mixins 区别"></a>mixin 和 mixins 区别</h3><p>mixin  用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.mixin(&#123;</span><br><span class="line">    <span class="function"><span class="title">beforeCreate</span></span>() &#123;</span><br><span class="line">        // ...逻辑</span><br><span class="line">        // 这种方式会影响到每个组件的 beforeCreate 钩子函数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>虽然文档不建议我们在应用中直接使用  mixin，但是如果不滥用的话也是很有帮助的，比如可以全局混入封装好的  ajax  或者一些工具函数等等。</p><p>mixins  应该是我们最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过  mixins  混入代码，比如上拉下拉加载数据这种逻辑等等。</p><p>另外需要注意的是  mixins  混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并，具体可以阅读   文档。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;mixin-和-mixins-区别&quot;&gt;&lt;a href=&quot;#mixin-和-mixins-区别&quot; class=&quot;headerlink&quot; title=&quot;mixin 和 mixins 区别&quot;&gt;&lt;/a&gt;mixin 和 mixins 区别&lt;/h3&gt;&lt;p&gt;mixin  用于全
      
    
    </summary>
    
    
      <category term="vue" scheme="http://blog.bochunhao.cn/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue_lifecycle</title>
    <link href="http://blog.bochunhao.cn/2018/03/26/vue-lifecycle/"/>
    <id>http://blog.bochunhao.cn/2018/03/26/vue-lifecycle/</id>
    <published>2018-03-26T05:56:41.000Z</published>
    <updated>2019-03-26T08:36:28.288Z</updated>
    
    <content type="html"><![CDATA[<h3 id="生命周期钩子函数"><a href="#生命周期钩子函数" class="headerlink" title="生命周期钩子函数"></a>生命周期钩子函数</h3><p>在  beforeCreate  钩子函数调用的时候，是获取不到  props  或者  data  中的数据的，因为这些数据的初始化都在  initState  中。</p><p>然后会执行  created  钩子函数，在这一步的时候已经可以访问到之前不能访问到的数据，但是这时候组件还没被挂载，所以是看不到的。</p><p>接下来会先执行  beforeMount  钩子函数，开始创建 VDOM，最后执行  mounted  钩子，并将 VDOM 渲染为真实 DOM 并且渲染数据。组件中如果有子组件的话，会递归挂载子组件，只有当所有子组件全部挂载完毕，才会执行根组件的挂载钩子。</p><p>接下来是数据更新时会调用的钩子函数  beforeUpdate  和  updated，这两个钩子函数没什么好说的，就是分别在数据更新前和更新后会调用。</p><p>另外还有  keep-alive  独有的生命周期，分别为  activated  和  deactivated 。用  keep-alive  包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行  deactivated  钩子函数，命中缓存渲染后会执行  actived  钩子函数。</p><p>最后就是销毁组件的钩子函数  beforeDestroy  和  destroyed。前者适合移除事件、定时器等等，否则可能会引起内存泄露的问题。然后进行一系列的销毁操作，如果有子组件的话，也会递归销毁子组件，所有子组件都销毁完毕后才会执行根组件的  destroyed  钩子函数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;生命周期钩子函数&quot;&gt;&lt;a href=&quot;#生命周期钩子函数&quot; class=&quot;headerlink&quot; title=&quot;生命周期钩子函数&quot;&gt;&lt;/a&gt;生命周期钩子函数&lt;/h3&gt;&lt;p&gt;在  beforeCreate  钩子函数调用的时候，是获取不到  props  或者  d
      
    
    </summary>
    
    
      <category term="vue" scheme="http://blog.bochunhao.cn/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>REACT_组件通信</title>
    <link href="http://blog.bochunhao.cn/2018/03/25/react_fscom/"/>
    <id>http://blog.bochunhao.cn/2018/03/25/react_fscom/</id>
    <published>2018-03-25T14:25:58.000Z</published>
    <updated>2019-03-26T08:32:56.317Z</updated>
    
    <content type="html"><![CDATA[<h3 id="父子组件通信"><a href="#父子组件通信" class="headerlink" title="父子组件通信"></a>父子组件通信</h3><p>父组件通过  props  传递数据给子组件，子组件通过调用父组件传来的函数传递数据给父组件，这两种方式是最常用的父子通信实现办法。这种父子通信方式也就是典型的单向数据流，父组件通过  props  传递数据，子组件不能直接修改  props， 而是必须通过调用父组件函数的方式告知父组件修改数据。</p><h3 id="兄弟组件通信"><a href="#兄弟组件通信" class="headerlink" title="兄弟组件通信"></a>兄弟组件通信</h3><p>对于这种情况可以通过共同的父组件来管理状态和事件函数。比如说其中一个兄弟组件调用父组件传递过来的事件函数修改父组件中的状态，然后父组件将状态传递给另一个兄弟组件。</p><h3 id="跨多层次组件通信"><a href="#跨多层次组件通信" class="headerlink" title="跨多层次组件通信"></a>跨多层次组件通信</h3><p>如果你使用 16.3 以上版本的话，对于这种情况可以使用 Context API。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 创建 Context，可以在开始就传入值</span><br><span class="line">const StateContext = React.createContext()</span><br><span class="line">class Parent extends React.Component &#123;</span><br><span class="line">  <span class="function"><span class="title">render</span></span> () &#123;</span><br><span class="line">    <span class="built_in">return</span> (</span><br><span class="line">      // value 就是传入 Context 中的值</span><br><span class="line">      &lt;StateContext.Provider value=<span class="string">'yck'</span>&gt;</span><br><span class="line">        &lt;Child /&gt;</span><br><span class="line">      &lt;/StateContext.Provider&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Child extends React.Component &#123;</span><br><span class="line">  <span class="function"><span class="title">render</span></span> () &#123;</span><br><span class="line">    <span class="built_in">return</span> (</span><br><span class="line">      &lt;ThemeContext.Consumer&gt;</span><br><span class="line">        // 取出值</span><br><span class="line">        &#123;context =&gt; (</span><br><span class="line">          name is &#123; context &#125;</span><br><span class="line">        )&#125;</span><br><span class="line">      &lt;/ThemeContext.Consumer&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;父子组件通信&quot;&gt;&lt;a href=&quot;#父子组件通信&quot; class=&quot;headerlink&quot; title=&quot;父子组件通信&quot;&gt;&lt;/a&gt;父子组件通信&lt;/h3&gt;&lt;p&gt;父组件通过  props  传递数据给子组件，子组件通过调用父组件传来的函数传递数据给父组件，这两种方式是最
      
    
    </summary>
    
    
      <category term="react" scheme="http://blog.bochunhao.cn/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>REACT_setState</title>
    <link href="http://blog.bochunhao.cn/2018/03/22/setStarte/"/>
    <id>http://blog.bochunhao.cn/2018/03/22/setStarte/</id>
    <published>2018-03-22T12:33:57.000Z</published>
    <updated>2019-03-26T08:33:25.838Z</updated>
    
    <content type="html"><![CDATA[<h3 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h3><p>setState 在 React 中是经常使用的一个 API，但是它存在一些的问题经常会导致初学者出错，核心原因就是因为这个 API 是异步的。首先  setState  的调用并不会马上引起  state  的改变，并且如果你一次调用了多个  setState ，那么结果可能并不如你期待的一样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">handle</span></span>() &#123;</span><br><span class="line">  // 初始化 `count` 为 0</span><br><span class="line">  console.log(this.state.count) // -&gt; 0</span><br><span class="line">  this.setState(&#123; count: this.state.count + 1 &#125;)</span><br><span class="line">  this.setState(&#123; count: this.state.count + 1 &#125;)</span><br><span class="line">  this.setState(&#123; count: this.state.count + 1 &#125;)</span><br><span class="line">  console.log(this.state.count) // -&gt; 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一，两次的打印都为 0，因为  setState  是个异步 API，只有同步代码运行完毕才会执行。setState  异步的原因我认为在于，setState  可能会导致 DOM 的重绘，如果调用一次就马上去进行重绘，那么调用多次就会造成不必要的性能损失。设计成异步的话，就可以将多次调用放入一个队列中，在恰当的时候统一进行更新过程。</p><p>第二，虽然调用了三次  setState ，但是  count  的值还是为 1。因为多次调用会合并为一次，只有当更新结束后  state  才会改变，三次调用等同于如下代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object.assign(</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  &#123; count: this.state.count + 1 &#125;,</span><br><span class="line">  &#123; count: this.state.count + 1 &#125;,</span><br><span class="line">  &#123; count: this.state.count + 1 &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>当然你也可以通过以下方式来实现调用三次  setState  使得  count  为 3</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">handle</span></span>() &#123;</span><br><span class="line">  this.setState((prevState) =&gt; (&#123; count: prevState.count + 1 &#125;))</span><br><span class="line">  this.setState((prevState) =&gt; (&#123; count: prevState.count + 1 &#125;))</span><br><span class="line">  this.setState((prevState) =&gt; (&#123; count: prevState.count + 1 &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你想在每次调用  setState  后获得正确的  state ，可以通过如下代码实现</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">handle</span></span>() &#123;</span><br><span class="line">    this.setState((prevState) =&gt; (&#123; count: prevState.count + 1 &#125;), () =&gt; &#123;</span><br><span class="line">        console.log(this.state)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;setState&quot;&gt;&lt;a href=&quot;#setState&quot; class=&quot;headerlink&quot; title=&quot;setState&quot;&gt;&lt;/a&gt;setState&lt;/h3&gt;&lt;p&gt;setState 在 React 中是经常使用的一个 API，但是它存在一些的问题经常会导致
      
    
    </summary>
    
      <category term="react" scheme="http://blog.bochunhao.cn/categories/react/"/>
    
    
      <category term="react" scheme="http://blog.bochunhao.cn/tags/react/"/>
    
  </entry>
  
</feed>
