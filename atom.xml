<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人博客</title>
  
  <subtitle>BCH</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.bochunhao.cn/"/>
  <updated>2019-03-26T08:31:32.126Z</updated>
  <id>http://blog.bochunhao.cn/</id>
  
  <author>
    <name>BCH</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mvvm</title>
    <link href="http://blog.bochunhao.cn/2018/10/26/mvvm/"/>
    <id>http://blog.bochunhao.cn/2018/10/26/mvvm/</id>
    <published>2018-10-26T13:59:31.000Z</published>
    <updated>2019-03-26T08:31:32.126Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><pre>涉及面试题：什么是 MVVM？比之 MVC 有什么区别？</pre><p>首先先申明一点，不管是 React 还是 Vue，它们都不是 MVVM 框架，只是有借鉴 MVVM 的思路。文中拿 Vue 举例也是为了更好地理解 MVVM 的概念。</p><p>接下来先说下 View 和 Model：</p><pre>View 很简单，就是用户看到的视图Model 同样很简单，一般就是本地数据和数据库中的数据</pre><p>基本上，我们写的产品就是通过接口从数据库中读取数据，然后将数据经过处理展现到用户看到的视图上。当然我们还可以从视图上读取用户的输入，然后又将用户的输入通过接口写入到数据库中。但是，如何将数据展示到视图上，然后又如何将用户的输入写入到数据中，不同的人就产生了不同的看法，从此出现了很多种架构设计。</p><p>传统的 MVC 架构通常是使用控制器更新模型，视图从模型中获取数据去渲染。当用户有输入时，会通过控制器去更新模型，并且通知视图进行更新。</p><p>但是 MVC 有一个巨大的缺陷就是控制器承担的责任太大了，随着项目愈加复杂，控制器中的代码会越来越臃肿，导致出现不利于维护的情况。</p><p>在 MVVM 架构中，引入了  ViewModel  的概念。ViewModel 只关心数据和业务的处理，不关心 View 如何处理数据，在这种情况下，View 和 Model 都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可复用的逻辑放在一个 ViewModel 中，让多个 View 复用这个 ViewModel。</p><p>以 Vue 框架来举例:</p><pre>ViewModel 就是组件的实例。View 就是模板。Model 的话在引入 Vuex 的情况下是完全可以和组件分离的。</pre><p>除了以上三个部分，其实在 MVVM 中还引入了一个隐式的 Binder 层，实现了 View 和 ViewModel 的绑定。</p><p>同样以 Vue 框架来举例，这个隐式的 Binder 层就是 Vue 通过解析模板中的插值和指令从而实现 View 与 ViewModel 的绑定。</p><p>对于 MVVM 来说，其实最重要的并不是通过双向绑定或者其他的方式将 View 与 ViewModel 绑定起来，而是通过 ViewModel 将视图中的状态和用户的行为分离出一个抽象，这才是 MVVM 的精髓。</p><h4 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h4><pre>涉及面试题：什么是 Virtual DOM？为什么 Virtual DOM 比原生 DOM 快？</pre><p>大家都知道操作 DOM 是很慢的，为什么慢的原因已经在「浏览器渲染原理」章节中说过，这里就不再赘述了。<br>那么相较于 DOM 来说，操作 JS 对象会快很多，并且我们也可以通过 JS 来模拟 DOM</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const ul = &#123;</span><br><span class="line">  tag: <span class="string">'ul'</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    class: <span class="string">'list'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  children: &#123;</span><br><span class="line">    tag: <span class="string">'li'</span>,</span><br><span class="line">    children: <span class="string">'1'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码对应的 DOM 就是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul class=<span class="string">'list'</span>&gt;</span><br><span class="line">  &lt;li&gt;1&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>那么既然 DOM 可以通过 JS 对象来模拟，反之也可以通过 JS 对象来渲染出对应的 DOM。当然了，通过 JS 来模拟 DOM 并且渲染对应的 DOM 只是第一步，难点在于如何判断新旧两个 JS 对象的最小差异并且实现局部更新  DOM。<br>首先 DOM 是一个多叉树的结构，如果需要完整的对比两颗树的差异，那么需要的时间复杂度会是 O(n ^ 3)，这个复杂度肯定是不能接受的。于是 React 团队优化了算法，实现了 O(n) 的复杂度来对比差异。 实现 O(n) 复杂度的关键就是只对比同层的节点，而不是跨层对比，这也是考虑到在实际业务中很少会去跨层的移动 DOM 元素。 所以判断差异的算法就分为了两步<br>首先从上至下，从左往右遍历对象，也就是树的深度遍历，这一步中会给每个节点添加索引，便于最后渲染差异<br>一旦节点有子元素，就去判断子元素是否有不同<br>在第一步算法中我们需要判断新旧节点的  tagName  是否相同，如果不相同的话就代表节点被替换了。如果没有更改  tagName  的话，就需要判断是否有子元素，有的话就进行第二步算法。<br>在第二步算法中，我们需要判断原本的列表中是否有节点被移除，在新的列表中需要判断是否有新的节点加入，还需要判断节点是否有移动。<br>举个例子来说，假设页面中只有一个列表，我们对列表中的元素进行了变更</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 假设这里模拟一个 ul，其中包含了 5 个 li</span><br><span class="line">[1, 2, 3, 4, 5]</span><br><span class="line">// 这里替换上面的 li</span><br><span class="line">[1, 2, 5, 4]</span><br></pre></td></tr></table></figure><p>从上述例子中，我们一眼就可以看出先前的  ul  中的第三个  li  被移除了，四五替换了位置。<br>那么在实际的算法中，我们如何去识别改动的是哪个节点呢？这就引入了  key  这个属性，想必大家在 Vue 或者 React 的列表中都用过这个属性。这个属性是用来给每一个节点打标志的，用于判断是否是同一个节点。<br>当然在判断以上差异的过程中，我们还需要判断节点的属性是否有变化等等。<br>当我们判断出以上的差异后，就可以把这些差异记录下来。当对比完两棵树以后，就可以通过差异去局部更新 DOM，实现性能的最优化。<br>另外再来回答「为什么 Virtual DOM 比原生 DOM 快」这个问题。首先这个问题得分场景来说，如果无脑替换所有的 DOM 这种场景来说，Virtual DOM 的局部更新肯定要来的快。但是如果你可以人肉也同样去局部替换 DOM，那么 Virtual DOM 必然没有你直接操作 DOM 来的快，毕竟还有一层 diff 算法的损耗。<br>当然了 Virtual DOM 提高性能是其中一个优势，其实最大的优势还是在于：</p><pre>将 Virtual DOM 作为一个兼容层，让我们还能对接非 Web 端的系统，实现跨端开发。同样的，通过 Virtual DOM 我们可以渲染到其他的平台，比如实现 SSR、同构渲染等等。实现组件的高度抽象化</pre><h4 id="路由原理"><a href="#路由原理" class="headerlink" title="路由原理"></a>路由原理</h4><pre>涉及面试题：前端路由原理？两种实现方式有什么区别？</pre><p>前端路由实现起来其实很简单，本质就是监听 URL 的变化，然后匹配路由规则，显示相应的页面，并且无须刷新页面。目前前端使用的路由就只有两种实现方式</p><pre>Hash 模式History 模式</pre><h5 id="Hash-模式"><a href="#Hash-模式" class="headerlink" title="Hash 模式"></a>Hash 模式</h5><p><a href="http://www.test.com/#/" target="_blank" rel="noopener">www.test.com/#/</a>  就是 Hash URL，当  #  后面的哈希值发生变化时，可以通过  hashchange  事件来监听到 URL 的变化，从而进行跳转页面，并且无论哈希值如何变化，服务端接收到的 URL 请求永远是  <a href="http://www.test.com。" target="_blank" rel="noopener">www.test.com。</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(<span class="string">'hashchange'</span>, () =&gt; &#123;</span><br><span class="line">  // ... 具体逻辑</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Hash 模式相对来说更简单，并且兼容性也更好。</p><h5 id="History-模式"><a href="#History-模式" class="headerlink" title="History 模式"></a>History 模式</h5><p>History 模式是 HTML5 新推出的功能，主要使用  history.pushState  和  history.replaceState  改变 URL。<br>通过 History 模式改变 URL 同样不会引起页面的刷新，只会更新浏览器的历史记录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 新增历史记录</span><br><span class="line">history.pushState(stateObject, title, URL)</span><br><span class="line">// 替换当前历史记录</span><br><span class="line">history.replaceState(stateObject, title, URL)</span><br><span class="line">当用户做出浏览器动作时，比如点击后退按钮时会触发 popState 事件</span><br><span class="line">window.addEventListener(<span class="string">'popstate'</span>, e =&gt; &#123;</span><br><span class="line">  // e.state 就是 pushState(stateObject) 中的 stateObject</span><br><span class="line">  console.log(e.state)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h6 id="两种模式对比"><a href="#两种模式对比" class="headerlink" title="两种模式对比"></a>两种模式对比</h6><pre>Hash 模式只可以更改  #  后面的内容，History 模式可以通过 API 设置任意的同源 URLHistory 模式可以通过 API 添加任意类型的数据到历史记录中，Hash 模式只能更改哈希值，也就是字符串Hash 模式无需后端配置，并且兼容性好。History 模式在用户手动输入地址或者刷新页面的时候会发起 URL 请求，        后端需要配置  index.html  页面用于匹配不到静态资源的时候</pre><h4 id="Vue-和-React-之间的区别"><a href="#Vue-和-React-之间的区别" class="headerlink" title="Vue 和 React 之间的区别"></a>Vue 和 React 之间的区别</h4><p>Vue 的表单可以使用  v-model  支持双向绑定，相比于 React 来说开发上更加方便，当然了  v-model 其实就是个语法糖，本质上和 React 写表单的方式没什么区别。<br>改变数据方式不同，Vue 修改状态相比来说要简单许多，React 需要使用  setState  来改变状态，并且使用这个 API 也有一些坑点。并且 Vue 的底层使用了依赖追踪，页面更新渲染已经是最优的了，但是 React 还是需要用户手动去优化这方面的问题。<br>React 16 以后，有些钩子函数会执行多次，这是因为引入 Fiber 的原因，这在后续的章节中会讲到。<br>React 需要使用 JSX，有一定的上手成本，并且需要一整套的工具链支持，但是完全可以通过 JS 来控制页面，更加的灵活。Vue 使用了模板语法，相比于 JSX 来说没有那么灵活，但是完全可以脱离工具链，通过直接编写  render  函数就能在浏览器中运行。<br>在生态上来说，两者其实没多大的差距，当然 React 的用户是远远高于 Vue 的。<br>在上手成本上来说，Vue 一开始的定位就是尽可能的降低前端开发的门槛，然而 React 更多的是去改变用户去接受它的概念和思想，相较于 Vue 来说上手成本略高。</p><h4 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h4><p>Vue 内部使用了  Object.defineProperty()  来实现数据响应式，通过这个函数可以监听到  set  和  get  的事件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">var data = &#123; name: <span class="string">'yck'</span> &#125;</span><br><span class="line">observe(data)</span><br><span class="line"><span class="built_in">let</span> name = data.name // -&gt; get value</span><br><span class="line">data.name = <span class="string">'yyy'</span> // -&gt; change value</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> observe(obj) &#123;</span><br><span class="line">  // 判断类型</span><br><span class="line">  <span class="keyword">if</span> (!obj || typeof obj !== <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="built_in">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  Object.keys(obj).forEach(key =&gt; &#123;</span><br><span class="line">    defineReactive(obj, key, obj[key])</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> defineReactive(obj, key, val) &#123;</span><br><span class="line">  // 递归子属性</span><br><span class="line">  observe(val)</span><br><span class="line">  Object.defineProperty(obj, key, &#123;</span><br><span class="line">    // 可枚举</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    // 可配置</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    // 自定义函数</span><br><span class="line">    get: <span class="keyword">function</span> <span class="function"><span class="title">reactiveGetter</span></span>() &#123;</span><br><span class="line">      console.log(<span class="string">'get value'</span>)</span><br><span class="line">      <span class="built_in">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">set</span>: <span class="keyword">function</span> reactiveSetter(newVal) &#123;</span><br><span class="line">      console.log(<span class="string">'change value'</span>)</span><br><span class="line">      val = newVal</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码简单的实现了如何监听数据的  set  和  get  的事件，但是仅仅如此是不够的，因为自定义的函数一开始是不会执行的。只有先执行了依赖收集，才能在属性更新的时候派发更新，所以接下来我们需要先触发依赖收集。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;&#123;name&#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>在解析如上模板代码时，遇到    就会进行依赖收集。<br>接下来我们先来实现一个  Dep  类，用于解耦属性的依赖收集和派发更新操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 通过 Dep 解耦属性的依赖和更新操作</span><br><span class="line">class Dep &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    this.subs = []</span><br><span class="line">  &#125;</span><br><span class="line">  // 添加依赖</span><br><span class="line">  addSub(sub) &#123;</span><br><span class="line">    this.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line">  // 更新</span><br><span class="line">  <span class="function"><span class="title">notify</span></span>() &#123;</span><br><span class="line">    this.subs.forEach(sub =&gt; &#123;</span><br><span class="line">      sub.update()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 全局属性，通过该属性配置 Watcher</span><br><span class="line">Dep.target = null</span><br></pre></td></tr></table></figure><p>以上的代码实现很简单，当需要依赖收集的时候调用  addSub，当需要派发更新的时候调用  notify。</p><h4 id="Vue-组件挂载时添加响应式的过程。"><a href="#Vue-组件挂载时添加响应式的过程。" class="headerlink" title="Vue 组件挂载时添加响应式的过程。"></a>Vue 组件挂载时添加响应式的过程。</h4><p>在组件挂载时，会先对所有需要的属性调用  Object.defineProperty()，然后实例化  Watcher，传入组件更新的回调。在实例化过程中，会对模板中的属性进行求值，触发依赖收集。<br>因为这一小节主要目的是学习响应式原理的细节，所以接下来的代码会简略的表达触发依赖收集时的操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Watcher &#123;</span><br><span class="line">  constructor(obj, key, cb) &#123;</span><br><span class="line">    // 将 Dep.target 指向自己</span><br><span class="line">    // 然后触发属性的 getter 添加监听</span><br><span class="line">    // 最后将 Dep.target 置空</span><br><span class="line">    Dep.target = this</span><br><span class="line">    this.cb = cb</span><br><span class="line">    this.obj = obj</span><br><span class="line">    this.key = key</span><br><span class="line">    this.value = obj[key]</span><br><span class="line">    Dep.target = null</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">update</span></span>() &#123;</span><br><span class="line">    // 获得新值</span><br><span class="line">    this.value = this.obj[this.key]</span><br><span class="line">    // 调用 update 方法更新 Dom</span><br><span class="line">    this.cb(this.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是  Watcher  的简单实现，在执行构造函数的时候将  Dep.target  指向自身，从而使得收集到了对应的  Watcher，在派发更新的时候取出对应的  Watcher  然后执行  update  函数。<br>接下来，需要对  defineReactive  函数进行改造，在自定义函数中添加依赖收集和派发更新相关的代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> defineReactive(obj, key, val) &#123;</span><br><span class="line">  // 递归子属性</span><br><span class="line">  observe(val)</span><br><span class="line">  <span class="built_in">let</span> dp = new Dep()</span><br><span class="line">  Object.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    get: <span class="keyword">function</span> <span class="function"><span class="title">reactiveGetter</span></span>() &#123;</span><br><span class="line">      console.log(<span class="string">'get value'</span>)</span><br><span class="line">      // 将 Watcher 添加到订阅</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        dp.addSub(Dep.target)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">set</span>: <span class="keyword">function</span> reactiveSetter(newVal) &#123;</span><br><span class="line">      console.log(<span class="string">'change value'</span>)</span><br><span class="line">      val = newVal</span><br><span class="line">      // 执行 watcher 的 update 方法</span><br><span class="line">      dp.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上所有代码实现了一个简易的数据响应式，核心思路就是手动触发一次属性的 getter 来实现依赖收集。<br>现在我们就来测试下代码的效果，只需要把所有的代码复制到浏览器中执行，就会发现页面的内容全部被替换了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var data = &#123; name: <span class="string">'yck'</span> &#125;</span><br><span class="line">observe(data)</span><br><span class="line"><span class="keyword">function</span> update(value) &#123;</span><br><span class="line">  document.querySelector(<span class="string">'div'</span>).innerText = value</span><br><span class="line">&#125;</span><br><span class="line">// 模拟解析到 `&#123;&#123;name&#125;&#125;` 触发的操作</span><br><span class="line">new Watcher(data, <span class="string">'name'</span>, update)</span><br><span class="line">// update Dom innerText</span><br><span class="line">data.name = <span class="string">'yyy'</span></span><br></pre></td></tr></table></figure><h4 id="Object-defineProperty-的缺陷"><a href="#Object-defineProperty-的缺陷" class="headerlink" title="Object.defineProperty 的缺陷"></a>Object.defineProperty 的缺陷</h4><p>以上已经分析完了 Vue 的响应式原理，接下来说一点  Object.defineProperty  中的缺陷。<br>如果通过下标方式修改数组数据或者给对象新增属性并不会触发组件的重新渲染，因为  Object.defineProperty  不能拦截到这些操作，更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过重写函数的方式解决了这个问题。<br>对于第一个问题，Vue 提供了一个 API 解决</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> <span class="built_in">set</span> (target: Array&lt;any&gt; | Object, key: any, val: any): any &#123;</span><br><span class="line">  // 判断是否为数组且下标是否有效</span><br><span class="line">  <span class="keyword">if</span> (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123;</span><br><span class="line">    // 调用 splice 函数触发派发更新</span><br><span class="line">    // 该函数已被重写</span><br><span class="line">    target.length = Math.max(target.length, key)</span><br><span class="line">    target.splice(key, 1, val)</span><br><span class="line">    <span class="built_in">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  // 判断 key 是否已经存在</span><br><span class="line">  <span class="keyword">if</span> (key <span class="keyword">in</span> target &amp;&amp; !(key <span class="keyword">in</span> Object.prototype)) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    <span class="built_in">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  const ob = (target: any).__ob__</span><br><span class="line">  // 如果对象不是响应式对象，就赋值返回</span><br><span class="line">  <span class="keyword">if</span> (!ob) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    <span class="built_in">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  // 进行双向绑定</span><br><span class="line">  defineReactive(ob.value, key, val)</span><br><span class="line">  // 手动派发更新</span><br><span class="line">  ob.dep.notify()</span><br><span class="line">  <span class="built_in">return</span> val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于数组而言，Vue 内部重写了以下函数实现派发更新</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 获得数组原型</span><br><span class="line">const arrayProto = Array.prototype</span><br><span class="line"><span class="built_in">export</span> const arrayMethods = Object.create(arrayProto)</span><br><span class="line">// 重写以下函数</span><br><span class="line">const methodsToPatch = [ <span class="string">'push'</span>, <span class="string">'pop'</span>, <span class="string">'shift'</span>, <span class="string">'unshift'</span>, <span class="string">'splice'</span>, <span class="string">'sort'</span>, <span class="string">'reverse'</span> ]</span><br><span class="line">methodsToPatch.forEach(<span class="keyword">function</span> (method) &#123;</span><br><span class="line">  // 缓存原生函数 const original = arrayProto[method]</span><br><span class="line">  // 重写函数</span><br><span class="line">  def(arrayMethods, method, <span class="keyword">function</span> mutator (...args) &#123;</span><br><span class="line">    // 先调用原生函数获得结果</span><br><span class="line">    const result = original.apply(this, args) const ob = this.__ob__ <span class="built_in">let</span> inserted</span><br><span class="line">    // 调用以下几个函数时，监听新数据</span><br><span class="line">    switch (method) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'push'</span>: <span class="keyword">case</span> <span class="string">'unshift'</span>: inserted = args <span class="built_in">break</span> <span class="keyword">case</span> <span class="string">'splice'</span>: inserted = args.slice(2) <span class="built_in">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inserted) ob.observeArray(inserted)</span><br><span class="line">    // 手动派发更新</span><br><span class="line">    ob.dep.notify() <span class="built_in">return</span> result</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h4><p>想必大家在使用 Vue 开发的过程中，基本都是使用模板的方式。那么你有过「模板是怎么在浏览器中运行的」这种疑虑嘛？<br>首先直接把模板丢到浏览器中肯定是不能运行的，模板只是为了方便开发者进行开发。Vue 会通过编译器将模板通过几个阶段最终编译为  render  函数，然后通过执行  render  函数生成 Virtual DOM 最终映射为真实 DOM。<br>接下来我们就来学习这个编译的过程，了解这个过程中大概发生了什么事情。这个过程其中又分为三个阶段，分别为：<br>将模板解析为 AST</p><h5 id="优化-AST"><a href="#优化-AST" class="headerlink" title="优化 AST"></a>优化 AST</h5><p>将 AST 转换为  render  函数<br>在第一个阶段中，最主要的事情还是通过各种各样的正则表达式去匹配模板中的内容，然后将内容提取出来做各种逻辑操作，接下来会生成一个最基本的 AST 对象</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // 类型</span><br><span class="line">    <span class="built_in">type</span>: 1,</span><br><span class="line">    // 标签</span><br><span class="line">    tag,</span><br><span class="line">    // 属性列表</span><br><span class="line">    attrsList: attrs,</span><br><span class="line">    // 属性映射</span><br><span class="line">    attrsMap: makeAttrsMap(attrs),</span><br><span class="line">    // 父节点</span><br><span class="line">    parent,</span><br><span class="line">    // 子节点</span><br><span class="line">    children: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后会根据这个最基本的 AST 对象中的属性，进一步扩展 AST。<br>当然在这一阶段中，还会进行其他的一些判断逻辑。比如说对比前后开闭标签是否一致，判断根组件是否只存在一个，判断是否符合 HTML5 Content Model  规范等等问题。<br>接下来就是优化 AST 的阶段。在当前版本下，Vue 进行的优化内容其实还是不多的。只是对节点进行了静态内容提取，也就是将永远不会变动的节点提取了出来，实现复用 Virtual DOM，跳过对比算法的功能。在下一个大版本中，Vue 会在优化 AST 的阶段继续发力，实现更多的优化功能，尽可能的在编译阶段压榨更多的性能，比如说提取静态的属性等等优化行为。<br>最后一个阶段就是通过 AST 生成  render  函数了。其实这一阶段虽然分支有很多，但是最主要的目的就是遍历整个 AST，根据不同的条件生成不同的代码罢了。</p><h5 id="NextTick-原理分析"><a href="#NextTick-原理分析" class="headerlink" title="NextTick 原理分析"></a>NextTick 原理分析</h5><p>nextTick  可以让我们在下次 DOM 更新循环结束之后执行延迟回调，用于获得更新后的 DOM。<br>在 Vue 2.4 之前都是使用的 microtasks，但是 microtasks 的优先级过高，在某些情况下可能会出现比事件冒泡更快的情况，但如果都使用 macrotasks 又可能会出现渲染的性能问题。所以在新版本中，会默认使用 microtasks，但在特殊情况下会使用 macrotasks，比如 v-on。<br>对于实现 macrotasks ，会先判断是否能使用  setImmediate ，不能的话降级为  MessageChannel ，以上都不行的话就使用  setTimeout</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (typeof setImmediate !== <span class="string">'undefined'</span> &amp;&amp; isNative(setImmediate)) &#123;</span><br><span class="line">  macroTimerFunc = () =&gt; &#123;</span><br><span class="line">    setImmediate(flushCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">  typeof MessageChannel !== <span class="string">'undefined'</span> &amp;&amp;</span><br><span class="line">  (isNative(MessageChannel) ||</span><br><span class="line">    // PhantomJS</span><br><span class="line">    MessageChannel.toString() === <span class="string">'[object MessageChannelConstructor]'</span>)</span><br><span class="line">) &#123;</span><br><span class="line">  const channel = new MessageChannel()</span><br><span class="line">  const port = channel.port2</span><br><span class="line">  channel.port1.onmessage = flushCallbacks</span><br><span class="line">  macroTimerFunc = () =&gt; &#123;</span><br><span class="line">    port.postMessage(1)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  macroTimerFunc = () =&gt; &#123;</span><br><span class="line">    setTimeout(flushCallbacks, 0)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码很简单，就是判断能不能使用相应的 API。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;MVVM&quot;&gt;&lt;a href=&quot;#MVVM&quot; class=&quot;headerlink&quot; title=&quot;MVVM&quot;&gt;&lt;/a&gt;MVVM&lt;/h3&gt;&lt;pre&gt;涉及面试题：什么是 MVVM？比之 MVC 有什么区别？&lt;/pre&gt;

&lt;p&gt;首先先申明一点，不管是 React 还是 
      
    
    </summary>
    
    
      <category term="mvvm" scheme="http://blog.bochunhao.cn/tags/mvvm/"/>
    
  </entry>
  
  <entry>
    <title>webpack</title>
    <link href="http://blog.bochunhao.cn/2018/10/03/webpack/"/>
    <id>http://blog.bochunhao.cn/2018/10/03/webpack/</id>
    <published>2018-10-03T06:45:23.000Z</published>
    <updated>2019-03-26T07:14:06.438Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Webpack-性能优化"><a href="#Webpack-性能优化" class="headerlink" title="Webpack 性能优化"></a>Webpack 性能优化</h3><pre>有哪些方式可以减少 Webpack 的打包时间有哪些方式可以让 Webpack 打出来的包更小</pre><h4 id="减少-Webpack-打包时间"><a href="#减少-Webpack-打包时间" class="headerlink" title="减少 Webpack 打包时间"></a>减少 Webpack 打包时间</h4><h5 id="优化-Loader"><a href="#优化-Loader" class="headerlink" title="优化 Loader"></a>优化 Loader</h5><p>对于 Loader 来说，影响打包效率首当其冲必属 Babel 了。因为 Babel 会将代码转为字符串生成 AST，然后对 AST 继续进行转变最后再生成新的代码，项目越大，转换代码越多，效率就越低。当然了，我们是有办法优化的。</p><h6 id="首先我们可以优化-Loader-的文件搜索范围"><a href="#首先我们可以优化-Loader-的文件搜索范围" class="headerlink" title="首先我们可以优化 Loader 的文件搜索范围"></a>首先我们可以优化 Loader 的文件搜索范围</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        // js 文件才使用 babel</span><br><span class="line">        <span class="built_in">test</span>: /\.js\$/,</span><br><span class="line">        loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">        // 只在 src 文件夹下查找</span><br><span class="line">        include: [resolve(<span class="string">'src'</span>)],</span><br><span class="line">        // 不会去查找的路径</span><br><span class="line">        exclude: /node_modules/</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="对于-Babel-来说，我们肯定是希望只作用在-JS-代码上的，然后-node-modules-中使用的代码都是编译过的，所以我们也完全没有必要再去处理一遍。"><a href="#对于-Babel-来说，我们肯定是希望只作用在-JS-代码上的，然后-node-modules-中使用的代码都是编译过的，所以我们也完全没有必要再去处理一遍。" class="headerlink" title="对于 Babel 来说，我们肯定是希望只作用在 JS 代码上的，然后 node_modules 中使用的代码都是编译过的，所以我们也完全没有必要再去处理一遍。"></a>对于 Babel 来说，我们肯定是希望只作用在 JS 代码上的，然后 node_modules 中使用的代码都是编译过的，所以我们也完全没有必要再去处理一遍。</h6><h6 id="当然这样做还不够，我们还可以将-Babel-编译过的文件缓存起来，下次只需要编译更改过的代码文件即可，这样可以大幅度加快打包时间"><a href="#当然这样做还不够，我们还可以将-Babel-编译过的文件缓存起来，下次只需要编译更改过的代码文件即可，这样可以大幅度加快打包时间" class="headerlink" title="当然这样做还不够，我们还可以将 Babel 编译过的文件缓存起来，下次只需要编译更改过的代码文件即可，这样可以大幅度加快打包时间"></a>当然这样做还不够，我们还可以将 Babel 编译过的文件缓存起来，下次只需要编译更改过的代码文件即可，这样可以大幅度加快打包时间</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loader: <span class="string">'babel-loader?cacheDirectory=true'</span></span><br></pre></td></tr></table></figure><h3 id="HappyPack"><a href="#HappyPack" class="headerlink" title="HappyPack"></a>HappyPack</h3><p>受限于 Node 是单线程运行的，所以 Webpack 在打包的过程中也是单线程的，特别是在执行 Loader 的时候，长时间编译的任务很多，这样就会导致等待的情况。</p><h6 id="HappyPack-可以将-Loader-的同步执行转换为并行的，这样就能充分利用系统资源来加快打包效率了"><a href="#HappyPack-可以将-Loader-的同步执行转换为并行的，这样就能充分利用系统资源来加快打包效率了" class="headerlink" title="HappyPack 可以将 Loader 的同步执行转换为并行的，这样就能充分利用系统资源来加快打包效率了"></a>HappyPack 可以将 Loader 的同步执行转换为并行的，这样就能充分利用系统资源来加快打包效率了</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">  loaders: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">test</span>: /\.js\$/,</span><br><span class="line">      include: [resolve(<span class="string">'src'</span>)],</span><br><span class="line">      exclude: /node_modules/,</span><br><span class="line">      // id 后面的内容对应下面</span><br><span class="line">      loader: <span class="string">'happypack/loader?id=happybabel'</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br><span class="line">plugins: [</span><br><span class="line">  new HappyPack(&#123;</span><br><span class="line">    id: <span class="string">'happybabel'</span>,</span><br><span class="line">    loaders: [<span class="string">'babel-loader?cacheDirectory'</span>],</span><br><span class="line">    // 开启 4 个线程</span><br><span class="line">    threads: 4</span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="DllPlugin"><a href="#DllPlugin" class="headerlink" title="DllPlugin"></a>DllPlugin</h3><h5 id="DllPlugin-可以将特定的类库提前打包然后引入。这种方式可以极大的减少打包类库的次数，只有当类库更新版本才有需要重新打包，并且也实现了将公共代码抽离成单独文件的优化方案。"><a href="#DllPlugin-可以将特定的类库提前打包然后引入。这种方式可以极大的减少打包类库的次数，只有当类库更新版本才有需要重新打包，并且也实现了将公共代码抽离成单独文件的优化方案。" class="headerlink" title="DllPlugin 可以将特定的类库提前打包然后引入。这种方式可以极大的减少打包类库的次数，只有当类库更新版本才有需要重新打包，并且也实现了将公共代码抽离成单独文件的优化方案。"></a>DllPlugin 可以将特定的类库提前打包然后引入。这种方式可以极大的减少打包类库的次数，只有当类库更新版本才有需要重新打包，并且也实现了将公共代码抽离成单独文件的优化方案。</h5><h6 id="接下来我们就来学习如何使用-DllPlugin"><a href="#接下来我们就来学习如何使用-DllPlugin" class="headerlink" title="接下来我们就来学习如何使用 DllPlugin"></a>接下来我们就来学习如何使用 DllPlugin</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 单独配置在一个文件中</span><br><span class="line">// webpack.dll.conf.js</span><br><span class="line">const path = require(<span class="string">'path'</span>)</span><br><span class="line">const webpack = require(<span class="string">'webpack'</span>)</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">  // 想统一打包的类库</span><br><span class="line">  vendor: [<span class="string">'react'</span>]</span><br><span class="line">&#125;,</span><br><span class="line">output: &#123;</span><br><span class="line">  path: path.join(**dirname, <span class="string">'dist'</span>),</span><br><span class="line">  filename: <span class="string">'[name].dll.js'</span>,</span><br><span class="line">  library: <span class="string">'[name]-[hash]'</span></span><br><span class="line">&#125;,</span><br><span class="line">plugins: [</span><br><span class="line">  new webpack.DllPlugin(&#123;</span><br><span class="line">    // name 必须和 output.library 一致</span><br><span class="line">    name: <span class="string">'[name]-[hash]'</span>,</span><br><span class="line">    // 该属性需要与 DllReferencePlugin 中一致</span><br><span class="line">    context: **dirname,</span><br><span class="line">    path: path.join(\_\_dirname, <span class="string">'dist'</span>, <span class="string">'[name]-manifest.json'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="然后我们需要执行这个配置文件生成依赖文件，接下来我们需要使用-DllReferencePlugin-将依赖文件引入项目中"><a href="#然后我们需要执行这个配置文件生成依赖文件，接下来我们需要使用-DllReferencePlugin-将依赖文件引入项目中" class="headerlink" title="然后我们需要执行这个配置文件生成依赖文件，接下来我们需要使用 DllReferencePlugin 将依赖文件引入项目中"></a>然后我们需要执行这个配置文件生成依赖文件，接下来我们需要使用 DllReferencePlugin 将依赖文件引入项目中</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// webpack.conf.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  // ...省略其他配置</span><br><span class="line">  plugins: [</span><br><span class="line">    new webpack.DllReferencePlugin(&#123;</span><br><span class="line">      context: __dirname,</span><br><span class="line">      // manifest 就是之前打包出来的 json 文件</span><br><span class="line">      manifest: require(<span class="string">'./dist/vendor-manifest.json'</span>),</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码压缩"><a href="#代码压缩" class="headerlink" title="代码压缩"></a>代码压缩</h4><p>在 Webpack3 中，我们一般使用 UglifyJS 来压缩代码，但是这个是单线程运行的，为了加快效率，我们可以使用 webpack-parallel-uglify-plugin 来并行运行 UglifyJS，从而提高效率。</p><p>在 Webpack4 中，我们就不需要以上这些操作了，只需要将 mode 设置为 production 就可以默认开启以上功能。代码压缩也是我们必做的性能优化方案，当然我们不止可以压缩 JS 代码，还可以压缩 HTML、CSS 代码，并且在压缩 JS 代码的过程中，我们还可以通过配置实现比如删除 console.log 这类代码的功能。</p><h4 id="一些小的优化点"><a href="#一些小的优化点" class="headerlink" title="一些小的优化点"></a>一些小的优化点</h4><p>我们还可以通过一些小的优化点来加快打包速度</p><h5 id="resolve-extensions："><a href="#resolve-extensions：" class="headerlink" title="resolve.extensions："></a>resolve.extensions：</h5><p>用来表明文件后缀列表，默认查找顺序是 [‘.js’, ‘.json’]，如果你的导入文件没有添加后缀就会按照这个顺序查找文件。我们应该尽可能减少后缀列表长度，然后将出现频率高的后缀排在前面</p><h5 id="resolve-alias："><a href="#resolve-alias：" class="headerlink" title="resolve.alias："></a>resolve.alias：</h5><p>可以通过别名的方式来映射一个路径，能让 Webpack 更快找到路径</p><h5 id="module-noParse："><a href="#module-noParse：" class="headerlink" title="module.noParse："></a>module.noParse：</h5><p>如果你确定一个文件下没有其他依赖，就可以使用该属性让 Webpack 不扫描该文件，这种方式对于大型的类库很有帮助</p><h4 id="减少-Webpack-打包后的文件体积"><a href="#减少-Webpack-打包后的文件体积" class="headerlink" title="减少 Webpack 打包后的文件体积"></a>减少 Webpack 打包后的文件体积</h4><p>注意：该内容也属于性能优化领域。</p><h4 id="按需加载"><a href="#按需加载" class="headerlink" title="按需加载"></a>按需加载</h4><p>想必大家在开发 SPA 项目的时候，项目中都会存在十几甚至更多的路由页面。如果我们将这些页面全部打包进一个 JS 文件的话，虽然将多个请求合并了，但是同样也加载了很多并不需要的代码，耗费了更长的时间。那么为了首页能更快地呈现给用户，我们肯定是希望首页能加载的文件体积越小越好，这时候我们就可以使用按需加载，将每个路由页面单独打包为一个文件。当然不仅仅路由可以按需加载，对于 loadash 这种大型类库同样可以使用这个功能。</p><pre>按需加载的代码实现这里就不详细展开了，因为鉴于用的框架不同，实现起来都是不一样的。当然了，虽然他们的用法可能不同，但是底层的机制都是一样的。都是当使用的时候再去下载对应文件，返回一个 Promise，当 Promise 成功以后去执行回调。</pre><h5 id="Scope-Hoisting"><a href="#Scope-Hoisting" class="headerlink" title="Scope Hoisting"></a>Scope Hoisting</h5><p>Scope Hoisting 会分析出模块之间的依赖关系，尽可能的把打包出来的模块合并到一个函数中去。</p><p>比如我们希望打包两个文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// test.js</span><br><span class="line"><span class="built_in">export</span> const a = 1</span><br><span class="line">// index.js</span><br><span class="line">import &#123; a &#125; from <span class="string">'./test.js'</span></span><br></pre></td></tr></table></figure><p>对于这种情况，我们打包出来的代码会类似这样</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  /* 0 */</span><br><span class="line">  <span class="keyword">function</span> (module, exports, require) &#123;</span><br><span class="line">    //...</span><br><span class="line">  &#125;,</span><br><span class="line">  /* 1 */</span><br><span class="line">  <span class="keyword">function</span> (module, exports, require) &#123;</span><br><span class="line">    //...</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>但是如果我们使用 Scope Hoisting 的话，代码就会尽可能的合并到一个函数中去，也就变成了这样的类似代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  /* 0 */</span><br><span class="line">  <span class="keyword">function</span> (module, exports, require) &#123;</span><br><span class="line">    //...</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这样的打包方式生成的代码明显比之前的少多了。如果在 Webpack4 中你希望开启这个功能，只需要启用 optimization.concatenateModules 就可以了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    concatenateModules: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Tree-Shaking"><a href="#Tree-Shaking" class="headerlink" title="Tree Shaking"></a>Tree Shaking</h4><p>Tree Shaking 可以实现删除项目中未被引用的代码，比如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// test.js</span><br><span class="line"><span class="built_in">export</span> const a = 1</span><br><span class="line"><span class="built_in">export</span> const b = 2</span><br><span class="line">// index.js</span><br><span class="line">import &#123; a &#125; from <span class="string">'./test.js'</span></span><br></pre></td></tr></table></figure><p>对于以上情况，test 文件中的变量 b 如果没有在项目中使用到的话，就不会被打包到文件中。</p><p>如果你使用 Webpack 4 的话，开启生产环境就会自动启动这个优化功能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Webpack-性能优化&quot;&gt;&lt;a href=&quot;#Webpack-性能优化&quot; class=&quot;headerlink&quot; title=&quot;Webpack 性能优化&quot;&gt;&lt;/a&gt;Webpack 性能优化&lt;/h3&gt;&lt;pre&gt;有哪些方式可以减少 Webpack 的打包时间

有哪些
      
    
    </summary>
    
    
      <category term="webpack" scheme="http://blog.bochunhao.cn/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>vue_data</title>
    <link href="http://blog.bochunhao.cn/2018/09/11/vue-data/"/>
    <id>http://blog.bochunhao.cn/2018/09/11/vue-data/</id>
    <published>2018-09-11T11:50:03.000Z</published>
    <updated>2019-03-26T06:29:35.640Z</updated>
    
    <content type="html"><![CDATA[<h3 id="组件中-data-什么时候可以使用对象"><a href="#组件中-data-什么时候可以使用对象" class="headerlink" title="组件中 data 什么时候可以使用对象"></a>组件中 data 什么时候可以使用对象</h3><h5 id="组件复用时所有组件实例都会共享-data，如果-data-是对象的话，就会造成一个组件修改-data-以后会影响到其他所有组件，所以需要将-data-写成函数，每次用到就调用一次函数获得新的数据。"><a href="#组件复用时所有组件实例都会共享-data，如果-data-是对象的话，就会造成一个组件修改-data-以后会影响到其他所有组件，所以需要将-data-写成函数，每次用到就调用一次函数获得新的数据。" class="headerlink" title="组件复用时所有组件实例都会共享  data，如果  data  是对象的话，就会造成一个组件修改  data  以后会影响到其他所有组件，所以需要将  data  写成函数，每次用到就调用一次函数获得新的数据。"></a>组件复用时所有组件实例都会共享  data，如果  data  是对象的话，就会造成一个组件修改  data  以后会影响到其他所有组件，所以需要将  data  写成函数，每次用到就调用一次函数获得新的数据。</h5><h5 id="当我们使用-new-Vue-的方式的时候，无论我们将-data-设置为对象还是函数都是可以的，因为-new-Vue-的方式是生成一个根组件，该组件不会复用，也就不存在共享-data-的情况了。"><a href="#当我们使用-new-Vue-的方式的时候，无论我们将-data-设置为对象还是函数都是可以的，因为-new-Vue-的方式是生成一个根组件，该组件不会复用，也就不存在共享-data-的情况了。" class="headerlink" title="当我们使用  new Vue()  的方式的时候，无论我们将  data  设置为对象还是函数都是可以的，因为  new Vue()  的方式是生成一个根组件，该组件不会复用，也就不存在共享  data  的情况了。"></a>当我们使用  new Vue()  的方式的时候，无论我们将  data  设置为对象还是函数都是可以的，因为  new Vue()  的方式是生成一个根组件，该组件不会复用，也就不存在共享  data  的情况了。</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;组件中-data-什么时候可以使用对象&quot;&gt;&lt;a href=&quot;#组件中-data-什么时候可以使用对象&quot; class=&quot;headerlink&quot; title=&quot;组件中 data 什么时候可以使用对象&quot;&gt;&lt;/a&gt;组件中 data 什么时候可以使用对象&lt;/h3&gt;&lt;h5 i
      
    
    </summary>
    
    
      <category term="vue" scheme="http://blog.bochunhao.cn/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue_keep-alive</title>
    <link href="http://blog.bochunhao.cn/2018/06/16/vue-keep-alive/"/>
    <id>http://blog.bochunhao.cn/2018/06/16/vue-keep-alive/</id>
    <published>2018-06-16T11:35:08.000Z</published>
    <updated>2019-03-26T06:27:10.260Z</updated>
    
    <content type="html"><![CDATA[<h3 id="keep-alive-组件有什么作用"><a href="#keep-alive-组件有什么作用" class="headerlink" title="keep-alive 组件有什么作用"></a>keep-alive 组件有什么作用</h3><h5 id="如果你需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用-keep-alive-组件包裹需要保存的组件。"><a href="#如果你需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用-keep-alive-组件包裹需要保存的组件。" class="headerlink" title="如果你需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用  keep-alive  组件包裹需要保存的组件。"></a>如果你需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用  keep-alive  组件包裹需要保存的组件。</h5><h5 id="对于-keep-alive-组件来说，它拥有两个独有的生命周期钩子函数，分别为-activated-和-deactivated-。用-keep-alive-包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行-deactivated-钩子函数，命中缓存渲染后会执行-actived-钩子函数。"><a href="#对于-keep-alive-组件来说，它拥有两个独有的生命周期钩子函数，分别为-activated-和-deactivated-。用-keep-alive-包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行-deactivated-钩子函数，命中缓存渲染后会执行-actived-钩子函数。" class="headerlink" title="对于  keep-alive  组件来说，它拥有两个独有的生命周期钩子函数，分别为  activated  和  deactivated 。用  keep-alive  包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行  deactivated  钩子函数，命中缓存渲染后会执行  actived  钩子函数。"></a>对于  keep-alive  组件来说，它拥有两个独有的生命周期钩子函数，分别为  activated  和  deactivated 。用  keep-alive  包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行  deactivated  钩子函数，命中缓存渲染后会执行  actived  钩子函数。</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;keep-alive-组件有什么作用&quot;&gt;&lt;a href=&quot;#keep-alive-组件有什么作用&quot; class=&quot;headerlink&quot; title=&quot;keep-alive 组件有什么作用&quot;&gt;&lt;/a&gt;keep-alive 组件有什么作用&lt;/h3&gt;&lt;h5 id=&quot;如
      
    
    </summary>
    
    
      <category term="vue" scheme="http://blog.bochunhao.cn/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue_v-show_v-if</title>
    <link href="http://blog.bochunhao.cn/2018/06/02/vue-v-show-v-if/"/>
    <id>http://blog.bochunhao.cn/2018/06/02/vue-v-show-v-if/</id>
    <published>2018-06-02T13:23:24.000Z</published>
    <updated>2019-03-26T06:29:44.835Z</updated>
    
    <content type="html"><![CDATA[<h3 id="v-show-与-v-if-区别"><a href="#v-show-与-v-if-区别" class="headerlink" title="v-show 与 v-if 区别"></a>v-show 与 v-if 区别</h3><h4 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h4><h5 id="v-show-只是在-display-none-和-display-block-之间切换。无论初始条件是什么都会被渲染出来，后面只需要切换-CSS，DOM-还是一直保留着的。所以总的来说-v-show-在初始渲染时有更高的开销，但是切换开销很小，更适合于频繁切换的场景。"><a href="#v-show-只是在-display-none-和-display-block-之间切换。无论初始条件是什么都会被渲染出来，后面只需要切换-CSS，DOM-还是一直保留着的。所以总的来说-v-show-在初始渲染时有更高的开销，但是切换开销很小，更适合于频繁切换的场景。" class="headerlink" title="v-show 只是在  display: none  和  display: block  之间切换。无论初始条件是什么都会被渲染出来，后面只需要切换 CSS，DOM 还是一直保留着的。所以总的来说  v-show  在初始渲染时有更高的开销，但是切换开销很小，更适合于频繁切换的场景。"></a>v-show 只是在  display: none  和  display: block  之间切换。无论初始条件是什么都会被渲染出来，后面只需要切换 CSS，DOM 还是一直保留着的。所以总的来说  v-show  在初始渲染时有更高的开销，但是切换开销很小，更适合于频繁切换的场景。</h5><h4 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h4><h5 id="v-if-的话就得说到-Vue-底层的编译了。当属性初始为-false-时，组件就不会被渲染，直到条件为-true，并且切换条件时会触发销毁-挂载组件，所以总的来说在切换时开销更高，更适合不经常切换的场景。"><a href="#v-if-的话就得说到-Vue-底层的编译了。当属性初始为-false-时，组件就不会被渲染，直到条件为-true，并且切换条件时会触发销毁-挂载组件，所以总的来说在切换时开销更高，更适合不经常切换的场景。" class="headerlink" title="v-if 的话就得说到 Vue 底层的编译了。当属性初始为  false  时，组件就不会被渲染，直到条件为  true，并且切换条件时会触发销毁/挂载组件，所以总的来说在切换时开销更高，更适合不经常切换的场景。"></a>v-if 的话就得说到 Vue 底层的编译了。当属性初始为  false  时，组件就不会被渲染，直到条件为  true，并且切换条件时会触发销毁/挂载组件，所以总的来说在切换时开销更高，更适合不经常切换的场景。</h5><h4 id="并且基于-v-if-的这种惰性渲染机制，可以在必要的时候才去渲染组件，减少整个页面的初始渲染开销。"><a href="#并且基于-v-if-的这种惰性渲染机制，可以在必要的时候才去渲染组件，减少整个页面的初始渲染开销。" class="headerlink" title="并且基于  v-if  的这种惰性渲染机制，可以在必要的时候才去渲染组件，减少整个页面的初始渲染开销。"></a>并且基于  v-if  的这种惰性渲染机制，可以在必要的时候才去渲染组件，减少整个页面的初始渲染开销。</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;v-show-与-v-if-区别&quot;&gt;&lt;a href=&quot;#v-show-与-v-if-区别&quot; class=&quot;headerlink&quot; title=&quot;v-show 与 v-if 区别&quot;&gt;&lt;/a&gt;v-show 与 v-if 区别&lt;/h3&gt;&lt;h4 id=&quot;v-show&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="vue" scheme="http://blog.bochunhao.cn/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue_computed_watch</title>
    <link href="http://blog.bochunhao.cn/2018/05/10/vue-computed-watch/"/>
    <id>http://blog.bochunhao.cn/2018/05/10/vue-computed-watch/</id>
    <published>2018-05-10T12:17:10.000Z</published>
    <updated>2019-03-26T06:20:25.227Z</updated>
    
    <content type="html"><![CDATA[<h3 id="computed-和-watch-区别"><a href="#computed-和-watch-区别" class="headerlink" title="computed 和 watch 区别"></a>computed 和 watch 区别</h3><h4 id="computed-是计算属性，依赖其他属性计算值，并且-computed-的值有缓存，只有当计算值变化才会返回内容。"><a href="#computed-是计算属性，依赖其他属性计算值，并且-computed-的值有缓存，只有当计算值变化才会返回内容。" class="headerlink" title="computed  是计算属性，依赖其他属性计算值，并且  computed  的值有缓存，只有当计算值变化才会返回内容。"></a>computed  是计算属性，依赖其他属性计算值，并且  computed  的值有缓存，只有当计算值变化才会返回内容。</h4><h4 id="watch-监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。"><a href="#watch-监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。" class="headerlink" title="watch  监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。"></a>watch  监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。</h4><p>所以一般来说需要依赖别的属性来动态获得值的时候可以使用  computed，对于监听到值的变化需要做一些复杂业务逻辑的情况可以使用  watch。</p><h6 id="另外-computed-和-watch-还都支持对象的写法，这种方式知道的人并不多。"><a href="#另外-computed-和-watch-还都支持对象的写法，这种方式知道的人并不多。" class="headerlink" title="另外  computed  和  watch  还都支持对象的写法，这种方式知道的人并不多。"></a>另外  computed  和  watch  还都支持对象的写法，这种方式知道的人并不多。</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vm.<span class="variable">$watch</span>(<span class="string">'obj'</span>, &#123;</span><br><span class="line">    // 深度遍历</span><br><span class="line">    deep: <span class="literal">true</span>,</span><br><span class="line">    // 立即触发</span><br><span class="line">    immediate: <span class="literal">true</span>,</span><br><span class="line">    // 执行的函数</span><br><span class="line">    handler: <span class="keyword">function</span>(val, oldVal) &#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  data: &#123; a: 1 &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    aPlus: &#123;</span><br><span class="line">      // this.aPlus 时触发</span><br><span class="line">      get: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        <span class="built_in">return</span> this.a + 1</span><br><span class="line">      &#125;,</span><br><span class="line">      // this.aPlus = 1 时触发</span><br><span class="line">      <span class="built_in">set</span>: <span class="keyword">function</span> (v) &#123;</span><br><span class="line">        this.a = v - 1</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;computed-和-watch-区别&quot;&gt;&lt;a href=&quot;#computed-和-watch-区别&quot; class=&quot;headerlink&quot; title=&quot;computed 和 watch 区别&quot;&gt;&lt;/a&gt;computed 和 watch 区别&lt;/h3&gt;&lt;h4 i
      
    
    </summary>
    
    
      <category term="vue" scheme="http://blog.bochunhao.cn/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue_communication</title>
    <link href="http://blog.bochunhao.cn/2018/04/08/vue-communication/"/>
    <id>http://blog.bochunhao.cn/2018/04/08/vue-communication/</id>
    <published>2018-04-08T05:51:48.000Z</published>
    <updated>2019-03-26T06:08:05.711Z</updated>
    
    <content type="html"><![CDATA[<h3 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h3><h5 id="组件通信一般分为以下几种情况："><a href="#组件通信一般分为以下几种情况：" class="headerlink" title="组件通信一般分为以下几种情况："></a>组件通信一般分为以下几种情况：</h5><p>父子组件通信<br>兄弟组件通信<br>跨多层级组件通信<br>任意组件</p><h5 id="对于以上每种情况都有多种方式去实现，接下来就来学习下如何实现。"><a href="#对于以上每种情况都有多种方式去实现，接下来就来学习下如何实现。" class="headerlink" title="对于以上每种情况都有多种方式去实现，接下来就来学习下如何实现。"></a>对于以上每种情况都有多种方式去实现，接下来就来学习下如何实现。</h5><h4 id="父子通信"><a href="#父子通信" class="headerlink" title="父子通信"></a>父子通信</h4><h6 id="父组件通过-props-传递数据给子组件，子组件通过-emit-发送事件传递数据给父组件，这两种方式是最常用的父子通信实现办法。"><a href="#父组件通过-props-传递数据给子组件，子组件通过-emit-发送事件传递数据给父组件，这两种方式是最常用的父子通信实现办法。" class="headerlink" title="父组件通过  props  传递数据给子组件，子组件通过  emit  发送事件传递数据给父组件，这两种方式是最常用的父子通信实现办法。"></a>父组件通过  props  传递数据给子组件，子组件通过  emit  发送事件传递数据给父组件，这两种方式是最常用的父子通信实现办法。</h6><p>这种父子通信方式也就是典型的单向数据流，父组件通过  props  传递数据，子组件不能直接修改  props， 而是必须通过发送事件的方式告知父组件修改数据。</p><h6 id="另外这两种方式还可以使用语法糖-v-model-来直接实现，因为-v-model-默认会解析成名为-value-的-prop-和名为-input-的事件。这种语法糖的方式是典型的双向绑定，常用于-UI-控件上，但是究其根本，还是通过事件的方法让父组件修改数据。"><a href="#另外这两种方式还可以使用语法糖-v-model-来直接实现，因为-v-model-默认会解析成名为-value-的-prop-和名为-input-的事件。这种语法糖的方式是典型的双向绑定，常用于-UI-控件上，但是究其根本，还是通过事件的方法让父组件修改数据。" class="headerlink" title="另外这两种方式还可以使用语法糖  v-model  来直接实现，因为  v-model  默认会解析成名为  value  的  prop  和名为  input  的事件。这种语法糖的方式是典型的双向绑定，常用于 UI 控件上，但是究其根本，还是通过事件的方法让父组件修改数据。"></a>另外这两种方式还可以使用语法糖  v-model  来直接实现，因为  v-model  默认会解析成名为  value  的  prop  和名为  input  的事件。这种语法糖的方式是典型的双向绑定，常用于 UI 控件上，但是究其根本，还是通过事件的方法让父组件修改数据。</h6><p>当然我们还可以通过访问  $parent 或者 $children  对象来访问组件实例中的方法和数据。</p><p>另外如果你使用 Vue 2.3 及以上版本的话还可以使用  \$listeners  和  .sync  这两个属性。</p><h6 id="listeners-属性会将父组件中的-不含-native-修饰器的-v-on-事件监听器传递给子组件，子组件可以通过访问-listeners-来自定义监听器。"><a href="#listeners-属性会将父组件中的-不含-native-修饰器的-v-on-事件监听器传递给子组件，子组件可以通过访问-listeners-来自定义监听器。" class="headerlink" title="$listeners 属性会将父组件中的 (不含 .native 修饰器的) v-on 事件监听器传递给子组件，子组件可以通过访问 $listeners  来自定义监听器。"></a>$listeners 属性会将父组件中的 (不含 .native 修饰器的) v-on 事件监听器传递给子组件，子组件可以通过访问 $listeners  来自定义监听器。</h6><h6 id="sync-属性是个语法糖，可以很简单的实现子组件与父组件通信"><a href="#sync-属性是个语法糖，可以很简单的实现子组件与父组件通信" class="headerlink" title=".sync  属性是个语法糖，可以很简单的实现子组件与父组件通信"></a>.sync  属性是个语法糖，可以很简单的实现子组件与父组件通信</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--父组件中--&gt;</span><br><span class="line">&lt;input :value.sync=<span class="string">"value"</span> /&gt;</span><br><span class="line">&lt;!--以上写法等同于--&gt;</span><br><span class="line">&lt;input :value=<span class="string">"value"</span> @update:value=<span class="string">"v =&gt; value = v"</span>&gt;&lt;/comp&gt;</span><br><span class="line">&lt;!--子组件中--&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  this.<span class="variable">$emit</span>(<span class="string">'update:value'</span>, 1)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="兄弟组件通信"><a href="#兄弟组件通信" class="headerlink" title="兄弟组件通信"></a>兄弟组件通信</h4><h6 id="对于这种情况可以通过查找父组件中的子组件实现，也就是-this-parent-children，在-children-中可以通过组件-name-查询到需要的组件实例，然后进行通信。"><a href="#对于这种情况可以通过查找父组件中的子组件实现，也就是-this-parent-children，在-children-中可以通过组件-name-查询到需要的组件实例，然后进行通信。" class="headerlink" title="对于这种情况可以通过查找父组件中的子组件实现，也就是  this.$parent.$children，在  \$children 中可以通过组件  name  查询到需要的组件实例，然后进行通信。"></a>对于这种情况可以通过查找父组件中的子组件实现，也就是  this.$parent.$children，在  \$children 中可以通过组件  name  查询到需要的组件实例，然后进行通信。</h6><h4 id="跨多层次组件通信"><a href="#跨多层次组件通信" class="headerlink" title="跨多层次组件通信"></a>跨多层次组件通信</h4><h6 id="对于这种情况可以使用-Vue-2-2-新增的-API-provide-inject，虽然文档中不推荐直接使用在业务中，但是如果用得好的话还是很有用的。"><a href="#对于这种情况可以使用-Vue-2-2-新增的-API-provide-inject，虽然文档中不推荐直接使用在业务中，但是如果用得好的话还是很有用的。" class="headerlink" title="对于这种情况可以使用 Vue 2.2 新增的 API provide / inject，虽然文档中不推荐直接使用在业务中，但是如果用得好的话还是很有用的。"></a>对于这种情况可以使用 Vue 2.2 新增的 API provide / inject，虽然文档中不推荐直接使用在业务中，但是如果用得好的话还是很有用的。</h6><h5 id="假设有父组件-A，然后有一个跨多层级的子组件-B"><a href="#假设有父组件-A，然后有一个跨多层级的子组件-B" class="headerlink" title="假设有父组件 A，然后有一个跨多层级的子组件 B"></a>假设有父组件 A，然后有一个跨多层级的子组件 B</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 父组件 A</span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  provide: &#123;</span><br><span class="line">    data: 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 子组件 B</span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  inject: [<span class="string">'data'</span>],</span><br><span class="line">  <span class="function"><span class="title">mounted</span></span>() &#123;</span><br><span class="line">    // 无论跨几层都能获得父组件的 data 属性</span><br><span class="line">    console.log(this.data) // =&gt; 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="任意组件"><a href="#任意组件" class="headerlink" title="任意组件"></a>任意组件</h4><h6 id="这种方式可以通过-Vuex-或者-Event-Bus-解决，另外如果你不怕麻烦的话，可以使用这种方式解决上述所有的通信情况"><a href="#这种方式可以通过-Vuex-或者-Event-Bus-解决，另外如果你不怕麻烦的话，可以使用这种方式解决上述所有的通信情况" class="headerlink" title="这种方式可以通过 Vuex 或者 Event Bus 解决，另外如果你不怕麻烦的话，可以使用这种方式解决上述所有的通信情况"></a>这种方式可以通过 Vuex 或者 Event Bus 解决，另外如果你不怕麻烦的话，可以使用这种方式解决上述所有的通信情况</h6>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;组件通信&quot;&gt;&lt;a href=&quot;#组件通信&quot; class=&quot;headerlink&quot; title=&quot;组件通信&quot;&gt;&lt;/a&gt;组件通信&lt;/h3&gt;&lt;h5 id=&quot;组件通信一般分为以下几种情况：&quot;&gt;&lt;a href=&quot;#组件通信一般分为以下几种情况：&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="vue" scheme="http://blog.bochunhao.cn/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue_mixin_mixins</title>
    <link href="http://blog.bochunhao.cn/2018/04/02/vue-mixin-mixins/"/>
    <id>http://blog.bochunhao.cn/2018/04/02/vue-mixin-mixins/</id>
    <published>2018-04-02T06:06:29.000Z</published>
    <updated>2019-03-26T06:07:41.895Z</updated>
    
    <content type="html"><![CDATA[<h3 id="mixin-和-mixins-区别"><a href="#mixin-和-mixins-区别" class="headerlink" title="mixin 和 mixins 区别"></a>mixin 和 mixins 区别</h3><h6 id="mixin-用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的。"><a href="#mixin-用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的。" class="headerlink" title="mixin  用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的。"></a>mixin  用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的。</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.mixin(&#123;</span><br><span class="line">    <span class="function"><span class="title">beforeCreate</span></span>() &#123;</span><br><span class="line">        // ...逻辑</span><br><span class="line">        // 这种方式会影响到每个组件的 beforeCreate 钩子函数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="虽然文档不建议我们在应用中直接使用-mixin，但是如果不滥用的话也是很有帮助的，比如可以全局混入封装好的-ajax-或者一些工具函数等等。"><a href="#虽然文档不建议我们在应用中直接使用-mixin，但是如果不滥用的话也是很有帮助的，比如可以全局混入封装好的-ajax-或者一些工具函数等等。" class="headerlink" title="虽然文档不建议我们在应用中直接使用  mixin，但是如果不滥用的话也是很有帮助的，比如可以全局混入封装好的  ajax  或者一些工具函数等等。"></a>虽然文档不建议我们在应用中直接使用  mixin，但是如果不滥用的话也是很有帮助的，比如可以全局混入封装好的  ajax  或者一些工具函数等等。</h5><h6 id="mixins-应该是我们最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过-mixins-混入代码，比如上拉下拉加载数据这种逻辑等等。"><a href="#mixins-应该是我们最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过-mixins-混入代码，比如上拉下拉加载数据这种逻辑等等。" class="headerlink" title="mixins  应该是我们最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过  mixins  混入代码，比如上拉下拉加载数据这种逻辑等等。"></a>mixins  应该是我们最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过  mixins  混入代码，比如上拉下拉加载数据这种逻辑等等。</h6><h6 id="另外需要注意的是-mixins-混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并，具体可以阅读-文档。"><a href="#另外需要注意的是-mixins-混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并，具体可以阅读-文档。" class="headerlink" title="另外需要注意的是  mixins  混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并，具体可以阅读   文档。"></a>另外需要注意的是  mixins  混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并，具体可以阅读   文档。</h6>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;mixin-和-mixins-区别&quot;&gt;&lt;a href=&quot;#mixin-和-mixins-区别&quot; class=&quot;headerlink&quot; title=&quot;mixin 和 mixins 区别&quot;&gt;&lt;/a&gt;mixin 和 mixins 区别&lt;/h3&gt;&lt;h6 id=&quot;mixin
      
    
    </summary>
    
    
      <category term="vue" scheme="http://blog.bochunhao.cn/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue_lifecycle</title>
    <link href="http://blog.bochunhao.cn/2018/03/26/vue-lifecycle/"/>
    <id>http://blog.bochunhao.cn/2018/03/26/vue-lifecycle/</id>
    <published>2018-03-26T05:56:41.000Z</published>
    <updated>2019-03-26T06:30:37.383Z</updated>
    
    <content type="html"><![CDATA[<h3 id="生命周期钩子函数"><a href="#生命周期钩子函数" class="headerlink" title="生命周期钩子函数"></a>生命周期钩子函数</h3><h5 id="在-beforeCreate-钩子函数调用的时候，是获取不到-props-或者-data-中的数据的，因为这些数据的初始化都在-initState-中。"><a href="#在-beforeCreate-钩子函数调用的时候，是获取不到-props-或者-data-中的数据的，因为这些数据的初始化都在-initState-中。" class="headerlink" title="在  beforeCreate  钩子函数调用的时候，是获取不到  props  或者  data  中的数据的，因为这些数据的初始化都在  initState  中。"></a>在  beforeCreate  钩子函数调用的时候，是获取不到  props  或者  data  中的数据的，因为这些数据的初始化都在  initState  中。</h5><h5 id="然后会执行-created-钩子函数，在这一步的时候已经可以访问到之前不能访问到的数据，但是这时候组件还没被挂载，所以是看不到的。"><a href="#然后会执行-created-钩子函数，在这一步的时候已经可以访问到之前不能访问到的数据，但是这时候组件还没被挂载，所以是看不到的。" class="headerlink" title="然后会执行  created  钩子函数，在这一步的时候已经可以访问到之前不能访问到的数据，但是这时候组件还没被挂载，所以是看不到的。"></a>然后会执行  created  钩子函数，在这一步的时候已经可以访问到之前不能访问到的数据，但是这时候组件还没被挂载，所以是看不到的。</h5><h5 id="接下来会先执行-beforeMount-钩子函数，开始创建-VDOM，最后执行-mounted-钩子，并将-VDOM-渲染为真实-DOM-并且渲染数据。组件中如果有子组件的话，会递归挂载子组件，只有当所有子组件全部挂载完毕，才会执行根组件的挂载钩子。"><a href="#接下来会先执行-beforeMount-钩子函数，开始创建-VDOM，最后执行-mounted-钩子，并将-VDOM-渲染为真实-DOM-并且渲染数据。组件中如果有子组件的话，会递归挂载子组件，只有当所有子组件全部挂载完毕，才会执行根组件的挂载钩子。" class="headerlink" title="接下来会先执行  beforeMount  钩子函数，开始创建 VDOM，最后执行  mounted  钩子，并将 VDOM 渲染为真实 DOM 并且渲染数据。组件中如果有子组件的话，会递归挂载子组件，只有当所有子组件全部挂载完毕，才会执行根组件的挂载钩子。"></a>接下来会先执行  beforeMount  钩子函数，开始创建 VDOM，最后执行  mounted  钩子，并将 VDOM 渲染为真实 DOM 并且渲染数据。组件中如果有子组件的话，会递归挂载子组件，只有当所有子组件全部挂载完毕，才会执行根组件的挂载钩子。</h5><h5 id="接下来是数据更新时会调用的钩子函数-beforeUpdate-和-updated，这两个钩子函数没什么好说的，就是分别在数据更新前和更新后会调用。"><a href="#接下来是数据更新时会调用的钩子函数-beforeUpdate-和-updated，这两个钩子函数没什么好说的，就是分别在数据更新前和更新后会调用。" class="headerlink" title="接下来是数据更新时会调用的钩子函数  beforeUpdate  和  updated，这两个钩子函数没什么好说的，就是分别在数据更新前和更新后会调用。"></a>接下来是数据更新时会调用的钩子函数  beforeUpdate  和  updated，这两个钩子函数没什么好说的，就是分别在数据更新前和更新后会调用。</h5><h5 id="另外还有-keep-alive-独有的生命周期，分别为-activated-和-deactivated-。用-keep-alive-包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行-deactivated-钩子函数，命中缓存渲染后会执行-actived-钩子函数。"><a href="#另外还有-keep-alive-独有的生命周期，分别为-activated-和-deactivated-。用-keep-alive-包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行-deactivated-钩子函数，命中缓存渲染后会执行-actived-钩子函数。" class="headerlink" title="另外还有  keep-alive  独有的生命周期，分别为  activated  和  deactivated 。用  keep-alive  包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行  deactivated  钩子函数，命中缓存渲染后会执行  actived  钩子函数。"></a>另外还有  keep-alive  独有的生命周期，分别为  activated  和  deactivated 。用  keep-alive  包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行  deactivated  钩子函数，命中缓存渲染后会执行  actived  钩子函数。</h5><h5 id="最后就是销毁组件的钩子函数-beforeDestroy-和-destroyed。前者适合移除事件、定时器等等，否则可能会引起内存泄露的问题。然后进行一系列的销毁操作，如果有子组件的话，也会递归销毁子组件，所有子组件都销毁完毕后才会执行根组件的-destroyed-钩子函数。"><a href="#最后就是销毁组件的钩子函数-beforeDestroy-和-destroyed。前者适合移除事件、定时器等等，否则可能会引起内存泄露的问题。然后进行一系列的销毁操作，如果有子组件的话，也会递归销毁子组件，所有子组件都销毁完毕后才会执行根组件的-destroyed-钩子函数。" class="headerlink" title="最后就是销毁组件的钩子函数  beforeDestroy  和  destroyed。前者适合移除事件、定时器等等，否则可能会引起内存泄露的问题。然后进行一系列的销毁操作，如果有子组件的话，也会递归销毁子组件，所有子组件都销毁完毕后才会执行根组件的  destroyed  钩子函数。"></a>最后就是销毁组件的钩子函数  beforeDestroy  和  destroyed。前者适合移除事件、定时器等等，否则可能会引起内存泄露的问题。然后进行一系列的销毁操作，如果有子组件的话，也会递归销毁子组件，所有子组件都销毁完毕后才会执行根组件的  destroyed  钩子函数。</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;生命周期钩子函数&quot;&gt;&lt;a href=&quot;#生命周期钩子函数&quot; class=&quot;headerlink&quot; title=&quot;生命周期钩子函数&quot;&gt;&lt;/a&gt;生命周期钩子函数&lt;/h3&gt;&lt;h5 id=&quot;在-beforeCreate-钩子函数调用的时候，是获取不到-props-或者-d
      
    
    </summary>
    
    
      <category term="vue" scheme="http://blog.bochunhao.cn/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>REACT_组件通信</title>
    <link href="http://blog.bochunhao.cn/2018/03/25/react_fscom/"/>
    <id>http://blog.bochunhao.cn/2018/03/25/react_fscom/</id>
    <published>2018-03-25T14:25:58.000Z</published>
    <updated>2019-03-25T14:59:16.887Z</updated>
    
    <content type="html"><![CDATA[<h3 id="父子组件通信"><a href="#父子组件通信" class="headerlink" title="父子组件通信"></a>父子组件通信</h3><h5 id="父组件通过-props-传递数据给子组件，子组件通过调用父组件传来的函数传递数据给父组件，这两种方式是最常用的父子通信实现办法。这种父子通信方式也就是典型的单向数据流，父组件通过-props-传递数据，子组件不能直接修改-props，-而是必须通过调用父组件函数的方式告知父组件修改数据。"><a href="#父组件通过-props-传递数据给子组件，子组件通过调用父组件传来的函数传递数据给父组件，这两种方式是最常用的父子通信实现办法。这种父子通信方式也就是典型的单向数据流，父组件通过-props-传递数据，子组件不能直接修改-props，-而是必须通过调用父组件函数的方式告知父组件修改数据。" class="headerlink" title="父组件通过  props  传递数据给子组件，子组件通过调用父组件传来的函数传递数据给父组件，这两种方式是最常用的父子通信实现办法。这种父子通信方式也就是典型的单向数据流，父组件通过  props  传递数据，子组件不能直接修改  props， 而是必须通过调用父组件函数的方式告知父组件修改数据。"></a>父组件通过  props  传递数据给子组件，子组件通过调用父组件传来的函数传递数据给父组件，这两种方式是最常用的父子通信实现办法。这种父子通信方式也就是典型的单向数据流，父组件通过  props  传递数据，子组件不能直接修改  props， 而是必须通过调用父组件函数的方式告知父组件修改数据。</h5><h3 id="兄弟组件通信"><a href="#兄弟组件通信" class="headerlink" title="兄弟组件通信"></a>兄弟组件通信</h3><h5 id="对于这种情况可以通过共同的父组件来管理状态和事件函数。比如说其中一个兄弟组件调用父组件传递过来的事件函数修改父组件中的状态，然后父组件将状态传递给另一个兄弟组件。"><a href="#对于这种情况可以通过共同的父组件来管理状态和事件函数。比如说其中一个兄弟组件调用父组件传递过来的事件函数修改父组件中的状态，然后父组件将状态传递给另一个兄弟组件。" class="headerlink" title="对于这种情况可以通过共同的父组件来管理状态和事件函数。比如说其中一个兄弟组件调用父组件传递过来的事件函数修改父组件中的状态，然后父组件将状态传递给另一个兄弟组件。"></a>对于这种情况可以通过共同的父组件来管理状态和事件函数。比如说其中一个兄弟组件调用父组件传递过来的事件函数修改父组件中的状态，然后父组件将状态传递给另一个兄弟组件。</h5><h3 id="跨多层次组件通信"><a href="#跨多层次组件通信" class="headerlink" title="跨多层次组件通信"></a>跨多层次组件通信</h3><h5 id="如果你使用-16-3-以上版本的话，对于这种情况可以使用-Context-API。"><a href="#如果你使用-16-3-以上版本的话，对于这种情况可以使用-Context-API。" class="headerlink" title="如果你使用 16.3 以上版本的话，对于这种情况可以使用 Context API。"></a>如果你使用 16.3 以上版本的话，对于这种情况可以使用 Context API。</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 创建 Context，可以在开始就传入值</span><br><span class="line">const StateContext = React.createContext()</span><br><span class="line">class Parent extends React.Component &#123;</span><br><span class="line">  <span class="function"><span class="title">render</span></span> () &#123;</span><br><span class="line">    <span class="built_in">return</span> (</span><br><span class="line">      // value 就是传入 Context 中的值</span><br><span class="line">      &lt;StateContext.Provider value=<span class="string">'yck'</span>&gt;</span><br><span class="line">        &lt;Child /&gt;</span><br><span class="line">      &lt;/StateContext.Provider&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Child extends React.Component &#123;</span><br><span class="line">  <span class="function"><span class="title">render</span></span> () &#123;</span><br><span class="line">    <span class="built_in">return</span> (</span><br><span class="line">      &lt;ThemeContext.Consumer&gt;</span><br><span class="line">        // 取出值</span><br><span class="line">        &#123;context =&gt; (</span><br><span class="line">          name is &#123; context &#125;</span><br><span class="line">        )&#125;</span><br><span class="line">      &lt;/ThemeContext.Consumer&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;父子组件通信&quot;&gt;&lt;a href=&quot;#父子组件通信&quot; class=&quot;headerlink&quot; title=&quot;父子组件通信&quot;&gt;&lt;/a&gt;父子组件通信&lt;/h3&gt;&lt;h5 id=&quot;父组件通过-props-传递数据给子组件，子组件通过调用父组件传来的函数传递数据给父组件，这两种方
      
    
    </summary>
    
    
      <category term="react" scheme="http://blog.bochunhao.cn/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>REACT_setState</title>
    <link href="http://blog.bochunhao.cn/2018/03/22/setStarte/"/>
    <id>http://blog.bochunhao.cn/2018/03/22/setStarte/</id>
    <published>2018-03-22T12:33:57.000Z</published>
    <updated>2019-03-25T15:33:50.419Z</updated>
    
    <content type="html"><![CDATA[<h2 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h2><h3 id="setState-在-React-中是经常使用的一个-API，但是它存在一些的问题经常会导致初学者出错，核心原因就是因为这个-API-是异步的。首先-setState-的调用并不会马上引起-state-的改变，并且如果你一次调用了多个-setState-，那么结果可能并不如你期待的一样。"><a href="#setState-在-React-中是经常使用的一个-API，但是它存在一些的问题经常会导致初学者出错，核心原因就是因为这个-API-是异步的。首先-setState-的调用并不会马上引起-state-的改变，并且如果你一次调用了多个-setState-，那么结果可能并不如你期待的一样。" class="headerlink" title="setState 在 React 中是经常使用的一个 API，但是它存在一些的问题经常会导致初学者出错，核心原因就是因为这个 API 是异步的。首先  setState  的调用并不会马上引起  state  的改变，并且如果你一次调用了多个  setState ，那么结果可能并不如你期待的一样。"></a>setState 在 React 中是经常使用的一个 API，但是它存在一些的问题经常会导致初学者出错，核心原因就是因为这个 API 是异步的。首先  setState  的调用并不会马上引起  state  的改变，并且如果你一次调用了多个  setState ，那么结果可能并不如你期待的一样。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">handle</span></span>() &#123;</span><br><span class="line">  // 初始化 `count` 为 0</span><br><span class="line">  console.log(this.state.count) // -&gt; 0</span><br><span class="line">  this.setState(&#123; count: this.state.count + 1 &#125;)</span><br><span class="line">  this.setState(&#123; count: this.state.count + 1 &#125;)</span><br><span class="line">  this.setState(&#123; count: this.state.count + 1 &#125;)</span><br><span class="line">  console.log(this.state.count) // -&gt; 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第一，两次的打印都为-0，因为-setState-是个异步-API，只有同步代码运行完毕才会执行。setState-异步的原因我认为在于，setState-可能会导致-DOM-的重绘，如果调用一次就马上去进行重绘，那么调用多次就会造成不必要的性能损失。设计成异步的话，就可以将多次调用放入一个队列中，在恰当的时候统一进行更新过程。"><a href="#第一，两次的打印都为-0，因为-setState-是个异步-API，只有同步代码运行完毕才会执行。setState-异步的原因我认为在于，setState-可能会导致-DOM-的重绘，如果调用一次就马上去进行重绘，那么调用多次就会造成不必要的性能损失。设计成异步的话，就可以将多次调用放入一个队列中，在恰当的时候统一进行更新过程。" class="headerlink" title="第一，两次的打印都为 0，因为  setState  是个异步 API，只有同步代码运行完毕才会执行。setState  异步的原因我认为在于，setState  可能会导致 DOM 的重绘，如果调用一次就马上去进行重绘，那么调用多次就会造成不必要的性能损失。设计成异步的话，就可以将多次调用放入一个队列中，在恰当的时候统一进行更新过程。"></a>第一，两次的打印都为 0，因为  setState  是个异步 API，只有同步代码运行完毕才会执行。setState  异步的原因我认为在于，setState  可能会导致 DOM 的重绘，如果调用一次就马上去进行重绘，那么调用多次就会造成不必要的性能损失。设计成异步的话，就可以将多次调用放入一个队列中，在恰当的时候统一进行更新过程。</h3><h3 id="第二，虽然调用了三次-setState-，但是-count-的值还是为-1。因为多次调用会合并为一次，只有当更新结束后-state-才会改变，三次调用等同于如下代码"><a href="#第二，虽然调用了三次-setState-，但是-count-的值还是为-1。因为多次调用会合并为一次，只有当更新结束后-state-才会改变，三次调用等同于如下代码" class="headerlink" title="第二，虽然调用了三次  setState ，但是  count  的值还是为 1。因为多次调用会合并为一次，只有当更新结束后  state  才会改变，三次调用等同于如下代码"></a>第二，虽然调用了三次  setState ，但是  count  的值还是为 1。因为多次调用会合并为一次，只有当更新结束后  state  才会改变，三次调用等同于如下代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object.assign(</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  &#123; count: this.state.count + 1 &#125;,</span><br><span class="line">  &#123; count: this.state.count + 1 &#125;,</span><br><span class="line">  &#123; count: this.state.count + 1 &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="当然你也可以通过以下方式来实现调用三次-setState-使得-count-为-3"><a href="#当然你也可以通过以下方式来实现调用三次-setState-使得-count-为-3" class="headerlink" title="当然你也可以通过以下方式来实现调用三次  setState  使得  count  为 3"></a>当然你也可以通过以下方式来实现调用三次  setState  使得  count  为 3</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">handle</span></span>() &#123;</span><br><span class="line">  this.setState((prevState) =&gt; (&#123; count: prevState.count + 1 &#125;))</span><br><span class="line">  this.setState((prevState) =&gt; (&#123; count: prevState.count + 1 &#125;))</span><br><span class="line">  this.setState((prevState) =&gt; (&#123; count: prevState.count + 1 &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如果你想在每次调用-setState-后获得正确的-state-，可以通过如下代码实现"><a href="#如果你想在每次调用-setState-后获得正确的-state-，可以通过如下代码实现" class="headerlink" title="如果你想在每次调用  setState  后获得正确的  state ，可以通过如下代码实现"></a>如果你想在每次调用  setState  后获得正确的  state ，可以通过如下代码实现</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">handle</span></span>() &#123;</span><br><span class="line">    this.setState((prevState) =&gt; (&#123; count: prevState.count + 1 &#125;), () =&gt; &#123;</span><br><span class="line">        console.log(this.state)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;setState&quot;&gt;&lt;a href=&quot;#setState&quot; class=&quot;headerlink&quot; title=&quot;setState&quot;&gt;&lt;/a&gt;setState&lt;/h2&gt;&lt;h3 id=&quot;setState-在-React-中是经常使用的一个-API，但是它存在一些的问题
      
    
    </summary>
    
      <category term="react" scheme="http://blog.bochunhao.cn/categories/react/"/>
    
    
      <category term="react" scheme="http://blog.bochunhao.cn/tags/react/"/>
    
  </entry>
  
</feed>
