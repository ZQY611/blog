<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>es6_Symbol | 个人博客 | BCH</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="es6">
    <meta name="description" content="ES6 symbol概述ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入 Symbol 的原因。 ES6 引入了一种新的原始数据类型 Symbol，表示独一无二">
<meta name="keywords" content="es6">
<meta property="og:type" content="article">
<meta property="og:title" content="es6_Symbol">
<meta property="og:url" content="http://blog.bochunhao.cn/2019/02/15/es6-Symbol/index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="ES6 symbol概述ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入 Symbol 的原因。 ES6 引入了一种新的原始数据类型 Symbol，表示独一无二">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-03-29T16:32:57.871Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="es6_Symbol">
<meta name="twitter:description" content="ES6 symbol概述ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入 Symbol 的原因。 ES6 引入了一种新的原始数据类型 Symbol，表示独一无二">
    
        <link rel="alternate" type="application/atom+xml" title="个人博客" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide">
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/loggo.png">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">BCH</h5>
          <a href="mailto:17600280987@163.com" title="17600280987@163.com" class="mail">17600280987@163.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/">
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories">
                <i class="icon icon-lg icon-archives"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags">
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/bch9479/blog" target="_blank">
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://weibo.com/5900743344/profile?rightmod=1&wvr=6&mod=personinfo" target="_blank">
                <i class="icon icon-lg icon-weibo"></i>
                微博
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">es6_Symbol</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">es6_Symbol</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-02-14T16:21:28.000Z" itemprop="datePublished" class="page-time">
  2019-02-15
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/es6/">es6</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ES6-symbol"><span class="post-toc-number">1.</span> <span class="post-toc-text">ES6 symbol</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#概述"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">概述</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#作为属性名的-Symbol"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">作为属性名的 Symbol</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#实例：消除魔术字符串"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">实例：消除魔术字符串</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#属性名的遍历"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">属性名的遍历</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Symbol-for-，Symbol-keyFor"><span class="post-toc-number">1.4.1.</span> <span class="post-toc-text">Symbol.for()，Symbol.keyFor()</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#实例：模块的-Singleton-模式"><span class="post-toc-number">1.5.</span> <span class="post-toc-text">实例：模块的 Singleton 模式</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#内置的-Symbol-值"><span class="post-toc-number">1.6.</span> <span class="post-toc-text">内置的 Symbol 值</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Symbol-hasInstance"><span class="post-toc-number">1.6.1.</span> <span class="post-toc-text">Symbol.hasInstance</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Symbol-isConcatSpreadable"><span class="post-toc-number">1.6.2.</span> <span class="post-toc-text">Symbol.isConcatSpreadable</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Symbol-species"><span class="post-toc-number">1.6.3.</span> <span class="post-toc-text">Symbol.species</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Symbol-match"><span class="post-toc-number">1.6.4.</span> <span class="post-toc-text">Symbol.match</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Symbol-replace"><span class="post-toc-number">1.6.5.</span> <span class="post-toc-text">Symbol.replace</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Symbol-search"><span class="post-toc-number">1.6.6.</span> <span class="post-toc-text">Symbol.search</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Symbol-split"><span class="post-toc-number">1.6.7.</span> <span class="post-toc-text">Symbol.split</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Symbol-iterator"><span class="post-toc-number">1.6.8.</span> <span class="post-toc-text">Symbol.iterator</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Symbol-toPrimitive"><span class="post-toc-number">1.6.9.</span> <span class="post-toc-text">Symbol.toPrimitive</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Symbol-toStringTag"><span class="post-toc-number">1.6.10.</span> <span class="post-toc-text">Symbol.toStringTag</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Symbol-unscopables"><span class="post-toc-number">1.6.11.</span> <span class="post-toc-text">Symbol.unscopables</span></a></li></ol></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-es6-Symbol" class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">es6_Symbol</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-02-15 00:21:28" datetime="2019-02-14T16:21:28.000Z" itemprop="datePublished">2019-02-15</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/es6/">es6</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style="display:none">
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h3 id="ES6-symbol"><a href="#ES6-symbol" class="headerlink" title="ES6 symbol"></a>ES6 symbol</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入 Symbol 的原因。</p>
<p>ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：Undefined、Null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</p>
<p>Symbol 值通过 Symbol 函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> s = Symbol();</span><br><span class="line"></span><br><span class="line">typeof s</span><br><span class="line">// <span class="string">"symbol"</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，变量 s 就是一个独一无二的值。typeof 运算符的结果，表明变量 s 是 Symbol 数据类型，而不是字符串之类的其他类型。</p>
<p>注意，Symbol 函数前不能使用 new 命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。</p>
<p>Symbol 函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var s1 = Symbol(<span class="string">'foo'</span>);</span><br><span class="line">var s2 = Symbol(<span class="string">'bar'</span>);</span><br><span class="line"></span><br><span class="line">s1 // Symbol(foo)</span><br><span class="line">s2 // Symbol(bar)</span><br><span class="line"></span><br><span class="line">s1.toString() // <span class="string">"Symbol(foo)"</span></span><br><span class="line">s2.toString() // <span class="string">"Symbol(bar)"</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，s1 和 s2 是两个 Symbol 值。如果不加参数，它们在控制台的输出都是 Symbol()，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。</p>
<p>如果 Symbol 的参数是一个对象，就会调用该对象的 toString 方法，将其转为字符串，然后才生成一个 Symbol 值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line">  <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">'abc'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const sym = Symbol(obj);</span><br><span class="line">sym // Symbol(abc)</span><br></pre></td></tr></table></figure>
<p>注意，Symbol 函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的 Symbol 函数的返回值是不相等的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 没有参数的情况</span><br><span class="line">var s1 = Symbol();</span><br><span class="line">var s2 = Symbol();</span><br><span class="line"></span><br><span class="line">s1 === s2 // <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">// 有参数的情况</span><br><span class="line">var s1 = Symbol(<span class="string">'foo'</span>);</span><br><span class="line">var s2 = Symbol(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line">s1 === s2 // <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，s1 和 s2 都是 Symbol 函数的返回值，而且参数相同，但是它们是不相等的。</p>
<p>Symbol 值不能与其他类型的值进行运算，会报错。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var sym = Symbol(<span class="string">'My symbol'</span>);</span><br><span class="line"></span><br><span class="line"><span class="string">"your symbol is "</span> + sym</span><br><span class="line">// TypeError: can<span class="string">'t convert symbol to string</span></span><br><span class="line"><span class="string">`your symbol is $&#123;sym&#125;`</span></span><br><span class="line"><span class="string">// TypeError: can'</span>t convert symbol to string</span><br><span class="line">但是，Symbol值可以显式转为字符串。</span><br><span class="line"></span><br><span class="line">var sym = Symbol(<span class="string">'My symbol'</span>);</span><br><span class="line"></span><br><span class="line">String(sym) // <span class="string">'Symbol(My symbol)'</span></span><br><span class="line">sym.toString() // <span class="string">'Symbol(My symbol)'</span></span><br></pre></td></tr></table></figure>
<p>另外，Symbol 值也可以转为布尔值，但是不能转为数值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var sym = Symbol();</span><br><span class="line">Boolean(sym) // <span class="literal">true</span></span><br><span class="line">!sym  // <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sym) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Number(sym) // TypeError</span><br><span class="line">sym + 2 // TypeError</span><br></pre></td></tr></table></figure>
<h4 id="作为属性名的-Symbol"><a href="#作为属性名的-Symbol" class="headerlink" title="作为属性名的 Symbol"></a>作为属性名的 Symbol</h4><p>由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var mySymbol = Symbol();</span><br><span class="line"></span><br><span class="line">// 第一种写法</span><br><span class="line">var a = &#123;&#125;;</span><br><span class="line">a[mySymbol] = <span class="string">'Hello!'</span>;</span><br><span class="line"></span><br><span class="line">// 第二种写法</span><br><span class="line">var a = &#123;</span><br><span class="line">  [mySymbol]: <span class="string">'Hello!'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 第三种写法</span><br><span class="line">var a = &#123;&#125;;</span><br><span class="line">Object.defineProperty(a, mySymbol, &#123; value: <span class="string">'Hello!'</span> &#125;);</span><br><span class="line"></span><br><span class="line">// 以上写法都得到同样结果</span><br><span class="line">a[mySymbol] // <span class="string">"Hello!"</span></span><br></pre></td></tr></table></figure>
<p>上面代码通过方括号结构和 Object.defineProperty，将对象的属性名指定为一个 Symbol 值。</p>
<p>注意，Symbol 值作为对象属性名时，不能用点运算符。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var mySymbol = Symbol();</span><br><span class="line">var a = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">a.mySymbol = <span class="string">'Hello!'</span>;</span><br><span class="line">a[mySymbol] // undefined</span><br><span class="line">a[<span class="string">'mySymbol'</span>] // <span class="string">"Hello!"</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，因为点运算符后面总是字符串，所以不会读取 mySymbol 作为标识名所指代的那个值，导致 a 的属性名实际上是一个字符串，而不是一个 Symbol 值。</p>
<p>同理，在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> s = Symbol();</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> obj = &#123;</span><br><span class="line">  [s]: <span class="keyword">function</span> (arg) &#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj[s](123);</span><br></pre></td></tr></table></figure>
<p>上面代码中，如果 s 不放在方括号中，该属性的键名就是字符串 s，而不是 s 所代表的那个 Symbol 值。</p>
<p>采用增强的对象写法，上面代码的 obj 对象可以写得更简洁一些。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> obj = &#123;</span><br><span class="line">  [s](arg) &#123; ... &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Symbol 类型还可以用于定义一组常量，保证这组常量的值都是不相等的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">log.levels = &#123;</span><br><span class="line">  DEBUG: Symbol(<span class="string">'debug'</span>),</span><br><span class="line">  INFO: Symbol(<span class="string">'info'</span>),</span><br><span class="line">  WARN: Symbol(<span class="string">'warn'</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">log</span>(log.levels.DEBUG, <span class="string">'debug message'</span>);</span><br><span class="line"><span class="built_in">log</span>(log.levels.INFO, <span class="string">'info message'</span>);</span><br></pre></td></tr></table></figure>
<p>下面是另外一个例子。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const COLOR_RED    = Symbol();</span><br><span class="line">const COLOR_GREEN  = Symbol();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> getComplement(color) &#123;</span><br><span class="line">  switch (color) &#123;</span><br><span class="line">    <span class="keyword">case</span> COLOR_RED:</span><br><span class="line">      <span class="built_in">return</span> COLOR_GREEN;</span><br><span class="line">    <span class="keyword">case</span> COLOR_GREEN:</span><br><span class="line">      <span class="built_in">return</span> COLOR_RED;</span><br><span class="line">    default:</span><br><span class="line">      throw new Error(<span class="string">'Undefined color'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常量使用 Symbol 值最大的好处，就是其他任何值都不可能有相同的值了，因此可以保证上面的 switch 语句会按设计的方式工作。</p>
<p>还有一点需要注意，Symbol 值作为属性名时，该属性还是公开属性，不是私有属性。</p>
<h4 id="实例：消除魔术字符串"><a href="#实例：消除魔术字符串" class="headerlink" title="实例：消除魔术字符串"></a>实例：消除魔术字符串</h4><p>魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。风格良好的代码，应该尽量消除魔术字符串，该由含义清晰的变量代替。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> getArea(shape, options) &#123;</span><br><span class="line">  var area = 0;</span><br><span class="line"></span><br><span class="line">  switch (shape) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'Triangle'</span>: // 魔术字符串</span><br><span class="line">      area = .5 * options.width * options.height;</span><br><span class="line">      <span class="built_in">break</span>;</span><br><span class="line">    /* ... more code ... */</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> area;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getArea(<span class="string">'Triangle'</span>, &#123; width: 100, height: 100 &#125;); // 魔术字符串</span><br></pre></td></tr></table></figure>
<p>上面代码中，字符串“Triangle”就是一个魔术字符串。它多次出现，与代码形成“强耦合”，不利于将来的修改和维护。</p>
<p>常用的消除魔术字符串的方法，就是把它写成一个变量。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var shapeType = &#123;</span><br><span class="line">  triangle: <span class="string">'Triangle'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> getArea(shape, options) &#123;</span><br><span class="line">  var area = 0;</span><br><span class="line">  switch (shape) &#123;</span><br><span class="line">    <span class="keyword">case</span> shapeType.triangle:</span><br><span class="line">      area = .5 * options.width * options.height;</span><br><span class="line">      <span class="built_in">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> area;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getArea(shapeType.triangle, &#123; width: 100, height: 100 &#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中，我们把“Triangle”写成 shapeType 对象的 triangle 属性，这样就消除了强耦合。</p>
<p>如果仔细分析，可以发现 shapeType.triangle 等于哪个值并不重要，只要确保不会跟其他 shapeType 属性的值冲突即可。因此，这里就很适合改用 Symbol 值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const shapeType = &#123;</span><br><span class="line">  triangle: Symbol()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码中，除了将 shapeType.triangle 的值设为一个 Symbol，其他地方都不用修改。</p>
<h4 id="属性名的遍历"><a href="#属性名的遍历" class="headerlink" title="属性名的遍历"></a>属性名的遍历</h4><p>Symbol 作为属性名，该属性不会出现在 for…in、for…of 循环中，也不会被 Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。但是，它也不是私有属性，有一个 Object.getOwnPropertySymbols 方法，可以获取指定对象的所有 Symbol 属性名。</p>
<p>Object.getOwnPropertySymbols 方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">var a = Symbol(<span class="string">'a'</span>);</span><br><span class="line">var b = Symbol(<span class="string">'b'</span>);</span><br><span class="line"></span><br><span class="line">obj[a] = <span class="string">'Hello'</span>;</span><br><span class="line">obj[b] = <span class="string">'World'</span>;</span><br><span class="line"></span><br><span class="line">var objectSymbols = Object.getOwnPropertySymbols(obj);</span><br><span class="line"></span><br><span class="line">objectSymbols</span><br><span class="line">// [Symbol(a), Symbol(b)]</span><br></pre></td></tr></table></figure>
<p>下面是另一个例子，Object.getOwnPropertySymbols 方法与 for…in 循环、Object.getOwnPropertyNames 方法进行对比的例子。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">var foo = Symbol(<span class="string">"foo"</span>);</span><br><span class="line"></span><br><span class="line">Object.defineProperty(obj, foo, &#123;</span><br><span class="line">  value: <span class="string">"foobar"</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (var i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  console.log(i); // 无输出</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object.getOwnPropertyNames(obj)</span><br><span class="line">// []</span><br><span class="line"></span><br><span class="line">Object.getOwnPropertySymbols(obj)</span><br><span class="line">// [Symbol(foo)]</span><br></pre></td></tr></table></figure>
<p>上面代码中，使用 Object.getOwnPropertyNames 方法得不到 Symbol 属性名，需要使用 Object.getOwnPropertySymbols 方法。</p>
<p>另一个新的 API，Reflect.ownKeys 方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> obj = &#123;</span><br><span class="line">  [Symbol(<span class="string">'my_key'</span>)]: 1,</span><br><span class="line">  enum: 2,</span><br><span class="line">  nonEnum: 3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Reflect.ownKeys(obj)</span><br><span class="line">// [Symbol(my_key), <span class="string">'enum'</span>, <span class="string">'nonEnum'</span>]</span><br></pre></td></tr></table></figure>
<p>由于以 Symbol 值作为名称的属性，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var size = Symbol(<span class="string">'size'</span>);</span><br><span class="line"></span><br><span class="line">class Collection &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    this[size] = 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  add(item) &#123;</span><br><span class="line">    this[this[size]] = item;</span><br><span class="line">    this[size]++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static sizeOf(instance) &#123;</span><br><span class="line">    <span class="built_in">return</span> instance[size];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var x = new Collection();</span><br><span class="line">Collection.sizeOf(x) // 0</span><br><span class="line"></span><br><span class="line">x.add(<span class="string">'foo'</span>);</span><br><span class="line">Collection.sizeOf(x) // 1</span><br><span class="line"></span><br><span class="line">Object.keys(x) // [<span class="string">'0'</span>]</span><br><span class="line">Object.getOwnPropertyNames(x) // [<span class="string">'0'</span>]</span><br><span class="line">Object.getOwnPropertySymbols(x) // [Symbol(size)]</span><br></pre></td></tr></table></figure>
<p>上面代码中，对象 x 的 size 属性是一个 Symbol 值，所以 Object.keys(x)、Object.getOwnPropertyNames(x)都无法获取它。这就造成了一种非私有的内部方法的效果。</p>
<h5 id="Symbol-for-，Symbol-keyFor"><a href="#Symbol-for-，Symbol-keyFor" class="headerlink" title="Symbol.for()，Symbol.keyFor()"></a>Symbol.for()，Symbol.keyFor()</h5><p>有时，我们希望重新使用同一个 Symbol 值，Symbol.for 方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var s1 = Symbol.for(<span class="string">'foo'</span>);</span><br><span class="line">var s2 = Symbol.for(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line">s1 === s2 // <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，s1 和 s2 都是 Symbol 值，但是它们都是同样参数的 Symbol.for 方法生成的，所以实际上是同一个值。</p>
<p>Symbol.for()与 Symbol()这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。Symbol.for()不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的 key 是否已经存在，如果不存在才会新建一个值。比如，如果你调用 Symbol.for(“cat”)30 次，每次都会返回同一个 Symbol 值，但是调用 Symbol(“cat”)30 次，会返回 30 个不同的 Symbol 值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Symbol.for(<span class="string">"bar"</span>) === Symbol.for(<span class="string">"bar"</span>)</span><br><span class="line">// <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">Symbol(<span class="string">"bar"</span>) === Symbol(<span class="string">"bar"</span>)</span><br><span class="line">// <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，由于 Symbol()写法没有登记机制，所以每次调用都会返回一个不同的值。</p>
<p>Symbol.keyFor 方法返回一个已登记的 Symbol 类型值的 key。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var s1 = Symbol.for(<span class="string">"foo"</span>);</span><br><span class="line">Symbol.keyFor(s1) // <span class="string">"foo"</span></span><br><span class="line"></span><br><span class="line">var s2 = Symbol(<span class="string">"foo"</span>);</span><br><span class="line">Symbol.keyFor(s2) // undefined</span><br></pre></td></tr></table></figure>
<p>上面代码中，变量 s2 属于未登记的 Symbol 值，所以返回 undefined。</p>
<p>需要注意的是，Symbol.for 为 Symbol 值登记的名字，是全局环境的，可以在不同的 iframe 或 service worker 中取到同一个值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iframe = document.createElement(<span class="string">'iframe'</span>);</span><br><span class="line">iframe.src = String(window.location);</span><br><span class="line">document.body.appendChild(iframe);</span><br><span class="line"></span><br><span class="line">iframe.contentWindow.Symbol.for(<span class="string">'foo'</span>) === Symbol.for(<span class="string">'foo'</span>)</span><br><span class="line">// <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，iframe 窗口生成的 Symbol 值，可以在主页面得到。</p>
<h4 id="实例：模块的-Singleton-模式"><a href="#实例：模块的-Singleton-模式" class="headerlink" title="实例：模块的 Singleton 模式"></a>实例：模块的 Singleton 模式</h4><p>Singleton 模式指的是调用一个类，任何时候返回的都是同一个实例。</p>
<p>对于 Node 来说，模块文件可以看成是一个类。怎么保证每次执行这个模块文件，返回的都是同一个实例呢？</p>
<p>很容易想到，可以把实例放到顶层对象 global。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// mod.js</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">A</span></span>() &#123;</span><br><span class="line">  this.foo = <span class="string">'hello'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!global._foo) &#123;</span><br><span class="line">  global._foo = new A();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = global._foo;</span><br></pre></td></tr></table></figure>
<p>然后，加载上面的 mod.js。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = require(<span class="string">'./mod.js'</span>);</span><br><span class="line">console.log(a.foo);</span><br></pre></td></tr></table></figure>
<p>上面代码中，变量 a 任何时候加载的都是 A 的同一个实例。</p>
<p>但是，这里有一个问题，全局变量 global._foo 是可写的，任何文件都可以修改。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = require(<span class="string">'./mod.js'</span>);</span><br><span class="line">global._foo = 123;</span><br></pre></td></tr></table></figure>
<p>上面的代码，会使得别的脚本加载 mod.js 都失真。</p>
<p>为了防止这种情况出现，我们就可以使用 Symbol。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// mod.js</span><br><span class="line">const FOO_KEY = Symbol.for(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">A</span></span>() &#123;</span><br><span class="line">  this.foo = <span class="string">'hello'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!global[FOO_KEY]) &#123;</span><br><span class="line">  global[FOO_KEY] = new A();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = global[FOO_KEY];</span><br></pre></td></tr></table></figure>
<p>上面代码中，可以保证 global[FOO_KEY]不会被无意间覆盖，但还是可以被改写。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = require(<span class="string">'./mod.js'</span>);</span><br><span class="line">global[Symbol.for(<span class="string">'foo'</span>)] = 123;</span><br></pre></td></tr></table></figure>
<p>如果键名使用 Symbol 方法生成，那么外部将无法引用这个值，当然也就无法改写。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// mod.js</span><br><span class="line">const FOO_KEY = Symbol(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line">// 后面代码相同 ……</span><br></pre></td></tr></table></figure>
<p>上面代码将导致其他脚本都无法引用 FOO_KEY。但这样也有一个问题，就是如果多次执行这个脚本，每次得到的 FOO_KEY 都是不一样的。虽然 Node 会将脚本的执行结果缓存，一般情况下，不会多次执行同一个脚本，但是用户可以手动清除缓存，所以也不是完全可靠。</p>
<h4 id="内置的-Symbol-值"><a href="#内置的-Symbol-值" class="headerlink" title="内置的 Symbol 值"></a>内置的 Symbol 值</h4><p>除了定义自己使用的 Symbol 值以外，ES6 还提供了 11 个内置的 Symbol 值，指向语言内部使用的方法。</p>
<h5 id="Symbol-hasInstance"><a href="#Symbol-hasInstance" class="headerlink" title="Symbol.hasInstance"></a>Symbol.hasInstance</h5><p>对象的 Symbol.hasInstance 属性，指向一个内部方法。当其他对象使用 instanceof 运算符，判断是否为该对象的实例时，会调用这个方法。比如，foo instanceof Foo 在语言内部，实际调用的是 Foo<a href="foo">Symbol.hasInstance</a>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">  [Symbol.hasInstance](foo) &#123;</span><br><span class="line">    <span class="built_in">return</span> foo instanceof Array;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[1, 2, 3] instanceof new MyClass() // <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，MyClass 是一个类，new MyClass()会返回一个实例。该实例的 Symbol.hasInstance 方法，会在进行 instanceof 运算时自动调用，判断左侧的运算子是否为 Array 的实例。</p>
<p>下面是另一个例子。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Even &#123;</span><br><span class="line">  static [Symbol.hasInstance](obj) &#123;</span><br><span class="line">    <span class="built_in">return</span> Number(obj) % 2 === 0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">1 instanceof Even // <span class="literal">false</span></span><br><span class="line">2 instanceof Even // <span class="literal">true</span></span><br><span class="line">12345 instanceof Even // <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h5 id="Symbol-isConcatSpreadable"><a href="#Symbol-isConcatSpreadable" class="headerlink" title="Symbol.isConcatSpreadable"></a>Symbol.isConcatSpreadable</h5><p>对象的 Symbol.isConcatSpreadable 属性等于一个布尔值，表示该对象使用 Array.prototype.concat()时，是否可以展开。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arr1 = [<span class="string">'c'</span>, <span class="string">'d'</span>];</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>].concat(arr1, <span class="string">'e'</span>) // [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>]</span><br><span class="line">arr1[Symbol.isConcatSpreadable] // undefined</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> arr2 = [<span class="string">'c'</span>, <span class="string">'d'</span>];</span><br><span class="line">arr2[Symbol.isConcatSpreadable] = <span class="literal">false</span>;</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>].concat(arr2, <span class="string">'e'</span>) // [<span class="string">'a'</span>, <span class="string">'b'</span>, [<span class="string">'c'</span>,<span class="string">'d'</span>], <span class="string">'e'</span>]</span><br></pre></td></tr></table></figure>
<p>上面代码说明，数组的默认行为是可以展开。Symbol.isConcatSpreadable 属性等于 true 或 undefined，都有这个效果。</p>
<p>类似数组的对象也可以展开，但它的 Symbol.isConcatSpreadable 属性默认为 false，必须手动打开。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> obj = &#123;length: 2, 0: <span class="string">'c'</span>, 1: <span class="string">'d'</span>&#125;;</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>].concat(obj, <span class="string">'e'</span>) // [<span class="string">'a'</span>, <span class="string">'b'</span>, obj, <span class="string">'e'</span>]</span><br><span class="line"></span><br><span class="line">obj[Symbol.isConcatSpreadable] = <span class="literal">true</span>;</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>].concat(obj, <span class="string">'e'</span>) // [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>]</span><br></pre></td></tr></table></figure>
<p>对于一个类来说，Symbol.isConcatSpreadable 属性必须写成实例的属性。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class A1 extends Array &#123;</span><br><span class="line">  constructor(args) &#123;</span><br><span class="line">    super(args);</span><br><span class="line">    this[Symbol.isConcatSpreadable] = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class A2 extends Array &#123;</span><br><span class="line">  constructor(args) &#123;</span><br><span class="line">    super(args);</span><br><span class="line">    this[Symbol.isConcatSpreadable] = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> a1 = new A1();</span><br><span class="line">a1[0] = 3;</span><br><span class="line">a1[1] = 4;</span><br><span class="line"><span class="built_in">let</span> a2 = new A2();</span><br><span class="line">a2[0] = 5;</span><br><span class="line">a2[1] = 6;</span><br><span class="line">[1, 2].concat(a1).concat(a2)</span><br><span class="line">// [1, 2, 3, 4, [5, 6]]</span><br></pre></td></tr></table></figure>
<p>上面代码中，类 A1 是可展开的，类 A2 是不可展开的，所以使用 concat 时有不一样的结果。</p>
<h5 id="Symbol-species"><a href="#Symbol-species" class="headerlink" title="Symbol.species"></a>Symbol.species</h5><p>对象的 Symbol.species 属性，指向一个方法。该对象作为构造函数创造实例时，会调用这个方法。即如果 this.constructor[Symbol.species]存在，就会使用这个属性作为构造函数，来创造新的实例对象。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Symbol.species属性默认的读取器如下。</span><br><span class="line"></span><br><span class="line">static get [Symbol.species]() &#123;</span><br><span class="line">  <span class="built_in">return</span> this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Symbol-match"><a href="#Symbol-match" class="headerlink" title="Symbol.match"></a>Symbol.match</h5><p>对象的 Symbol.match 属性，指向一个函数。当执行 str.match(myObject)时，如果该属性存在，会调用它，返回该方法的返回值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String.prototype.match(regexp)</span><br><span class="line">// 等同于</span><br><span class="line">regexp[Symbol.match](this)</span><br><span class="line"></span><br><span class="line">class MyMatcher &#123;</span><br><span class="line">  [Symbol.match](string) &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">'hello world'</span>.indexOf(string);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">'e'</span>.match(new MyMatcher()) // 1</span><br></pre></td></tr></table></figure>
<h5 id="Symbol-replace"><a href="#Symbol-replace" class="headerlink" title="Symbol.replace"></a>Symbol.replace</h5><p>对象的 Symbol.replace 属性，指向一个方法，当该对象被 String.prototype.replace 方法调用时，会返回该方法的返回值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String.prototype.replace(searchValue, replaceValue)</span><br><span class="line">// 等同于</span><br><span class="line">searchValue[Symbol.replace](this, replaceValue)</span><br></pre></td></tr></table></figure>
<p>下面是一个例子。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const x = &#123;&#125;;</span><br><span class="line">x[Symbol.replace] = (...s) =&gt; console.log(s);</span><br><span class="line"></span><br><span class="line"><span class="string">'Hello'</span>.replace(x, <span class="string">'World'</span>) // [<span class="string">"Hello"</span>, <span class="string">"World"</span>]</span><br></pre></td></tr></table></figure>
<p>Symbol.replace 方法会收到两个参数，第一个参数是 replace 方法正在作用的对象，上面例子是 Hello，第二个参数是替换后的值，上面例子是 World。</p>
<h5 id="Symbol-search"><a href="#Symbol-search" class="headerlink" title="Symbol.search"></a>Symbol.search</h5><p>对象的 Symbol.search 属性，指向一个方法，当该对象被 String.prototype.search 方法调用时，会返回该方法的返回值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String.prototype.search(regexp)</span><br><span class="line">// 等同于</span><br><span class="line">regexp[Symbol.search](this)</span><br><span class="line"></span><br><span class="line">class MySearch &#123;</span><br><span class="line">  constructor(value) &#123;</span><br><span class="line">    this.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">  [Symbol.search](string) &#123;</span><br><span class="line">    <span class="built_in">return</span> string.indexOf(this.value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">'foobar'</span>.search(new MySearch(<span class="string">'foo'</span>)) // 0</span><br></pre></td></tr></table></figure>
<h5 id="Symbol-split"><a href="#Symbol-split" class="headerlink" title="Symbol.split"></a>Symbol.split</h5><p>对象的 Symbol.split 属性，指向一个方法，当该对象被 String.prototype.split 方法调用时，会返回该方法的返回值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String.prototype.split(separator, <span class="built_in">limit</span>)</span><br><span class="line">// 等同于</span><br><span class="line">separator[Symbol.split](this, <span class="built_in">limit</span>)</span><br></pre></td></tr></table></figure>
<h5 id="Symbol-iterator"><a href="#Symbol-iterator" class="headerlink" title="Symbol.iterator"></a>Symbol.iterator</h5><p>对象的 Symbol.iterator 属性，指向该对象的默认遍历器方法。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var myIterable = &#123;&#125;;</span><br><span class="line">myIterable[Symbol.iterator] = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  yield 2;</span><br><span class="line">  yield 3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[...myIterable] // [1, 2, 3]</span><br></pre></td></tr></table></figure>
<p>对象进行 for…of 循环时，会调用 Symbol.iterator 方法，返回该对象的默认遍历器，详细介绍参见《Iterator 和 for…of 循环》一章。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Collection &#123;</span><br><span class="line">  *[Symbol.iterator]() &#123;</span><br><span class="line">    <span class="built_in">let</span> i = 0;</span><br><span class="line">    <span class="keyword">while</span>(this[i] !== undefined) &#123;</span><br><span class="line">      yield this[i];</span><br><span class="line">      ++i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> myCollection = new Collection();</span><br><span class="line">myCollection[0] = 1;</span><br><span class="line">myCollection[1] = 2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">let</span> value of myCollection) &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br></pre></td></tr></table></figure>
<h5 id="Symbol-toPrimitive"><a href="#Symbol-toPrimitive" class="headerlink" title="Symbol.toPrimitive"></a>Symbol.toPrimitive</h5><p>对象的 Symbol.toPrimitive 属性，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。</p>
<p>Symbol.toPrimitive 被调用时，会接受一个字符串参数，表示当前运算的模式，一共有三种模式。</p>
<p>1.Number：该场合需要转成数值<br>2.String：该场合需要转成字符串<br>3.Default：该场合可以转成数值，也可以转成字符串</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> obj = &#123;</span><br><span class="line">  [Symbol.toPrimitive](hint) &#123;</span><br><span class="line">    switch (hint) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'number'</span>:</span><br><span class="line">        <span class="built_in">return</span> 123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'string'</span>:</span><br><span class="line">        <span class="built_in">return</span> <span class="string">'str'</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'default'</span>:</span><br><span class="line">        <span class="built_in">return</span> <span class="string">'default'</span>;</span><br><span class="line">      default:</span><br><span class="line">        throw new Error();</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">2 * obj // 246</span><br><span class="line">3 + obj // <span class="string">'3default'</span></span><br><span class="line">obj == <span class="string">'default'</span> // <span class="literal">true</span></span><br><span class="line">String(obj) // <span class="string">'str'</span></span><br></pre></td></tr></table></figure>
<h5 id="Symbol-toStringTag"><a href="#Symbol-toStringTag" class="headerlink" title="Symbol.toStringTag"></a>Symbol.toStringTag</h5><p>对象的 Symbol.toStringTag 属性，指向一个方法。在该对象上面调用 Object.prototype.toString 方法时，如果这个属性存在，它的返回值会出现在 toString 方法返回的字符串之中，表示对象的类型。也就是说，这个属性可以用来定制[object Object]或[object Array]中 object 后面的那个字符串。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 例一</span><br><span class="line">(&#123;[Symbol.toStringTag]: <span class="string">'Foo'</span>&#125;.toString())</span><br><span class="line">// <span class="string">"[object Foo]"</span></span><br><span class="line"></span><br><span class="line">// 例二</span><br><span class="line">class Collection &#123;</span><br><span class="line">  get [Symbol.toStringTag]() &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">'xxx'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var x = new Collection();</span><br><span class="line">Object.prototype.toString.call(x) // <span class="string">"[object xxx]"</span></span><br></pre></td></tr></table></figure>
<p>ES6 新增内置对象的 Symbol.toStringTag 属性值如下。</p>
<p>1.JSON[Symbol.toStringTag]：’JSON’<br>2.Math[Symbol.toStringTag]：’Math’<br>3.Module 对象 M[Symbol.toStringTag]：’Module’<br>4.ArrayBuffer.prototype[Symbol.toStringTag]：’ArrayBuffer’<br>5.DataView.prototype[Symbol.toStringTag]：’DataView’<br>6.Map.prototype[Symbol.toStringTag]：’Map’<br>7.Promise.prototype[Symbol.toStringTag]：’Promise’<br>8.Set.prototype[Symbol.toStringTag]：’Set’<br>9.%TypedArray%.prototype[Symbol.toStringTag]：’Uint8Array’等<br>10.WeakMap.prototype[Symbol.toStringTag]：’WeakMap’<br>11.WeakSet.prototype[Symbol.toStringTag]：’WeakSet’<br>12.%MapIteratorPrototype%[Symbol.toStringTag]：’Map Iterator’<br>13.%SetIteratorPrototype%[Symbol.toStringTag]：’Set Iterator’<br>14.%StringIteratorPrototype%[Symbol.toStringTag]：’String Iterator’<br>15.Symbol.prototype[Symbol.toStringTag]：’Symbol’<br>16.Generator.prototype[Symbol.toStringTag]：’Generator’<br>17.GeneratorFunction.prototype[Symbol.toStringTag]：’GeneratorFunction’</p>
<h5 id="Symbol-unscopables"><a href="#Symbol-unscopables" class="headerlink" title="Symbol.unscopables"></a>Symbol.unscopables</h5><p>对象的 Symbol.unscopables 属性，指向一个对象。该对象指定了使用 with 关键字时，哪些属性会被 with 环境排除。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype[Symbol.unscopables]</span><br><span class="line">// &#123;</span><br><span class="line">//   copyWithin: <span class="literal">true</span>,</span><br><span class="line">//   entries: <span class="literal">true</span>,</span><br><span class="line">//   fill: <span class="literal">true</span>,</span><br><span class="line">//   find: <span class="literal">true</span>,</span><br><span class="line">//   findIndex: <span class="literal">true</span>,</span><br><span class="line">//   keys: <span class="literal">true</span></span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">Object.keys(Array.prototype[Symbol.unscopables])</span><br><span class="line">// [<span class="string">'copyWithin'</span>, <span class="string">'entries'</span>, <span class="string">'fill'</span>, <span class="string">'find'</span>, <span class="string">'findIndex'</span>, <span class="string">'keys'</span>]</span><br></pre></td></tr></table></figure>
<p>上面代码说明，数组有 6 个属性，会被 with 命令排除。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 没有unscopables时</span><br><span class="line">class MyClass &#123;</span><br><span class="line">  <span class="function"><span class="title">foo</span></span>() &#123; <span class="built_in">return</span> 1; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var foo = <span class="function"><span class="title">function</span></span> () &#123; <span class="built_in">return</span> 2; &#125;;</span><br><span class="line"></span><br><span class="line">with (MyClass.prototype) &#123;</span><br><span class="line">  foo(); // 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 有unscopables时</span><br><span class="line">class MyClass &#123;</span><br><span class="line">  <span class="function"><span class="title">foo</span></span>() &#123; <span class="built_in">return</span> 1; &#125;</span><br><span class="line">  get [Symbol.unscopables]() &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123; foo: <span class="literal">true</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var foo = <span class="function"><span class="title">function</span></span> () &#123; <span class="built_in">return</span> 2; &#125;;</span><br><span class="line"></span><br><span class="line">with (MyClass.prototype) &#123;</span><br><span class="line">  foo(); // 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        </div>

        <blockquote class="post-copyright">
    
    <footer>
        <a href="http://blog.bochunhao.cn">
            <img src="/img/loggo.png" alt="BCH">
            BCH
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es6/">es6</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://blog.bochunhao.cn/2019/02/15/es6-Symbol/&title=《es6_Symbol》 — 个人博客&pic=http://blog.bochunhao.cn/img/loggo.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://blog.bochunhao.cn/2019/02/15/es6-Symbol/&title=《es6_Symbol》 — 个人博客&source=bch_bk" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://blog.bochunhao.cn/2019/02/15/es6-Symbol/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《es6_Symbol》 — 个人博客&url=http://blog.bochunhao.cn/2019/02/15/es6-Symbol/&via=http://blog.bochunhao.cn" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://blog.bochunhao.cn/2019/02/15/es6-Symbol/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between flex-row-reverse">
  

  
    <div class="waves-block waves-effect next">
      <a href="/2019/02/10/es6-Object/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">es6_Object</h4>
      </a>
    </div>
  
</nav>



    




















</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        感谢支持
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/vx.png" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check" data-wechat="/img/vx.png" data-alipay="/img/zfb.png">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <p>个人博客 &copy; 2018</p>
    <p style="color:#fff;font-size: 16px;font-weight:bolder">
        不积跬步，无以至千里
    </p>
    <p style="color:#fff;font-size: 16px;font-weight:bolder">
        不积小流，无以成江海
    </p>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://blog.bochunhao.cn/2019/02/15/es6-Symbol/&title=《es6_Symbol》 — 个人博客&pic=http://blog.bochunhao.cn/img/loggo.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://blog.bochunhao.cn/2019/02/15/es6-Symbol/&title=《es6_Symbol》 — 个人博客&source=bch_bk" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://blog.bochunhao.cn/2019/02/15/es6-Symbol/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《es6_Symbol》 — 个人博客&url=http://blog.bochunhao.cn/2019/02/15/es6-Symbol/&via=http://blog.bochunhao.cn" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://blog.bochunhao.cn/2019/02/15/es6-Symbol/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACJElEQVR42u3aQW7cMBAEwP3/p51zYEfpHkowRJZOC8GWWHuYJafn84mvr+Xr+mnf73+euDAwMF7LSF5/vaD2b9rPyVeDgYFxAuNfFWz2+bqwJpUzXxsGBgZGUlhXtobtV4OBgYHRFtzZGbO9g4GBgZEfYhN8XlJ/7SyOgYHxQsbKwfLpz4/kGxgYGK9izGLIp7eS9aowMDC2ZuSvud6QrYedLRsDA+McRlteV1r/dzXg6gqNgYGxEaONCtaDgesnFw07DAyMrRnJtqwNCVaelh+Yi44gBgbGyxlFOYu3ickGNHlL8WOAgYGxNSNvnLVbuvaYmsOGvyEYGBivZbT/MCu47RPyZ/51FsfAwDiAsTKwdW+QkB99MTAwTmbkkWceHgyLaTstgoGBsSkj35xd35kdgJOG2n/uYGBgHMCYDVLk0WbLrqMLDAyMrRmzheaFtW2i5Qutsw4MDIzXMoYl7KZxills+cO7MDAwtmbMgsnZqNbK4EX0RgwMjAMYdzXu8yXOwsth7xADA2MLxkromMQJs0JcjJ1hYGAcwMjbak8sfdb+w8DAOIHxVV5tuJhvLvOY85PXewwMjC0Yd9XsNgBog8zbkkoMDIzXMpIimw9S5N9WG1JiYGBgrBS+vG03ixnqYQsMDIzjGW20sBJt1k03DAwMjIV22Ppm8ZHfDQwMjFcx8kNpPsLVjk20oQIGBsY5jPzoONs4zhaaD4VgYGBszfgD3NDbGTTC9SAAAAAASUVORK5CYII=" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>






<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '快回来看我呀！';
            clearTimeout(titleTime);
        } else {
            document.title = '个人博客';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
