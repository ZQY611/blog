<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>es6_Proxy_Reflect | 个人博客 | BCH</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="es6">
    <meta name="description" content="Proxy 和 ReflectProxy 概述Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。 Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代">
<meta name="keywords" content="es6">
<meta property="og:type" content="article">
<meta property="og:title" content="es6_Proxy_Reflect">
<meta property="og:url" content="http://blog.bochunhao.cn/2019/03/05/es6-Proxy-Reflect/index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="Proxy 和 ReflectProxy 概述Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。 Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-04-10T10:23:55.886Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="es6_Proxy_Reflect">
<meta name="twitter:description" content="Proxy 和 ReflectProxy 概述Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。 Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代">
    
        <link rel="alternate" type="application/atom+xml" title="个人博客" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide">
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/loggo.png">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">BCH</h5>
          <a href="mailto:17600280987@163.com" title="17600280987@163.com" class="mail">17600280987@163.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/">
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories">
                <i class="icon icon-lg icon-archives"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags">
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/bch9479/blog" target="_blank">
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://weibo.com/5900743344/profile?rightmod=1&wvr=6&mod=personinfo" target="_blank">
                <i class="icon icon-lg icon-weibo"></i>
                微博
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">es6_Proxy_Reflect</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">es6_Proxy_Reflect</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-03-05T09:58:55.000Z" itemprop="datePublished" class="page-time">
  2019-03-05
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/es6/">es6</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Proxy-和-Reflect"><span class="post-toc-number">1.</span> <span class="post-toc-text">Proxy 和 Reflect</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Proxy-概述"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">Proxy 概述</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#get-target-propKey-receiver"><span class="post-toc-number">1.1.1.</span> <span class="post-toc-text">get(target, propKey, receiver)</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#set-target-propKey-value-receiver"><span class="post-toc-number">1.1.2.</span> <span class="post-toc-text">set(target, propKey, value, receiver)</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#has-target-propKey"><span class="post-toc-number">1.1.3.</span> <span class="post-toc-text">has(target, propKey)</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#deleteProperty-target-propKey"><span class="post-toc-number">1.1.4.</span> <span class="post-toc-text">deleteProperty(target, propKey)</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#ownKeys-target"><span class="post-toc-number">1.1.5.</span> <span class="post-toc-text">ownKeys(target)</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#getOwnPropertyDescriptor-target-propKey"><span class="post-toc-number">1.1.6.</span> <span class="post-toc-text">getOwnPropertyDescriptor(target, propKey)</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#defineProperty-target-propKey-propDesc"><span class="post-toc-number">1.1.7.</span> <span class="post-toc-text">defineProperty(target, propKey, propDesc)</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#preventExtensions-target"><span class="post-toc-number">1.1.8.</span> <span class="post-toc-text">preventExtensions(target)</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#getPrototypeOf-target"><span class="post-toc-number">1.1.9.</span> <span class="post-toc-text">getPrototypeOf(target)</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#isExtensible-target"><span class="post-toc-number">1.1.10.</span> <span class="post-toc-text">isExtensible(target)</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#setPrototypeOf-target-proto"><span class="post-toc-number">1.1.11.</span> <span class="post-toc-text">setPrototypeOf(target, proto)</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#apply-target-object-args"><span class="post-toc-number">1.1.12.</span> <span class="post-toc-text">apply(target, object, args)</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#construct-target-args"><span class="post-toc-number">1.1.13.</span> <span class="post-toc-text">construct(target, args)</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Proxy-实例的方法"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">Proxy 实例的方法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#get"><span class="post-toc-number">1.2.1.</span> <span class="post-toc-text">get()</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#set"><span class="post-toc-number">1.2.2.</span> <span class="post-toc-text">set()</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#apply"><span class="post-toc-number">1.2.3.</span> <span class="post-toc-text">apply()</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#has"><span class="post-toc-number">1.2.4.</span> <span class="post-toc-text">has()</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#construct"><span class="post-toc-number">1.2.5.</span> <span class="post-toc-text">construct()</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#deleteProperty"><span class="post-toc-number">1.2.6.</span> <span class="post-toc-text">deleteProperty()</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#defineProperty"><span class="post-toc-number">1.2.7.</span> <span class="post-toc-text">defineProperty()</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#getOwnPropertyDescriptor"><span class="post-toc-number">1.2.8.</span> <span class="post-toc-text">getOwnPropertyDescriptor()</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#getPrototypeOf"><span class="post-toc-number">1.2.9.</span> <span class="post-toc-text">getPrototypeOf()</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#isExtensible"><span class="post-toc-number">1.2.10.</span> <span class="post-toc-text">isExtensible()</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#ownKeys"><span class="post-toc-number">1.2.11.</span> <span class="post-toc-text">ownKeys()</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#preventExtensions"><span class="post-toc-number">1.2.12.</span> <span class="post-toc-text">preventExtensions()</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#setPrototypeOf"><span class="post-toc-number">1.2.13.</span> <span class="post-toc-text">setPrototypeOf()</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Proxy-revocable"><span class="post-toc-number">1.2.14.</span> <span class="post-toc-text">Proxy.revocable()</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#this-问题"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">this 问题</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Reflect-概述"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">Reflect 概述</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Reflect-对象的方法"><span class="post-toc-number">1.5.</span> <span class="post-toc-text">Reflect 对象的方法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Reflect-get-target-name-receiver"><span class="post-toc-number">1.5.1.</span> <span class="post-toc-text">Reflect.get(target, name, receiver)</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Reflect-set-target-name-value-receiver"><span class="post-toc-number">1.5.2.</span> <span class="post-toc-text">Reflect.set(target, name, value, receiver)</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Reflect-has-obj-name"><span class="post-toc-number">1.5.3.</span> <span class="post-toc-text">Reflect.has(obj, name)</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Reflect-deleteProperty-obj-name"><span class="post-toc-number">1.5.4.</span> <span class="post-toc-text">Reflect.deleteProperty(obj, name)</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Reflect-construct-target-args"><span class="post-toc-number">1.5.5.</span> <span class="post-toc-text">Reflect.construct(target, args)</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Reflect-getPrototypeOf-obj"><span class="post-toc-number">1.5.6.</span> <span class="post-toc-text">Reflect.getPrototypeOf(obj)</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Reflect-setPrototypeOf-obj-newProto"><span class="post-toc-number">1.5.7.</span> <span class="post-toc-text">Reflect.setPrototypeOf(obj, newProto)</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Reflect-apply-fun-thisArg-args"><span class="post-toc-number">1.5.8.</span> <span class="post-toc-text">Reflect.apply(fun,thisArg,args)</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#实例：使用-Proxy-实现观察者模式"><span class="post-toc-number">1.6.</span> <span class="post-toc-text">实例：使用 Proxy 实现观察者模式</span></a></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-es6-Proxy-Reflect" class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">es6_Proxy_Reflect</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-03-05 17:58:55" datetime="2019-03-05T09:58:55.000Z" itemprop="datePublished">2019-03-05</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/es6/">es6</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style="display:none">
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h3 id="Proxy-和-Reflect"><a href="#Proxy-和-Reflect" class="headerlink" title="Proxy 和 Reflect"></a>Proxy 和 Reflect</h3><h4 id="Proxy-概述"><a href="#Proxy-概述" class="headerlink" title="Proxy 概述"></a>Proxy 概述</h4><p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。</p>
<p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var obj = new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  get: <span class="keyword">function</span> (target, key, receiver) &#123;</span><br><span class="line">    console.log(`getting <span class="variable">$&#123;key&#125;</span>!`);</span><br><span class="line">    <span class="built_in">return</span> Reflect.get(target, key, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">set</span>: <span class="keyword">function</span> (target, key, value, receiver) &#123;</span><br><span class="line">    console.log(`setting <span class="variable">$&#123;key&#125;</span>!`);</span><br><span class="line">    <span class="built_in">return</span> Reflect.set(target, key, value, receiver);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码对一个空对象架设了一层拦截，重定义了属性的读取（get）和设置（set）行为。这里暂时先不解释具体的语法，只看运行结果。对设置了拦截行为的对象 obj，去读写它的属性，就会得到下面的结果。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">obj.count = 1</span><br><span class="line">//  setting count!</span><br><span class="line">++obj.count</span><br><span class="line">//  getting count!</span><br><span class="line">//  setting count!</span><br><span class="line">//  2</span><br></pre></td></tr></table></figure>
<p>上面代码说明，Proxy 实际上重载（overload）了点运算符，即用自己的定义覆盖了语言的原始定义。</p>
<p>ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。</p>
<p>var proxy = new Proxy(target, handler);<br>Proxy 对象的所有用法，都是上面这种形式，不同的只是 handler 参数的写法。其中，new Proxy()表示生成一个 Proxy 实例，target 参数表示所要拦截的目标对象，handler 参数也是一个对象，用来定制拦截行为。</p>
<p>下面是另一个拦截读取属性行为的例子。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var proxy = new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  get: <span class="keyword">function</span>(target, property) &#123;</span><br><span class="line">    <span class="built_in">return</span> 35;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.time // 35</span><br><span class="line">proxy.name // 35</span><br><span class="line">proxy.title // 35</span><br></pre></td></tr></table></figure>
<p>上面代码中，作为构造函数，Proxy 接受两个参数。第一个参数是所要代理的目标对象（上例是一个空对象），即如果没有 Proxy 的介入，操作原来要访问的就是这个对象；第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。比如，上面代码中，配置对象有一个 get 方法，用来拦截对目标对象属性的访问请求。get 方法的两个参数分别是目标对象和所要访问的属性。可以看到，由于拦截函数总是返回 35，所以访问任何属性都得到 35。</p>
<p>注意，要使得 Proxy 起作用，必须针对 Proxy 实例（上例是 proxy 对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。</p>
<p>如果 handler 没有设置任何拦截，那就等同于直接通向原对象。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var target = &#123;&#125;;</span><br><span class="line">var handler = &#123;&#125;;</span><br><span class="line">var proxy = new Proxy(target, handler);</span><br><span class="line">proxy.a = <span class="string">'b'</span>;</span><br><span class="line">target.a // <span class="string">"b"</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，handler 是一个空对象，没有任何拦截效果，访问 handler 就等同于访问 target。</p>
<p>一个技巧是将 Proxy 对象，设置到 object.proxy 属性，从而可以在 object 对象上调用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var object = &#123; proxy: new Proxy(target, handler) &#125;;</span><br></pre></td></tr></table></figure>
<p>Proxy 实例也可以作为其他对象的原型对象。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var proxy = new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  get: <span class="keyword">function</span>(target, property) &#123;</span><br><span class="line">    <span class="built_in">return</span> 35;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> obj = Object.create(proxy);</span><br><span class="line">obj.time // 35</span><br></pre></td></tr></table></figure>
<p>上面代码中，proxy 对象是 obj 对象的原型，obj 对象本身并没有 time 属性，所以根据原型链，会在 proxy 对象上读取该属性，导致被拦截。</p>
<p>同一个拦截器函数，可以设置拦截多个操作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var handler = &#123;</span><br><span class="line">  get: <span class="keyword">function</span>(target, name) &#123;</span><br><span class="line">    <span class="keyword">if</span> (name === <span class="string">'prototype'</span>) &#123;</span><br><span class="line">      <span class="built_in">return</span> Object.prototype;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">'Hello, '</span> + name;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  apply: <span class="keyword">function</span>(target, thisBinding, args) &#123;</span><br><span class="line">    <span class="built_in">return</span> args[0];</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  construct: <span class="keyword">function</span>(target, args) &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;value: args[1]&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var fproxy = new Proxy(<span class="keyword">function</span>(x, y) &#123;</span><br><span class="line">  <span class="built_in">return</span> x + y;</span><br><span class="line">&#125;, handler);</span><br><span class="line"></span><br><span class="line">fproxy(1, 2) // 1</span><br><span class="line">new fproxy(1,2) // &#123;value: 2&#125;</span><br><span class="line">fproxy.prototype === Object.prototype // <span class="literal">true</span></span><br><span class="line">fproxy.foo // <span class="string">"Hello, foo"</span></span><br></pre></td></tr></table></figure>
<p>下面是 Proxy 支持的拦截操作一览。</p>
<p>对于可以设置、但没有设置拦截的操作，则直接落在目标对象上，按照原先的方式产生结果。</p>
<h5 id="get-target-propKey-receiver"><a href="#get-target-propKey-receiver" class="headerlink" title="get(target, propKey, receiver)"></a>get(target, propKey, receiver)</h5><p>拦截对象属性的读取，比如 proxy.foo 和 proxy[‘foo’]。</p>
<p>最后一个参数 receiver 是一个对象，可选，参见下面 Reflect.get 的部分。</p>
<h5 id="set-target-propKey-value-receiver"><a href="#set-target-propKey-value-receiver" class="headerlink" title="set(target, propKey, value, receiver)"></a>set(target, propKey, value, receiver)</h5><p>拦截对象属性的设置，比如 proxy.foo = v 或 proxy[‘foo’] = v，返回一个布尔值。</p>
<h5 id="has-target-propKey"><a href="#has-target-propKey" class="headerlink" title="has(target, propKey)"></a>has(target, propKey)</h5><p>拦截 propKey in proxy 的操作，以及对象的 hasOwnProperty 方法，返回一个布尔值。</p>
<h5 id="deleteProperty-target-propKey"><a href="#deleteProperty-target-propKey" class="headerlink" title="deleteProperty(target, propKey)"></a>deleteProperty(target, propKey)</h5><p>拦截 delete proxy[propKey]的操作，返回一个布尔值。</p>
<h5 id="ownKeys-target"><a href="#ownKeys-target" class="headerlink" title="ownKeys(target)"></a>ownKeys(target)</h5><p>拦截 Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)，返回一个数组。该方法返回对象所有自身的属性，而 Object.keys()仅返回对象可遍历的属性。</p>
<h5 id="getOwnPropertyDescriptor-target-propKey"><a href="#getOwnPropertyDescriptor-target-propKey" class="headerlink" title="getOwnPropertyDescriptor(target, propKey)"></a>getOwnPropertyDescriptor(target, propKey)</h5><p>拦截 Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。</p>
<h5 id="defineProperty-target-propKey-propDesc"><a href="#defineProperty-target-propKey-propDesc" class="headerlink" title="defineProperty(target, propKey, propDesc)"></a>defineProperty(target, propKey, propDesc)</h5><p>拦截 Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。</p>
<h5 id="preventExtensions-target"><a href="#preventExtensions-target" class="headerlink" title="preventExtensions(target)"></a>preventExtensions(target)</h5><p>拦截 Object.preventExtensions(proxy)，返回一个布尔值。</p>
<h5 id="getPrototypeOf-target"><a href="#getPrototypeOf-target" class="headerlink" title="getPrototypeOf(target)"></a>getPrototypeOf(target)</h5><p>拦截 Object.getPrototypeOf(proxy)，返回一个对象。</p>
<h5 id="isExtensible-target"><a href="#isExtensible-target" class="headerlink" title="isExtensible(target)"></a>isExtensible(target)</h5><p>拦截 Object.isExtensible(proxy)，返回一个布尔值。</p>
<h5 id="setPrototypeOf-target-proto"><a href="#setPrototypeOf-target-proto" class="headerlink" title="setPrototypeOf(target, proto)"></a>setPrototypeOf(target, proto)</h5><p>拦截 Object.setPrototypeOf(proxy, proto)，返回一个布尔值。</p>
<p>如果目标对象是函数，那么还有两种额外操作可以拦截。</p>
<h5 id="apply-target-object-args"><a href="#apply-target-object-args" class="headerlink" title="apply(target, object, args)"></a>apply(target, object, args)</h5><p>拦截 Proxy 实例作为函数调用的操作，比如 proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。</p>
<h5 id="construct-target-args"><a href="#construct-target-args" class="headerlink" title="construct(target, args)"></a>construct(target, args)</h5><p>拦截 Proxy 实例作为构造函数调用的操作，比如 new proxy(…args)。</p>
<h4 id="Proxy-实例的方法"><a href="#Proxy-实例的方法" class="headerlink" title="Proxy 实例的方法"></a>Proxy 实例的方法</h4><p>下面是上面这些拦截方法的详细介绍。</p>
<h5 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h5><p>get 方法用于拦截某个属性的读取操作。上文已经有一个例子，下面是另一个拦截读取操作的例子。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">  name: <span class="string">"张三"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var proxy = new Proxy(person, &#123;</span><br><span class="line">  get: <span class="keyword">function</span>(target, property) &#123;</span><br><span class="line">    <span class="keyword">if</span> (property <span class="keyword">in</span> target) &#123;</span><br><span class="line">      <span class="built_in">return</span> target[property];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      throw new ReferenceError(<span class="string">"Property \""</span> + property + <span class="string">"\" does not exist."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.name // <span class="string">"张三"</span></span><br><span class="line">proxy.age // 抛出一个错误</span><br></pre></td></tr></table></figure>
<p>上面代码表示，如果访问目标对象不存在的属性，会抛出一个错误。如果没有这个拦截函数，访问不存在的属性，只会返回 undefined。</p>
<p>get 方法可以继承。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> proto = new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  get(target, propertyKey, receiver) &#123;</span><br><span class="line">    console.log(<span class="string">'GET '</span>+propertyKey);</span><br><span class="line">    <span class="built_in">return</span> target[propertyKey];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> obj = Object.create(proto);</span><br><span class="line">obj.xxx // <span class="string">"GET xxx"</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，拦截操作定义在 Prototype 对象上面，所以如果读取 obj 对象继承的属性时，拦截会生效。</p>
<p>下面的例子使用 get 拦截，实现数组读取负数的索引。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> createArray(...elements) &#123;</span><br><span class="line">  <span class="built_in">let</span> handler = &#123;</span><br><span class="line">    get(target, propKey, receiver) &#123;</span><br><span class="line">      <span class="built_in">let</span> index = Number(propKey);</span><br><span class="line">      <span class="keyword">if</span> (index &lt; 0) &#123;</span><br><span class="line">        propKey = String(target.length + index);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">return</span> Reflect.get(target, propKey, receiver);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">let</span> target = [];</span><br><span class="line">  target.push(...elements);</span><br><span class="line">  <span class="built_in">return</span> new Proxy(target, handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> arr = createArray(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>);</span><br><span class="line">arr[-1] // c</span><br></pre></td></tr></table></figure>
<p>上面代码中，数组的位置参数是-1，就会输出数组的倒数最后一个成员。</p>
<p>利用 Proxy，可以将读取属性的操作（get），转变为执行某个函数，从而实现属性的链式操作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var pipe = (<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  <span class="built_in">return</span> <span class="keyword">function</span> (value) &#123;</span><br><span class="line">    var funcStack = [];</span><br><span class="line">    var oproxy = new Proxy(&#123;&#125; , &#123;</span><br><span class="line">      get : <span class="keyword">function</span> (pipeObject, fnName) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fnName === <span class="string">'get'</span>) &#123;</span><br><span class="line">          <span class="built_in">return</span> funcStack.reduce(<span class="keyword">function</span> (val, fn) &#123;</span><br><span class="line">            <span class="built_in">return</span> fn(val);</span><br><span class="line">          &#125;,value);</span><br><span class="line">        &#125;</span><br><span class="line">        funcStack.push(window[fnName]);</span><br><span class="line">        <span class="built_in">return</span> oproxy;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> oproxy;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">var double = n =&gt; n * 2;</span><br><span class="line">var pow    = n =&gt; n * n;</span><br><span class="line">var reverseInt = n =&gt; n.toString().split(<span class="string">""</span>).reverse().join(<span class="string">""</span>) | 0;</span><br><span class="line"></span><br><span class="line">pipe(3).double.pow.reverseInt.get; // 63</span><br></pre></td></tr></table></figure>
<p>上面代码设置 Proxy 以后，达到了将函数名链式使用的效果。</p>
<p>下面的例子则是利用 get 拦截，实现一个生成各种 DOM 节点的通用函数 dom。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">const dom = new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  get(target, property) &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="keyword">function</span>(attrs = &#123;&#125;, ...children) &#123;</span><br><span class="line">      const el = document.createElement(property);</span><br><span class="line">      <span class="keyword">for</span> (<span class="built_in">let</span> prop of Object.keys(attrs)) &#123;</span><br><span class="line">        el.setAttribute(prop, attrs[prop]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="built_in">let</span> child of children) &#123;</span><br><span class="line">        <span class="keyword">if</span> (typeof child === <span class="string">'string'</span>) &#123;</span><br><span class="line">          child = document.createTextNode(child);</span><br><span class="line">        &#125;</span><br><span class="line">        el.appendChild(child);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">return</span> el;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const el = dom.div(&#123;&#125;,</span><br><span class="line">  <span class="string">'Hello, my name is '</span>,</span><br><span class="line">  dom.a(&#123;href: <span class="string">'//example.com'</span>&#125;, <span class="string">'Mark'</span>),</span><br><span class="line">  <span class="string">'. I like:'</span>,</span><br><span class="line">  dom.ul(&#123;&#125;,</span><br><span class="line">    dom.li(&#123;&#125;, <span class="string">'The web'</span>),</span><br><span class="line">    dom.li(&#123;&#125;, <span class="string">'Food'</span>),</span><br><span class="line">    dom.li(&#123;&#125;, <span class="string">'…actually that\'</span>s it<span class="string">')</span></span><br><span class="line"><span class="string">  )</span></span><br><span class="line"><span class="string">);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">document.body.appendChild(el);</span></span><br></pre></td></tr></table></figure>
<h5 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h5><p>set 方法用来拦截某个属性的赋值操作。</p>
<p>假定 Person 对象有一个 age 属性，该属性应该是一个不大于 200 的整数，那么可以使用 Proxy 保证 age 的属性值符合要求。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> validator = &#123;</span><br><span class="line">  <span class="built_in">set</span>: <span class="keyword">function</span>(obj, prop, value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">'age'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!Number.isInteger(value)) &#123;</span><br><span class="line">        throw new TypeError(<span class="string">'The age is not an integer'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (value &gt; 200) &#123;</span><br><span class="line">        throw new RangeError(<span class="string">'The age seems invalid'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 对于age以外的属性，直接保存</span><br><span class="line">    obj[prop] = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> person = new Proxy(&#123;&#125;, validator);</span><br><span class="line"></span><br><span class="line">person.age = 100;</span><br><span class="line"></span><br><span class="line">person.age // 100</span><br><span class="line">person.age = <span class="string">'young'</span> // 报错</span><br><span class="line">person.age = 300 // 报错</span><br></pre></td></tr></table></figure>
<p>上面代码中，由于设置了存值函数 set，任何不符合要求的 age 属性赋值，都会抛出一个错误。利用 set 方法，还可以数据绑定，即每当对象发生变化时，会自动更新 DOM。</p>
<p>有时，我们会在对象上面设置内部属性，属性名的第一个字符使用下划线开头，表示这些属性不应该被外部使用。结合 get 和 set 方法，就可以做到防止这些内部属性被外部读写。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var handler = &#123;</span><br><span class="line">  get (target, key) &#123;</span><br><span class="line">    invariant(key, <span class="string">'get'</span>);</span><br><span class="line">    <span class="built_in">return</span> target[key];</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">set</span> (target, key, value) &#123;</span><br><span class="line">    invariant(key, <span class="string">'set'</span>);</span><br><span class="line">    target[key] = value;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> invariant (key, action) &#123;</span><br><span class="line">  <span class="keyword">if</span> (key[0] === <span class="string">'_'</span>) &#123;</span><br><span class="line">    throw new Error(`Invalid attempt to <span class="variable">$&#123;action&#125;</span> private <span class="string">"<span class="variable">$&#123;key&#125;</span>"</span> property`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var target = &#123;&#125;;</span><br><span class="line">var proxy = new Proxy(target, handler);</span><br><span class="line">proxy._prop</span><br><span class="line">// Error: Invalid attempt to get private <span class="string">"_prop"</span> property</span><br><span class="line">proxy._prop = <span class="string">'c'</span></span><br><span class="line">// Error: Invalid attempt to <span class="built_in">set</span> private <span class="string">"_prop"</span> property</span><br></pre></td></tr></table></figure>
<p>上面代码中，只要读写的属性名的第一个字符是下划线，一律抛错，从而达到禁止读写内部属性的目的。</p>
<h5 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h5><p>apply 方法拦截函数的调用、call 和 apply 操作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var handler = &#123;</span><br><span class="line">  apply (target, ctx, args) &#123;</span><br><span class="line">    <span class="built_in">return</span> Reflect.apply(...arguments);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>apply 方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（this）和目标对象的参数数组。</p>
<p>下面是一个例子。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var target = <span class="function"><span class="title">function</span></span> () &#123; <span class="built_in">return</span> <span class="string">'I am the target'</span>; &#125;;</span><br><span class="line">var handler = &#123;</span><br><span class="line">  apply: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">'I am the proxy'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var p = new Proxy(target, handler);</span><br><span class="line"></span><br><span class="line">p()</span><br><span class="line">// <span class="string">"I am the proxy"</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，变量 p 是 Proxy 的实例，当它作为函数调用时（p()），就会被 apply 方法拦截，返回一个字符串。</p>
<p>下面是另外一个例子。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var twice = &#123;</span><br><span class="line">  apply (target, ctx, args) &#123;</span><br><span class="line">    <span class="built_in">return</span> Reflect.apply(...arguments) * 2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> sum (left, right) &#123;</span><br><span class="line">  <span class="built_in">return</span> left + right;</span><br><span class="line">&#125;;</span><br><span class="line">var proxy = new Proxy(sum, twice);</span><br><span class="line">proxy(1, 2) // 6</span><br><span class="line">proxy.call(null, 5, 6) // 22</span><br><span class="line">proxy.apply(null, [7, 8]) // 30</span><br></pre></td></tr></table></figure>
<p>上面代码中，每当执行 proxy 函数（直接调用或 call 和 apply 调用），就会被 apply 方法拦截。</p>
<p>另外，直接调用 Reflect.apply 方法，也会被拦截。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Reflect.apply(proxy, null, [9, 10]) // 38</span><br></pre></td></tr></table></figure>
<h5 id="has"><a href="#has" class="headerlink" title="has()"></a>has()</h5><p>has 方法用来拦截 HasProperty 操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是 in 运算符。</p>
<p>下面的例子使用 has 方法隐藏某些属性，不被 in 运算符发现。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var handler = &#123;</span><br><span class="line">  has (target, key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key[0] === <span class="string">'_'</span>) &#123;</span><br><span class="line">      <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> key <span class="keyword">in</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var target = &#123; _prop: <span class="string">'foo'</span>, prop: <span class="string">'foo'</span> &#125;;</span><br><span class="line">var proxy = new Proxy(target, handler);</span><br><span class="line"><span class="string">'_prop'</span> <span class="keyword">in</span> proxy // <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，如果原对象的属性名的第一个字符是下划线，proxy.has 就会返回 false，从而不会被 in 运算符发现。</p>
<p>如果原对象不可配置或者禁止扩展，这时 has 拦截会报错。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; a: 10 &#125;;</span><br><span class="line">Object.preventExtensions(obj);</span><br><span class="line">var p = new Proxy(obj, &#123;</span><br><span class="line">  has: <span class="keyword">function</span>(target, prop) &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="string">'a'</span> <span class="keyword">in</span> p // TypeError is thrown</span><br></pre></td></tr></table></figure>
<p>上面代码中，obj 对象禁止扩展，结果使用 has 拦截就会报错。</p>
<p>值得注意的是，has 方法拦截的是 HasProperty 操作，而不是 HasOwnProperty 操作，即 has 方法不判断一个属性是对象自身的属性，还是继承的属性。</p>
<p>另外，虽然 for…in 循环也用到了 in 运算符，但是 has 拦截对 for…in 循环不生效。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> stu1 = &#123;name: <span class="string">'张三'</span>, score: 59&#125;;</span><br><span class="line"><span class="built_in">let</span> stu2 = &#123;name: <span class="string">'李四'</span>, score: 99&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> handler = &#123;</span><br><span class="line">  has(target, prop) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">'score'</span> &amp;&amp; target[prop] &lt; 60) &#123;</span><br><span class="line">      console.log(`<span class="variable">$&#123;target.name&#125;</span> 不及格`);</span><br><span class="line">      <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> prop <span class="keyword">in</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> oproxy1 = new Proxy(stu1, handler);</span><br><span class="line"><span class="built_in">let</span> oproxy2 = new Proxy(stu2, handler);</span><br><span class="line"></span><br><span class="line"><span class="string">'score'</span> <span class="keyword">in</span> oproxy1</span><br><span class="line">// 张三 不及格</span><br><span class="line">// <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="string">'score'</span> <span class="keyword">in</span> oproxy2</span><br><span class="line">// <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> a <span class="keyword">in</span> oproxy1) &#123;</span><br><span class="line">  console.log(oproxy1[a]);</span><br><span class="line">&#125;</span><br><span class="line">// 张三</span><br><span class="line">// 59</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> b <span class="keyword">in</span> oproxy2) &#123;</span><br><span class="line">  console.log(oproxy2[b]);</span><br><span class="line">&#125;</span><br><span class="line">// 李四</span><br><span class="line">// 99</span><br></pre></td></tr></table></figure>
<p>上面代码中，has 拦截只对 in 循环生效，对 for…in 循环不生效，导致不符合要求的属性没有被排除在 for…in 循环之外。</p>
<h5 id="construct"><a href="#construct" class="headerlink" title="construct()"></a>construct()</h5><p>construct 方法用于拦截 new 命令，下面是拦截对象的写法。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var handler = &#123;</span><br><span class="line">  construct (target, args, newTarget) &#123;</span><br><span class="line">    <span class="built_in">return</span> new target(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>construct 方法可以接受两个参数。</p>
<pre>
target: 目标对象
args：构建函数的参数对象
</pre>

<p>下面是一个例子。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var p = new Proxy(<span class="function"><span class="title">function</span></span>() &#123;&#125;, &#123;</span><br><span class="line">  construct: <span class="keyword">function</span>(target, args) &#123;</span><br><span class="line">    console.log(<span class="string">'called: '</span> + args.join(<span class="string">', '</span>));</span><br><span class="line">    <span class="built_in">return</span> &#123; value: args[0] * 10 &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">new p(1).value</span><br><span class="line">// <span class="string">"called: 1"</span></span><br><span class="line">// 10</span><br></pre></td></tr></table></figure>
<p>construct 方法返回的必须是一个对象，否则会报错。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var p = new Proxy(<span class="function"><span class="title">function</span></span>() &#123;&#125;, &#123;</span><br><span class="line">  construct: <span class="keyword">function</span>(target, argumentsList) &#123;</span><br><span class="line">    <span class="built_in">return</span> 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">new p() // 报错</span><br></pre></td></tr></table></figure>
<h5 id="deleteProperty"><a href="#deleteProperty" class="headerlink" title="deleteProperty()"></a>deleteProperty()</h5><p>deleteProperty 方法用于拦截 delete 操作，如果这个方法抛出错误或者返回 false，当前属性就无法被 delete 命令删除。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var handler = &#123;</span><br><span class="line">  deleteProperty (target, key) &#123;</span><br><span class="line">    invariant(key, <span class="string">'delete'</span>);</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> invariant (key, action) &#123;</span><br><span class="line">  <span class="keyword">if</span> (key[0] === <span class="string">'_'</span>) &#123;</span><br><span class="line">    throw new Error(`Invalid attempt to <span class="variable">$&#123;action&#125;</span> private <span class="string">"<span class="variable">$&#123;key&#125;</span>"</span> property`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var target = &#123; _prop: <span class="string">'foo'</span> &#125;;</span><br><span class="line">var proxy = new Proxy(target, handler);</span><br><span class="line">delete proxy._prop</span><br><span class="line">// Error: Invalid attempt to delete private <span class="string">"_prop"</span> property</span><br></pre></td></tr></table></figure>
<p>上面代码中，deleteProperty 方法拦截了 delete 操作符，删除第一个字符为下划线的属性会报错。</p>
<h5 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty()"></a>defineProperty()</h5><p>defineProperty 方法拦截了 Object.defineProperty 操作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var handler = &#123;</span><br><span class="line">  defineProperty (target, key, descriptor) &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var target = &#123;&#125;;</span><br><span class="line">var proxy = new Proxy(target, handler);</span><br><span class="line">proxy.foo = <span class="string">'bar'</span></span><br><span class="line">// TypeError: proxy defineProperty handler returned <span class="literal">false</span> <span class="keyword">for</span> property <span class="string">'"foo"'</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，defineProperty 方法返回 false，导致添加新属性会抛出错误。</p>
<h5 id="getOwnPropertyDescriptor"><a href="#getOwnPropertyDescriptor" class="headerlink" title="getOwnPropertyDescriptor()"></a>getOwnPropertyDescriptor()</h5><p>getOwnPropertyDescriptor 方法拦截 Object.getOwnPropertyDescriptor，返回一个属性描述对象或者 undefined。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var handler = &#123;</span><br><span class="line">  getOwnPropertyDescriptor (target, key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key[0] === <span class="string">'_'</span>) &#123;</span><br><span class="line">      <span class="built_in">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> Object.getOwnPropertyDescriptor(target, key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var target = &#123; _foo: <span class="string">'bar'</span>, baz: <span class="string">'tar'</span> &#125;;</span><br><span class="line">var proxy = new Proxy(target, handler);</span><br><span class="line">Object.getOwnPropertyDescriptor(proxy, <span class="string">'wat'</span>)</span><br><span class="line">// undefined</span><br><span class="line">Object.getOwnPropertyDescriptor(proxy, <span class="string">'_foo'</span>)</span><br><span class="line">// undefined</span><br><span class="line">Object.getOwnPropertyDescriptor(proxy, <span class="string">'baz'</span>)</span><br><span class="line">// &#123; value: <span class="string">'tar'</span>, writable: <span class="literal">true</span>, enumerable: <span class="literal">true</span>, configurable: <span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，handler.getOwnPropertyDescriptor 方法对于第一个字符为下划线的属性名会返回 undefined。</p>
<h5 id="getPrototypeOf"><a href="#getPrototypeOf" class="headerlink" title="getPrototypeOf()"></a>getPrototypeOf()</h5><p>getPrototypeOf 方法主要用来拦截 Object.getPrototypeOf()运算符，以及其他一些操作。</p>
<pre>
Object.prototype.__proto__
Object.prototype.isPrototypeOf()
Object.getPrototypeOf()
Reflect.getPrototypeOf()
instanceof运算符
</pre>

<p>下面是一个例子。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var proto = &#123;&#125;;</span><br><span class="line">var p = new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  getPrototypeOf(target) &#123;</span><br><span class="line">    <span class="built_in">return</span> proto;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Object.getPrototypeOf(p) === proto // <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，getPrototypeOf 方法拦截 Object.getPrototypeOf()，返回 proto 对象。</p>
<h5 id="isExtensible"><a href="#isExtensible" class="headerlink" title="isExtensible()"></a>isExtensible()</h5><p>isExtensible 方法拦截 Object.isExtensible 操作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var p = new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  isExtensible: <span class="keyword">function</span>(target) &#123;</span><br><span class="line">    console.log(<span class="string">"called"</span>);</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Object.isExtensible(p)</span><br><span class="line">// <span class="string">"called"</span></span><br><span class="line">// <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>上面代码设置了 isExtensible 方法，在调用 Object.isExtensible 时会输出 called。</p>
<p>这个方法有一个强限制，如果不能满足下面的条件，就会抛出错误。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.isExtensible(proxy) === Object.isExtensible(target)</span><br></pre></td></tr></table></figure>
<p>下面是一个例子。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var p = new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  isExtensible: <span class="keyword">function</span>(target) &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Object.isExtensible(p) // 报错</span><br></pre></td></tr></table></figure>
<h5 id="ownKeys"><a href="#ownKeys" class="headerlink" title="ownKeys()"></a>ownKeys()</h5><p>ownKeys 方法用来拦截 Object.keys()操作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> target = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> handler = &#123;</span><br><span class="line">  ownKeys(target) &#123;</span><br><span class="line">    <span class="built_in">return</span> [<span class="string">'hello'</span>, <span class="string">'world'</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> proxy = new Proxy(target, handler);</span><br><span class="line"></span><br><span class="line">Object.keys(proxy)</span><br><span class="line">// [ <span class="string">'hello'</span>, <span class="string">'world'</span> ]</span><br></pre></td></tr></table></figure>
<p>上面代码拦截了对于 target 对象的 Object.keys()操作，返回预先设定的数组。</p>
<p>下面的例子是拦截第一个字符为下划线的属性名。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> target = &#123;</span><br><span class="line">  _bar: <span class="string">'foo'</span>,</span><br><span class="line">  _prop: <span class="string">'bar'</span>,</span><br><span class="line">  prop: <span class="string">'baz'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> handler = &#123;</span><br><span class="line">  ownKeys (target) &#123;</span><br><span class="line">    <span class="built_in">return</span> Reflect.ownKeys(target).filter(key =&gt; key[0] !== <span class="string">'_'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> proxy = new Proxy(target, handler);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> key of Object.keys(proxy)) &#123;</span><br><span class="line">  console.log(target[key]);</span><br><span class="line">&#125;</span><br><span class="line">// <span class="string">"baz"</span></span><br></pre></td></tr></table></figure>
<h5 id="preventExtensions"><a href="#preventExtensions" class="headerlink" title="preventExtensions()"></a>preventExtensions()</h5><p>preventExtensions 方法拦截 Object.preventExtensions()。该方法必须返回一个布尔值。</p>
<p>这个方法有一个限制，只有当 Object.isExtensible(proxy)为 false（即不可扩展）时，proxy.preventExtensions 才能返回 true，否则会报错。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var p = new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  preventExtensions: <span class="keyword">function</span>(target) &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Object.preventExtensions(p) // 报错</span><br></pre></td></tr></table></figure>
<p>上面代码中，proxy.preventExtensions 方法返回 true，但这时 Object.isExtensible(proxy)会返回 true，因此报错。</p>
<p>为了防止出现这个问题，通常要在 proxy.preventExtensions 方法里面，调用一次 Object.preventExtensions。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var p = new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  preventExtensions: <span class="keyword">function</span>(target) &#123;</span><br><span class="line">    console.log(<span class="string">"called"</span>);</span><br><span class="line">    Object.preventExtensions(target);</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Object.preventExtensions(p)</span><br><span class="line">// <span class="string">"called"</span></span><br><span class="line">// <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h5 id="setPrototypeOf"><a href="#setPrototypeOf" class="headerlink" title="setPrototypeOf()"></a>setPrototypeOf()</h5><p>setPrototypeOf 方法主要用来拦截 Object.setPrototypeOf 方法。</p>
<p>下面是一个例子。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var handler = &#123;</span><br><span class="line">  setPrototypeOf (target, proto) &#123;</span><br><span class="line">    throw new Error(<span class="string">'Changing the prototype is forbidden'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var proto = &#123;&#125;;</span><br><span class="line">var target = <span class="function"><span class="title">function</span></span> () &#123;&#125;;</span><br><span class="line">var proxy = new Proxy(target, handler);</span><br><span class="line">proxy.setPrototypeOf(proxy, proto);</span><br><span class="line">// Error: Changing the prototype is forbidden</span><br></pre></td></tr></table></figure>
<p>上面代码中，只要修改 target 的原型对象，就会报错。</p>
<h5 id="Proxy-revocable"><a href="#Proxy-revocable" class="headerlink" title="Proxy.revocable()"></a>Proxy.revocable()</h5><p>Proxy.revocable 方法返回一个可取消的 Proxy 实例。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> target = &#123;&#125;;</span><br><span class="line"><span class="built_in">let</span> handler = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> &#123;proxy, revoke&#125; = Proxy.revocable(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.foo = 123;</span><br><span class="line">proxy.foo // 123</span><br><span class="line"></span><br><span class="line">revoke();</span><br><span class="line">proxy.foo // TypeError: Revoked</span><br></pre></td></tr></table></figure>
<p>Proxy.revocable 方法返回一个对象，该对象的 proxy 属性是 Proxy 实例，revoke 属性是一个函数，可以取消 Proxy 实例。上面代码中，当执行 revoke 函数之后，再访问 Proxy 实例，就会抛出一个错误。</p>
<h4 id="this-问题"><a href="#this-问题" class="headerlink" title="this 问题"></a>this 问题</h4><p>虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的 this 关键字会指向 Proxy 代理。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const target = &#123;</span><br><span class="line">  m: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(this === proxy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const handler = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">const proxy = new Proxy(target, handler);</span><br><span class="line"></span><br><span class="line">target.m() // <span class="literal">false</span></span><br><span class="line">proxy.m()  // <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，一旦 proxy 代理 target.m，后者内部的 this 就是指向 proxy，而不是 target。</p>
<p>下面是一个例子，由于 this 指向的变化，导致 Proxy 无法代理目标对象。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const _name = new WeakMap();</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    _name.set(this, name);</span><br><span class="line">  &#125;</span><br><span class="line">  get <span class="function"><span class="title">name</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> _name.get(this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const jane = new Person(<span class="string">'Jane'</span>);</span><br><span class="line">jane.name // <span class="string">'Jane'</span></span><br><span class="line"></span><br><span class="line">const proxy = new Proxy(jane, &#123;&#125;);</span><br><span class="line">proxy.name // undefined</span><br></pre></td></tr></table></figure>
<p>上面代码中，目标对象 jane 的 name 属性，实际保存在外部 WeakMap 对象_name 上面，通过 this 键区分。由于通过 proxy.name 访问时，this 指向 proxy，导致无法取到值，所以返回 undefined。</p>
<p>此外，有些原生对象的内部属性，只有通过正确的 this 才能拿到，所以 Proxy 也无法代理这些原生对象的属性。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const target = new Date();</span><br><span class="line">const handler = &#123;&#125;;</span><br><span class="line">const proxy = new Proxy(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.getDate();</span><br><span class="line">// TypeError: this is not a Date object.</span><br></pre></td></tr></table></figure>
<p>上面代码中，getDate 方法只能在 Date 对象实例上面拿到，如果 this 不是 Date 对象实例就会报错。这时，this 绑定原始对象，就可以解决这个问题。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const target = new Date(<span class="string">'2015-01-01'</span>);</span><br><span class="line">const handler = &#123;</span><br><span class="line">  get(target, prop) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">'getDate'</span>) &#123;</span><br><span class="line">      <span class="built_in">return</span> target.getDate.bind(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> Reflect.get(target, prop);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const proxy = new Proxy(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.getDate() // 1</span><br></pre></td></tr></table></figure>
<h4 id="Reflect-概述"><a href="#Reflect-概述" class="headerlink" title="Reflect 概述"></a>Reflect 概述</h4><p>Reflect 对象与 Proxy 对象一样，也是 ES6 为了操作对象而提供的新 API。Reflect 对象的设计目的有这样几个。</p>
<p>（1） 将 Object 对象的一些明显属于语言内部的方法（比如 Object.defineProperty），放到 Reflect 对象上。现阶段，某些方法同时在 Object 和 Reflect 对象上部署，未来的新方法将只部署在 Reflect 对象上。</p>
<p>（2） 修改某些 Object 方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而 Reflect.defineProperty(obj, name, desc)则会返回 false。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 老写法</span><br><span class="line">try &#123;</span><br><span class="line">  Object.defineProperty(target, property, attributes);</span><br><span class="line">  // success</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">  // failure</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 新写法</span><br><span class="line"><span class="keyword">if</span> (Reflect.defineProperty(target, property, attributes)) &#123;</span><br><span class="line">  // success</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  // failure</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（3） 让 Object 操作都变成函数行为。某些 Object 操作是命令式，比如 name in obj 和 delete obj[name]，而 Reflect.has(obj, name)和 Reflect.deleteProperty(obj, name)让它们变成了函数行为。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 老写法</span><br><span class="line"><span class="string">'assign'</span> <span class="keyword">in</span> Object // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">// 新写法</span><br><span class="line">Reflect.has(Object, <span class="string">'assign'</span>) // <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>（4）Reflect 对象的方法与 Proxy 对象的方法一一对应，只要是 Proxy 对象的方法，就能在 Reflect 对象上找到对应的方法。这就让 Proxy 对象可以方便地调用对应的 Reflect 方法，完成默认行为，作为修改行为的基础。也就是说，不管 Proxy 怎么修改默认行为，你总可以在 Reflect 上获取默认行为。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Proxy(target, &#123;</span><br><span class="line">  <span class="built_in">set</span>: <span class="keyword">function</span>(target, name, value, receiver) &#123;</span><br><span class="line">    var success = Reflect.set(target,name, value, receiver);</span><br><span class="line">    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">      <span class="built_in">log</span>(<span class="string">'property '</span> + name + <span class="string">' on '</span> + target + <span class="string">' set to '</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> success;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中，Proxy 方法拦截 target 对象的属性赋值行为。它采用 Reflect.set 方法将值赋值给对象的属性，然后再部署额外的功能。</p>
<p>下面是另一个例子。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var loggedObj = new Proxy(obj, &#123;</span><br><span class="line">  get(target, name) &#123;</span><br><span class="line">    console.log(<span class="string">'get'</span>, target, name);</span><br><span class="line">    <span class="built_in">return</span> Reflect.get(target, name);</span><br><span class="line">  &#125;,</span><br><span class="line">  deleteProperty(target, name) &#123;</span><br><span class="line">    console.log(<span class="string">'delete'</span> + name);</span><br><span class="line">    <span class="built_in">return</span> Reflect.deleteProperty(target, name);</span><br><span class="line">  &#125;,</span><br><span class="line">  has(target, name) &#123;</span><br><span class="line">    console.log(<span class="string">'has'</span> + name);</span><br><span class="line">    <span class="built_in">return</span> Reflect.has(target, name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中，每一个 Proxy 对象的拦截操作（get、delete、has），内部都调用对应的 Reflect 方法，保证原生行为能够正常执行。添加的工作，就是将每一个操作输出一行日志。</p>
<p>有了 Reflect 对象以后，很多操作会更易读。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 老写法</span><br><span class="line">Function.prototype.apply.call(Math.floor, undefined, [1.75]) // 1</span><br><span class="line"></span><br><span class="line">// 新写法</span><br><span class="line">Reflect.apply(Math.floor, undefined, [1.75]) // 1</span><br></pre></td></tr></table></figure>
<h4 id="Reflect-对象的方法"><a href="#Reflect-对象的方法" class="headerlink" title="Reflect 对象的方法"></a>Reflect 对象的方法</h4><p>Reflect 对象的方法清单如下，共 13 个。</p>
<pre>
Reflect.apply(target,thisArg,args)
Reflect.construct(target,args)
Reflect.get(target,name,receiver)
Reflect.set(target,name,value,receiver)
Reflect.defineProperty(target,name,desc)
Reflect.deleteProperty(target,name)
Reflect.has(target,name)
Reflect.ownKeys(target)
Reflect.isExtensible(target)
Reflect.preventExtensions(target)
Reflect.getOwnPropertyDescriptor(target, name)
Reflect.getPrototypeOf(target)
Reflect.setPrototypeOf(target, prototype)
</pre>

<p>上面这些方法的作用，大部分与 Object 对象的同名方法的作用都是相同的，而且它与 Proxy 对象的方法是一一对应的。下面是对其中几个方法的解释。</p>
<h5 id="Reflect-get-target-name-receiver"><a href="#Reflect-get-target-name-receiver" class="headerlink" title="Reflect.get(target, name, receiver)"></a>Reflect.get(target, name, receiver)</h5><p>查找并返回 target 对象的 name 属性，如果没有该属性，则返回 undefined。</p>
<p>如果 name 属性部署了读取函数，则读取函数的 this 绑定 receiver。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  get <span class="function"><span class="title">foo</span></span>() &#123; <span class="built_in">return</span> this.bar(); &#125;,</span><br><span class="line">  bar: <span class="function"><span class="title">function</span></span>() &#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 下面语句会让 this.bar()</span><br><span class="line">// 变成调用 wrapper.bar()</span><br><span class="line">Reflect.get(obj, <span class="string">"foo"</span>, wrapper);</span><br></pre></td></tr></table></figure>
<h5 id="Reflect-set-target-name-value-receiver"><a href="#Reflect-set-target-name-value-receiver" class="headerlink" title="Reflect.set(target, name, value, receiver)"></a>Reflect.set(target, name, value, receiver)</h5><p>设置 target 对象的 name 属性等于 value。如果 name 属性设置了赋值函数，则赋值函数的 this 绑定 receiver。</p>
<h5 id="Reflect-has-obj-name"><a href="#Reflect-has-obj-name" class="headerlink" title="Reflect.has(obj, name)"></a>Reflect.has(obj, name)</h5><p>等同于 name in obj。</p>
<h5 id="Reflect-deleteProperty-obj-name"><a href="#Reflect-deleteProperty-obj-name" class="headerlink" title="Reflect.deleteProperty(obj, name)"></a>Reflect.deleteProperty(obj, name)</h5><p>等同于 delete obj[name]。</p>
<h5 id="Reflect-construct-target-args"><a href="#Reflect-construct-target-args" class="headerlink" title="Reflect.construct(target, args)"></a>Reflect.construct(target, args)</h5><p>等同于 new target(…args)，这提供了一种不使用 new，来调用构造函数的方法。</p>
<h5 id="Reflect-getPrototypeOf-obj"><a href="#Reflect-getPrototypeOf-obj" class="headerlink" title="Reflect.getPrototypeOf(obj)"></a>Reflect.getPrototypeOf(obj)</h5><p>读取对象的<strong>proto</strong>属性，对应 Object.getPrototypeOf(obj)。</p>
<h5 id="Reflect-setPrototypeOf-obj-newProto"><a href="#Reflect-setPrototypeOf-obj-newProto" class="headerlink" title="Reflect.setPrototypeOf(obj, newProto)"></a>Reflect.setPrototypeOf(obj, newProto)</h5><p>设置对象的<strong>proto</strong>属性，对应 Object.setPrototypeOf(obj, newProto)。</p>
<h5 id="Reflect-apply-fun-thisArg-args"><a href="#Reflect-apply-fun-thisArg-args" class="headerlink" title="Reflect.apply(fun,thisArg,args)"></a>Reflect.apply(fun,thisArg,args)</h5><p>等同于 Function.prototype.apply.call(fun,thisArg,args)。一般来说，如果要绑定一个函数的 this 对象，可以这样写 fn.apply(obj, args)，但是如果函数定义了自己的 apply 方法，就只能写成 Function.prototype.apply.call(fn, obj, args)，采用 Reflect 对象可以简化这种操作。</p>
<p>另外，需要注意的是，Reflect.set()、Reflect.defineProperty()、Reflect.freeze()、Reflect.seal()和 Reflect.preventExtensions()返回一个布尔值，表示操作是否成功。它们对应的 Object 方法，失败时都会抛出错误。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 失败时抛出错误</span><br><span class="line">Object.defineProperty(obj, name, desc);</span><br><span class="line">// 失败时返回<span class="literal">false</span></span><br><span class="line">Reflect.defineProperty(obj, name, desc);</span><br></pre></td></tr></table></figure>
<p>上面代码中，Reflect.defineProperty 方法的作用与 Object.defineProperty 是一样的，都是为对象定义一个属性。但是，Reflect.defineProperty 方法失败时，不会抛出错误，只会返回 false。</p>
<h4 id="实例：使用-Proxy-实现观察者模式"><a href="#实例：使用-Proxy-实现观察者模式" class="headerlink" title="实例：使用 Proxy 实现观察者模式"></a>实例：使用 Proxy 实现观察者模式</h4><p>观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const person = observable(&#123;</span><br><span class="line">  name: <span class="string">'张三'</span>,</span><br><span class="line">  age: 20</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">print</span></span>() &#123;</span><br><span class="line">  console.log(`<span class="variable">$&#123;person.name&#125;</span>, <span class="variable">$&#123;person.age&#125;</span>`)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">observe(<span class="built_in">print</span>);</span><br><span class="line">person.name = <span class="string">'李四'</span>;</span><br><span class="line">// 输出</span><br><span class="line">// 李四, 20</span><br></pre></td></tr></table></figure>
<p>上面代码中，数据对象 person 是观察目标，函数 print 是观察者。一旦数据对象发生变化，print 就会自动执行。</p>
<p>下面，使用 Proxy 写一个观察者模式的最简单实现，即实现 observable 和 observe 这两个函数。思路是 observable 函数返回一个原始对象的 Proxy 代理，拦截赋值操作，触发充当观察者的各个函数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const queuedObservers = new Set();</span><br><span class="line"></span><br><span class="line">const observe = fn =&gt; queuedObservers.add(fn);</span><br><span class="line">const observable = obj =&gt; new Proxy(obj, &#123;<span class="built_in">set</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="built_in">set</span>(target, key, value, receiver) &#123;</span><br><span class="line">  const result = Reflect.set(target, key, value, receiver);</span><br><span class="line">  queuedObservers.forEach(observer =&gt; observer());</span><br><span class="line">  <span class="built_in">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，先定义了一个 Set 集合，所有观察者函数都放进这个集合。然后，observable 函数返回原始对象的代理，拦截赋值操作。拦截函数 set 之中，会自动执行所有观察者。</p>

        </div>

        <blockquote class="post-copyright">
    
    <footer>
        <a href="http://blog.bochunhao.cn">
            <img src="/img/loggo.png" alt="BCH">
            BCH
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es6/">es6</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://blog.bochunhao.cn/2019/03/05/es6-Proxy-Reflect/&title=《es6_Proxy_Reflect》 — 个人博客&pic=http://blog.bochunhao.cn/img/loggo.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://blog.bochunhao.cn/2019/03/05/es6-Proxy-Reflect/&title=《es6_Proxy_Reflect》 — 个人博客&source=bch_bk" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://blog.bochunhao.cn/2019/03/05/es6-Proxy-Reflect/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《es6_Proxy_Reflect》 — 个人博客&url=http://blog.bochunhao.cn/2019/03/05/es6-Proxy-Reflect/&via=http://blog.bochunhao.cn" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://blog.bochunhao.cn/2019/03/05/es6-Proxy-Reflect/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2019/03/15/es6-Iterator/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">es6_Iterator</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2019/02/27/es6-Set-Map/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">es6_Set_Map</h4>
      </a>
    </div>
  
</nav>



    




















</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        感谢支持
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/vx.png" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check" data-wechat="/img/vx.png" data-alipay="/img/zfb.png">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <p>个人博客 &copy; 2018</p>
    <p style="color:#fff;font-size: 16px;font-weight:bolder">
        不积跬步，无以至千里
    </p>
    <p style="color:#fff;font-size: 16px;font-weight:bolder">
        不积小流，无以成江海
    </p>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://blog.bochunhao.cn/2019/03/05/es6-Proxy-Reflect/&title=《es6_Proxy_Reflect》 — 个人博客&pic=http://blog.bochunhao.cn/img/loggo.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://blog.bochunhao.cn/2019/03/05/es6-Proxy-Reflect/&title=《es6_Proxy_Reflect》 — 个人博客&source=bch_bk" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://blog.bochunhao.cn/2019/03/05/es6-Proxy-Reflect/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《es6_Proxy_Reflect》 — 个人博客&url=http://blog.bochunhao.cn/2019/03/05/es6-Proxy-Reflect/&via=http://blog.bochunhao.cn" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://blog.bochunhao.cn/2019/03/05/es6-Proxy-Reflect/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACIElEQVR42u3aO3LDMAwFQN//0kqbxswDIGcsclV5xpKoZYEhPq9XfF2/rvzOd0+9+zdfpXlhYGA8lnEtr/ye/P3rDWqui4GBcQDj3fLre9Z39gJosi4GBgZG73U5uxroMTAwMOYBdxKm1wEaAwMDYx74JgW7/PfNuTgGBsYDGZMw+unfH+lvYGBgPIpxFa/14Swp+ifPlr8KAwNja0avNFbF5EMYo+/BwMDYlJGXw5Lkttq8zMttf8AwMDAOYPQC3/owN18rHxfDwMA4gdF8uPgpPWpUesPAwDiG0RunWAfc6lGvV+bDwMDYm5FgJv/2NihvMGBgYGDMg+xdrcqoCYGBgbEpY5JSJkfAvBhXDbjlqiEGBsZjGfmVLJCE2iqp2mDAwMDYj5EvXD3M5XvWGzXDwMA4h5GU5nuBdZ6yVg+jGBgYJzCqZa8kTe0Nc9yWpmJgYGzE6KWU1cNfXp6rps0YGBgnMKqjXXmQrbYBeq1QDAyMExj5Ia/XmOxtU/4vBgbGOYxeYM2DZrXonyTS0T5hYGBsxOgNOpSbi/F7yk9hYGBsyrhrbOLekYtCkO3NgGBgYDyKMW9w9hoAeRPin/q0GBgYX89oJo0xoLpzvfQYAwPjBEYe+PKUtRqaJ0gMDAyMeZLZW6WwcRgYGBjFMYvecEYyBPbxgIuBgfHFjCSJnTQaJ6NjERgDA2NrRp465i9KQmov7I6amhgYGM9j/ACWbCy6rLdfeAAAAABJRU5ErkJggg==" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>






<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '快回来看我呀！';
            clearTimeout(titleTime);
        } else {
            document.title = '个人博客';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
