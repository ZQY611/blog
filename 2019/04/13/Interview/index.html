<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>Interview | 个人博客 | BCH</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="前端面试">
    <meta name="description" content="什么是闭包？闭包有什么好处？为什么要用它？使用闭包要注意什么？闭包：闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域，将函数内部的变量和参数传递到外部。该变量和参数不会被垃圾回收机制所回收 好处 ：1）希望一个变量长期驻扎在内存之中2）避免全局变量的污染3）私有成员的存在注意：参数和变">
<meta name="keywords" content="前端面试">
<meta property="og:type" content="article">
<meta property="og:title" content="Interview">
<meta property="og:url" content="http://blog.bochunhao.cn/2019/04/13/Interview/index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="什么是闭包？闭包有什么好处？为什么要用它？使用闭包要注意什么？闭包：闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域，将函数内部的变量和参数传递到外部。该变量和参数不会被垃圾回收机制所回收 好处 ：1）希望一个变量长期驻扎在内存之中2）避免全局变量的污染3）私有成员的存在注意：参数和变">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-04-13T13:06:31.530Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Interview">
<meta name="twitter:description" content="什么是闭包？闭包有什么好处？为什么要用它？使用闭包要注意什么？闭包：闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域，将函数内部的变量和参数传递到外部。该变量和参数不会被垃圾回收机制所回收 好处 ：1）希望一个变量长期驻扎在内存之中2）避免全局变量的污染3）私有成员的存在注意：参数和变">
    
        <link rel="alternate" type="application/atom+xml" title="个人博客" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide">
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/loggo.png">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">BCH</h5>
          <a href="mailto:17600280987@163.com" title="17600280987@163.com" class="mail">17600280987@163.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/">
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories">
                <i class="icon icon-lg icon-archives"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags">
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/bch9479/blog" target="_blank">
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://weibo.com/5900743344/profile?rightmod=1&wvr=6&mod=personinfo" target="_blank">
                <i class="icon icon-lg icon-weibo"></i>
                微博
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Interview</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">Interview</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-04-13T13:45:23.000Z" itemprop="datePublished" class="page-time">
  2019-04-13
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/前端面试/">前端面试</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#什么是闭包？闭包有什么好处？为什么要用它？使用闭包要注意什么？"><span class="post-toc-number">1.</span> <span class="post-toc-text">什么是闭包？闭包有什么好处？为什么要用它？使用闭包要注意什么？</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#闭包："><span class="post-toc-number">1.1.</span> <span class="post-toc-text">闭包：</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#好处-："><span class="post-toc-number">1.2.</span> <span class="post-toc-text">好处 ：</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#闭包的原理和应用"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">闭包的原理和应用</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#闭包的用途："><span class="post-toc-number">1.4.</span> <span class="post-toc-text">闭包的用途：</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#使用生成器实现"><span class="post-toc-number">1.5.</span> <span class="post-toc-text">使用生成器实现</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#iframe-有那些优缺点？"><span class="post-toc-number">2.</span> <span class="post-toc-text">iframe 有那些优缺点？</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#优点："><span class="post-toc-number">2.1.</span> <span class="post-toc-text">优点：</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#缺点："><span class="post-toc-number">2.2.</span> <span class="post-toc-text">缺点：</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#JavaScript-原型，原型链-有什么特点？"><span class="post-toc-number">3.</span> <span class="post-toc-text">JavaScript 原型，原型链 ? 有什么特点？</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Javascript-作用链域"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">Javascript 作用链域?</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#javascript-是面向对象的，怎么体现-javascript-的继承关系？"><span class="post-toc-number">4.</span> <span class="post-toc-text">javascript 是面向对象的，怎么体现 javascript 的继承关系？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#javascript-继承的-6-种方法"><span class="post-toc-number">5.</span> <span class="post-toc-text">javascript 继承的 6 种方法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#10、javascript-创建对象的几种方式？"><span class="post-toc-number">6.</span> <span class="post-toc-text">10、javascript 创建对象的几种方式？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#11、call-方法，apply-方法"><span class="post-toc-number">7.</span> <span class="post-toc-text">11、call 方法，apply 方法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#说几条写-JavaScript-的基本规范？"><span class="post-toc-number">8.</span> <span class="post-toc-text">说几条写 JavaScript 的基本规范？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#在-js-中通过-typeof-能弹出的数据类型有哪些"><span class="post-toc-number">9.</span> <span class="post-toc-text">在 js 中通过 typeof 能弹出的数据类型有哪些</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#谈谈-This-对象的理解。"><span class="post-toc-number">10.</span> <span class="post-toc-text">谈谈 This 对象的理解。</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#eval-是做什么的？"><span class="post-toc-number">11.</span> <span class="post-toc-text">eval 是做什么的？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#什么是-window-对象-什么是-document-对象"><span class="post-toc-number">12.</span> <span class="post-toc-text">什么是 window 对象? 什么是 document 对象?</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#null，undefined-的区别？"><span class="post-toc-number">13.</span> <span class="post-toc-text">null，undefined 的区别？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#写一个通用的事件侦听器函数。"><span class="post-toc-number">14.</span> <span class="post-toc-text">写一个通用的事件侦听器函数。</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#“1”-“2”-“3”-map-parseInt-答案是多少？"><span class="post-toc-number">15.</span> <span class="post-toc-text">[“1”, “2”, “3”].map(parseInt) 答案是多少？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#事件是？IE-与火狐的事件机制有什么区别？-如何阻止冒泡？"><span class="post-toc-number">16.</span> <span class="post-toc-text">事件是？IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#如何判断一个对象是否属于某个类？"><span class="post-toc-number">17.</span> <span class="post-toc-text">如何判断一个对象是否属于某个类？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#new-操作符具体干了什么呢"><span class="post-toc-number">18.</span> <span class="post-toc-text">new 操作符具体干了什么呢?</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Javascript-中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？"><span class="post-toc-number">19.</span> <span class="post-toc-text">Javascript 中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#JSON-的了解？"><span class="post-toc-number">20.</span> <span class="post-toc-text">JSON 的了解？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#js-延迟加载的方式有哪些？"><span class="post-toc-number">21.</span> <span class="post-toc-text">js 延迟加载的方式有哪些？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Ajax-是什么-ajax-原理是什么？ajax-的交互模型-同步和异步的区别-如何解决跨域问题"><span class="post-toc-number">22.</span> <span class="post-toc-text">Ajax 是什么?ajax 原理是什么？ajax 的交互模型?同步和异步的区别?如何解决跨域问题?</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#原理："><span class="post-toc-number">22.1.</span> <span class="post-toc-text">原理：</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#整个-XMLHttpRequest-对象的生命周期应该包含如下阶段："><span class="post-toc-number">22.2.</span> <span class="post-toc-text">整个 XMLHttpRequest 对象的生命周期应该包含如下阶段：</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#优势"><span class="post-toc-number">22.3.</span> <span class="post-toc-text">优势:</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Ajax-的最大的特点是什么"><span class="post-toc-number">22.4.</span> <span class="post-toc-text">Ajax 的最大的特点是什么:</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Ajax-同步和异步的区别"><span class="post-toc-number">22.5.</span> <span class="post-toc-text">Ajax 同步和异步的区别:</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#ajax-的缺点"><span class="post-toc-number">22.6.</span> <span class="post-toc-text">ajax 的缺点:</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#AJAX-注意点及适用和不适用场景"><span class="post-toc-number">22.7.</span> <span class="post-toc-text">AJAX 注意点及适用和不适用场景</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#注意点"><span class="post-toc-number">22.7.1.</span> <span class="post-toc-text">注意点</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#Ajax-适用场景"><span class="post-toc-number">22.7.2.</span> <span class="post-toc-text">Ajax 适用场景</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#Ajax-不适用场景"><span class="post-toc-number">22.7.3.</span> <span class="post-toc-text">Ajax 不适用场景</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Ajax-解决浏览器缓存问题？"><span class="post-toc-number">23.</span> <span class="post-toc-text">Ajax 解决浏览器缓存问题？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Flash、Ajax-各自的优缺点，在使用中如何取舍？"><span class="post-toc-number">24.</span> <span class="post-toc-text">Flash、Ajax 各自的优缺点，在使用中如何取舍？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#简述同步和异步的区别"><span class="post-toc-number">25.</span> <span class="post-toc-text">简述同步和异步的区别</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#如何解决跨域问题"><span class="post-toc-number">26.</span> <span class="post-toc-text">如何解决跨域问题?</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#模块化开发怎么做？"><span class="post-toc-number">27.</span> <span class="post-toc-text">模块化开发怎么做？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#AMD（Modules-Asynchronous-Definition）、CMD（Common-Module-Definition）规范区别？"><span class="post-toc-number">28.</span> <span class="post-toc-text">AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#requireJS-的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何缓存的？）"><span class="post-toc-number">29.</span> <span class="post-toc-text">requireJS 的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何缓存的？）</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#异步加载-JS-的方式有哪些？"><span class="post-toc-number">30.</span> <span class="post-toc-text">异步加载 JS 的方式有哪些？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#DOM-操作——怎样添加、移除、移动、复制、创建和查找节点"><span class="post-toc-number">31.</span> <span class="post-toc-text">DOM 操作——怎样添加、移除、移动、复制、创建和查找节点?</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#JS-怎么实现一个类。怎么实例化这个类"><span class="post-toc-number">32.</span> <span class="post-toc-text">JS 怎么实现一个类。怎么实例化这个类</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Jquery-与-jQuery-UI-有啥区别？"><span class="post-toc-number">33.</span> <span class="post-toc-text">Jquery 与 jQuery UI 有啥区别？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#针对-jQuery-的优化方法？"><span class="post-toc-number">34.</span> <span class="post-toc-text">针对 jQuery 的优化方法？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#如何判断当前脚本运行在浏览器还是-node-环境中？"><span class="post-toc-number">35.</span> <span class="post-toc-text">如何判断当前脚本运行在浏览器还是 node 环境中？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#那些操作会造成内存泄漏？"><span class="post-toc-number">36.</span> <span class="post-toc-text">那些操作会造成内存泄漏？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#什么是“前端路由”-什么时候适合使用“前端路由”-“前端路由”有哪些优点和缺点"><span class="post-toc-number">37.</span> <span class="post-toc-text">什么是“前端路由”?什么时候适合使用“前端路由”? “前端路由”有哪些优点和缺点?</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#什么是前端路由？"><span class="post-toc-number">37.1.</span> <span class="post-toc-text">什么是前端路由？</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#什么时候使用前端路由？"><span class="post-toc-number">37.2.</span> <span class="post-toc-text">什么时候使用前端路由？</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#前端路由有什么优点和缺点？"><span class="post-toc-number">37.3.</span> <span class="post-toc-text">前端路由有什么优点和缺点？</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#优点：-1"><span class="post-toc-number">37.3.1.</span> <span class="post-toc-text">优点：</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#缺点：-1"><span class="post-toc-number">37.3.2.</span> <span class="post-toc-text">缺点：</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#用-js-实现千位分隔符-提示：正则-replace"><span class="post-toc-number">38.</span> <span class="post-toc-text">用 js 实现千位分隔符?(提示：正则+replace)</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#我们给一个-dom-同时绑定两个点击事件，一个用捕获，一个用冒泡。会执行几次事件，会先执行冒泡还是捕获？"><span class="post-toc-number">39.</span> <span class="post-toc-text">我们给一个 dom 同时绑定两个点击事件，一个用捕获，一个用冒泡。会执行几次事件，会先执行冒泡还是捕获？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#使用-JS-实现获取文件扩展名？"><span class="post-toc-number">40.</span> <span class="post-toc-text">使用 JS 实现获取文件扩展名？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#跨域访问"><span class="post-toc-number">41.</span> <span class="post-toc-text">跨域访问</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#1）—-ajax-支持-get-方式跨域：jsonp-JSON-with-Padding"><span class="post-toc-number">41.1.</span> <span class="post-toc-text">1）—\$.ajax()支持 get 方式跨域：jsonp(JSON with Padding)</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#2）—html5-WebSocket-跨域：IE-浏览器目前不支持-WebSocket-通信"><span class="post-toc-number">41.2.</span> <span class="post-toc-text">2）—html5 WebSocket 跨域：IE 浏览器目前不支持 WebSocket 通信</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#3）—Flash："><span class="post-toc-number">41.3.</span> <span class="post-toc-text">3）—Flash：</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#4）—AJAX-long-polling"><span class="post-toc-number">41.4.</span> <span class="post-toc-text">4）—AJAX long-polling</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#5）—IFrame："><span class="post-toc-number">41.5.</span> <span class="post-toc-text">5）—IFrame：</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#6）CORS：支持-POST"><span class="post-toc-number">41.6.</span> <span class="post-toc-text">6）CORS：支持 POST</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#IE-IE8-支持-对-CORS-的实现："><span class="post-toc-number">41.6.1.</span> <span class="post-toc-text">IE(IE8+支持)对 CORS 的实现：</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#其他浏览器对-CORS-的实现："><span class="post-toc-number">41.6.2.</span> <span class="post-toc-text">其他浏览器对 CORS 的实现：</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#Comet：长轮询和流。"><span class="post-toc-number">41.6.3.</span> <span class="post-toc-text">Comet：长轮询和流。</span></a></li></ol></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#7）动态创建-script"><span class="post-toc-number">41.7.</span> <span class="post-toc-text">7）动态创建 script</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#事件"><span class="post-toc-number">42.</span> <span class="post-toc-text">事件</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#事件委托："><span class="post-toc-number">42.1.</span> <span class="post-toc-text">事件委托：</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#jquery-的绑定事件有几种方式-，请举例说明其优缺点。"><span class="post-toc-number">42.2.</span> <span class="post-toc-text">jquery 的绑定事件有几种方式 ，请举例说明其优缺点。</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#bind"><span class="post-toc-number">42.2.1.</span> <span class="post-toc-text">.bind()</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#live"><span class="post-toc-number">42.2.2.</span> <span class="post-toc-text">.live()</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#delegate"><span class="post-toc-number">42.2.3.</span> <span class="post-toc-text">.delegate()</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#on"><span class="post-toc-number">42.2.4.</span> <span class="post-toc-text">.on()</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#总结："><span class="post-toc-number">42.2.5.</span> <span class="post-toc-text">总结：</span></a></li></ol></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#当一个-DOM-节点被点击时候，我们希望能够执行一个函数，应该怎么做？"><span class="post-toc-number">42.3.</span> <span class="post-toc-text">当一个 DOM 节点被点击时候，我们希望能够执行一个函数，应该怎么做？</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#JavaScript-的事件流模型都有什么？"><span class="post-toc-number">42.4.</span> <span class="post-toc-text">JavaScript 的事件流模型都有什么？</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#IE-和-DOM-事件流的区别"><span class="post-toc-number">42.5.</span> <span class="post-toc-text">IE 和 DOM 事件流的区别:</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#http-请求头，请求体，cookie-在哪个里面？url-在哪里面？"><span class="post-toc-number">43.</span> <span class="post-toc-text">http 请求头，请求体，cookie 在哪个里面？url 在哪里面？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#null-undefined"><span class="post-toc-number">44.</span> <span class="post-toc-text">{}=={}? []==[]? null==undefined?</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#，根据以下规则："><span class="post-toc-number">44.1.</span> <span class="post-toc-text">==，根据以下规则：</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#null-和-undefined-的区别？"><span class="post-toc-number">45.</span> <span class="post-toc-text">null 和 undefined 的区别？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#什么叫优雅降级和渐进增强？"><span class="post-toc-number">46.</span> <span class="post-toc-text">什么叫优雅降级和渐进增强？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#异步加载和延迟加载"><span class="post-toc-number">47.</span> <span class="post-toc-text">异步加载和延迟加载</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#说说你对-Promise-的理解"><span class="post-toc-number">48.</span> <span class="post-toc-text">说说你对 Promise 的理解?</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#写一个通用的事件侦听器函数"><span class="post-toc-number">49.</span> <span class="post-toc-text">写一个通用的事件侦听器函数?</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#js-操作获取和设置-cookie"><span class="post-toc-number">50.</span> <span class="post-toc-text">js 操作获取和设置 cookie</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#jQuery-中-attr-、prop-、data-用法及区别？"><span class="post-toc-number">51.</span> <span class="post-toc-text">jQuery 中 attr()、prop()、data()用法及区别？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#正则表达式验证邮箱，电话号码"><span class="post-toc-number">52.</span> <span class="post-toc-text">正则表达式验证邮箱，电话号码</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#javascript-的本地对象，内置对象和宿主对象"><span class="post-toc-number">53.</span> <span class="post-toc-text">javascript 的本地对象，内置对象和宿主对象</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-个技巧避免不必要的浏览器兼容性问题"><span class="post-toc-number">54.</span> <span class="post-toc-text">5 个技巧避免不必要的浏览器兼容性问题</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Object-is-与原来的比较操作符“-”、“-”的区别？"><span class="post-toc-number">55.</span> <span class="post-toc-text">Object.is() 与原来的比较操作符“ ===”、“ ==”的区别？</span></a></li></ol>
        </nav>
    </aside>


<article id="post-Interview" class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">Interview</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-04-13 21:45:23" datetime="2019-04-13T13:45:23.000Z" itemprop="datePublished">2019-04-13</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/前端面试/">前端面试</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style="display:none">
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h4 id="什么是闭包？闭包有什么好处？为什么要用它？使用闭包要注意什么？"><a href="#什么是闭包？闭包有什么好处？为什么要用它？使用闭包要注意什么？" class="headerlink" title="什么是闭包？闭包有什么好处？为什么要用它？使用闭包要注意什么？"></a>什么是闭包？闭包有什么好处？为什么要用它？使用闭包要注意什么？</h4><h5 id="闭包："><a href="#闭包：" class="headerlink" title="闭包："></a>闭包：</h5><p>闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域，将函数内部的变量和参数传递到外部。该变量和参数不会被垃圾回收机制所回收</p>
<h5 id="好处-："><a href="#好处-：" class="headerlink" title="好处 ："></a>好处 ：</h5><p>1）希望一个变量长期驻扎在内存之中<br>2）避免全局变量的污染<br>3）私有成员的存在<br>注意：参数和变量不会被垃圾回收机制回收，使用闭包后变量就在内存中，所以也不宜使用太多的闭包。可能会造成内存泄漏</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//li节点的onclick事件都能正确的弹出当前被点击的li索引</span><br><span class="line"></span><br><span class="line"> &lt;ul id=<span class="string">"testUL"</span>&gt;</span><br><span class="line">    &lt;li&gt; index = 0&lt;/li&gt;</span><br><span class="line">    &lt;li&gt; index = 1&lt;/li&gt;</span><br><span class="line">    &lt;li&gt; index = 2&lt;/li&gt;</span><br><span class="line">    &lt;li&gt; index = 3&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    var nodes = document.getElementsByTagName(<span class="string">"li"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = 0;i&lt;nodes.length;i++)&#123;</span><br><span class="line">        nodes[i].onclick = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">            console.log(i+1);//不用闭包的话，值每次都是4</span><br><span class="line">        &#125;(i);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>执行 say667()后,say667()闭包内部变量会存在,而闭包内部函数的内部变量不会存在，使得 Javascript 的垃圾回收机制 GC 不会收回 say667()所占用的资源，因为 say667()的内部函数的执行需要依赖 say667()中的变量</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">say667</span></span>() &#123;</span><br><span class="line">    // Local variable that ends up within closure</span><br><span class="line">    var num = 666;</span><br><span class="line">    var sayAlert = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        alert(num);</span><br><span class="line">    &#125;</span><br><span class="line">    num++;</span><br><span class="line">    <span class="built_in">return</span> sayAlert;</span><br><span class="line">&#125;</span><br><span class="line">var sayAlert = say667();</span><br><span class="line">sayAlert()//执行结果应该弹出的667</span><br></pre></td></tr></table></figure>
<h5 id="闭包的原理和应用"><a href="#闭包的原理和应用" class="headerlink" title="闭包的原理和应用"></a>闭包的原理和应用</h5><p>闭包就是能够读取其他函数内部变量的函数。<br>当回调发生时，闭包能记住它原来所在的执行上下文<br>它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。<br>1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在 IE 中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。<br>2）闭包会在父函数外部，改变父函数内部变量的值。</p>
<h5 id="闭包的用途："><a href="#闭包的用途：" class="headerlink" title="闭包的用途："></a>闭包的用途：</h5><p>(1)匿名自执行函数<br>如果变量不加上 var 关键字，则会默认添加到全局对象属性上去，这样可能造成别的函数误用这些变量，造成全局对象过于庞大，影响访问速度。此外，也会有的函数只需执行一次，内部的变量无需维护</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var datamodel=&#123;</span><br><span class="line">  table:[],</span><br><span class="line">  tree:&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">(<span class="keyword">function</span>(dm)&#123;</span><br><span class="line">&#125;)(datamodel);</span><br></pre></td></tr></table></figure>
<p>创建了一个匿名的函数，并立即执行它，由于外部无法引用它内部的变量，因此在执行完后很快就会被释放，关键是这种机制不会污染全局对象。<br>(2)有一个很耗时的函数对象，每次调用都会花费很长时间，就需要把计算的值存储起来，当调用的时候，首先在缓存中查找，找不到，则进行计算。（闭包不会释放外部的引用，从而使函数内部的值可以保留）<br>(3)实现封装，person 之外的地方无法访问其内部变量的值，通过闭包的形式访问</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var person=<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">  var name=”default”;</span><br><span class="line">  <span class="built_in">return</span>&#123;</span><br><span class="line">      getName:<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">          <span class="built_in">return</span> name;</span><br><span class="line">&#125;,</span><br><span class="line">setName:<span class="keyword">function</span> (newName)&#123;</span><br><span class="line">  	name=newName;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="built_in">print</span>(person.name);  // 直接访问，结果为undefined</span><br><span class="line"><span class="built_in">print</span>(person.getName());  //default</span><br><span class="line">person.setName(“MIKE”);</span><br><span class="line"><span class="built_in">print</span>(person.getName());   //MIKE</span><br></pre></td></tr></table></figure>
<p>(4)实现面向对象中的对象</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Person</span></span>()&#123;</span><br><span class="line">    var name = <span class="string">"default"</span>;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">       getName : <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">           <span class="built_in">return</span> name;</span><br><span class="line">       &#125;,</span><br><span class="line">       setName : <span class="keyword">function</span>(newName)&#123;</span><br><span class="line">           name = newName;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var john =new Person();</span><br><span class="line"><span class="built_in">print</span>(john.getName());   //default</span><br><span class="line">john.setName(<span class="string">"john"</span>);</span><br><span class="line"><span class="built_in">print</span>(john.getName());    //john</span><br><span class="line">varjack =new Person();</span><br><span class="line"><span class="built_in">print</span>(jack.getName());   //default</span><br><span class="line">jack.setName(<span class="string">"jack"</span>);</span><br><span class="line"><span class="built_in">print</span>(jack.getName());    //jack</span><br><span class="line">//john和jack都可以称为是Person这个类的实例，因为这两个实例对name这个成员的访问是独立的，互不影响的。</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> lazy_sum(arr) &#123;</span><br><span class="line">    var sum = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        <span class="built_in">return</span> arr.reduce(<span class="keyword">function</span> (x, y) &#123;</span><br><span class="line">            <span class="built_in">return</span> x + y;   //在函数lazy_sum中又定义了函数sum，</span><br><span class="line">        &#125;); //并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，</span><br><span class="line">    &#125; //当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中</span><br><span class="line">    <span class="built_in">return</span> sum;   //注意sum是一个函数</span><br><span class="line">&#125;</span><br><span class="line">varf = lazy_sum([1, 2, 3, 4, 5]); // 调用lazy_sum返回的不是求和结果，而是求和函数</span><br><span class="line">f();  //15  调用函数f时，才是真正的计算结果</span><br></pre></td></tr></table></figure>
<p>函数在其定义内部引用了局部变量 arr，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">count</span></span>() &#123;</span><br><span class="line">    var arr = [];</span><br><span class="line">    <span class="keyword">for</span> (var i=1; i&lt;=3; i++) &#123;</span><br><span class="line">        arr.push(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">            <span class="built_in">return</span> i * i;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line">var results = count();</span><br><span class="line">var f1 = results[0];   //16</span><br><span class="line">var f2 = results[1];   //16</span><br><span class="line">var f3 = results[2];  //16</span><br></pre></td></tr></table></figure>
<p>返回的函数引用了变量 i，但它并非立刻执行。等到 3 个函数都返回时，它们所引用的变量 i 已经变成了 4，因此最终结果为 16。<br>返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。<br>如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，然后立即调用该循环变量，无论该循环变量后续如何更改，已绑定到函数参数的值不变：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">count</span></span>() &#123;</span><br><span class="line">    var arr = [];</span><br><span class="line">    <span class="keyword">for</span> (var i=1; i&lt;=3; i++) &#123;</span><br><span class="line">        arr.push(</span><br><span class="line">(<span class="keyword">function</span> (n) &#123;</span><br><span class="line">            <span class="built_in">return</span> <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">                <span class="built_in">return</span> n * n;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)(i)     //这是一个匿名函数</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line">varresults = count();</span><br><span class="line">var f1 = results[0];</span><br><span class="line">var f2 = results[1];</span><br><span class="line">var f3 = results[2];</span><br><span class="line">f1();// 1</span><br><span class="line">f2();// 4</span><br><span class="line">f3();// 9</span><br></pre></td></tr></table></figure>
<p>闭包的可以封装一个私有变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>  create_counter(initial) &#123;</span><br><span class="line">    var x = initial || 0;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">        inc: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">            x += 1;</span><br><span class="line">            <span class="built_in">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">varc1 = create_counter();</span><br><span class="line">c1.inc();// 1</span><br><span class="line">c1.inc();// 2</span><br><span class="line">c1.inc();// 3</span><br><span class="line">varc2 = create_counter(10);</span><br><span class="line">c2.inc();// 11</span><br><span class="line">c2.inc();// 12</span><br><span class="line">c2.inc();// 13</span><br></pre></td></tr></table></figure>
<p>在返回的对象中，实现了一个闭包，该闭包携带了局部变量 x，并且，从外部代码根本无法访问到变量 x。<br>使用闭包写一个斐波那契数列求值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> fibonacii(n)&#123;</span><br><span class="line">    var sum=0,pre=0,next=1;</span><br><span class="line">    <span class="built_in">return</span> <span class="keyword">function</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==0)&#123;</span><br><span class="line">            <span class="built_in">return</span> 0;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==1)&#123;</span><br><span class="line">            <span class="built_in">return</span> 1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(var i=2;i&lt;=n;i++)&#123;</span><br><span class="line">            sum=pre+next;</span><br><span class="line">            pre=next;</span><br><span class="line">            next=sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(var i=0;i&lt;n;i++)&#123;//显示斐波那契数列前n项</span><br><span class="line">    console.log(fibonacii(i)(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="使用生成器实现"><a href="#使用生成器实现" class="headerlink" title="使用生成器实现"></a>使用生成器实现</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">fibonacci</span></span>()&#123;</span><br><span class="line">   <span class="built_in">let</span> a=0;</span><br><span class="line">   <span class="built_in">let</span> b=1;</span><br><span class="line">   yield a;</span><br><span class="line">   yield b;</span><br><span class="line">   <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">	 <span class="built_in">let</span> next=a+b;</span><br><span class="line">	 a=b;</span><br><span class="line">	 b=next;</span><br><span class="line">	 yield next;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> gen=fibonacci();</span><br><span class="line"><span class="keyword">for</span>(var i=0;i&lt;n;i++)&#123;</span><br><span class="line">    console.log(gen.next().value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="iframe-有那些优缺点？"><a href="#iframe-有那些优缺点？" class="headerlink" title="iframe 有那些优缺点？"></a>iframe 有那些优缺点？</h4><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><p>1）解决加载缓慢的第三方内容如图标和广告等的加载问题<br>2）Security sandbox<br>3）并行加载脚本</p>
<h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><p>1）在网页中使用框架结构最大的弊病是搜索引擎的检索程序无法解读这种页面，不利于 SEO;<br>2）iframe 会阻塞主页面的 Onload 事件；<br>3）iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。即使内容为空，加载也需要时间。<br>4）框架结构有时会让人感到迷惑，页面很混乱，没有语义。 使用 iframe 之前需要考虑这两个缺点。如果需要使用 iframe，最好是通过 javascript 动态给 iframe 添加 src 属性值，这样可以绕开以上两个问题。</p>
<h4 id="JavaScript-原型，原型链-有什么特点？"><a href="#JavaScript-原型，原型链-有什么特点？" class="headerlink" title="JavaScript 原型，原型链 ? 有什么特点？"></a>JavaScript 原型，原型链 ? 有什么特点？</h4><p>每个对象都会在其内部初始化一个属性，就是 prototype(原型)，当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去 prototype 里找这个属性，这个 prototype 又会有自己的 prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念。<br>关系：instance.constructor.prototype = instance.proto（对象的<strong>proto</strong>属性和创建这个对象的构造函数的 prototype 属性是一个东西）</p>
<p>特点：<br>JavaScript 对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。而且创建子类型的实例时不能向超类型的构造函数中传递参数。<br>当我们需要一个属性的时，Javascript 引擎会先看当前对象中是否有这个属性， 如果没有的话，就会查找他的 Prototype 对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Func</span></span>()&#123;&#125;</span><br><span class="line">Func.prototype.name = <span class="string">"Sean"</span>;</span><br><span class="line">Func.prototype.getInfo = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> this.name;</span><br><span class="line">&#125;</span><br><span class="line">var person = new Func();//现在可以参考var person = Object.create(oldObject);</span><br><span class="line">console.log(person.getInfo());//它拥有了Func的属性和方法</span><br><span class="line">//<span class="string">"Sean"</span></span><br><span class="line">console.log(Func.prototype);</span><br><span class="line">// Func &#123; name=<span class="string">"Sean"</span>, getInfo=<span class="keyword">function</span>()&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Javascript-作用链域"><a href="#Javascript-作用链域" class="headerlink" title="Javascript 作用链域?"></a>Javascript 作用链域?</h5><p>全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节。<br>当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找，直至全局函数，这种组织形式就是作用域链。</p>
<h4 id="javascript-是面向对象的，怎么体现-javascript-的继承关系？"><a href="#javascript-是面向对象的，怎么体现-javascript-的继承关系？" class="headerlink" title="javascript 是面向对象的，怎么体现 javascript 的继承关系？"></a>javascript 是面向对象的，怎么体现 javascript 的继承关系？</h4><p>实现继承主要是依靠原型链来实现的<br>1）属性</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父级构造函数.apply(this,arguments);</span><br><span class="line">SuperType.apply(this,arguments);   实现父级构造函数的操作</span><br></pre></td></tr></table></figure>
<p>2）方法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">person1.constructor == Person</span><br><span class="line">Person.prototype.constructor == Person</span><br><span class="line">子级构造函数.prototype=new 父级构造();       SubType.prototype=new SuperType();</span><br><span class="line">子级构造函数.prototype.constructor=子级构造;   SubType.prototype.constructor=SubType;</span><br></pre></td></tr></table></figure>
<h4 id="javascript-继承的-6-种方法"><a href="#javascript-继承的-6-种方法" class="headerlink" title="javascript 继承的 6 种方法"></a>javascript 继承的 6 种方法</h4><pre>
原型链继承
借用构造函数继承
组合继承(原型+借用构造)
原型式继承
寄生式继承
寄生组合式继承
</pre>

<p>原型 prototype 机制或 apply 和 call 方法去实现较简单，建议使用构造函数与原型混合方式。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Parent</span></span>()&#123;</span><br><span class="line">   this.name = <span class="string">'wang'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Child</span></span>()&#123;</span><br><span class="line">   this.age = 28;</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = new Parent();//继承了Parent，通过原型</span><br><span class="line">var demo = new Child();</span><br><span class="line">alert(demo.age);</span><br><span class="line">alert(demo.name);//得到被继承的属性</span><br></pre></td></tr></table></figure>
<h4 id="10、javascript-创建对象的几种方式？"><a href="#10、javascript-创建对象的几种方式？" class="headerlink" title="10、javascript 创建对象的几种方式？"></a>10、javascript 创建对象的几种方式？</h4><pre>
工厂模式
构造函数模式
原型模式
混合构造函数和原型模式
动态原型模式
寄生构造函数模式
稳妥构造函数模式
</pre>

<p>javascript 创建对象简单的说,无非就是使用内置对象或各种自定义对象，当然还可以用 JSON；但写法有很多种，也能混合使用。<br>1）、对象字面量的方式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">person=&#123;</span><br><span class="line">  firstname:<span class="string">"Mark"</span>,</span><br><span class="line">  lastname:<span class="string">"Yun"</span>,</span><br><span class="line">  age:25,</span><br><span class="line">  eyecolor:<span class="string">"black"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>2）、用 function 来模拟无参的构造函数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Person</span></span>()&#123;&#125;</span><br><span class="line">var person=new Person();//定义一个<span class="keyword">function</span>，如果使用new<span class="string">"实例化"</span>,该<span class="keyword">function</span>可以看作是一个Class</span><br><span class="line">person.name=<span class="string">"Mark"</span>;</span><br><span class="line">person.age=<span class="string">"25"</span>;</span><br><span class="line">person.work=<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    alert(person.name+<span class="string">" hello..."</span>);</span><br><span class="line">&#125;</span><br><span class="line">person.work();</span><br></pre></td></tr></table></figure>
<p>3）、用 function 来模拟参构造函数来实现（用 this 关键字定义构造的上下文属性）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Pet(name,age,hobby)&#123;</span><br><span class="line">   this.name=name;//this作用域：当前对象</span><br><span class="line">   this.age=age;</span><br><span class="line">   this.hobby=hobby;</span><br><span class="line">   this.eat=<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">      alert(<span class="string">"我叫"</span>+this.name+<span class="string">",我喜欢"</span>+this.hobby+<span class="string">",是个程序员"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">var maidou =new Pet(<span class="string">"麦兜"</span>,25,<span class="string">"coding"</span>);//实例化、创建对象</span><br><span class="line">maidou.eat();//调用eat方法</span><br></pre></td></tr></table></figure>
<p>4）、用工厂方式来创建（内置对象）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var wcDog =new Object();</span><br><span class="line">wcDog.name=<span class="string">"旺财"</span>;</span><br><span class="line">wcDog.age=3;</span><br><span class="line">wcDog.work=<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">   alert(<span class="string">"我是"</span>+wcDog.name+<span class="string">",汪汪汪......"</span>);</span><br><span class="line">&#125;</span><br><span class="line">wcDog.work();</span><br></pre></td></tr></table></figure>
<p>5）、用原型方式来创建</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Dog</span></span>()&#123;</span><br><span class="line">&#125;</span><br><span class="line">Dog.prototype.name=<span class="string">"旺财"</span>;</span><br><span class="line">Dog.prototype.eat=<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">   alert(this.name+<span class="string">"是个吃货"</span>);</span><br><span class="line">&#125;</span><br><span class="line">var wangcai =new Dog();</span><br><span class="line">wangcai.eat();</span><br></pre></td></tr></table></figure>
<p>6）、用混合方式来创建</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Car(name,price)&#123;</span><br><span class="line">   this.name=name;</span><br><span class="line">   this.price=price;</span><br><span class="line">&#125;</span><br><span class="line">Car.prototype.sell=<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">   alert(<span class="string">"我是"</span>+this.name+<span class="string">"，我现在卖"</span>+this.price+<span class="string">"万元"</span>);</span><br><span class="line">&#125;</span><br><span class="line">var camry =new Car(<span class="string">"凯美瑞"</span>,27);</span><br><span class="line">camry.sell();</span><br></pre></td></tr></table></figure>
<h4 id="11、call-方法，apply-方法"><a href="#11、call-方法，apply-方法" class="headerlink" title="11、call 方法，apply 方法"></a>11、call 方法，apply 方法</h4><p>call 方法：<br>语法：call(thisObj，Object)<br>定义：调用一个对象的一个方法，以另一个对象替换当前对象。<br>说明：call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。如果没有提供 thisObj 参数，那么 Global 对象被用作 thisObj。<br>apply 方法：<br>语法：apply(thisObj，[argArray])<br>定义：应用某一对象的一个方法，用另一个对象替换当前对象。<br>说明：如果 argArray 不是一个有效的数组或者不是 arguments 对象，那么将导致一个 TypeError。如果没有提供 argArray 和 thisObj 任何一个参数，那么 Global 对象将被用作 thisObj， 并且无法被传递任何参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> add(a,b)&#123;</span><br><span class="line">    alert(a+b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> sub(a,b)&#123;</span><br><span class="line">    alert(a-b);</span><br><span class="line">&#125;</span><br><span class="line">add.call(sub,3,1);</span><br></pre></td></tr></table></figure>
<p>例子中用 add 来替换 sub，add.call(sub,3,1) == add(3,1) ，所以运行结果为：alert(4); 注意：js 中的函数其实是对象，函数名是对 Function 对象的引用。</p>
<h4 id="说几条写-JavaScript-的基本规范？"><a href="#说几条写-JavaScript-的基本规范？" class="headerlink" title="说几条写 JavaScript 的基本规范？"></a>说几条写 JavaScript 的基本规范？</h4><p>1）.不要在同一行声明多个变量。<br>2）.请使用 ===/!==来比较 true/false 或者数值<br>3）.使用对象字面量替代 new Array 这种形式<br>4）.不要使用全局函数。<br>5）.Switch 语句必须带有 default 分支<br>6）.函数不应该有时候有返回值，有时候没有返回值。<br>7）.For 循环必须使用大括号<br>8）.If 语句必须使用大括号<br>9）.for-in 循环中的变量应该使用 var 关键字明确限定作用域，从而避免作用域污染。</p>
<h4 id="在-js-中通过-typeof-能弹出的数据类型有哪些"><a href="#在-js-中通过-typeof-能弹出的数据类型有哪些" class="headerlink" title="在 js 中通过 typeof 能弹出的数据类型有哪些"></a>在 js 中通过 typeof 能弹出的数据类型有哪些</h4><p>number，string，boolean，function，object，undefined 记住 typeof null 是’object’</p>
<p>js 数据类型和区分:<br>基本数据类型：String,boolean,Number,Undefined, Null<br>引用数据类型：Object(Array,Date,RegExp,Function)<br>Object 是 JavaScript 中所有对象的父对象 数据封装类对象：Object、Array、Boolean、Number 和 String 其他对象：Function、Arguments、Math、Date、RegExp、Error 区分基本数据类型：typeof;Undefined 只能用 typeof 检测 typeof a==’undefined’ typeof null 是’object’<br>typeof 返回的类型都是字符串形式，可以判断 function 的类型<br>区分引用数据类型：instanceof<br>区分各数据类型： Object.prototype.toString.call()</p>
<p>js 数组中提供了以下几个方法可以让我们很方便实现堆栈：<br>shift:从数组中把第一个元素删除，并返回这个元素的值。<br>unshift: 在数组的开头添加一个或更多元素，并返回新的长度<br>push:在数组的中末尾添加元素，并返回新的长度<br>pop:从数组中把最后一个元素删除，并返回这个元素的值。</p>
<h4 id="谈谈-This-对象的理解。"><a href="#谈谈-This-对象的理解。" class="headerlink" title="谈谈 This 对象的理解。"></a>谈谈 This 对象的理解。</h4><p>this 总是指向函数的直接调用者（而非间接调用者）；<br>如果有 new 关键字，this 指向 new 出来的那个对象；<br>在事件中，this 指向触发这个事件的对象，特殊的是，IE 中的 attachEvent 中的 this 总是指向全局对象 Window；</p>
<h4 id="eval-是做什么的？"><a href="#eval-是做什么的？" class="headerlink" title="eval 是做什么的？"></a>eval 是做什么的？</h4><p>它的功能是把对应的字符串解析成 JS 代码并运行；<br>应该避免使用 eval，不安全，非常耗性能（2 次，一次解析成 js 语句，一次执行）。<br>由 JSON 字符串转换为 JSON 对象的时候可以用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>，var obj =<span class="built_in">eval</span>(<span class="string">'('</span>+ str +<span class="string">')'</span>);</span><br></pre></td></tr></table></figure>
<h4 id="什么是-window-对象-什么是-document-对象"><a href="#什么是-window-对象-什么是-document-对象" class="headerlink" title="什么是 window 对象? 什么是 document 对象?"></a>什么是 window 对象? 什么是 document 对象?</h4><p>window 对象代表浏览器中打开的一个窗口。document 对象代表整个 html 文档。实际上，document 对象是 window 对象的对象属性。</p>
<h4 id="null，undefined-的区别？"><a href="#null，undefined-的区别？" class="headerlink" title="null，undefined 的区别？"></a>null，undefined 的区别？</h4><p>null：示一个对象被定义了，值为“空值”；<br>undefined：表示不存在这个值。<br>typeof undefine//“undefined”<br>undefined :是一个表示”无”的原始值或者说表示”缺少值”，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 undefined；例如变量被声明了，但没有赋值时，就等于 undefined。<br>typeof null//“object”<br>null : 是一个对象(空对象, 没有任何属性和方法)；<br>例如作为函数的参数，表示该函数的参数不是对象；<br>注意：<br>在验证 null 时，一定要使用　=== ，因为 == 无法区别 null 和　 undefined</p>
<h4 id="写一个通用的事件侦听器函数。"><a href="#写一个通用的事件侦听器函数。" class="headerlink" title="写一个通用的事件侦听器函数。"></a>写一个通用的事件侦听器函数。</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">markyun.Event = &#123;</span><br><span class="line">  // 页面加载完成后</span><br><span class="line">  readyEvent : <span class="keyword">function</span>(fn) &#123;</span><br><span class="line">      <span class="keyword">if</span> (fn==null) &#123;</span><br><span class="line">          fn=document;</span><br><span class="line">      &#125;</span><br><span class="line">      var oldonload = window.onload;</span><br><span class="line">      <span class="keyword">if</span> (typeof window.onload != <span class="string">'function'</span>) &#123;</span><br><span class="line">          window.onload = fn;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          window.onload = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">              oldonload();</span><br><span class="line">              fn();</span><br><span class="line">          &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 视能力分别使用dom0||dom2||IE方式 来绑定事件</span><br><span class="line">  // 参数： 操作的元素,事件名称 ,事件处理程序</span><br><span class="line">  addEvent : <span class="keyword">function</span>(element, <span class="built_in">type</span>, handler) &#123;</span><br><span class="line">      <span class="keyword">if</span> (element.addEventListener) &#123;</span><br><span class="line">          //事件类型、需要执行的函数、是否捕捉</span><br><span class="line">          element.addEventListener(<span class="built_in">type</span>, handler, <span class="literal">false</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent) &#123;</span><br><span class="line">          element.attachEvent(<span class="string">'on'</span> + <span class="built_in">type</span>, <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">              handler.call(element);</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          element[<span class="string">'on'</span> + <span class="built_in">type</span>] = handler;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 移除事件</span><br><span class="line">  removeEvent : <span class="keyword">function</span>(element, <span class="built_in">type</span>, handler) &#123;</span><br><span class="line">      <span class="keyword">if</span> (element.removeEventListener) &#123;</span><br><span class="line">          element.removeEventListener(<span class="built_in">type</span>, handler, <span class="literal">false</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.datachEvent) &#123;</span><br><span class="line">          element.detachEvent(<span class="string">'on'</span> + <span class="built_in">type</span>, handler);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          element[<span class="string">'on'</span> + <span class="built_in">type</span>] = null;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获)</span><br><span class="line">  stopPropagation : <span class="keyword">function</span>(ev) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ev.stopPropagation) &#123;</span><br><span class="line">          ev.stopPropagation();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          ev.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 取消事件的默认行为</span><br><span class="line">  preventDefault : <span class="keyword">function</span>(event) &#123;</span><br><span class="line">      <span class="keyword">if</span> (event.preventDefault) &#123;</span><br><span class="line">          event.preventDefault();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          event.returnValue = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 获取事件目标</span><br><span class="line">  getTarget : <span class="keyword">function</span>(event) &#123;</span><br><span class="line">      <span class="built_in">return</span> event.target || event.srcElement;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 获取event对象的引用，取到事件的所有信息，确保随时能使用event；</span><br><span class="line">  getEvent : <span class="keyword">function</span>(e) &#123;</span><br><span class="line">      var ev = e || window.event;</span><br><span class="line">      <span class="keyword">if</span> (!ev) &#123;</span><br><span class="line">          var c = this.getEvent.caller;</span><br><span class="line">          <span class="keyword">while</span> (c) &#123;</span><br><span class="line">              ev = c.arguments[0];</span><br><span class="line">              <span class="keyword">if</span> (ev &amp;&amp; Event == ev.constructor) &#123;</span><br><span class="line">                  <span class="built_in">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              c = c.caller;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">return</span> ev;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="“1”-“2”-“3”-map-parseInt-答案是多少？"><a href="#“1”-“2”-“3”-map-parseInt-答案是多少？" class="headerlink" title="[“1”, “2”, “3”].map(parseInt) 答案是多少？"></a>[“1”, “2”, “3”].map(parseInt) 答案是多少？</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, NaN, NaN]</span><br></pre></td></tr></table></figure>
<p>parseInt() 函数能解析一个字符串，并返回一个整数，需要两个参数 (val, radix),其中 radix 表示要解析的数字的基数。【该值介于 2 ~ 36 之间，并且字符串中的数字不能大于 radix 才能正确返回数字结果值;但此处 map 传了 3 个 (element, index, array),我们重写 parseInt 函数测试一下是否符合上面的规则。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> parseInt(str, radix) &#123;</span><br><span class="line">    <span class="built_in">return</span> str+<span class="string">'-'</span>+radix;</span><br><span class="line">&#125;;</span><br><span class="line">var a=[<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>];</span><br><span class="line">a.map(parseInt);  // [<span class="string">"1-0"</span>, <span class="string">"2-1"</span>, <span class="string">"3-2"</span>] 不能大于radix</span><br></pre></td></tr></table></figure>
<p>因为二进制里面，没有数字 3,导致出现超范围的 radix 赋值和不合法的进制解析，才会返回 NaN。所以[“1”, “2”, “3”].map(parseInt) 答案也就是：[1, NaN, NaN]</p>
<h4 id="事件是？IE-与火狐的事件机制有什么区别？-如何阻止冒泡？"><a href="#事件是？IE-与火狐的事件机制有什么区别？-如何阻止冒泡？" class="headerlink" title="事件是？IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？"></a>事件是？IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？</h4><p>1）、我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。<br>2）、事件处理机制：IE 是事件冒泡、Firefox 同时支持两种事件模型，也就是：捕获型事件和冒泡型事件；<br>3）、ev.stopPropagation();（旧 ie 的方法 ev.cancelBubble = true;）</p>
<h4 id="如何判断一个对象是否属于某个类？"><a href="#如何判断一个对象是否属于某个类？" class="headerlink" title="如何判断一个对象是否属于某个类？"></a>如何判断一个对象是否属于某个类？</h4><p>使用 instanceof （待完善）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a instanceof Person)&#123;</span><br><span class="line">    alert(<span class="string">'yes'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="new-操作符具体干了什么呢"><a href="#new-操作符具体干了什么呢" class="headerlink" title="new 操作符具体干了什么呢?"></a>new 操作符具体干了什么呢?</h4><p>1）、声明一个中间对象；<br>2）、将该中间对象的原型指向构造函数的原型；<br>3）、调用该构造函数，将构造函数的上下文对象 this，指向该中间对象；<br>4）、返回该中间对象，即返回实例对象。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj  = &#123;&#125;;</span><br><span class="line">obj.__proto__ = fn.prototype;</span><br><span class="line">fn.call(obj);//如果构造函数明确指定了返回对象时，那么new的执行结果就是该返回对象，否则就是返回的实例对象</span><br></pre></td></tr></table></figure>
<h4 id="Javascript-中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？"><a href="#Javascript-中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？" class="headerlink" title="Javascript 中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？"></a>Javascript 中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？</h4><p>hasOwnProperty<br>javaScript 中 hasOwnProperty 函数方法是返回一个布尔值，指出一个对象是否具有指定名称的属性。此方法无法检查该对象的原型链中是否具有该属性；该属性必须是对象本身的一个成员。<br>使用方法：<br>object.hasOwnProperty(proName),其中参数 object 是必选项。一个对象的实例。proName 是必选项。一个属性名称的字符串值。如果 object 具有指定名称的属性，那么 JavaScript 中 hasOwnProperty 函数方法返回 true，反之则返回 false。</p>
<h4 id="JSON-的了解？"><a href="#JSON-的了解？" class="headerlink" title="JSON 的了解？"></a>JSON 的了解？</h4><p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。是键值对，是一个对象。<br>它是基于 JavaScript 的一个子集。数据格式简单, 易于读写, 占用带宽小<br>如：{“age”:”12”, “name”:”back”}<br>JSON 字符串转换为 JSON 对象:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj =<span class="built_in">eval</span>(<span class="string">'('</span>+ str +<span class="string">')'</span>);</span><br><span class="line">var obj = str.parseJSON();</span><br><span class="line">var obj = JSON.parse(str);</span><br></pre></td></tr></table></figure>
<p>JSON 对象转换为 JSON 字符串：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var last=obj.toJSONString();</span><br><span class="line">var last=JSON.stringify(obj);</span><br></pre></td></tr></table></figure>
<h4 id="js-延迟加载的方式有哪些？"><a href="#js-延迟加载的方式有哪些？" class="headerlink" title="js 延迟加载的方式有哪些？"></a>js 延迟加载的方式有哪些？</h4><p>defer 和 async、动态创建 DOM 方式（用得最多）、按需异步载入 js</p>
<h4 id="Ajax-是什么-ajax-原理是什么？ajax-的交互模型-同步和异步的区别-如何解决跨域问题"><a href="#Ajax-是什么-ajax-原理是什么？ajax-的交互模型-同步和异步的区别-如何解决跨域问题" class="headerlink" title="Ajax 是什么?ajax 原理是什么？ajax 的交互模型?同步和异步的区别?如何解决跨域问题?"></a>Ajax 是什么?ajax 原理是什么？ajax 的交互模型?同步和异步的区别?如何解决跨域问题?</h4><p>ajax 的全称：Asynchronous Javascript And XML。<br>异步传输+js+xml。<br>所谓异步，在这里简单地解释就是：向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验。<br>Ajax 就是通过 JavaScript 创建 XMLHttpRequest 对象，再由 JavaScript 调用 XMLHttpRequest 对象的方法完成异步通信；然后，再由 JavaScript 通过 DOM 的属性和方法，完成页面的不完全刷新。<br>由事件触发，创建一个 XMLHttpRequest 对象，把 HTTP 方法（Get/Post）和目标 URL 以及请求返回后的回调函数设置到 XMLHttpRequest 对象，通过 XMLHttpRequest 向服务器发送请求，请求发送后继续响应用户的界面交互，只有等到请求真正从服务器返回的时候才调用 callback()函数，对响应数据进行处理。</p>
<h5 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h5><p>AJAX 技术的核心是 XMLHttpRequest 对象(XHR)，AJAX 与数据格式无关，这种即使是无需刷新技术就可以从服务器取得数据，不一定是 XML 数据。<br>要完整实现一个 AJAX 异步调用和局部刷新,通常需要以下几个步骤:<br>(1)创建 XMLHttpRequest 对象,也就是创建一个异步调用对象。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var xmlHttpRequest = new ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);//IE</span><br><span class="line">var xmlHttpRequest = new XMLHttpRequest();</span><br></pre></td></tr></table></figure>
<p>(2)创建一个新的 HTTP 请求,并指定该 HTTP 请求的方法、URL 及验证信息。说明 XMLHttpRequest 对象要从哪里获取数据。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XMLHttpRequest.open(method,URL,flag,name,password)//method：get、post、head、put、delete</span><br></pre></td></tr></table></figure>
<p>(3)设置响应 HTTP 请求状态变化的函数。<br>XMLHttpRequest 对象可以响应 readystatechange 事件，该事件在 XMLHttpRequest 对象状态改变时（readyState 属性只要发生改变就会触发该函数）激发。因此，可以通过该事件调用一个函数，并在该函数中判断 XMLHttpRequest 对象的 readyState 属性值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//设置当XMLHttpRequest对象状态改变时调用的函数，注意函数名后面不要添加小括号</span><br><span class="line">xmlHttpRequest.onreadystatechange = getData;</span><br><span class="line">//定义函数</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">getData</span></span>()&#123;</span><br><span class="line">     //判断XMLHttpRequest对象的readyState属性值是否为4，如果为4表示异步调用完成</span><br><span class="line">     <span class="keyword">if</span>(xmlHttpRequest.readyState == 4)&#123;</span><br><span class="line">          //设置获取数据的语句</span><br><span class="line">          <span class="keyword">if</span>(xmlHttpRequest.status &gt;= 200 &amp;&amp; xmlHttpRequest.status &lt;300|| xmlHttpRequest.status == 304)&#123;</span><br><span class="line">              //使用以下语句将返回结果以字符串形式输出</span><br><span class="line">              document.write(xmlHttpRequest.responseText);</span><br><span class="line">              //或者使用以下语句将返回结果以XML形式输出</span><br><span class="line">              //docunment.write(xmlHttpRequest.responseXML);</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(4)发送 HTTP 请求。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MLHttpRequest.send(data)</span><br></pre></td></tr></table></figure>
<p>其中 data 是作为请求主体发送的数据，如果请求的数据不需要参数，则必须传入 null。<br>(5)获取异步调用返回的数据。<br>如果 XMLHttpRequest 对象的 readyState 属性值等于 4，表示异步调用过程完毕，使用 responseText 属性（作为响应主体）或 responseXml 属性来获取数据。但是，异步调用过程完毕，并不代表异步调用成功了，如果要判断异步调用是否成功，还要判断 XMLHttpRequest 对象的 status 属性值，只有该属性值为 200，才表示异步调用成功。<br>(6)使用 JavaScript 和 DOM 实现局部刷新。<br>注意：在调用 open()函数之前制定 onreadystatechange 事件处理程序才能确保跨浏览器兼容性。没有使用 event 对象直接使用 XHR 对象确定下一步该怎么做是较为可靠的一种方式。</p>
<h5 id="整个-XMLHttpRequest-对象的生命周期应该包含如下阶段："><a href="#整个-XMLHttpRequest-对象的生命周期应该包含如下阶段：" class="headerlink" title="整个 XMLHttpRequest 对象的生命周期应该包含如下阶段："></a>整个 XMLHttpRequest 对象的生命周期应该包含如下阶段：</h5><p>创建－初始化请求－发送请求－接收数据－解析数据－完成<br>readyState 共有五个状态，分别为 01234，但一般我们只关注 4 这个状态就好。但对于其各个状态的含义可以了解下，具体如下：<br>　　 0 － （未初始化）还没有调用 open()方法<br>　　 1 － （启动）已调用 open()方法，尚未调用 send()方法<br>　　 2 － （发送）已经调用 send()，但尚未接收到响应<br>　　 3 － （接收）已经接收到部分相应数据(已经接收到 HTTP 响应头部信息，但是消息体部分还没有完全接收到)<br>　　 4 － （完成）已经接收到全部响应数据，可以在客户端调用了<br>(0)未初始化<br>此阶段确认 XMLHttpRequest 对象是否创建，并为调用 open()方法进行未初始化作好准备。值为 0 表示对象已经存在，否则浏览器会报错－－对象不存在。<br>(1)启动<br>此阶段对 XMLHttpRequest 对象进行初始化，即调用 open()方法，根据参数(method,url,true)完成对象状态的设置。并且 XMLHttpRequest 对象已经准备好将一个请求发送到服务器端。<br>(2)发送<br>已经通过 send 方法把一个请求发送到服务器端，但是还没有收到一个响应<br>(3)接收<br>此阶段解析接收到的服务器端响应数据。即根据服务器端响应头部返回的 MIME 类型把数据转换成能通过 responseBody、responseText 或 responseXML 属性存取的格式，为在客户端调用作好准备。状态 3 表示正在解析数据。<br>(4)完成<br>此阶段确认全部数据都已经解析为客户端可用的格式，解析已经完成。值为 4 表示数据解析完毕，可以通过 XMLHttpRequest 对象的相应属性取得数据。</p>
<p>请求返回前可调用 abort()方法终止请求。<br>Comet 是 Ajax 的进一步发展，让服务器几乎能够实时的向客户端发送数据，实现 Comet 主要有长轮询和 HTTP 流，所有浏览器都支持长轮询，而只有部分浏览器原生支持 HTTP 流，SSE 是一种实现 Comet 交互的浏览器 API，既支持长轮询，也支持 HTTP 流。</p>
<h5 id="优势"><a href="#优势" class="headerlink" title="优势:"></a>优势:</h5><p><1>.无刷新更新数据。<br>AJAX 最大优点就是能在不刷新整个页面的前提下与服务器通信维护数据。这使得 Web 应用程序更为迅捷地响应用户交互，并避免了在网络上发送那些没有改变的信息，减少用户等待时间，带来非常好的用户体验。</1></p>
<p><2>.异步与服务器通信。<br>AJAX 使用异步方式与服务器通信，不需要打断用户的操作，具有更加迅速的响应能力。优化了 Browser 和 Server 之间的沟通，减少不必要的数据传输、时间及降低网络上数据流量。</2></p>
<p><3>.前端和后端负载平衡。<br>AJAX 可以把以前一些服务器负担的工作转嫁到客户端，利用客户端闲置的能力来处理，减轻服务器和带宽的负担，节约空间和宽带租用成本。并且减轻服务器的负担，AJAX 的原则是“按需取数据”，可以最大程度的减少冗余请求和响应对服务器造成的负担，提升站点性能。</3></p>
<p><4>.基于标准被广泛支持。</4></p>
<p><5>.界面与应用分离。<br>Ajax 使 WEB 中的界面与应用分离（也可以说是数据与呈现分离），有利于分工合作、减少非技术人员对页面的修改造成的 WEB 应用程序错误、提高效率、也更加适用于现在的发布系统。</5></p>
<h5 id="Ajax-的最大的特点是什么"><a href="#Ajax-的最大的特点是什么" class="headerlink" title="Ajax 的最大的特点是什么:"></a>Ajax 的最大的特点是什么:</h5><p>Ajax 可以实现动态不刷新（局部刷新）<br>readyState 属性 状态 有 5 个可取值： 0=未初始化 ，1=启动 2=发送，3=接收，4=完成</p>
<h5 id="Ajax-同步和异步的区别"><a href="#Ajax-同步和异步的区别" class="headerlink" title="Ajax 同步和异步的区别:"></a>Ajax 同步和异步的区别:</h5><p>1）同步：提交请求 -&gt; 等待服务器处理 -&gt; 处理完毕返回，这个期间客户端浏览器不能干任何事<br>2）异步：请求通过事件触发 -&gt; 服务器处理（这是浏览器仍然可以作其他事情）-&gt; 处理完毕<br>ajax.open 方法中，第 3 个参数是设同步或者异步</p>
<h5 id="ajax-的缺点"><a href="#ajax-的缺点" class="headerlink" title="ajax 的缺点:"></a>ajax 的缺点:</h5><p>1）ajax 不支持浏览器 back 按钮。<br>back 和 history 存在的根本就是 url 的改变，ajax 并没有改变 url，用户单击后退按钮访问历史记录时，通过创建或使用一个隐藏的 IFRAME 来重现页面上的变更。（例如，当用户在 Google Maps 中单击后退时，它在一个隐藏的 IFRAME 中进行搜索，然后将搜索结果反映到 Ajax 元素上，以便将应用程序状态恢复到当时的状态。）但是它所带来的开发成本是非常高的，和 ajax 框架所要求的快速开发是相背离的。这是 ajax 所带来的一个非常严重的问题。<br>2）安全问题 AJAX 暴露了与服务器交互的细节。<br>ajax 技术就如同对企业数据建立了一个直接通道。这使得开发者在不经意间会暴露比以前更多的数据和服务器逻辑。ajax 的逻辑可以对客户端的安全扫描技术隐藏起来，允许黑客从远端服务器上建立新的攻击。还有 ajax 也难以避免一些已知的安全弱点，诸如跨站点脚本攻击、SQL 注入攻击和基于 credentials 的安全漏洞等。<br>3）对搜索引擎的支持比较弱。<br>搜索引擎在抓取页面的时候会屏蔽所有的 JavaScript 代码，而基于 ajax 技术的 web 站点所用的到的很重要的技术就是 js 代码，这样一来 ajax 载入的内容相对于搜索引擎就是透明的不利于各大搜索引擎的搜索。<br>4）破坏了程序的异常机制。<br>5）不容易调试。<br>6）违背 URL 和资源定位的初衷。<br>7）AJAX 不能很好支持移动设备。<br>8）客户端过肥，太多客户端代码造成开发上的成本。编写复杂、容易出错；冗余代码比较多，破坏了 Web 的原有标准。<br>跨域： jsonp、 iframe、window.name、window.postMessage、服务器上设置代理页面</p>
<h5 id="AJAX-注意点及适用和不适用场景"><a href="#AJAX-注意点及适用和不适用场景" class="headerlink" title="AJAX 注意点及适用和不适用场景"></a>AJAX 注意点及适用和不适用场景</h5><h6 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h6><p>Ajax 开发时，网络延迟——即用户发出请求到服务器发出响应之间的间隔——需要慎重考虑。不给予用户明确的回应，没有恰当的预读数据，或者对 XMLHttpRequest 的不恰当处理，都会使用户感到延迟，这是用户不希望看到的，也是他们无法理解的。通常的解决方案是，使用一个可视化的组件来告诉用户系统正在进行后台操作并且正在读取数据和内容。</p>
<h6 id="Ajax-适用场景"><a href="#Ajax-适用场景" class="headerlink" title="Ajax 适用场景"></a>Ajax 适用场景</h6><p><1>.表单驱动的交互</1></p>
<p><2>.深层次的树的导航</2></p>
<p><3>.快速的用户与用户间的交流响应</3></p>
<p><4>.类似投票 yes/no 等无关痛痒的场景</4></p>
<p><5>.对数据进行过滤和操纵相关数据的场景</5></p>
<p><6>.普通的文本输入提示和自动完成的场景。</6></p>
<h6 id="Ajax-不适用场景"><a href="#Ajax-不适用场景" class="headerlink" title="Ajax 不适用场景"></a>Ajax 不适用场景</h6><p><1>.部分简单的表单</1></p>
<p><2>.搜索</2></p>
<p><3>.基本的导航</3></p>
<p><4>.替换大量的文本</4></p>
<p><5>.对呈现的操纵。</5></p>
<h4 id="Ajax-解决浏览器缓存问题？"><a href="#Ajax-解决浏览器缓存问题？" class="headerlink" title="Ajax 解决浏览器缓存问题？"></a>Ajax 解决浏览器缓存问题？</h4><p>确保 ajax 或连接不走缓存路径：<br>1）、在 ajax 发送请求前加上 anyAjaxObj.setRequestHeader(“If-Modified-Since”,”0”)。<br>2）、在 ajax 发送请求前加上 anyAjaxObj.setRequestHeader(“Cache-Control”,”no-cache”)。<br>3）、在 URL 后面加上一个随机数： “fresh=” + Math.random();。<br>4）、在 URL 后面加上时间搓：”nowtime=” + new Date().getTime();。<br>5）、如果是使用 jQuery，直接这样就可以了 \$.ajaxSetup({cache:false})。这样页面的所有 ajax 都会执行这条语句就是不需要保存缓存记录。</p>
<h4 id="Flash、Ajax-各自的优缺点，在使用中如何取舍？"><a href="#Flash、Ajax-各自的优缺点，在使用中如何取舍？" class="headerlink" title="Flash、Ajax 各自的优缺点，在使用中如何取舍？"></a>Flash、Ajax 各自的优缺点，在使用中如何取舍？</h4><p>Flash 适合处理多媒体、矢量图形、访问机器；对 CSS、处理文本上不足，不容易被搜索。<br>Ajax 对 CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。<br>共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作 DOM。</p>
<h4 id="简述同步和异步的区别"><a href="#简述同步和异步的区别" class="headerlink" title="简述同步和异步的区别"></a>简述同步和异步的区别</h4><p>同步是阻塞模式，异步是非阻塞模式。<br>同步就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去；<br>异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率<br>同步的概念应该是来自于 OS 中关于同步的概念:不同进程为协同完成某项工作而在先后次序上调整(通过阻塞,唤醒等方式).同步强调的是顺序性.谁先谁后.异步则不存在这种顺序性.<br>同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作。<br>异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容。</p>
<h4 id="如何解决跨域问题"><a href="#如何解决跨域问题" class="headerlink" title="如何解决跨域问题?"></a>如何解决跨域问题?</h4><p>jsonp、document.domain + iframe(只有在主域相同的时候才能使用该方法) iframe、window.name、web-cocket、postMessage（HTML5 中的 XMLHttpRequest Level 2 中的 API）、服务器上设置代理页面，动态创建 script，CORS</p>
<h4 id="模块化开发怎么做？"><a href="#模块化开发怎么做？" class="headerlink" title="模块化开发怎么做？"></a>模块化开发怎么做？</h4><p>模块化开发指的是在解决某一个复杂问题或者一系列问题时，依照一种分类的思维把问题进行系统性的分解以之解决。模块化是一种处理复杂系统分解为代码结构更合理，可维护性更高的可管理的模方式。对于软件行业：系统被分解为一组高内聚，低耦合的模块。<br>（1）定义封装的模块<br>（2）定义新模块对其他模块的依赖<br>（3）可对其他模块的引入支持<br>在 JavaScript 中出现了一些非传统模块开发方式的规范 CommonJS 的模块规范，AMD（Asynchronous Module Definition），CMD（Common Module Definition）等 AMD 是异步模块定义，所有的模块将被异步加载，模块加载不影响后边语句运行。<br>立即执行函数,不暴露私有成员</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var module1 = (<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">   var _count = 0;</span><br><span class="line">   var m1 = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    　//...</span><br><span class="line">   &#125;;</span><br><span class="line">   var m2 = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    　//...</span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="built_in">return</span> &#123;</span><br><span class="line">    　m1 : m1,</span><br><span class="line">    　m2 : m2</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<h4 id="AMD（Modules-Asynchronous-Definition）、CMD（Common-Module-Definition）规范区别？"><a href="#AMD（Modules-Asynchronous-Definition）、CMD（Common-Module-Definition）规范区别？" class="headerlink" title="AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？"></a>AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？</h4><p>Asynchronous Module Definition，异步模块定义，所有的模块将被异步加载，模块加载不影响后面语句运行。所有依赖某些模块的语句均放置在回调函数中。</p>
<p>区别： 1.对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.<br>2.CMD 推崇依赖就近（在语句中使用到这个模块的内容时再书写），AMD 推崇依赖前置（在编写代码开始就写好依赖）。看代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="keyword">function</span>(require, exports, module) &#123;</span><br><span class="line">    var a = require(<span class="string">'./a'</span>)</span><br><span class="line">    a.doSomething()</span><br><span class="line">    // 此处略去 100 行</span><br><span class="line">    var b = require(<span class="string">'./b'</span>) // 依赖可以就近书写</span><br><span class="line">    b.doSomething()</span><br><span class="line">    // ...</span><br><span class="line">&#125;)</span><br><span class="line">// AMD 默认推荐</span><br><span class="line">define([<span class="string">'./a'</span>, <span class="string">'./b'</span>], <span class="keyword">function</span>(a, b) &#123; // 依赖必须一开始就写好</span><br><span class="line">    a.doSomething()</span><br><span class="line">    // 此处略去 100 行</span><br><span class="line">    b.doSomething()</span><br><span class="line">    // ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="requireJS-的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何缓存的？）"><a href="#requireJS-的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何缓存的？）" class="headerlink" title="requireJS 的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何缓存的？）"></a>requireJS 的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何缓存的？）</h4><p>（1）实现 js 文件的异步加载，避免网页失去响应；<br>（2）管理模块之间的依赖性，便于代码的编写和维护。<br>Requirejs 基于 AMD 规范，每个模块用 define 定义，如果这个模块还依赖其他模块，那么 define()函数的第一个参数，必须是一个数组，指明该模块的依赖性。主模块依次加载 require 的模块，使用 require.config()方法，我们可以对模块的加载行为进行自定义。require.config()就写在主模块（main.js）的头部。参数就是一个对象，这个对象的 paths 属性指定各个模块的加载路径。shim 属性，专门用来配置不兼容的模块。具体来说，每个模块要定义（1）exports 值（输出的变量名），表明这个模块外部调用时的名称；（2）deps 数组，表明该模块的依赖性。然后监测 script 的 onload 事件，判断所有模块加载成功，执行 require 的 callback， 如果只带一个参数且不是数组，就是加载成功后 return 模块，会记录加载成功的个数以及各个模块的顺序。</p>
<p>对 CommonJs 和 AMD，CMD 的理解：<br>都是为了使 js 代码模块化的规范，以前的时候如果一个 js 模块调用另一个模块，需要在 html 中进行 link，而且必须有严格的引入顺序，但是这样又有可能造成阻塞，使页面失去响应。<br>CommonJS 规定一个文件是一个模块，每个模块内部，module 变量代表当前模块。这个变量是一个对象，它的 exports 属性（即 module.exports）是对外的接口。加载某个模块，其实是加载该模块的 module.exports 属性。内置的 require（路径以/开头是绝对路径，以./开头是相对本文件所在位置的路径,不以“./“或”/“开头，则表示加载的是一个默认提供的核心模块（位于 Node 的系统安装目录中），或者一个位于各级 node_modules 目录的已安装模块（全局安装或局部安装））命令用于加载模块文件。当使用 require 调用该模块时，就获得了 exports 对象。</p>
<p>每个模块内部，都有一个 module 对象，代表当前模块。它有以下属性。<br>● module.id 模块的识别符，通常是带有绝对路径的模块文件名。<br>● module.filename 模块的文件名，带有绝对路径。<br>● module.loaded 返回一个布尔值，表示模块是否已经完成加载。<br>● module.parent 返回一个对象，表示调用该模块的模块。<br>● module.children 返回一个数组，表示该模块要用到的其他模块。<br>● module.exports 表示模块对外输出的值。</p>
<p>CommonJs 是同步加载 JS 脚本，Node.js 使用了这一规范。这一规范和我们之前的做法比较类似，是同步加载 JS 脚本。这么做在服务端毫无问题，因为文件都存在磁盘上，然而浏览器的特性决定了 JS 脚本需要异步加载，否则就会失去响应，因此 CommonJS 规范无法直接在浏览器中使用。</p>
<p>CommonJS 模块的特点如下:<br>● 所有代码都运行在模块作用域，不会污染全局作用域。<br>● 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。<br>● 模块加载的顺序，按照其在代码中出现的顺序。</p>
<p>在 Node 中使用 exports=module.exports，可以对 exports 进行返回值的设定，但是不能对 exports 和 module.exports 进行赋值，而且也不能使用 exports 输出，只能使用 module.exports 输出 module.exports = function (x){ console.log(x);};。当使用 require 调用自身模块时就会执行自身的 module.exports<br>CommonJS 模块的加载机制是，输入的是被输出的值的拷贝。<br>AMD 规范：前置加载，所有前置模块异步加载结束后，才进行调用 callback。require.js 实现了这个规范。<br>缓存：所有缓存的模块保存在 require.cache 之中，如果想删除模块的缓存，可以像下面这样写。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 删除指定模块的缓存</span><br><span class="line">delete require.cache[moduleName];</span><br><span class="line">// 删除所有模块的缓存</span><br><span class="line">Object.keys(require.cache).forEach(<span class="keyword">function</span>(key) &#123;</span><br><span class="line">delete require.cache[key];</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>注意，缓存是根据绝对路径识别模块的，如果同样的模块名，但是保存在不同的路径，require 命令还是会重新加载该模块。<br>require.main：<br>require 方法有一个 main 属性，可以用来判断模块是直接执行，还是被调用执行。直接执行的时候（node module.js），require.main 属性指向模块本身。require.main === module// true。调用执行的时候（通过 require 加载该脚本执行），上面的表达式返回 false。</p>
<p>require 的内部处理流程：<br>require 命令是 CommonJS 规范之中，用来加载其他模块的命令。它其实不是一个全局命令，而是指向当前模块的 module.require 命令，而后者又调用 Node 的内部命令 Module._load。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Module._load = <span class="keyword">function</span>(request, parent, isMain) &#123;</span><br><span class="line">  // 1. 检查 Module._cache，是否缓存之中有指定模块</span><br><span class="line">  // 2. 如果缓存之中没有，就创建一个新的Module实例</span><br><span class="line">  // 3. 将它保存到缓存</span><br><span class="line">  // 4. 使用 module.load() 加载指定的模块文件，</span><br><span class="line">  //    读取文件内容之后，使用 module.compile() 执行文件代码</span><br><span class="line">  // 5. 如果加载/解析过程报错，就从缓存删除该模块</span><br><span class="line">  // 6. 返回该模块的 module.exports</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的第 4 步，采用 module.compile()执行指定模块的脚本，逻辑如下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Module.prototype._compile = <span class="keyword">function</span>(content, filename) &#123;</span><br><span class="line">  // 1. 生成一个require函数，指向module.require</span><br><span class="line">  // 2. 加载其他辅助方法到require</span><br><span class="line">  // 3. 将文件内容放到一个函数之中，该函数可调用 require</span><br><span class="line">  // 4. 执行该函数</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的第 1 步和第 2 步，require 函数及其辅助方法主要如下。<br>● require(): 加载外部模块<br>● require.resolve()：将模块名解析到一个绝对路径<br>● require.main：指向主模块<br>● require.cache：指向所有缓存的模块<br>● require.extensions：根据文件的后缀名，调用不同的执行函数<br>一旦 require 函数准备完毕，整个所要加载的脚本内容，就被放到一个新的函数之中，这样可以避免污染全局环境。该函数的参数包括 require、module、exports，以及其他一些参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (exports, require, module, __filename, __dirname) &#123;</span><br><span class="line">  // YOUR CODE INJECTED HERE!</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Module._compile 方法是同步执行的，所以 Module._load 要等它执行完成，才会向用户返回 module.exports 的值。</p>
<p>CMD 规范：就近加载，在需要用到依赖的时候才申明，可同步可异步，Sea.js 实现了这个规范，Sea.js 遇到依赖后只会去下载 JS 文件，并不会执行，而是等到所有被依赖的 JS 脚本都下载完以后，才从头开始执行主逻辑。因此被依赖模块的执行顺序和书写顺序完全一致。</p>
<h4 id="异步加载-JS-的方式有哪些？"><a href="#异步加载-JS-的方式有哪些？" class="headerlink" title="异步加载 JS 的方式有哪些？"></a>异步加载 JS 的方式有哪些？</h4><p>(1) defer，只支持 IE<br>(2) async：<br>(3) 动态创建 script，插入到 DOM 中，加载完毕后 callBack</p>
<h4 id="DOM-操作——怎样添加、移除、移动、复制、创建和查找节点"><a href="#DOM-操作——怎样添加、移除、移动、复制、创建和查找节点" class="headerlink" title="DOM 操作——怎样添加、移除、移动、复制、创建和查找节点?"></a>DOM 操作——怎样添加、移除、移动、复制、创建和查找节点?</h4><p>（1）创建新节点</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">createDocumentFragment()//创建一个DOM片段</span><br><span class="line">createElement() //创建一个具体的元素</span><br><span class="line">createTextNode() //创建一个文本节点</span><br></pre></td></tr></table></figure>
<p>（2）添加、移除、替换、插入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">appendChild()</span><br><span class="line">removeChild()</span><br><span class="line">replaceChild()</span><br><span class="line">insertBefore() //在已有的子节点前插入一个新的子节点</span><br></pre></td></tr></table></figure>
<p>（3）查找</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getElementsByTagName()   //通过标签名称</span><br><span class="line">getElementsByName()   //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)</span><br><span class="line">getElementById() //通过元素Id，唯一性</span><br></pre></td></tr></table></figure>
<h4 id="JS-怎么实现一个类。怎么实例化这个类"><a href="#JS-怎么实现一个类。怎么实例化这个类" class="headerlink" title="JS 怎么实现一个类。怎么实例化这个类"></a>JS 怎么实现一个类。怎么实例化这个类</h4><p>可以使用命名空间，js 中的一个类就是一个对象，也可以说就是一个模块，</p>
<h4 id="Jquery-与-jQuery-UI-有啥区别？"><a href="#Jquery-与-jQuery-UI-有啥区别？" class="headerlink" title="Jquery 与 jQuery UI 有啥区别？"></a>Jquery 与 jQuery UI 有啥区别？</h4><p>jQuery 是一个 js 库，主要提供的功能是选择器，属性修改和事件绑定等等。<br>jQuery UI 则是在 jQuery 的基础上，利用 jQuery 的扩展性，设计的插件。<br>提供了一些常用的界面元素，诸如对话框、拖动行为、改变大小行为等等</p>
<h4 id="针对-jQuery-的优化方法？"><a href="#针对-jQuery-的优化方法？" class="headerlink" title="针对 jQuery 的优化方法？"></a>针对 jQuery 的优化方法？</h4><p>1）基于 Class 的选择性的性能相对于 Id 选择器开销很大，因为需遍历所有 DOM 元素。<br>2）频繁操作的 DOM，先缓存起来再操作。用 Jquery 的链式调用更好。<br>比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var str=$(<span class="string">"a"</span>).attr(<span class="string">"href"</span>);</span><br></pre></td></tr></table></figure>
<p>3）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (var i = size; i &lt; arr.length; i++) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>for 循环每一次循环都查找了数组 (arr) 的.length 属性，在开始循环的时候设置一个变量来存储这个数字，可以让循环跑得更快：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (var i = size, length = arr.length; i &lt; length; i++) &#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="如何判断当前脚本运行在浏览器还是-node-环境中？"><a href="#如何判断当前脚本运行在浏览器还是-node-环境中？" class="headerlink" title="如何判断当前脚本运行在浏览器还是 node 环境中？"></a>如何判断当前脚本运行在浏览器还是 node 环境中？</h4><p>通过判断 Global 对象是否为 window，如果不为 window，当前脚本没有运行在浏览器中。即在 node 中的全局变量是 global ,浏览器的全局变量是 window。 可以通过该全局变量是否定义来判断宿主环境</p>
<h4 id="那些操作会造成内存泄漏？"><a href="#那些操作会造成内存泄漏？" class="headerlink" title="那些操作会造成内存泄漏？"></a>那些操作会造成内存泄漏？</h4><p>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。<br>垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。<br>setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。<br>闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）<br>防止内存泄露： 1)、不要动态绑定事件； 2)、不要在动态添加，或者会被动态移除的 dom 上绑事件，用事件冒泡在父容器监听事件； 3)、如果要违反上面的原则，必须提供 destroy 方法，保证移除 dom 后事件也被移除，这点可以参考 Backbone 的源代码，做的比较好； 4)、单例化，少创建 dom，少绑事件。</p>
<h4 id="什么是“前端路由”-什么时候适合使用“前端路由”-“前端路由”有哪些优点和缺点"><a href="#什么是“前端路由”-什么时候适合使用“前端路由”-“前端路由”有哪些优点和缺点" class="headerlink" title="什么是“前端路由”?什么时候适合使用“前端路由”? “前端路由”有哪些优点和缺点?"></a>什么是“前端路由”?什么时候适合使用“前端路由”? “前端路由”有哪些优点和缺点?</h4><h5 id="什么是前端路由？"><a href="#什么是前端路由？" class="headerlink" title="什么是前端路由？"></a>什么是前端路由？</h5><p>路由是根据不同的 url 地址展示不同的内容或页面。前端路由就是把不同路由对应不同的内容或页面的任务交给前端来做，之前是通过服务端根据 url 的不同返回不同的页面实现的。</p>
<h5 id="什么时候使用前端路由？"><a href="#什么时候使用前端路由？" class="headerlink" title="什么时候使用前端路由？"></a>什么时候使用前端路由？</h5><p>在单页面应用，大部分页面结构不变，只改变部分内容的使用</p>
<h5 id="前端路由有什么优点和缺点？"><a href="#前端路由有什么优点和缺点？" class="headerlink" title="前端路由有什么优点和缺点？"></a>前端路由有什么优点和缺点？</h5><h6 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h6><p>用户体验好，不需要每次都从服务器全部获取，快速展现给用户。</p>
<h6 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h6><p>使用浏览器的前进，后退键的时候会重新发送请求，没有合理地利用缓存。<br>单页面无法记住之前滚动的位置，无法在前进，后退的时候记住滚动的位置</p>
<h4 id="用-js-实现千位分隔符-提示：正则-replace"><a href="#用-js-实现千位分隔符-提示：正则-replace" class="headerlink" title="用 js 实现千位分隔符?(提示：正则+replace)"></a>用 js 实现千位分隔符?(提示：正则+replace)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> commafy(num) &#123;</span><br><span class="line">     num = num + <span class="string">''</span>;</span><br><span class="line">     var reg = /(-?d+)(d&#123;3&#125;)/;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(reg.test(num))&#123;</span><br><span class="line">     num = num.replace(reg, <span class="string">'$1,$2'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="我们给一个-dom-同时绑定两个点击事件，一个用捕获，一个用冒泡。会执行几次事件，会先执行冒泡还是捕获？"><a href="#我们给一个-dom-同时绑定两个点击事件，一个用捕获，一个用冒泡。会执行几次事件，会先执行冒泡还是捕获？" class="headerlink" title="我们给一个 dom 同时绑定两个点击事件，一个用捕获，一个用冒泡。会执行几次事件，会先执行冒泡还是捕获？"></a>我们给一个 dom 同时绑定两个点击事件，一个用捕获，一个用冒泡。会执行几次事件，会先执行冒泡还是捕获？</h4><p>从上往下，如有捕获事件，则执行；一直向下到目标元素后，从目标元素开始向上执行冒泡元素，即第三个参数为 true 表示捕获阶段调用事件处理程序，如果是 false 则是冒泡阶段调用事件处理程序。(在向上执行过程中，已经执行过的捕获事件不再执行，只执行冒泡事件。)<br>点击的某一个元素的时候，其祖先元素的事件是遵循先捕获再冒泡，但是在本元素上的事件是按照代码顺序执行的，与冒泡和捕获无关，写在前面的先执行，所以结论是：绑定在被点击元素的事件是按照代码顺序发生，其他元素通过冒泡或者捕获“感知”的事件，按照 W3C 的标准，先发生捕获事件，后发生冒泡事件。</p>
<p>所有事件的顺序是：<br>其他元素捕获阶段事件 -&gt; 本元素代码顺序事件 -&gt; 其他元素冒泡阶段事件 。<br>所以本题是会执行两次，但是执行顺序按照代码的书写顺序执行。</p>
<h4 id="使用-JS-实现获取文件扩展名？"><a href="#使用-JS-实现获取文件扩展名？" class="headerlink" title="使用 JS 实现获取文件扩展名？"></a>使用 JS 实现获取文件扩展名？</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> getFileExtension(filename) &#123;</span><br><span class="line">  <span class="built_in">return</span> filename.slice((filename.lastIndexOf(<span class="string">"."</span>) - 1 &gt;&gt;&gt; 0) + 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>String.lastIndexOf() 方法返回指定值（本例中的’.’）在调用该方法的字符串中最后出现的位置，如果没找到则返回 -1。对于’filename’和’.hiddenfile’，lastIndexOf 的返回值分别为 0 和-1 无符号右移操作符(&gt;&gt;&gt;) 将-1 转换为 4294967295，将-2 转换为 4294967294，这个方法可以保证边缘情况时文件名不变。String.prototype.slice() 从上面计算的索引处提取文件的扩展名。如果索引比文件名的长度大，结果为””。</p>
<h4 id="跨域访问"><a href="#跨域访问" class="headerlink" title="跨域访问"></a>跨域访问</h4><p>在同源策略影响下，一个域名 A 的网页可以获取域名 B 下的脚本,css,图片等，但是不能发送 Ajax 请求，也不能操作 Cookie、LocalStorage 等数据。AJAX 通信默认情况下，XHR 对象只能访问与包含它的页面位于同一个域(协议，域名，端口相同)中的资源(使用 XMLHttpRequest 对象发起 HTTP 请求就必须遵守同源策略。)，这种安全策略可以防止某些恶意行为。</p>
<h5 id="1）—-ajax-支持-get-方式跨域：jsonp-JSON-with-Padding"><a href="#1）—-ajax-支持-get-方式跨域：jsonp-JSON-with-Padding" class="headerlink" title="1）—\$.ajax()支持 get 方式跨域：jsonp(JSON with Padding)"></a>1）—\$.ajax()支持 get 方式跨域：jsonp(JSON with Padding)</h5><p>JSONP 是包含在函数调用中的 json。e.g.callback({‘name’:’nini’})。<br>dataType: ‘jsonp’,原先的 beforeSend 和 error 方法都不再触发，原因可能是 dataType 如果指定为 jsonp 的话,就已经不是 ajax 事件了(即 JSONP 始终是无状态连接，不能获悉连接状态和错误事件)，只能使用计时器在规定时间内是否接收到了响应。<br>原理：<br>动态添加一个 script 标签，而 script 标签的 src 属性是没有跨域的限制的。这样说来,这种跨域方式其实与 ajax XmlHttpRequest 协议无关了。取而代之的则是 JSONP 协议，主要是利用 script 标签不受同源策略(同源策略，即 JavaScript 或 Cookie 只能访问同域下的内容)限制的特性，向跨域的服务器请求并返回一段 JSON 数据。 JSONP 是一个非官方的协议，它允许在服务器端集成 Script tags 返回至客户端，通过 javascript callback 的形式实现跨域访问 JSONP 即 JSON with Padding。由于同源策略的限制，XmlHttpRequest 只允许请求当前源（域名、协议、端口）的资源。如果要进行跨域请求，我们可以通过使用 html 的 script 标记来进行跨域请求，并在响应中返回要执行的 script 代码，其中可以直接使用 JSON 传递 javascript 对象。这种跨域的通讯方式称为 JSONP。onCallback 函数 是浏览器客户端注册的，获取跨域服务器上的 json 数据后，回调的函数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">   async:<span class="literal">false</span>,</span><br><span class="line">   url: http://跨域的dns/document!searchJSONResult.action,</span><br><span class="line">   <span class="built_in">type</span>: <span class="string">"GET"</span>,</span><br><span class="line">   dataType: <span class="string">'jsonp'</span>,</span><br><span class="line">   jsonpCallback: <span class="string">'jsonp1236827957501'</span>,// //callback名称</span><br><span class="line">   data: qsData,</span><br><span class="line">   timeout: 5000,</span><br><span class="line">   success: <span class="keyword">function</span> (json) &#123;//客户端jquery预先定义好的callback函数,成功获取跨域服务器上的json数据后,会动态执行这个callback函数</span><br><span class="line">    <span class="keyword">if</span>(json.actionErrors.length!=0)&#123;</span><br><span class="line">           alert(json.actionErrors);</span><br><span class="line">     &#125;</span><br><span class="line">       	   genDynamicContent(qsData,<span class="built_in">type</span>,json);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>流程：<br>1）首先在客户端注册一个 callback (如:’jsoncallback’), 然后把 callback 的名字(如:jsonp1236827957501)传给服务器。注意：服务端得到 callback 的数值后，要用 jsonp1236827957501(……)把将要输出的 json 内容包括起来，此时，服务器生成 json 数据才能被客户端正确接收。<br>2）以 javascript 语法的方式，生成一个 function , function 名字就是传递上来的参数 ‘jsoncallback’的值 jsonp1236827957501。<br>3）将 json 数据直接以入参的方式，放置到 function 中，这样就生成了一段 js 语法的文档，返回给客户端。<br>客户端浏览器，解析 script 标签，并执行返回的 javascript 文档，此时 javascript 文档数据,作为参数，传入到了客户端预先定义好的 callback 函数(如上例中 jquery \$.ajax()方法封装的的 success: function (json))里。（动态执行回调函数）可以说 jsonp 的方式原理上和 script src=”http://跨域/…xx.js”是一致的(qq空间就是大量采用这种方式来实现跨域数据交换的)。JSONP是一种脚本注入(Script Injection)行为,所以也有一定的安全隐患.<br>原理代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//客户端的JAVASCRIPT代码</span><br><span class="line">var script=document.createElement(<span class="string">"script"</span>);</span><br><span class="line">script.src=<span class="string">"http://www.pl4cj.com:8888/5/6/action.php?param=123&amp;callback="</span>+fnName;</span><br><span class="line">document.getElementsByTagName(<span class="string">"head"</span>)[0].appendChild(script)</span><br><span class="line">//服务器端的PHP代码，一定要有callback来进行回调，在这里加上括号，是让它以语句块的方式来进行解析</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">&lt;SPAN style=<span class="string">"COLOR: #ff00ff"</span>&gt;<span class="built_in">echo</span> <span class="variable">$_GET</span>[<span class="string">"callback"</span>].<span class="string">"("</span>.json_encode(<span class="variable">$_GET</span>).<span class="string">");"</span>;</span><br><span class="line">&lt;/SPAN&gt;?</span><br></pre></td></tr></table></figure>
<p>jquey 是不支持 post 方式跨域的。</p>
<h5 id="2）—html5-WebSocket-跨域：IE-浏览器目前不支持-WebSocket-通信"><a href="#2）—html5-WebSocket-跨域：IE-浏览器目前不支持-WebSocket-通信" class="headerlink" title="2）—html5 WebSocket 跨域：IE 浏览器目前不支持 WebSocket 通信"></a>2）—html5 WebSocket 跨域：IE 浏览器目前不支持 WebSocket 通信</h5><p>WebSocket protocol 是 HTML5 一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是 server push 技术的一种很棒的实现。<br>Web Sockets 使用了自定义的协议，未加密的连接是 ws://加密的连接是 wss://。使用自定义的协议而非标准 HTTP 协议的好处是能够在客户端和服务器端传送非常少的数据，而不必担心 http 那样字节级的开销，由于传递数据包小，web socket 非常适合移动应用。<br>WebSocket 对象也有一个 readyState 属性表示当前状态 WebSocket.OPENING(0)：正在创建连接；WebSocket.OPEN(1)：已经创建连接；WebSocket.CLOSING(2)：正在关闭连接；WebSocket.CLOSE(3)：已经关闭连接。<br>客户端：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var socket = new WebSocket(<span class="string">'ws://localhost:8080'</span>);// 创建Socket实例，只能是ws或wss，马上尝试创建连接</span><br><span class="line">socket.onopen = <span class="keyword">function</span>(event) &#123;                                        // 打开Socket</span><br><span class="line">socket.send(<span class="string">'I am the client and I\'</span>m listening!<span class="string">');                  // 发送任意字符串JSON.stringify(message)</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">socket.onmessage = function(event) &#123;                                  // 接收到服务器消息时触发</span></span><br><span class="line"><span class="string"> console.log('</span>Client received a message<span class="string">',event.data); 	//event.data返回的是字符串</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">socket.onclose = function(event) &#123;                                         // 监听Socket的关闭</span></span><br><span class="line"><span class="string">console.log('</span>Client notified socket has closed<span class="string">',event.data);</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">socket.onerror=function(event)&#123;                      //event有三个属性wasClean-连接是否明确关闭，code-服务器反</span></span><br><span class="line"><span class="string">console.log('</span>Connection error<span class="string">');                 //回的状态码，reason-字符串包含服务器返回的消息</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">socket.close()                                                                          // 关闭Socket....</span></span><br></pre></td></tr></table></figure>
<p>onmessage 事件提供了一个 data 属性，它可以包含消息的 Body 部分。消息的 Body 部分必须是一个字符串，可以进行序列化/反序列化操作，以便传递更多的数据。由于 IE 不支持 WebSocket 通信，Guillermo Rauch 创建了一个 Socket.IO 技术。Socket.IO 使用检测功能来判断是否建立 WebSocket 连接，或者是 AJAX long-polling 连接，或 Flash 等。可快速创建实时的应用程序。Socket.IO 还提供了一个 NodeJS API，它看起来非常像客户端 API</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"http://cdn.socket.io/stable/socket.io.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">var socket= new io.Socket(<span class="string">'localhost'</span>,&#123;                         // 创建Socket.IO实例，建立连接</span><br><span class="line">  port: 8080</span><br><span class="line">&#125;);</span><br><span class="line">socket.connect();</span><br><span class="line">socket.on(<span class="string">'connect'</span>,<span class="function"><span class="title">function</span></span>() &#123;                                    // 添加一个连接监听器</span><br><span class="line">  console.log(<span class="string">'Client has connected to the server!'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">socket.on(<span class="string">'message'</span>,<span class="keyword">function</span>(data) &#123;                           // 添加一个连接监听器</span><br><span class="line">  console.log(<span class="string">'Received a message from the server!'</span>,data);</span><br><span class="line">&#125;);</span><br><span class="line">socket.on(<span class="string">'disconnect'</span>,<span class="function"><span class="title">function</span></span>() &#123;                              // 添加一个关闭连接的监听器</span><br><span class="line">  console.log(<span class="string">'The client has disconnected!'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">function</span> sendMessageToServer(message) &#123;                // 通过Socket发送一条消息到服务器</span><br><span class="line">  socket.send(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务器端：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 需要HTTP 模块来启动服务器和Socket.IO</span><br><span class="line">var http= require(<span class="string">'http'</span>), io= require(<span class="string">'socket.io'</span>);</span><br><span class="line">// 在8080端口启动服务器</span><br><span class="line">var server= http.createServer(<span class="keyword">function</span>(req, res)&#123;</span><br><span class="line">res.writeHead(200,&#123; <span class="string">'Content-Type'</span>: <span class="string">'text/html'</span> &#125;);              // 发送HTML的headers和message</span><br><span class="line">res.end(<span class="string">'&lt;h1&gt;Hello Socket Lover!&lt;/h1&gt;'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(8080);</span><br><span class="line">var socket= io.listen(server);                                               // 创建一个Socket.IO实例，把它传递给服务器</span><br><span class="line">socket.on(<span class="string">'connection'</span>, <span class="keyword">function</span>(client)&#123;</span><br><span class="line">client.on(<span class="string">'message'</span>,<span class="keyword">function</span>(event)&#123;                                  // 成功！现在开始监听接收到的消息</span><br><span class="line">    console.log(<span class="string">'Received message from client!'</span>,event);</span><br><span class="line">  &#125;);</span><br><span class="line">client.on(<span class="string">'disconnect'</span>,<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">clearInterval(interval);</span><br><span class="line">console.log(<span class="string">'Server has disconnected'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>javascript 跨域有两种情况：<br>1、基于同一父域的子域之间，如：a.c.com 和 b.c.com<br>2、基于不同的父域之间，如：<a href="http://www.a.com" target="_blank" rel="noopener">www.a.com</a> 和 <a href="http://www.b.com" target="_blank" rel="noopener">www.b.com</a><br>3、端口的不同，如：<a href="http://www.a.com:8080" target="_blank" rel="noopener">www.a.com:8080</a> 和 <a href="http://www.a.com:8088" target="_blank" rel="noopener">www.a.com:8088</a><br>4、协议不同，如：<a href="http://www.a.com" target="_blank" rel="noopener">http://www.a.com</a> 和<a href="https://www.a.com" target="_blank" rel="noopener">https://www.a.com</a><br>对于情况 3 和 4，需要通过后台 proxy 来解决，具体方式如下：<br>a、在发起方的域下创建 proxy 程序<br>b、发起方的 js 调用本域下的 proxy 程序<br>c、proxy 将请求发送给接收方并获取相应数据<br>d、proxy 将获得的数据返回给发起方的 js<br>代码和 ajax 调用一致，其实这种方式就是通过 ajax 进行调用的。<br>而情况 1 和 2 除了通过后台 proxy 这种方式外，还可以有多种办法来解决：<br>1、document.domain+iframe（只能解决情况 1）：<br>a 、在发起方页面和接收方页面设置 document.domain ， 并将值设为父域的主域名(window.location.hostname)<br>b、在发起方页面创建一个隐藏的 iframe，iframe 的源是接收方页面<br>c、根据浏览器的不同，通过 iframe.contentDocument || iframe.contentWindow.document 来获得接收方页面的内容<br>d、通过获得的接收方页面的内容来与接收方进行交互<br>这种方法有个缺点，就是当一个域被攻击时，另一个域会有安全漏洞出现。<br>当不能使用 web socket 组合 XHR 和 SSE 也是可以实现双向通信的。</p>
<h5 id="3）—Flash："><a href="#3）—Flash：" class="headerlink" title="3）—Flash："></a>3）—Flash：</h5><p>跟 WebSocket 一样走的 TCP/IP 套接字协议</p>
<h5 id="4）—AJAX-long-polling"><a href="#4）—AJAX-long-polling" class="headerlink" title="4）—AJAX long-polling"></a>4）—AJAX long-polling</h5><p>模拟 websocket</p>
<h5 id="5）—IFrame："><a href="#5）—IFrame：" class="headerlink" title="5）—IFrame："></a>5）—IFrame：</h5><p>该方法只适合主域相同但子域不同的情况，比如 a.com 和 <a href="http://www.a.com，我们只需要给这两个页面都加上一句" target="_blank" rel="noopener">www.a.com，我们只需要给这两个页面都加上一句</a> document.domain = ‘a.com’ ，就可以在其中一个页面嵌套另一个页面，然后进行窗体间的交互。</p>
<h5 id="6）CORS：支持-POST"><a href="#6）CORS：支持-POST" class="headerlink" title="6）CORS：支持 POST"></a>6）CORS：支持 POST</h5><p>CORS 定义一种跨域访问的机制，可以让 AJAX 实现跨域访问。基本思想是使用自定义的 HTTP 头部允许浏览器和服务器相互了解对方，从而决定请求或响应成功与否。 在发送头信息的时候，会附加一个额外的 Origin 头部，Origin 头部包含请求页面的头部（协议，域名，端口），这样服务器可以很容易的决定它是否应该提供响应。如果服务器认为这个请求可以接受，就在 Access-Control-Allow-Origin 的头部中回发相同的域信息，如果是公共资源就回发。</p>
<h6 id="IE-IE8-支持-对-CORS-的实现："><a href="#IE-IE8-支持-对-CORS-的实现：" class="headerlink" title="IE(IE8+支持)对 CORS 的实现："></a>IE(IE8+支持)对 CORS 的实现：</h6><p>引入 XDomainRequest，这个对象不发送和接收 cookie，只能设置请求头信息中的 Content-Type，不能访问返回头，只支持 get 和 post，使用与 XHR 类似，open（请求类型，URL），只支持异步，接到响应后，没有办法确定响应的状态代码，响应有效触发 onload 事件，失败触发 onerror 事件也支持 timeout 和 ontimeout 事件.发送 post 请求时需要设置请求头的 contentType 属性。</p>
<h6 id="其他浏览器对-CORS-的实现："><a href="#其他浏览器对-CORS-的实现：" class="headerlink" title="其他浏览器对 CORS 的实现："></a>其他浏览器对 CORS 的实现：</h6><p>通过 XHR 实现对 CORS 的原生支持，与 XDR 不同，通过 SHR 跨域对象可以访问 status 和 statusText 属性，而且支持同步，限制了不能使用 setRequestHeader()自定义头部，不能发送和接收 cookie，调用 getAllResponseHeader()总返回空字符串。<br>默认情况下跨源请求不提供凭据（cookie，http 认证以及客户端 ssl 证明）,通过设置 withCredentials 为 ture，指定某个请求应该发送凭据。服务器接收后会返回 Access-Control-Allow-Credentials:true<br>CORS 提供了一种跨域请求方案，但没有为安全访问提供足够的保障机制。jsonp 是 get 形式，承载的信息量有限，所以信息量较大时 CORS 是不二选择；</p>
<h6 id="Comet：长轮询和流。"><a href="#Comet：长轮询和流。" class="headerlink" title="Comet：长轮询和流。"></a>Comet：长轮询和流。</h6><p>SSE：长轮询，短轮询和 HTTP 流，半双工。SSE 支持短轮询、长轮询和 HTTP 流，而且能在断开连接时自动确定何时重新连接。，要创建新的 EventSource 对象，并传入一个入口点：<br>var source=new EventSource(“myevents.php”);<br>注意：要传入的 URL 必须与创建对象的页面同源。EventSource 的实例有一个 readyState 属性，值为 0 表示正连接到服务器，值为 1 表示打开了连接，值为 2 表示关闭连接。另外还有以下三个事件：<br>open：在建立连接时触发。<br>message：在从服务器接收到新事件时触发。<br>error：在无法建立连接时触发。<br>服务器返回的数据以字符串的格式保存在 event.data 中。<br>默认情况下，EventSource 对象会保存于服务器的活动连接。如果连接断开，还会重新连接。这就意味着 SSE 适合长轮询和 HTTP 流。如果想强制立即断开连接并且不再重新连接，可以调用 close()方法。</p>
<h5 id="7）动态创建-script"><a href="#7）动态创建-script" class="headerlink" title="7）动态创建 script"></a>7）动态创建 script</h5><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>IE 的事件流叫事件冒泡，IE5.5 更早版本事件冒泡会跳过 html 元素，其他的都一直冒泡到 window 对象，DOM 事件模型的最独特的性质是，文本节点也触发事件(在 IE 不会)。IE 提出的是冒泡流，而网景提出的是捕获流，后来在 W3C 组织的统一之下，JS 支持了冒泡流和捕获流。但是目前 IE6,IE7,IE8 均只支持冒泡流，所以为了能够兼容更多的浏览器，建议大家使用冒泡流。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 阻止浏览器默认行为兼容性写法</span><br><span class="line">event.preventDefault ? event.preventDefault() :(event.returnValue = <span class="literal">false</span>);</span><br><span class="line">// 阻止冒泡写法</span><br><span class="line">event.stopPropagation ? event.stopPropagation(): (event.cancelBubble = <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>DOM 事件流：“DOM2 级事件”规定事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。高版本浏览器都会在捕获阶段触发事件对象上的事件，结果就是有两个机会在目标对象上面操作。<br>事件处理程序：响应某个事件的函数就叫做事件处理程序。DOM0 级的事件处理程序很简单，只会在冒泡阶段被处理。<br>0 级 DOM：<br>分为 2 个：一是在标签内写 onclick 事件<br>　　　　 二是在 JS 写 onlicke=function（）{}函数<br>2 级 DOM：<br>只有一个：监听方法，原生有两个方法用来添加和移除事件处理程序：addEventListener()和 removeEventListener()。<br>它们都有三个参数：第一个参数是事件名（如 click）；<br>　　　　　　　　　第二个参数是事件处理程序函数；<br>　　　　　　　　 第三个参数如果是 true 则表示在捕获阶段调用，为 false 表示在冒泡阶段调用。<br>● addEventListener():可以为元素添加多个事件处理程序，触发时会按照添加顺序依次调用。（这也是为什么 DOM0 级事件兼容各种浏览器，我们却还是要使用 DOM2 的原因之一。）<br>● removeEventListener():不能移除匿名添加的函数。<br>而 IE 与 DOM 不同，它有自己的方法：attachEvent()和 detachEvent()，由于 IE8 以及更早版本只支持事件冒泡，所以通过 attachEvent()添加的事件处理程序都会被添加到冒泡阶段（所以不需要第三个参数）。注意第一个参数是 onclick，而非 DOM 标准的 click，在 IE 中使用 attachEvent()与使用 DOM0 级方法的主要区别在于事件处理程序的作用域，在使用 DOM0 级方法的情况下，事件处理程序会在其所属元素的作用域内运行，而在使用 attachEvent()方法的情况下，事件处理程序在全局作用域中运行，因此 this 等于 window（这点要特别注意！！！）。attachEvent()也能添加多个事件处理程序，但是事件的执行顺序和添加顺序相反。</p>
<p>区别：如果定义了两个 dom0 级事件，dom0 级事件会覆盖<br>dom2 不会覆盖，会依次执行。<br>dom0 和 dom2 可以共存，不互相覆盖，但是 dom0 之间依然会覆盖</p>
<h5 id="事件委托："><a href="#事件委托：" class="headerlink" title="事件委托："></a>事件委托：</h5><p>对“事件处理程序过多”问题的解决方案就是事件委托。事件委托利用了事件冒泡，将监听器安放到它们的父元素，只指定一个事件处理程序，就可以管理某一类型的所有事件。新添加的子元素也会拥有该事件。<br>如何能知道是那个子元素被点击：当子元素的事件冒泡到父元素时，你可以检查事件对象的 target 属性，捕获真正被点击的节点元素的引用<br>var event= event|| window.event; //获得 event 对象兼容性写法<br>var target = event.target || event.srcElement; //获得 target 兼容型写法<br>bind 不能为新添的元素添加已经绑定的事件。<br>JQuery1.3 通过 live 进行事件委托，但是不能在连缀的 DOM 遍历方法后面使用，默认把事件绑定到$(document)元素，如果DOM嵌套结构很深，事件冒泡通过大量祖先元素会导致性能损失；为了避免生成不必要的jQuery对象，可以使用一种叫做“早委托”的hack，即在$(document).ready()方法外部调用.live()：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>($)&#123;</span><br><span class="line">    $(<span class="string">"#info_table td"</span>).live(<span class="string">"click"</span>,<span class="function"><span class="title">function</span></span>()&#123;/*显示更多信息*/&#125;);</span><br><span class="line">&#125;)(jQuery);</span><br></pre></td></tr></table></figure>
<p>(function(\$){…})(jQuery)是一个“立即执行的匿名函数”，构成了一个闭包，可以防止命名冲突。使用这个 hack 时，脚本必须是在页面的 head 元素中链接和(或)执行的。因为这时候刚好 document 元素可用，而整个 DOM 还远未生成。不会产生多余的 jquery 对象。<br>jQuery 从 1.4 开始支持在使用.live()方法时配合使用一个上下文参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"td"</span>,$(<span class="string">"#info_table"</span>)[0]).live(<span class="string">"click"</span>,<span class="function"><span class="title">function</span></span>()&#123;&#125;);</span><br></pre></td></tr></table></figure>
<p>“受托方”就从默认的$(document)变成了$(“#info_table”)[0]，节省了冒泡的旅程，上下文对象使用的是</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#info_table"</span>)[0]。</span><br></pre></td></tr></table></figure>
<p>jQuery 1.4.2 干脆直接引入了一个新方法.delegate()，支持在连缀的 DOM 遍历方法后面调用。<br>提示：使用事件委托时，如果注册到目标元素上的其他事件处理程序使用.stopPropagation()阻止了事件传播，那么事件委托就会失效。<br>undelegate(): 移除 delegate 的绑定。</p>
<p>jquery 事件绑定，on 和冒泡.我们的页面可以理解为一棵 DOM 树，当我们在叶子结点上做什么事情的时候（如 click 一个 a 元素），如果我们不人为的设置 stopPropagation(Moder Browser), cancelBubble(IE)，那么它的所有父元素，祖宗元素都会受之影响，它们上面绑定的事件也会产生作用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'a'</span>).<span class="built_in">bind</span>(<span class="string">'click'</span>, <span class="function"><span class="title">function</span></span>() &#123; alert(<span class="string">"That tickles!"</span>) &#125;);</span><br></pre></td></tr></table></figure>
<p>当我们在 a 上面点击的时候，首先会触发它本身所绑定的 click 事件，然后会一路往上，触发它的父元素，祖先元素上所有绑定的 click 事件。</p>
<h5 id="jquery-的绑定事件有几种方式-，请举例说明其优缺点。"><a href="#jquery-的绑定事件有几种方式-，请举例说明其优缺点。" class="headerlink" title="jquery 的绑定事件有几种方式 ，请举例说明其优缺点。"></a>jquery 的绑定事件有几种方式 ，请举例说明其优缺点。</h5><p>jQuery 中提供了四种事件监听方式，分别是 bind、live、delegate、on，对应的解除监听的函数分别是 unbind、die、undelegate、off。</p>
<h6 id="bind"><a href="#bind" class="headerlink" title=".bind()"></a>.bind()</h6><p>.bind()是最直接的绑定方法 ，会绑定事件类型和处理函数到 DOM element 上, 这个方法是存在最久的，而且也很好的解决了浏览器在事件处理中的兼容问题。但是这个方法有一些 performance 方面的问题，看下面的代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$( <span class="string">"#members li a"</span> ).<span class="built_in">bind</span>( <span class="string">"click"</span>, <span class="keyword">function</span>( e ) &#123;&#125; );</span><br><span class="line">$( <span class="string">"#members li a"</span> ).click( <span class="keyword">function</span>( e ) &#123;&#125; );</span><br></pre></td></tr></table></figure>
<p>上面的两行代码所完成的任务都是一致的，就是把 event handler 加到全部的匹配的 a 元素上。 效率:<br>一方面，我们隐式地把 click handler 加到所有的 a 标签上，这个过程是昂贵的;另一方面在执行的时候也是一种浪费，因为它们都是做了同一件事却被执行了一次又一次（比如我们可以把它 hook 到它们的父元素上，通过冒泡可以对它们中的每一个进行区分，然后再执行这个 event handler）。<br>优点：<br>·这个方法提供了一种在各种浏览器之间对事件处理的兼容性解决方案；<br>·非常方便简单的绑定事件到元素上；<br>·.click(), .hover()…这些非常方便的事件绑定，都是 bind 的一种简化处理方式；<br>·对于利用 ID 选出来的元素是非常好的，不仅仅是很快的可以 hook 上去(因为一个页面只有一个 id),而且当事件发生时，handler 可以立即被执行(相对于后面的 live, delegate)实现方式；<br>缺点：<br>·它会绑定事件到所有的选出来的元素上；<br>·它不会绑定到在它执行完后动态添加的那些元素上；<br>·当元素很多时，会出现效率问题；<br>·当页面加载完的时候，你才可以进行 bind()，所以可能产生效率问题；</p>
<h6 id="live"><a href="#live" class="headerlink" title=".live()"></a>.live()</h6><p>.live()方法用到了事件委托的概念来处理事件的绑定。它和用.bind()来绑定事件是一样的。.live()方法会绑定相应的事件到你所选择的元素的根元素上，即是 document 元素上。那么所有通过冒泡上来的事件都可以用这个相同的 handler 来处理了。它的处理机制是这样的，一旦事件冒泡到 document 上，jQuery 将会查找 selector/event metadata,然后决定那个 handler 应该被调用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$( <span class="string">"#members li a"</span> ).live( <span class="string">"click"</span>, <span class="keyword">function</span>( e ) &#123;&#125; );</span><br></pre></td></tr></table></figure>
<p>不需要在每个元素上再去绑定事件，而只在 document 上绑定一次就可以了。尽管这个不是最快的方式，但是确实是最少浪费的。</p>
<p>优点：<br>·这里仅有一次的事件绑定，绑定到 document 上而不像.bind()那样给所有的元素挨个绑定；<br>·那些动态添加的 elemtns 依然可以触发那些早先绑定的事件，因为事件真正的绑定是在 document 上；<br>·你可以在 document ready 之前就可以绑定那些需要的事件；<br>缺点：<br>·从 1.7 开始已经不被推荐了，所以你也要开始逐步淘汰它了；<br>·Chaining 没有被正确的支持；<br>·当使用 event.stopPropagation()是没用的，因为都要到达 document；<br>·因为所有的 selector/event 都被绑定到 document, 所以当我们使用 matchSelector 方法来选出那个事件被调用时，会非常慢；<br>·当发生事件的元素在你的 DOM 树中很深的时候，会有 performance 问题；</p>
<h6 id="delegate"><a href="#delegate" class="headerlink" title=".delegate()"></a>.delegate()</h6><p>.delegate()有点像.live(),不同于.live()的地方在于，它不会把所有的 event 全部绑定到 document,而是由你决定把它放在哪儿。而和.live()相同的地方在于都是用 event delegation.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$( <span class="string">"#members"</span> ).delegate( <span class="string">"li a"</span>, <span class="string">"click"</span>, <span class="keyword">function</span>( e ) &#123;&#125; )</span><br></pre></td></tr></table></figure>
<p>·可以选择把这个事件放到哪个元素上；<br>·jQuery 仍然需要迭代查找所有的 selector/event data 来决定那个子元素来匹配，但是因为你可以决定放在那个根元素上，所以可以有效的减小你所要查找的元素；<br>·可以用在动态添加的元素上；<br>缺点：<br>·需要查找哪个元素上发生了哪个事件了，尽管比 document 少很多了，不过，还是得浪费时间来查找；</p>
<h6 id="on"><a href="#on" class="headerlink" title=".on()"></a>.on()</h6><p>其实.bind(), .live(), .delegate()都是通过.on()来实现的，.unbind(), .die(), .undelegate(),也是一样的都是通过.off()来实现的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Bind</span><br><span class="line">$( <span class="string">"#members li a"</span> ).on( <span class="string">"click"</span>, <span class="keyword">function</span>( e ) &#123;&#125; );</span><br><span class="line">$( <span class="string">"#members li a"</span> ).<span class="built_in">bind</span>( <span class="string">"click"</span>, <span class="keyword">function</span>( e ) &#123;&#125; );</span><br><span class="line">// Live</span><br><span class="line">$( document ).on( <span class="string">"click"</span>, <span class="string">"#members li a"</span>, <span class="keyword">function</span>( e ) &#123;&#125; );</span><br><span class="line">$( <span class="string">"#members li a"</span> ).live( <span class="string">"click"</span>, <span class="keyword">function</span>( e ) &#123;&#125; );</span><br><span class="line">// Delegate</span><br><span class="line">$( <span class="string">"#members"</span> ).on( <span class="string">"click"</span>, <span class="string">"li a"</span>, <span class="keyword">function</span>( e ) &#123;&#125; );</span><br><span class="line">$( <span class="string">"#members"</span> ).delegate( <span class="string">"li a"</span>, <span class="string">"click"</span>, <span class="keyword">function</span>( e ) &#123;&#125; );</span><br></pre></td></tr></table></figure>
<p>优点：<br>·提供了一种统一绑定事件的方法；<br>·仍然提供了.delegate()的优点，当然如果需要你也可以直接用.bind()；</p>
<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>用.bind()的代价是非常大的，它会把相同的一个事件处理程序 hook 到所有匹配的 DOM 元素上；<br>·不要再用.live()了，它已经不再被推荐了，而且还有许多问题；<br>·.delegate()会提供很好的方法来提高效率，同时我们可以添加一事件处理方法到动态添加的元素上；<br>·我们可以用.on()来代替上述的 3 种方法；</p>
<h5 id="当一个-DOM-节点被点击时候，我们希望能够执行一个函数，应该怎么做？"><a href="#当一个-DOM-节点被点击时候，我们希望能够执行一个函数，应该怎么做？" class="headerlink" title="当一个 DOM 节点被点击时候，我们希望能够执行一个函数，应该怎么做？"></a>当一个 DOM 节点被点击时候，我们希望能够执行一个函数，应该怎么做？</h5><p>（1）直接在 DOM 里绑定事件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div onclick=”<span class="built_in">test</span>()”&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>（2）在 JS 里通过 onclick 绑定：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx.onclick = <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<p>（3）通过事件添加进行绑定：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">btn.addEventListener(“click”,<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">alert(his.id);</span><br><span class="line">&#125;,<span class="literal">false</span>);//最后的参数是<span class="literal">true</span>，是在捕获阶段调用，<span class="literal">false</span>则是在冒泡阶段调用</span><br></pre></td></tr></table></figure>
<p>IE 事件处理程序：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">btn.attachEvent(“onclick”,<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">alert(“clicked”); &#125; );</span><br></pre></td></tr></table></figure>
<h5 id="JavaScript-的事件流模型都有什么？"><a href="#JavaScript-的事件流模型都有什么？" class="headerlink" title="JavaScript 的事件流模型都有什么？"></a>JavaScript 的事件流模型都有什么？</h5><p>“事件冒泡”：事件开始由最具体的元素接受，然后逐级向上传播<br>“事件捕捉”：事件由最不具体的节点先接收，然后逐级向下，一直到最具体的<br>“DOM 事件流”：三个阶段：事件捕捉，目标阶段，事件冒泡</p>
<p>跨浏览器的事件绑定和解绑程序:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">addHandler:<span class="keyword">function</span>(element,<span class="built_in">type</span>,handler)&#123;</span><br><span class="line">  <span class="keyword">if</span>(element.addEventListener)&#123;   //removeEventListener</span><br><span class="line">      element.addEventListener(<span class="built_in">type</span>,handler,<span class="literal">false</span>);</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(element.attachEvent)&#123;    //detachEvent</span><br><span class="line">      element.attachEvent(“on”+<span class="built_in">type</span>,handler);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    element[“on”+<span class="built_in">type</span>]=handler;      //element[“on”+<span class="built_in">type</span>]=null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="IE-和-DOM-事件流的区别"><a href="#IE-和-DOM-事件流的区别" class="headerlink" title="IE 和 DOM 事件流的区别:"></a>IE 和 DOM 事件流的区别:</h5><p>执行顺序不一样，参数不一样 event||window.event,event.target||event.srcElement，事件类型加不加 on，this 指向不同（四不同）</p>
<h4 id="http-请求头，请求体，cookie-在哪个里面？url-在哪里面？"><a href="#http-请求头，请求体，cookie-在哪个里面？url-在哪里面？" class="headerlink" title="http 请求头，请求体，cookie 在哪个里面？url 在哪里面？"></a>http 请求头，请求体，cookie 在哪个里面？url 在哪里面？</h4><p>HTTP 通信机制是在一次完整的 HTTP 通信过程中，Web 浏览器与 Web 服务器之间将完成下列 7 个步骤：<br>（1） 建立 TCP 连接<br>（2） Web 浏览器向 Web 服务器发送请求命令 GET/sample/hello.jsp HTTP/1.1<br>（3） Web 浏览器发送请求头信息<br>浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。<br>（4） Web 服务器应答 HTTP/1.1 200 OK<br>应答的第一部分是协议的版本号和应答状态码<br>（5） Web 服务器发送应答头信息<br>（6） Web 服务器向浏览器发送数据<br>（7） Web 服务器关闭 TCP 连接<br>HTTP 请求信息由 3 部分组成：请求方法 URI 协议/版本|请求头(Request Header)|请求正文<br>请求头包含许多有关的客户端环境和请求正文的有用信息。例如，请求头可以声明浏览器所用的语言，请求正文的长度等。<br>Accept：浏览器可接受的 MIME 类型。<br>Accept-Charset：浏览器可接受的字符集。<br>Accept-Encoding：浏览器能够进行解码的数据编码方式，比如 gzip。<br>Accept-Language：浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到。<br>Connection：表示是否需要持久连接。如果 Servlet 看到这里的值为“Keep-Alive”，或者看到请求使用的是 HTTP<br>Content-Length：表示请求消息正文的长度。<br>Cookie：设置 cookie,这是最重要的请求头信息之一<br>Host：初始 URL 中的主机和端口。<br>Referer：包含一个 URL，用户从该 URL 代表的页面出发访问当前请求的页面。<br>User-Agent：浏览器类型，如果 Servlet 返回的内容与浏览器类型有关则该值非常有用。<br>不同浏览器实际发送的头部有所不同，但是上面的基本上所有浏览器都会发送的<br>可以在调用 open()和 send()方法之间调用 setRequestHeader()方法设置自定义的请求头信息。当是 POST 请求的时候，如果要表单序列化函数 serialize(form)，需设置请求头的 Content-type 为 application/x-www-form-urlencoded 但是在 XMLHttpRequest2 级可以使用对象 FormData(form)，这里则不用 XHR 对象设置请求头。<br>请求正文：<br>请求头和请求正文之间是一个空行，这个行非常重要，它表示请求头已经结束，接下来的是请求正文。请求正文中可以包含客户提交的查询字符串信息。<br>HTTP 响应也由 3 个部分构成，分别是：协议状态版本代码描述|响应头(Response Header)|响应正文 响应头(Response Header)响应头也和请求头一样包含许多有用的信息，例如服务器类型、日期时间、内容类型和长度等：响应头和正文之间也必须用空行分隔。　　 cookie 在请求头里面,url 在请求头里。</p>
<h4 id="null-undefined"><a href="#null-undefined" class="headerlink" title="{}=={}? []==[]? null==undefined?"></a>{}=={}? []==[]? null==undefined?</h4><p>==， 两边值类型不同的时候，要先进行类型转换</p>
<p>===: 1)、如果类型不同，就[不相等] 2)、如果两个都是数值，并且是同一个值，那么[相等]。 3)、如果两个都是字符串，每个位置的字符都一样，那么[相等]；否则[不相等]。 4)、如果两个值都是 true，或者都是 false，那么[相等]。 5)、如果两个值都引用同一个对象或函数，那么[相等]；否则[不相等]。 6)、如果两个值都是 null，或者都是 undefined，那么[相等]。</p>
<h5 id="，根据以下规则："><a href="#，根据以下规则：" class="headerlink" title="==，根据以下规则："></a>==，根据以下规则：</h5><p>一、首先看双等号前后有没有 NaN，如果存在 NaN，一律返回 false。<br>二、再看双等号前后有没有布尔，有布尔就将布尔转换为数字。（false 是 0，true 是 1）<br>三、接着看双等号前后有没有字符串, 有三种情况：<br>1、对方是对象，对象使用 toString()或者 valueOf()进行转换；<br>2、对方是数字，字符串转数字；（前面已经举例）<br>3、对方是字符串，直接比较；<br>4、其他返回 false<br>四、如果是数字，对方是对象，对象取 valueOf()或者 toString()进行比较, 其他一律返回 false<br>五、null, undefined 不会进行类型转换, 但它们俩相等<br>题目结果是 false false true</p>
<h4 id="null-和-undefined-的区别？"><a href="#null-和-undefined-的区别？" class="headerlink" title="null 和 undefined 的区别？"></a>null 和 undefined 的区别？</h4><p>null 是一个表示”无”的对象，转为数值时为 0；undefined 是一个表示”无”的原始值，转为数值时为 NaN。<br>当声明的变量还未被初始化时，变量的默认值为 undefined。 null 用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。<br>undefined 表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是：<br>（1） 变量被声明了，但没有赋值时，就等于 undefined。<br>（2） 调用函数时，应该提供的参数没有提供，该参数等于 undefined。<br>（3） 对象没有赋值的属性，该属性的值为 undefined。<br>（4） 函数没有返回值时，默认返回 undefined。<br>null 表示”没有对象”，即该处不应该有值。典型用法是：<br>（1） 作为函数的参数，表示该函数的参数不是对象。<br>（2） 作为对象原型链的终点。</p>
<h4 id="什么叫优雅降级和渐进增强？"><a href="#什么叫优雅降级和渐进增强？" class="headerlink" title="什么叫优雅降级和渐进增强？"></a>什么叫优雅降级和渐进增强？</h4><p>优雅降级：Web 站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于 IE 独特的盒模型布局问题，针对不同版本的 IE 的 hack 实践过优雅降级了,为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效。<br>渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能,向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。</p>
<h4 id="异步加载和延迟加载"><a href="#异步加载和延迟加载" class="headerlink" title="异步加载和延迟加载"></a>异步加载和延迟加载</h4><p>1).异步加载的方案： 动态插入 script 标签<br>2)).通过 ajax 去获取 js 代码，然后通过 eval 执行<br>3).script 标签上添加 defer 或者 async 属性<br>4).创建并插入 iframe，让它异步执行 js<br>5).延迟加载：有些 js 代码并不是页面初始化的时候就立刻需要的，而稍后的某些情况才需要的。</p>
<h4 id="说说你对-Promise-的理解"><a href="#说说你对-Promise-的理解" class="headerlink" title="说说你对 Promise 的理解?"></a>说说你对 Promise 的理解?</h4><p>ES6 原生提供了 Promise 对象。<br>所谓 Promise，就是一个对象，用来传递异步操作的消息。它代表了某个未来才会知道结果的事件(通常是一个异步操作)，并且这个事件提供统一的 API，可供进一步处理。Promise 对象有以下两个特点。<br>(1)、对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：Pending(进行中)、Resolved(已完成，又称 Fulfilled)和 Rejected(已失败)。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 Promise 这个名字的由来，它的英语意思就是「承诺」，表示其他手段无法改变。<br>(2)、一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise 对象的状态改变，只有两种可能：从 Pending 变为 Resolved 和从 Pending 变为 Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。这与事件(Event)完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。<br>有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise 对象提供统一的接口，使得控制异步操作更加容易。 Promise 也有一些缺点。首先，无法取消 Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。第三，当处于 Pending 状态时，无法得知目前进展到哪一个阶段(刚刚开始还是即将完成)。</p>
<h4 id="写一个通用的事件侦听器函数"><a href="#写一个通用的事件侦听器函数" class="headerlink" title="写一个通用的事件侦听器函数?"></a>写一个通用的事件侦听器函数?</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">markyun.Event = &#123;</span><br><span class="line">// 页面加载完成后</span><br><span class="line">  readyEvent : <span class="keyword">function</span>(fn) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fn==null) &#123;</span><br><span class="line">          fn=document;</span><br><span class="line">    &#125;</span><br><span class="line">    var oldonload = window.onload;</span><br><span class="line">    <span class="keyword">if</span> (typeof window.onload != <span class="string">'function'</span>) &#123;</span><br><span class="line">          window.onload = fn;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          window.onload = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">            oldonload();</span><br><span class="line">            fn();</span><br><span class="line">          &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 视能力分别使用dom0||dom2||IE方式 来绑定事件</span><br><span class="line">  // 参数： 操作的元素,事件名称 ,事件处理程序</span><br><span class="line">  addEvent : <span class="keyword">function</span>(element, <span class="built_in">type</span>, handler) &#123;</span><br><span class="line">      <span class="keyword">if</span> (element.addEventListener) &#123;</span><br><span class="line">        //事件类型、需要执行的函数、是否捕捉</span><br><span class="line">        element.addEventListener(<span class="built_in">type</span>, handler, <span class="literal">false</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent) &#123;</span><br><span class="line">        element.attachEvent(<span class="string">'on'</span> + <span class="built_in">type</span>, <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">            handler.call(element);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        element[<span class="string">'on'</span> + <span class="built_in">type</span>] = handler;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 移除事件</span><br><span class="line">    removeEvent : <span class="keyword">function</span>(element, <span class="built_in">type</span>, handler) &#123;</span><br><span class="line">        <span class="keyword">if</span> (element.removeEnentListener) &#123;</span><br><span class="line">            element.removeEnentListener(<span class="built_in">type</span>, handler, <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.datachEvent) &#123;</span><br><span class="line">            element.detachEvent(<span class="string">'on'</span> + <span class="built_in">type</span>, handler);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            element[<span class="string">'on'</span> + <span class="built_in">type</span>] = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获)</span><br><span class="line">    stopPropagation : <span class="keyword">function</span>(ev) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ev.stopPropagation) &#123;</span><br><span class="line">            ev.stopPropagation();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ev.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 取消事件的默认行为</span><br><span class="line">    preventDefault : <span class="keyword">function</span>(event) &#123;</span><br><span class="line">        <span class="keyword">if</span> (event.preventDefault) &#123;</span><br><span class="line">            event.preventDefault();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            event.returnValue = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 获取事件目标</span><br><span class="line">    getTarget : <span class="keyword">function</span>(event) &#123;</span><br><span class="line">        <span class="built_in">return</span> event.target || event.srcElement;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 获取event对象的引用，取到事件的所有信息，确保随时能使用event；</span><br><span class="line">    getEvent : <span class="keyword">function</span>(e) &#123;</span><br><span class="line">        var ev = e || window.event;</span><br><span class="line">        <span class="keyword">if</span> (!ev) &#123;</span><br><span class="line">            var c = this.getEvent.caller;</span><br><span class="line">            <span class="keyword">while</span> (c) &#123;</span><br><span class="line">                ev = c.arguments[0];</span><br><span class="line">                <span class="keyword">if</span> (ev &amp;&amp; Event == ev.constructor) &#123;</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                c = c.caller;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> ev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="js-操作获取和设置-cookie"><a href="#js-操作获取和设置-cookie" class="headerlink" title="js 操作获取和设置 cookie"></a>js 操作获取和设置 cookie</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//创建cookie</span><br><span class="line"><span class="keyword">function</span> setCookie(name, value, expires, path, domain, secure) &#123;</span><br><span class="line">    var cookieText = encodeURIComponent(name) + <span class="string">'='</span> + encodeURIComponent(value);</span><br><span class="line">    <span class="keyword">if</span> (expires instanceof Date) &#123;</span><br><span class="line">        cookieText += <span class="string">'; expires='</span> + expires;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (path) &#123;</span><br><span class="line">        cookieText += <span class="string">'; path='</span> + path;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (domain) &#123;</span><br><span class="line">        cookieText += <span class="string">'; domain='</span> + domain;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (secure) &#123;</span><br><span class="line">        cookieText += <span class="string">'; secure'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    document.cookie = cookieText;</span><br><span class="line">&#125;</span><br><span class="line">//获取cookie</span><br><span class="line"><span class="keyword">function</span> getCookie(name) &#123;</span><br><span class="line">    var cookieName = encodeURIComponent(name) + <span class="string">'='</span>;</span><br><span class="line">    var cookieStart = document.cookie.indexOf(cookieName);</span><br><span class="line">    var cookieValue = null;</span><br><span class="line">    <span class="keyword">if</span> (cookieStart &gt; -1) &#123;</span><br><span class="line">        var cookieEnd = document.cookie.indexOf(<span class="string">';'</span>, cookieStart);</span><br><span class="line">        <span class="keyword">if</span> (cookieEnd == -1) &#123;</span><br><span class="line">            cookieEnd = document.cookie.length;</span><br><span class="line">        &#125;</span><br><span class="line">        cookieValue = decodeURIComponent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> cookieValue;</span><br><span class="line">&#125;</span><br><span class="line">//删除cookie</span><br><span class="line"><span class="keyword">function</span> unsetCookie(name) &#123;</span><br><span class="line">    document.cookie = name + <span class="string">"= ; expires="</span> + new Date(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="jQuery-中-attr-、prop-、data-用法及区别？"><a href="#jQuery-中-attr-、prop-、data-用法及区别？" class="headerlink" title="jQuery 中 attr()、prop()、data()用法及区别？"></a>jQuery 中 attr()、prop()、data()用法及区别？</h4><p>从性能上对比，.prop() &gt; .data() &gt; .attr()。<br>attr 返回属性的值（标签自带属性和自定意属性都可以返回）<br>prop 返回 true 或 false（只能返回标签自带属性，不能返回自定义属性）<br>data 向被选元素附加数据，或者从被选元素获取数据（即 H5 的自定义属性）<br>attribute 表示 HTML 文档节点属性，property 表示 JS 对象的属性。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"message"</span>class=<span class="string">"test"</span> data_id=<span class="string">"123"</span>&gt;&lt;/div&gt;</span><br><span class="line">// 这里的name、age、url均是obj的property</span><br><span class="line">var obj =&#123; name: <span class="string">"CodePlayer"</span>, age: 18, url:<span class="string">"http://www.365mini.com/"</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>prop()的设计目标用于设置或获取指定 DOM 元素(指的是 JS 对象，Element 类型)上的属性(property);<br>attr()的设计目标是用于设置或获取指定 DOM 元素所对应的文档节点上的属性(attribute)。<br>在 html5 中 DOM 标签可以添加一些 data-xxx 的属性，可以把 data()看作是存取 data-xxx 这样的 DOM 附加信息的方法。data()存取的内容可以是字符串、数组和对象。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div data-role=<span class="string">"page"</span> data-last-value=<span class="string">"43"</span>data-hidden=<span class="string">"true"</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h4 id="正则表达式验证邮箱，电话号码"><a href="#正则表达式验证邮箱，电话号码" class="headerlink" title="正则表达式验证邮箱，电话号码"></a>正则表达式验证邮箱，电话号码</h4><p>验证邮箱：re =/^(\w-.)+@(\w-?)+(.\w{2,})+$/<br>验证电话号码：区号+号码，区号以0开头，3位或4位；号码由7位或8位数字组成；区号与号码之间可以无连接符，也可以“-”连接： re = /^0\d{2,3}-?\d{7,8}$/;</p>
<h4 id="javascript-的本地对象，内置对象和宿主对象"><a href="#javascript-的本地对象，内置对象和宿主对象" class="headerlink" title="javascript 的本地对象，内置对象和宿主对象"></a>javascript 的本地对象，内置对象和宿主对象</h4><p>本地对象为 array object regexp 等可以 new 实例化,ECMA 定义好的对象，是引用类型。<br>内置对象是本地对象的一种，只有 global 和 Math<br>宿主为浏览器自带的 document,window 等，所有的 BOM 和 DOM 对象。</p>
<h4 id="5-个技巧避免不必要的浏览器兼容性问题"><a href="#5-个技巧避免不必要的浏览器兼容性问题" class="headerlink" title="5 个技巧避免不必要的浏览器兼容性问题"></a>5 个技巧避免不必要的浏览器兼容性问题</h4><p>1). CSS3 风格的前缀<br>如果你正在使用最新的 CSS 代码，比如 box-sizing，或者 background-clip 等，确保你使用了合适的供应商前缀。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-moz- /* Firefox 和其他使用 Mozilla 浏览器引擎的浏览器 */</span><br><span class="line">-webkit- /* Safari，Chrome 和其他使用了 Webkit 引擎的浏览器 */</span><br><span class="line">-o- /* Opera */</span><br><span class="line">-ms- /* IE 浏览器（但不总是 IE） */</span><br></pre></td></tr></table></figure>
<p>2). 使用样式重置<br>你可以使用 normalize.css 或者其他从网络上能找到的样式重置都可以。这里我给出一个，来自于 Genesis 框架。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">html,body,div,span,applet,object,iframe,h1,h2,</span><br><span class="line">h3,h4,h5,h6,p,blockquote,a,abbr,acronym,address,</span><br><span class="line">big,cite,del,dfn,em,img,ins,kbd,q,s,samp,small,</span><br><span class="line">strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,</span><br><span class="line">dd,ol,ul,li,fieldset,form,label,legend,table,caption,</span><br><span class="line">tbody,tfoot,thead,tr,th,td,article,aside,canvas,details,</span><br><span class="line">embed,figure,figcaption,footer,header,hgroup,input,menu,</span><br><span class="line">nav,output,ruby,section,summary,time,mark,audio,video &#123;</span><br><span class="line">  border: 0;</span><br><span class="line">  margin: 0;</span><br><span class="line">  padding: 0;</span><br><span class="line">  vertical-align: baseline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3). 避免 padding 和 width 一起使用<br>当你给一个包含 width 的元素加 padding，那它实际显示的要比本应显示的大。因为 width 和 padding 会加到一起。比如一个元素 width 是 100px，又给它加了一个 10px 的 padding。那某些浏览器会将该元素显示成 120px。<br>为了 fix 这个问题，像下面这样做：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">-webkit-box-sizing: border-box; /* Safari/Chrome 等 WebKit 内核浏览器 */</span><br><span class="line">-moz-box-sizing: border-box; /* Firefox 等 Gecko 内核浏览器 */</span><br><span class="line">box-sizing: border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4). 清理浮动<br>确保你把浮动都清理掉了，如果不清理掉，可能会出现很奇怪的情况。想要了解更多关于浏览器处理浮动的原理，可以看 Chris Coyier 的这篇文章。可以用下面 CSS 代码清理浮动：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.parent-selector:after &#123;</span><br><span class="line">    content: <span class="string">""</span>;</span><br><span class="line">    display: table;</span><br><span class="line">    clear: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你要把你的大部分代码都包起来，有个更简单的方法就是把它添加到你的 wrap 类里面：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.wrap:after &#123;</span><br><span class="line">    content: <span class="string">""</span>;</span><br><span class="line">    display: table;</span><br><span class="line">    clear: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样你的浮动就被清理掉了。<br>5). 测试一下<br>搭建你自己的跨浏览器测试环境，或者用 Endtest 也可以。</p>
<h4 id="Object-is-与原来的比较操作符“-”、“-”的区别？"><a href="#Object-is-与原来的比较操作符“-”、“-”的区别？" class="headerlink" title="Object.is() 与原来的比较操作符“ ===”、“ ==”的区别？"></a>Object.is() 与原来的比较操作符“ ===”、“ ==”的区别？</h4><p>两等号判等，会在比较时进行类型转换；<br>三等号判等(判断严格)，比较时不进行隐式类型转换,（类型不同则会返回 false）；<br>Object.is 在三等号判等的基础上特别处理了 NaN 、-0 和 +0 ，保证 -0 和 +0 不再相同，<br>但 Object.is(NaN, NaN) 会返回 true.<br>Object.is 应被认为有其特殊的用途，而不能用它认为它比其它的相等对比更宽松或严格。</p>

        </div>

        <blockquote class="post-copyright">
    
    <footer>
        <a href="http://blog.bochunhao.cn">
            <img src="/img/loggo.png" alt="BCH">
            BCH
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端面试/">前端面试</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://blog.bochunhao.cn/2019/04/13/Interview/&title=《Interview》 — 个人博客&pic=http://blog.bochunhao.cn/img/loggo.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://blog.bochunhao.cn/2019/04/13/Interview/&title=《Interview》 — 个人博客&source=bch_bk" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://blog.bochunhao.cn/2019/04/13/Interview/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Interview》 — 个人博客&url=http://blog.bochunhao.cn/2019/04/13/Interview/&via=http://blog.bochunhao.cn" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://blog.bochunhao.cn/2019/04/13/Interview/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between flex-row-reverse">
  

  
    <div class="waves-block waves-effect next">
      <a href="/2019/04/12/redux/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">redux</h4>
      </a>
    </div>
  
</nav>



    




















</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        感谢支持
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/vx.png" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check" data-wechat="/img/vx.png" data-alipay="/img/zfb.png">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <p>个人博客 &copy; 2018</p>
    <p style="color:#fff;font-size: 16px;font-weight:bolder">
        不积跬步，无以至千里
    </p>
    <p style="color:#fff;font-size: 16px;font-weight:bolder">
        不积小流，无以成江海
    </p>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://blog.bochunhao.cn/2019/04/13/Interview/&title=《Interview》 — 个人博客&pic=http://blog.bochunhao.cn/img/loggo.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://blog.bochunhao.cn/2019/04/13/Interview/&title=《Interview》 — 个人博客&source=bch_bk" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://blog.bochunhao.cn/2019/04/13/Interview/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Interview》 — 个人博客&url=http://blog.bochunhao.cn/2019/04/13/Interview/&via=http://blog.bochunhao.cn" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://blog.bochunhao.cn/2019/04/13/Interview/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACMUlEQVR42u3aQZKDMAwEwPz/09kHZBNmZDhg2qfUBrCbVGktWa9XPN4f4/Pb5Mpv13/e+7piYGBg3Jbx/jm+TdBO+e0JOezgBWFgYDyAkYfF3/cmdyXgdl4MDAyMNvgmoTkP9BgYGBizgJsntMnSk9eBgYGBkQe+30tfSWJ/w07LxTEwMG7IWEksr/58yfkGBgbGrRjvcsy2iesJ7cGqMDAwtmbMNnbtxvGsJxy8OAwMjE0ZedLYhtG8OeyElg4MDIytGXnJrG3hWkmAV45FMTAw9mPkATEJfLN2ipUZX0lUxsDA2ILRtkHM7pq1U0THpRgYGFsz8qL8rNyfJLTryTAGBsYTGHkS25LaLWC76GEujoGBcUNGXZm7oLjfluQOTmIxMDAewJht45LS2wwWlQgxMDAewJiloLMDgLagVtQOMTAwtma0W7FZm8VZRwj1DhcDA+O2jPaQMm+qaNsvZltPDAyM5zDyRHS9vaxtKYsKcxgYGFszDr6IE9Tkcxtw21COgYHxBEb+uFlozts18rX9E3AxMDC2ZswC4qxIl1yfFO+Kk1gMDIwtGO2GL087h1u9NhnGwMDYlPEuRzJN3qLR3lv8DhgYGBsx8pFs8ta3hivNHxgYGHszZqX/vM2rfXPDVgwMDIwHMIq2hvjwYBaUZ0gMDAyM/HjgrOaw+jkYGBgYwfSz1rG8IeOS/xsYGBi3YuRJ6XUVvjzpxcDAeBojTx3b48/ZIvK/Y2BgPIDxB1F6Qc86ji8EAAAAAElFTkSuQmCC" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>






<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '快回来看我呀！';
            clearTimeout(titleTime);
        } else {
            document.title = '个人博客';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
