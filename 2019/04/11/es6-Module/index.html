<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>es6_Module | 个人博客 | BCH</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="es6">
    <meta name="description" content="ES6 module历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的 require、Python 的 import，甚至就连 CSS 都有@import，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。 在 ES6 之前，社区制定了">
<meta name="keywords" content="es6">
<meta property="og:type" content="article">
<meta property="og:title" content="es6_Module">
<meta property="og:url" content="http://blog.bochunhao.cn/2019/04/11/es6-Module/index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="ES6 module历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的 require、Python 的 import，甚至就连 CSS 都有@import，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。 在 ES6 之前，社区制定了">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-04-11T14:00:24.627Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="es6_Module">
<meta name="twitter:description" content="ES6 module历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的 require、Python 的 import，甚至就连 CSS 都有@import，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。 在 ES6 之前，社区制定了">
    
        <link rel="alternate" type="application/atom+xml" title="个人博客" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide">
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/loggo.png">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">BCH</h5>
          <a href="mailto:17600280987@163.com" title="17600280987@163.com" class="mail">17600280987@163.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/">
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories">
                <i class="icon icon-lg icon-archives"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags">
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/bch9479/blog" target="_blank">
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://weibo.com/5900743344/profile?rightmod=1&wvr=6&mod=personinfo" target="_blank">
                <i class="icon icon-lg icon-weibo"></i>
                微博
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">es6_Module</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">es6_Module</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-04-11T13:43:32.000Z" itemprop="datePublished" class="page-time">
  2019-04-11
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/es6/">es6</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ES6-module"><span class="post-toc-number">1.</span> <span class="post-toc-text">ES6 module</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#严格模式"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">严格模式</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#export-命令"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">export 命令</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#import-命令"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">import 命令</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#模块的整体加载"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">模块的整体加载</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#export-default-命令"><span class="post-toc-number">1.5.</span> <span class="post-toc-text">export default 命令</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#export-与-import-的复合写法"><span class="post-toc-number">1.6.</span> <span class="post-toc-text">export 与 import 的复合写法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#模块的继承"><span class="post-toc-number">1.7.</span> <span class="post-toc-text">模块的继承</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#ES6-模块加载的实质"><span class="post-toc-number">1.8.</span> <span class="post-toc-text">ES6 模块加载的实质</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#浏览器的模块加载"><span class="post-toc-number">1.9.</span> <span class="post-toc-text">浏览器的模块加载</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#循环加载"><span class="post-toc-number">1.10.</span> <span class="post-toc-text">循环加载</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#CommonJS-模块的加载原理"><span class="post-toc-number">1.11.</span> <span class="post-toc-text">CommonJS 模块的加载原理</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#CommonJS-模块的循环加载"><span class="post-toc-number">1.12.</span> <span class="post-toc-text">CommonJS 模块的循环加载</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#ES6-模块的循环加载"><span class="post-toc-number">1.13.</span> <span class="post-toc-text">ES6 模块的循环加载</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#跨模块常量"><span class="post-toc-number">1.14.</span> <span class="post-toc-text">跨模块常量</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#import"><span class="post-toc-number">1.15.</span> <span class="post-toc-text">import()</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#ES6-模块的转码"><span class="post-toc-number">1.16.</span> <span class="post-toc-text">ES6 模块的转码</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#ES6-module-transpiler"><span class="post-toc-number">1.16.1.</span> <span class="post-toc-text">ES6 module transpiler</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#SystemJS"><span class="post-toc-number">1.16.2.</span> <span class="post-toc-text">SystemJS</span></a></li></ol></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-es6-Module" class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">es6_Module</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-04-11 21:43:32" datetime="2019-04-11T13:43:32.000Z" itemprop="datePublished">2019-04-11</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/es6/">es6</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style="display:none">
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h3 id="ES6-module"><a href="#ES6-module" class="headerlink" title="ES6 module"></a>ES6 module</h3><p>历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的 require、Python 的 import，甚至就连 CSS 都有@import，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。</p>
<p>在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代现有的 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</p>
<p>ES6 模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// CommonJS模块</span><br><span class="line"><span class="built_in">let</span> &#123; <span class="built_in">stat</span>, exists, readFile &#125; = require(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line"><span class="built_in">let</span> _fs = require(<span class="string">'fs'</span>);</span><br><span class="line"><span class="built_in">let</span> <span class="built_in">stat</span> = _fs.stat, exists = _fs.exists, readfile = _fs.readfile;</span><br></pre></td></tr></table></figure>
<p>上面代码的实质是整体加载 fs 模块（即加载 fs 的所有方法），生成一个对象（_fs），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。</p>
<p>ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，再通过 import 命令输入。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// ES6模块</span><br><span class="line">import &#123; <span class="built_in">stat</span>, exists, readFile &#125; from <span class="string">'fs'</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码的实质是从 fs 模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。</p>
<p>由于 ES6 模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。</p>
<p>除了静态加载带来的各种好处，ES6 模块还有以下好处。</p>
<p>1.不再需要 UMD 模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。目前，通过各种工具库，其实已经做到了这一点。 2.将来浏览器的新 API 就能用模块格式提供，不再必要做成全局变量或者 navigator 对象的属性。 3.不再需要对象作为命名空间（比如 Math 对象），未来这些功能可以通过模块提供。</p>
<h4 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h4><p>ES6 的模块自动采用严格模式，不管你有没有在模块头部加上”use strict”;。</p>
<p>严格模式主要有以下限制。</p>
<pre>
变量必须声明后再使用
函数的参数不能有同名属性，否则报错
不能使用with语句
不能对只读属性赋值，否则报错
不能使用前缀0表示八进制数，否则报错
不能删除不可删除的属性，否则报错
不能删除变量delete prop，会报错，只能删除属性delete global[prop]
eval不会在它的外层作用域引入变量
eval和arguments不能被重新赋值
arguments不会自动反映函数参数的变化
不能使用arguments.callee
不能使用arguments.caller
禁止this指向全局对象
不能使用fn.caller和fn.arguments获取函数调用的堆栈
增加了保留字（比如protected、static和interface）
</pre>

<p>上面这些限制，模块都必须遵守。由于严格模式是 ES5 引入的，不属于 ES6，所以请参阅相关 ES5 书籍。</p>
<h4 id="export-命令"><a href="#export-命令" class="headerlink" title="export 命令"></a>export 命令</h4><p>模块功能主要由两个命令构成：export 和 import。export 命令用于规定模块的对外接口，import 命令用于输入其他模块提供的功能。</p>
<p>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用 export 关键字输出该变量。下面是一个 JS 文件，里面使用 export 命令输出变量。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// profile.js</span><br><span class="line"><span class="built_in">export</span> var firstName = <span class="string">'Michael'</span>;</span><br><span class="line"><span class="built_in">export</span> var lastName = <span class="string">'Jackson'</span>;</span><br><span class="line"><span class="built_in">export</span> var year = 1958;</span><br></pre></td></tr></table></figure>
<p>上面代码是 profile.js 文件，保存了用户信息。ES6 将其视为一个模块，里面用 export 命令对外部输出了三个变量。</p>
<p>export 的写法，除了像上面这样，还有另外一种。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// profile.js</span><br><span class="line">var firstName = <span class="string">'Michael'</span>;</span><br><span class="line">var lastName = <span class="string">'Jackson'</span>;</span><br><span class="line">var year = 1958;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> &#123;firstName, lastName, year&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码在 export 命令后面，使用大括号指定所要输出的一组变量。它与前一种写法（直接放置在 var 语句前）是等价的，但是应该优先考虑使用这种写法。因为这样就可以在脚本尾部，一眼看清楚输出了哪些变量。</p>
<p>export 命令除了输出变量，还可以输出函数或类（class）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> multiply(x, y) &#123;</span><br><span class="line">  <span class="built_in">return</span> x * y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码对外输出一个函数 multiply。</p>
<p>通常情况下，export 输出的变量就是本来的名字，但是可以使用 as 关键字重命名。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">v1</span></span>() &#123; ... &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">v2</span></span>() &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> &#123;</span><br><span class="line">  v1 as streamV1,</span><br><span class="line">  v2 as streamV2,</span><br><span class="line">  v2 as streamLatestVersion</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码使用 as 关键字，重命名了函数 v1 和 v2 的对外接口。重命名后，v2 可以用不同的名字输出两次。</p>
<p>需要特别注意的是，export 命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line"><span class="built_in">export</span> 1;</span><br><span class="line"></span><br><span class="line">// 报错</span><br><span class="line">var m = 1;</span><br><span class="line"><span class="built_in">export</span> m;</span><br></pre></td></tr></table></figure>
<p>上面两种写法都会报错，因为没有提供对外的接口。第一种写法直接输出 1，第二种写法通过变量 m，还是直接输出 1。1 只是一个值，不是接口。正确的写法是下面这样。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 写法一</span><br><span class="line"><span class="built_in">export</span> var m = 1;</span><br><span class="line"></span><br><span class="line">// 写法二</span><br><span class="line">var m = 1;</span><br><span class="line"><span class="built_in">export</span> &#123;m&#125;;</span><br><span class="line"></span><br><span class="line">// 写法三</span><br><span class="line">var n = 1;</span><br><span class="line"><span class="built_in">export</span> &#123;n as m&#125;;</span><br></pre></td></tr></table></figure>
<p>上面三种写法都是正确的，规定了对外的接口 m。其他脚本可以通过这个接口，取到值 1。它们的实质是，在接口名与模块内部变量之间，建立了一一对应的关系。</p>
<p>同样的，function 和 class 的输出，也必须遵守这样的写法。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;&#125;</span><br><span class="line"><span class="built_in">export</span> f;</span><br><span class="line"></span><br><span class="line">// 正确</span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// 正确</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;&#125;</span><br><span class="line"><span class="built_in">export</span> &#123;f&#125;;</span><br></pre></td></tr></table></figure>
<p>另外，export 语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> var foo = <span class="string">'bar'</span>;</span><br><span class="line">setTimeout(() =&gt; foo = <span class="string">'baz'</span>, 500);</span><br></pre></td></tr></table></figure>
<p>上面代码输出变量 foo，值为 bar，500 毫秒之后变成 baz。</p>
<p>这一点与 CommonJS 规范完全不同。CommonJS 模块输出的是值的缓存，不存在动态更新，详见下文《ES6 模块加载的实质》一节。</p>
<p>最后，export 命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，下一节的 import 命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了 ES6 模块的设计初衷。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">  <span class="built_in">export</span> default <span class="string">'bar'</span> // SyntaxError</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>
<p>上面代码中，export 语句放在函数之中，结果报错。</p>
<h4 id="import-命令"><a href="#import-命令" class="headerlink" title="import 命令"></a>import 命令</h4><p>使用 export 命令定义了模块的对外接口以后，其他 JS 文件就可以通过 import 命令加载这个模块。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// main.js</span><br><span class="line">import &#123;firstName, lastName, year&#125; from <span class="string">'./profile'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> setName(element) &#123;</span><br><span class="line">  element.textContent = firstName + <span class="string">' '</span> + lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码的 import 命令，用于加载 profile.js 文件，并从中输入变量。import 命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（profile.js）对外接口的名称相同。</p>
<p>如果想为输入的变量重新取一个名字，import 命令要使用 as 关键字，将输入的变量重命名。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; lastName as surname &#125; from <span class="string">'./profile'</span>;</span><br></pre></td></tr></table></figure>
<p>import 后面的 from 指定模块文件的位置，可以是相对路径，也可以是绝对路径，.js 路径可以省略。如果只是模块名，不带有路径，那么必须有配置文件，告诉 JavaScript 引擎该模块的位置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123;myMethod&#125; from <span class="string">'util'</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码中，util 是模块文件名，由于不带有路径，必须通过配置，告诉引擎怎么取到这个模块。</p>
<p>注意，import 命令具有提升效果，会提升到整个模块的头部，首先执行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo();</span><br><span class="line"></span><br><span class="line">import &#123; foo &#125; from <span class="string">'my_module'</span>;</span><br></pre></td></tr></table></figure>
<p>上面的代码不会报错，因为 import 的执行早于 foo 的调用。这种行为的本质是，import 命令是编译阶段执行的，在代码运行之前。</p>
<p>由于 import 是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line">import &#123; <span class="string">'f'</span> + <span class="string">'oo'</span> &#125; from <span class="string">'my_module'</span>;</span><br><span class="line"></span><br><span class="line">// 报错</span><br><span class="line"><span class="built_in">let</span> module = <span class="string">'my_module'</span>;</span><br><span class="line">import &#123; foo &#125; from module;</span><br><span class="line"></span><br><span class="line">// 报错</span><br><span class="line"><span class="keyword">if</span> (x === 1) &#123;</span><br><span class="line">  import &#123; foo &#125; from <span class="string">'module1'</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  import &#123; foo &#125; from <span class="string">'module2'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面三种写法都会报错，因为它们用到了表达式、变量和 if 结构。在静态分析阶段，这些语法都是没法得到值的。</p>
<p>最后，import 语句会执行所加载的模块，因此可以有下面的写法。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import <span class="string">'lodash'</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码仅仅执行 lodash 模块，但是不输入任何值。</p>
<p>如果多次重复执行同一句 import 语句，那么只会执行一次，而不会执行多次。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import <span class="string">'lodash'</span>;</span><br><span class="line">import <span class="string">'lodash'</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码加载了两次 lodash，但是只会执行一次。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &#123; foo &#125; from <span class="string">'my_module'</span>;</span><br><span class="line">import &#123; bar &#125; from <span class="string">'my_module'</span>;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">import &#123; foo, bar &#125; from <span class="string">'my_module'</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码中，虽然 foo 和 bar 在两个语句中加载，但是它们对应的是同一个 my_module 实例。也就是说，import 语句是 Singleton 模式。</p>
<h4 id="模块的整体加载"><a href="#模块的整体加载" class="headerlink" title="模块的整体加载"></a>模块的整体加载</h4><p>除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。</p>
<p>下面是一个 circle.js 文件，它输出两个方法 area 和 circumference。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// circle.js</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> area(radius) &#123;</span><br><span class="line">  <span class="built_in">return</span> Math.PI * radius * radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> circumference(radius) &#123;</span><br><span class="line">  <span class="built_in">return</span> 2 * Math.PI * radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，加载这个模块。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// main.js</span><br><span class="line"></span><br><span class="line">import &#123; area, circumference &#125; from <span class="string">'./circle'</span>;</span><br><span class="line"></span><br><span class="line">console.log(<span class="string">'圆面积：'</span> + area(4));</span><br><span class="line">console.log(<span class="string">'圆周长：'</span> + circumference(14));</span><br></pre></td></tr></table></figure>
<p>上面写法是逐一指定要加载的方法，整体加载的写法如下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import * as circle from <span class="string">'./circle'</span>;</span><br><span class="line"></span><br><span class="line">console.log(<span class="string">'圆面积：'</span> + circle.area(4));</span><br><span class="line">console.log(<span class="string">'圆周长：'</span> + circle.circumference(14));</span><br></pre></td></tr></table></figure>
<h4 id="export-default-命令"><a href="#export-default-命令" class="headerlink" title="export default 命令"></a>export default 命令</h4><p>从前面的例子可以看出，使用 import 命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。</p>
<p>为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到 export default 命令，为模块指定默认输出。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// <span class="built_in">export</span>-default.js</span><br><span class="line"><span class="built_in">export</span> default <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  console.log(<span class="string">'foo'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码是一个模块文件 export-default.js，它的默认输出是一个函数。</p>
<p>其他模块加载该模块时，import 命令可以为该匿名函数指定任意名字。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// import-default.js</span><br><span class="line">import customName from <span class="string">'./export-default'</span>;</span><br><span class="line">customName(); // <span class="string">'foo'</span></span><br></pre></td></tr></table></figure>
<p>上面代码的 import 命令，可以用任意名称指向 export-default.js 输出的方法，这时就不需要知道原模块输出的函数名。需要注意的是，这时 import 命令后面，不使用大括号。</p>
<p>export default 命令用在非匿名函数前，也是可以的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// <span class="built_in">export</span>-default.js</span><br><span class="line"><span class="built_in">export</span> default <span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">'foo'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 或者写成</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">'foo'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default foo;</span><br></pre></td></tr></table></figure>
<p>上面代码中，foo 函数的函数名 foo，在模块外部是无效的。加载的时候，视同匿名函数加载。</p>
<p>下面比较一下默认输出和正常输出。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 第一组</span><br><span class="line"><span class="built_in">export</span> default <span class="keyword">function</span> <span class="function"><span class="title">crc32</span></span>() &#123; // 输出</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">import crc32 from <span class="string">'crc32'</span>; // 输入</span><br><span class="line"></span><br><span class="line">// 第二组</span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> <span class="function"><span class="title">crc32</span></span>() &#123; // 输出</span><br><span class="line">  // ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">import &#123;crc32&#125; from <span class="string">'crc32'</span>; // 输入</span><br></pre></td></tr></table></figure>
<p>上面代码的两组写法，第一组是使用 export default 时，对应的 import 语句不需要使用大括号；第二组是不使用 export default 时，对应的 import 语句需要使用大括号。</p>
<p>export default 命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此 export default 命令只能使用一次。所以，import 命令后面才不用加大括号，因为只可能对应一个方法。</p>
<p>本质上，export default 就是输出一个叫做 default 的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// modules.js</span><br><span class="line"><span class="keyword">function</span> add(x, y) &#123;</span><br><span class="line">  <span class="built_in">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">export</span> &#123;add as default&#125;;</span><br><span class="line">// 等同于</span><br><span class="line">// <span class="built_in">export</span> default add;</span><br><span class="line"></span><br><span class="line">// app.js</span><br><span class="line">import &#123; default as xxx &#125; from <span class="string">'modules'</span>;</span><br><span class="line">// 等同于</span><br><span class="line">// import xxx from <span class="string">'modules'</span>;</span><br></pre></td></tr></table></figure>
<p>正是因为 export default 命令其实只是输出一个叫做 default 的变量，所以它后面不能跟变量声明语句。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 正确</span><br><span class="line"><span class="built_in">export</span> var a = 1;</span><br><span class="line"></span><br><span class="line">// 正确</span><br><span class="line">var a = 1;</span><br><span class="line"><span class="built_in">export</span> default a;</span><br><span class="line"></span><br><span class="line">// 错误</span><br><span class="line"><span class="built_in">export</span> default var a = 1;</span><br></pre></td></tr></table></figure>
<p>上面代码中，export default a 的含义是将变量 a 的值赋给变量 default。所以，最后一种写法会报错。</p>
<p>有了 export default 命令，输入模块时就非常直观了，以输入 lodash 模块为例。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import _ from <span class="string">'lodash'</span>;</span><br></pre></td></tr></table></figure>
<p>如果想在一条 import 语句中，同时输入默认方法和其他变量，可以写成下面这样。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import _, &#123; each &#125; from <span class="string">'lodash'</span>;</span><br></pre></td></tr></table></figure>
<p>对应上面代码的 export 语句如下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> default <span class="keyword">function</span> (obj) &#123;</span><br><span class="line">  // ···</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> each(obj, iterator, context) &#123;</span><br><span class="line">  // ···</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">export</span> &#123; each as forEach &#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码的最后一行的意思是，暴露出 forEach 接口，默认指向 each 接口，即 forEach 和 each 指向同一个方法。</p>
<p>如果要输出默认的值，只需将值跟在 export default 之后即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> default 42;</span><br><span class="line"><span class="built_in">export</span> default也可以用来输出类。</span><br><span class="line"></span><br><span class="line">// MyClass.js</span><br><span class="line"><span class="built_in">export</span> default class &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">// main.js</span><br><span class="line">import MyClass from <span class="string">'MyClass'</span>;</span><br><span class="line"><span class="built_in">let</span> o = new MyClass();</span><br></pre></td></tr></table></figure>
<h4 id="export-与-import-的复合写法"><a href="#export-与-import-的复合写法" class="headerlink" title="export 与 import 的复合写法"></a>export 与 import 的复合写法</h4><p>如果在一个模块之中，先输入后输出同一个模块，import 语句可以与 export 语句写在一起。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> &#123; foo, bar &#125; from <span class="string">'my_module'</span>;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">import &#123; foo, bar &#125; from <span class="string">'my_module'</span>;</span><br><span class="line"><span class="built_in">export</span> &#123; foo, boo&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码中，export 和 import 语句可以结合在一起，写成一行。</p>
<p>模块的接口改名和整体输出，也可以采用这种写法。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 接口改名</span><br><span class="line"><span class="built_in">export</span> &#123; foo as myFoo &#125; from <span class="string">'my_module'</span>;</span><br><span class="line"></span><br><span class="line">// 整体输出</span><br><span class="line"><span class="built_in">export</span> * from <span class="string">'my_module'</span>;</span><br></pre></td></tr></table></figure>
<p>默认接口的写法如下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> &#123; default &#125; from <span class="string">'foo'</span>;</span><br></pre></td></tr></table></figure>
<p>具名接口改为默认接口的写法如下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> &#123; es6 as default &#125; from <span class="string">'./someModule'</span>;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">import &#123; es6 &#125; from <span class="string">'./someModule'</span>;</span><br><span class="line"><span class="built_in">export</span> default es6;</span><br></pre></td></tr></table></figure>
<p>同样地，默认接口也可以改名为具名接口。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> &#123; default as es6 &#125; from <span class="string">'./someModule'</span>;</span><br></pre></td></tr></table></figure>
<p>另外，ES7 有一个提案，简化先输入后输出的写法，拿掉输出时的大括号。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 现行的写法</span><br><span class="line"><span class="built_in">export</span> &#123;v&#125; from <span class="string">'mod'</span>;</span><br><span class="line"></span><br><span class="line">// 提案的写法</span><br><span class="line"><span class="built_in">export</span> v from <span class="string">'mod'</span>;</span><br></pre></td></tr></table></figure>
<h4 id="模块的继承"><a href="#模块的继承" class="headerlink" title="模块的继承"></a>模块的继承</h4><p>模块之间也可以继承。</p>
<p>假设有一个 circleplus 模块，继承了 circle 模块。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// circleplus.js</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> * from <span class="string">'circle'</span>;</span><br><span class="line"><span class="built_in">export</span> var e = 2.71828182846;</span><br><span class="line"><span class="built_in">export</span> default <span class="keyword">function</span>(x) &#123;</span><br><span class="line">  <span class="built_in">return</span> Math.exp(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中的 export <em>，表示再输出 circle 模块的所有属性和方法。注意，export </em>命令会忽略 circle 模块的 default 方法。然后，上面代码又输出了自定义的 e 变量和默认方法。</p>
<p>这时，也可以将 circle 的属性或方法，改名后再输出。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// circleplus.js</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> &#123; area as circleArea &#125; from <span class="string">'circle'</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码表示，只输出 circle 模块的 area 方法，且将其改名为 circleArea。</p>
<p>加载上面模块的写法如下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// main.js</span><br><span class="line"></span><br><span class="line">import * as math from <span class="string">'circleplus'</span>;</span><br><span class="line">import exp from <span class="string">'circleplus'</span>;</span><br><span class="line">console.log(exp(math.e));</span><br></pre></td></tr></table></figure>
<p>上面代码中的 import exp 表示，将 circleplus 模块的默认方法加载为 exp 方法。</p>
<h4 id="ES6-模块加载的实质"><a href="#ES6-模块加载的实质" class="headerlink" title="ES6 模块加载的实质"></a>ES6 模块加载的实质</h4><p>ES6 模块加载的机制，与 CommonJS 模块完全不同。CommonJS 模块输出的是一个值的拷贝，而 ES6 模块输出的是值的引用。</p>
<p>CommonJS 模块输出的是被输出值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。请看下面这个模块文件 lib.js 的例子。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// lib.js</span><br><span class="line">var counter = 3;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">incCounter</span></span>() &#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  counter: counter,</span><br><span class="line">  incCounter: incCounter,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码输出内部变量 counter 和改写这个变量的内部方法 incCounter。然后，在 main.js 里面加载这个模块。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// main.js</span><br><span class="line">var mod = require(<span class="string">'./lib'</span>);</span><br><span class="line"></span><br><span class="line">console.log(mod.counter);  // 3</span><br><span class="line">mod.incCounter();</span><br><span class="line">console.log(mod.counter); // 3</span><br></pre></td></tr></table></figure>
<p>上面代码说明，lib.js 模块加载以后，它的内部变化就影响不到输出的 mod.counter 了。这是因为 mod.counter 是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// lib.js</span><br><span class="line">var counter = 3;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">incCounter</span></span>() &#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  get <span class="function"><span class="title">counter</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> counter</span><br><span class="line">  &#125;,</span><br><span class="line">  incCounter: incCounter,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码中，输出的 counter 属性实际上是一个取值器函数。现在再执行 main.js，就可以正确读取内部变量 counter 的变动了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ node main.js</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<p>ES6 模块的运行机制与 CommonJS 不一样，它遇到模块加载命令 import 时，不会去执行模块，而是只生成一个动态的只读引用。等到真的需要用到时，再到模块里面去取值，换句话说，ES6 的输入有点像 Unix 系统的“符号连接”，原始值变了，import 输入的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</p>
<p>还是举上面的例子。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// lib.js</span><br><span class="line"><span class="built_in">export</span> <span class="built_in">let</span> counter = 3;</span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> <span class="function"><span class="title">incCounter</span></span>() &#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// main.js</span><br><span class="line">import &#123; counter, incCounter &#125; from <span class="string">'./lib'</span>;</span><br><span class="line">console.log(counter); // 3</span><br><span class="line">incCounter();</span><br><span class="line">console.log(counter); // 4</span><br></pre></td></tr></table></figure>
<p>上面代码说明，ES6 模块输入的变量 counter 是活的，完全反应其所在模块 lib.js 内部的变化。</p>
<p>再举一个出现在 export 一节中的例子。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// m1.js</span><br><span class="line"><span class="built_in">export</span> var foo = <span class="string">'bar'</span>;</span><br><span class="line">setTimeout(() =&gt; foo = <span class="string">'baz'</span>, 500);</span><br><span class="line"></span><br><span class="line">// m2.js</span><br><span class="line">import &#123;foo&#125; from <span class="string">'./m1.js'</span>;</span><br><span class="line">console.log(foo);</span><br><span class="line">setTimeout(() =&gt; console.log(foo), 500);</span><br></pre></td></tr></table></figure>
<p>上面代码中，m1.js 的变量 foo，在刚加载时等于 bar，过了 500 毫秒，又变为等于 baz。</p>
<p>让我们看看，m2.js 能否正确读取这个变化。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ babel-node m2.js</span><br><span class="line"></span><br><span class="line">bar</span><br><span class="line">baz</span><br></pre></td></tr></table></figure>
<p>上面代码表明，ES6 模块不会缓存运行结果，而是动态地去被加载的模块取值，并且变量总是绑定其所在的模块。</p>
<p>由于 ES6 输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// lib.js</span><br><span class="line"><span class="built_in">export</span> <span class="built_in">let</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// main.js</span><br><span class="line">import &#123; obj &#125; from <span class="string">'./lib'</span>;</span><br><span class="line"></span><br><span class="line">obj.prop = 123; // OK</span><br><span class="line">obj = &#123;&#125;; // TypeError</span><br></pre></td></tr></table></figure>
<p>上面代码中，main.js 从 lib.js 输入变量 obj，可以对 obj 添加属性，但是重新赋值就会报错。因为变量 obj 指向的地址是只读的，不能重新赋值，这就好比 main.js 创造了一个名为 obj 的 const 变量。</p>
<p>最后，export 通过接口，输出的是同一个值。不同的脚本加载这个接口，得到的都是同样的实例。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// mod.js</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">C</span></span>() &#123;</span><br><span class="line">  this.sum = 0;</span><br><span class="line">  this.add = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    this.sum += 1;</span><br><span class="line">  &#125;;</span><br><span class="line">  this.show = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(this.sum);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> <span class="built_in">let</span> c = new C();</span><br></pre></td></tr></table></figure>
<p>上面的脚本 mod.js，输出的是一个 C 的实例。不同的脚本加载这个模块，得到的都是同一个实例。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// x.js</span><br><span class="line">import &#123;c&#125; from <span class="string">'./mod'</span>;</span><br><span class="line">c.add();</span><br><span class="line"></span><br><span class="line">// y.js</span><br><span class="line">import &#123;c&#125; from <span class="string">'./mod'</span>;</span><br><span class="line">c.show();</span><br><span class="line"></span><br><span class="line">// main.js</span><br><span class="line">import <span class="string">'./x'</span>;</span><br><span class="line">import <span class="string">'./y'</span>;</span><br></pre></td></tr></table></figure>
<p>现在执行 main.js，输出的是 1。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ babel-node main.js</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>这就证明了 x.js 和 y.js 加载的都是 C 的同一个实例。</p>
<h4 id="浏览器的模块加载"><a href="#浏览器的模块加载" class="headerlink" title="浏览器的模块加载"></a>浏览器的模块加载</h4><p>浏览器使用 ES6 模块的语法如下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"module"</span> src=<span class="string">"foo.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>上面代码在网页中插入一个模块 foo.js，由于 type 属性设为 module，所以浏览器知道这是一个 ES6 模块。</p>
<p>浏览器对于带有 type=”module”的 script 标签，都是异步加载外部脚本，不会造成堵塞浏览器。</p>
<p>对于外部的模块脚本（上例是 foo.js），有几点需要注意。</p>
<p>1.该脚本自动采用严格模块。 2.该脚本内部的顶层变量，都只在该脚本内部有效，外部不可见。 3.该脚本内部的顶层的 this 关键字，返回 undefined，而不是指向 window。</p>
<h4 id="循环加载"><a href="#循环加载" class="headerlink" title="循环加载"></a>循环加载</h4><p>“循环加载”（circular dependency）指的是，a 脚本的执行依赖 b 脚本，而 b 脚本的执行又依赖 a 脚本。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// a.js</span><br><span class="line">var b = require(<span class="string">'b'</span>);</span><br><span class="line"></span><br><span class="line">// b.js</span><br><span class="line">var a = require(<span class="string">'a'</span>);</span><br></pre></td></tr></table></figure>
<p>通常，“循环加载”表示存在强耦合，如果处理不好，还可能导致递归加载，使得程序无法执行，因此应该避免出现。</p>
<p>但是实际上，这是很难避免的，尤其是依赖关系复杂的大项目，很容易出现 a 依赖 b，b 依赖 c，c 又依赖 a 这样的情况。这意味着，模块加载机制必须考虑“循环加载”的情况。</p>
<p>对于 JavaScript 语言来说，目前最常见的两种模块格式 CommonJS 和 ES6，处理“循环加载”的方法是不一样的，返回的结果也不一样。</p>
<h4 id="CommonJS-模块的加载原理"><a href="#CommonJS-模块的加载原理" class="headerlink" title="CommonJS 模块的加载原理"></a>CommonJS 模块的加载原理</h4><p>介绍 ES6 如何处理”循环加载”之前，先介绍目前最流行的 CommonJS 模块格式的加载原理。</p>
<p>CommonJS 的一个模块，就是一个脚本文件。require 命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  id: <span class="string">'...'</span>,</span><br><span class="line">  exports: &#123; ... &#125;,</span><br><span class="line">  loaded: <span class="literal">true</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码就是 Node 内部加载模块后生成的一个对象。该对象的 id 属性是模块名，exports 属性是模块输出的各个接口，loaded 属性是一个布尔值，表示该模块的脚本是否执行完毕。其他还有很多属性，这里都省略了。</p>
<p>以后需要用到这个模块的时候，就会到 exports 属性上面取值。即使再次执行 require 命令，也不会再次执行该模块，而是到缓存之中取值。也就是说，CommonJS 模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。</p>
<h4 id="CommonJS-模块的循环加载"><a href="#CommonJS-模块的循环加载" class="headerlink" title="CommonJS 模块的循环加载"></a>CommonJS 模块的循环加载</h4><p>CommonJS 模块的重要特性是加载时执行，即脚本代码在 require 的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。</p>
<p>让我们来看，Node 官方文档里面的例子。脚本文件 a.js 代码如下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">exports.done = <span class="literal">false</span>;</span><br><span class="line">var b = require(<span class="string">'./b.js'</span>);</span><br><span class="line">console.log(<span class="string">'在 a.js 之中，b.done = %j'</span>, b.done);</span><br><span class="line">exports.done = <span class="literal">true</span>;</span><br><span class="line">console.log(<span class="string">'a.js 执行完毕'</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码之中，a.js 脚本先输出一个 done 变量，然后加载另一个脚本文件 b.js。注意，此时 a.js 代码就停在这里，等待 b.js 执行完毕，再往下执行。</p>
<p>再看 b.js 的代码。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">exports.done = <span class="literal">false</span>;</span><br><span class="line">var a = require(<span class="string">'./a.js'</span>);</span><br><span class="line">console.log(<span class="string">'在 b.js 之中，a.done = %j'</span>, a.done);</span><br><span class="line">exports.done = <span class="literal">true</span>;</span><br><span class="line">console.log(<span class="string">'b.js 执行完毕'</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码之中，b.js 执行到第二行，就会去加载 a.js，这时，就发生了“循环加载”。系统会去 a.js 模块对应对象的 exports 属性取值，可是因为 a.js 还没有执行完，从 exports 属性只能取回已经执行的部分，而不是最后的值。</p>
<p>a.js 已经执行的部分，只有一行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exports.done = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>因此，对于 b.js 来说，它从 a.js 只输入一个变量 done，值为 false。</p>
<p>然后，b.js 接着往下执行，等到全部执行完毕，再把执行权交还给 a.js。于是，a.js 接着往下执行，直到执行完毕。我们写一个脚本 main.js，验证这个过程。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = require(<span class="string">'./a.js'</span>);</span><br><span class="line">var b = require(<span class="string">'./b.js'</span>);</span><br><span class="line">console.log(<span class="string">'在 main.js 之中, a.done=%j, b.done=%j'</span>, a.done, b.done);</span><br></pre></td></tr></table></figure>
<p>执行 main.js，运行结果如下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ node main.js</span><br><span class="line">在 b.js 之中，a.done = <span class="literal">false</span></span><br><span class="line">b.js 执行完毕</span><br><span class="line">在 a.js 之中，b.done = <span class="literal">true</span></span><br><span class="line">a.js 执行完毕</span><br><span class="line">在 main.js 之中, a.done=<span class="literal">true</span>, b.done=<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>上面的代码证明了两件事。一是，在 b.js 之中，a.js 没有执行完毕，只执行了第一行。二是，main.js 执行到第二行时，不会再次执行 b.js，而是输出缓存的 b.js 的执行结果，即它的第四行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exports.done = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>总之，CommonJS 输入的是被输出值的拷贝，不是引用。</p>
<p>另外，由于 CommonJS 模块遇到循环加载时，返回的是当前已经执行的部分的值，而不是代码全部执行后的值，两者可能会有差异。所以，输入变量的时候，必须非常小心。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a = require(<span class="string">'a'</span>); // 安全的写法</span><br><span class="line">var foo = require(<span class="string">'a'</span>).foo; // 危险的写法</span><br><span class="line"></span><br><span class="line">exports.good = <span class="keyword">function</span> (arg) &#123;</span><br><span class="line">  <span class="built_in">return</span> a.foo(<span class="string">'good'</span>, arg); // 使用的是 a.foo 的最新值</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">exports.bad = <span class="keyword">function</span> (arg) &#123;</span><br><span class="line">  <span class="built_in">return</span> foo(<span class="string">'bad'</span>, arg); // 使用的是一个部分加载时的值</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码中，如果发生循环加载，require(‘a’).foo 的值很可能后面会被改写，改用 require(‘a’)会更保险一点。</p>
<h4 id="ES6-模块的循环加载"><a href="#ES6-模块的循环加载" class="headerlink" title="ES6 模块的循环加载"></a>ES6 模块的循环加载</h4><p>ES6 处理“循环加载”与 CommonJS 有本质的不同。ES6 模块是动态引用，如果使用 import 从一个模块加载变量（即 import foo from ‘foo’），那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。</p>
<p>请看下面这个例子。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// a.js如下</span><br><span class="line">import &#123;bar&#125; from <span class="string">'./b.js'</span>;</span><br><span class="line">console.log(<span class="string">'a.js'</span>);</span><br><span class="line">console.log(bar);</span><br><span class="line"><span class="built_in">export</span> <span class="built_in">let</span> foo = <span class="string">'foo'</span>;</span><br><span class="line"></span><br><span class="line">// b.js</span><br><span class="line">import &#123;foo&#125; from <span class="string">'./a.js'</span>;</span><br><span class="line">console.log(<span class="string">'b.js'</span>);</span><br><span class="line">console.log(foo);</span><br><span class="line"><span class="built_in">export</span> <span class="built_in">let</span> bar = <span class="string">'bar'</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码中，a.js 加载 b.js，b.js 又加载 a.js，构成循环加载。执行 a.js，结果如下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ babel-node a.js</span><br><span class="line">b.js</span><br><span class="line">undefined</span><br><span class="line">a.js</span><br><span class="line">bar</span><br></pre></td></tr></table></figure>
<p>上面代码中，由于 a.js 的第一行是加载 b.js，所以先执行的是 b.js。而 b.js 的第一行又是加载 a.js，这时由于 a.js 已经开始执行了，所以不会重复执行，而是继续往下执行 b.js，所以第一行输出的是 b.js。</p>
<p>接着，b.js 要打印变量 foo，这时 a.js 还没执行完，取不到 foo 的值，导致打印出来是 undefined。b.js 执行完，开始执行 a.js，这时就一切正常了。</p>
<p>再看一个稍微复杂的例子（摘自 Dr. Axel Rauschmayer 的《Exploring ES6》）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// a.js</span><br><span class="line">import &#123;bar&#125; from <span class="string">'./b.js'</span>;</span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">'foo'</span>);</span><br><span class="line">  bar();</span><br><span class="line">  console.log(<span class="string">'执行完毕'</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"></span><br><span class="line">// b.js</span><br><span class="line">import &#123;foo&#125; from <span class="string">'./a.js'</span>;</span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> <span class="function"><span class="title">bar</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">'bar'</span>);</span><br><span class="line">  <span class="keyword">if</span> (Math.random() &gt; 0.5) &#123;</span><br><span class="line">    foo();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照 CommonJS 规范，上面的代码是没法执行的。a 先加载 b，然后 b 又加载 a，这时 a 还没有任何执行结果，所以输出结果为 null，即对于 b.js 来说，变量 foo 的值等于 null，后面的 foo()就会报错。</p>
<p>但是，ES6 可以执行上面的代码。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ babel-node a.js</span><br><span class="line">foo</span><br><span class="line">bar</span><br><span class="line">执行完毕</span><br><span class="line">// 执行结果也有可能是</span><br><span class="line">foo</span><br><span class="line">bar</span><br><span class="line">foo</span><br><span class="line">bar</span><br><span class="line">执行完毕</span><br><span class="line">执行完毕</span><br></pre></td></tr></table></figure>
<p>上面代码中，a.js 之所以能够执行，原因就在于 ES6 加载的变量，都是动态引用其所在的模块。只要引用存在，代码就能执行。</p>
<p>下面，我们详细分析这段代码的运行过程。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// a.js</span><br><span class="line"></span><br><span class="line">// 这一行建立一个引用，</span><br><span class="line">// 从`b.js`引用`bar`</span><br><span class="line">import &#123;bar&#125; from <span class="string">'./b.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">  // 执行时第一行输出 foo</span><br><span class="line">  console.log(<span class="string">'foo'</span>);</span><br><span class="line">  // 到 b.js 执行 bar</span><br><span class="line">  bar();</span><br><span class="line">  console.log(<span class="string">'执行完毕'</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"></span><br><span class="line">// b.js</span><br><span class="line"></span><br><span class="line">// 建立`a.js`的`foo`引用</span><br><span class="line">import &#123;foo&#125; from <span class="string">'./a.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> <span class="function"><span class="title">bar</span></span>() &#123;</span><br><span class="line">  // 执行时，第二行输出 bar</span><br><span class="line">  console.log(<span class="string">'bar'</span>);</span><br><span class="line">  // 递归执行 foo，一旦随机数</span><br><span class="line">  // 小于等于0.5，就停止执行</span><br><span class="line">  <span class="keyword">if</span> (Math.random() &gt; 0.5) &#123;</span><br><span class="line">    foo();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们再来看 ES6 模块加载器 SystemJS 给出的一个例子。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// even.js</span><br><span class="line">import &#123; odd &#125; from <span class="string">'./odd'</span></span><br><span class="line"><span class="built_in">export</span> var counter = 0;</span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> even(n) &#123;</span><br><span class="line">  counter++;</span><br><span class="line">  <span class="built_in">return</span> n == 0 || odd(n - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// odd.js</span><br><span class="line">import &#123; even &#125; from <span class="string">'./even'</span>;</span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> odd(n) &#123;</span><br><span class="line">  <span class="built_in">return</span> n != 0 &amp;&amp; even(n - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，even.js 里面的函数 even 有一个参数 n，只要不等于 0，就会减去 1，传入加载的 odd()。odd.js 也会做类似操作。</p>
<p>运行上面这段代码，结果如下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ babel-node</span><br><span class="line">&gt; import * as m from <span class="string">'./even.js'</span>;</span><br><span class="line">&gt; m.even(10);</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; m.counter</span><br><span class="line">6</span><br><span class="line">&gt; m.even(20)</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; m.counter</span><br><span class="line">17</span><br></pre></td></tr></table></figure>
<p>上面代码中，参数 n 从 10 变为 0 的过程中，even()一共会执行 6 次，所以变量 counter 等于 6。第二次调用 even()时，参数 n 从 20 变为 0，even()一共会执行 11 次，加上前面的 6 次，所以变量 counter 等于 17。</p>
<p>这个例子要是改写成 CommonJS，就根本无法执行，会报错。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// even.js</span><br><span class="line">var odd = require(<span class="string">'./odd'</span>);</span><br><span class="line">var counter = 0;</span><br><span class="line">exports.counter = counter;</span><br><span class="line">exports.even = <span class="keyword">function</span>(n) &#123;</span><br><span class="line">  counter++;</span><br><span class="line">  <span class="built_in">return</span> n == 0 || odd(n - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// odd.js</span><br><span class="line">var even = require(<span class="string">'./even'</span>).even;</span><br><span class="line">module.exports = <span class="keyword">function</span>(n) &#123;</span><br><span class="line">  <span class="built_in">return</span> n != 0 &amp;&amp; even(n - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，even.js 加载 odd.js，而 odd.js 又去加载 even.js，形成“循环加载”。这时，执行引擎就会输出 even.js 已经执行的部分（不存在任何结果），所以在 odd.js 之中，变量 even 等于 null，等到后面调用 even(n-1)就会报错。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ node</span><br><span class="line">&gt; var m = require(<span class="string">'./even'</span>);</span><br><span class="line">&gt; m.even(10)</span><br><span class="line">TypeError: even is not a <span class="keyword">function</span></span><br></pre></td></tr></table></figure>
<h4 id="跨模块常量"><a href="#跨模块常量" class="headerlink" title="跨模块常量"></a>跨模块常量</h4><p>本书介绍 const 命令的时候说过，const 声明的常量只在当前代码块有效。如果想设置跨模块的常量（即跨多个文件），可以采用下面的写法。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// constants.js 模块</span><br><span class="line"><span class="built_in">export</span> const A = 1;</span><br><span class="line"><span class="built_in">export</span> const B = 3;</span><br><span class="line"><span class="built_in">export</span> const C = 4;</span><br><span class="line"></span><br><span class="line">// test1.js 模块</span><br><span class="line">import * as constants from <span class="string">'./constants'</span>;</span><br><span class="line">console.log(constants.A); // 1</span><br><span class="line">console.log(constants.B); // 3</span><br><span class="line"></span><br><span class="line">// test2.js 模块</span><br><span class="line">import &#123;A, B&#125; from <span class="string">'./constants'</span>;</span><br><span class="line">console.log(A); // 1</span><br><span class="line">console.log(B); // 3</span><br></pre></td></tr></table></figure>
<p>如果要使用的常量非常多，可以建一个专门的 constants 目录，将各种常量写在不同的文件里面，保存在该目录下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// constants/db.js</span><br><span class="line"><span class="built_in">export</span> const db = &#123;</span><br><span class="line">  url: <span class="string">'http://my.couchdbserver.local:5984'</span>,</span><br><span class="line">  admin_username: <span class="string">'admin'</span>,</span><br><span class="line">  admin_password: <span class="string">'admin password'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// constants/user.js</span><br><span class="line"><span class="built_in">export</span> const users = [<span class="string">'root'</span>, <span class="string">'admin'</span>, <span class="string">'staff'</span>, <span class="string">'ceo'</span>, <span class="string">'chief'</span>, <span class="string">'moderator'</span>];</span><br></pre></td></tr></table></figure>
<p>然后，将这些文件输出的常量，合并在 index.js 里面。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// constants/index.js</span><br><span class="line"><span class="built_in">export</span> &#123;db&#125; from <span class="string">'./db'</span>;</span><br><span class="line"><span class="built_in">export</span> &#123;users&#125; from <span class="string">'./users'</span>;</span><br></pre></td></tr></table></figure>
<p>使用的时候，直接加载 index.js 就可以了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// script.js</span><br><span class="line">import &#123;db, users&#125; from <span class="string">'./constants'</span>;</span><br></pre></td></tr></table></figure>
<h4 id="import"><a href="#import" class="headerlink" title="import()"></a>import()</h4><p>上面说过了，import 语句会被 JavaScript 引擎静态分析，先于模块内的其他模块执行（叫做”连接“更合适）。所以，下面的代码会报错。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line"><span class="keyword">if</span> (x === 2) &#123;</span><br><span class="line">  import MyModual from <span class="string">'./myModual'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，引擎处理 import 语句是在执行之前，所以 import 语句放在 if 代码块之中毫无意义，因此会报句法错误，而不是执行时错误。</p>
<p>这样的设计，固然有利于编译器提高效率，但也导致无法在运行时加载模块。从长远来看，import 语句会取代 Node 的 require 方法，但是 require 是运行时加载模块，import 语句显然无法取代这种动态加载功能。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const path = <span class="string">'./'</span> + fileName;</span><br><span class="line">const myModual = require(path);</span><br></pre></td></tr></table></figure>
<p>上面的语句就是动态加载，require 到底加载哪一个模块，只有运行时才知道。import 语句做不到这一点。</p>
<p>因此，有一个提案，建议引入 import()函数，完成动态加载。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import(specifier)</span><br></pre></td></tr></table></figure>
<p>上面代码中，import 函数的参数 specifier，指定所要加载的模块的位置。import 语句能够接受什么参数，import()函数就能接受什么参数，两者区别主要是后者为动态加载。</p>
<p>import()返回一个 Promise 对象。下面是一个例子。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const main = document.querySelector(<span class="string">'main'</span>);</span><br><span class="line"></span><br><span class="line">import(`./section-modules/<span class="variable">$&#123;someVariable&#125;</span>.js`)</span><br><span class="line">  .<span class="keyword">then</span>(module =&gt; &#123;</span><br><span class="line">    module.loadPageInto(main);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(err =&gt; &#123;</span><br><span class="line">    main.textContent = err.message;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>import()函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行到这一句，也会加载指定的模块。另外，import()函数与所加载的模块没有静态连接关系，这点也是与 import 语句不相同。</p>
<p>import()类似于 Node 的 require 方法，区别主要是前者是异步加载，后者是同步加载。</p>
<h4 id="ES6-模块的转码"><a href="#ES6-模块的转码" class="headerlink" title="ES6 模块的转码"></a>ES6 模块的转码</h4><p>浏览器目前还不支持 ES6 模块，为了现在就能使用，可以将转为 ES5 的写法。除了 Babel 可以用来转码之外，还有以下两个方法，也可以用来转码。</p>
<h5 id="ES6-module-transpiler"><a href="#ES6-module-transpiler" class="headerlink" title="ES6 module transpiler"></a>ES6 module transpiler</h5><p>ES6 module transpiler 是 square 公司开源的一个转码器，可以将 ES6 模块转为 CommonJS 模块或 AMD 模块的写法，从而在浏览器中使用。</p>
<p>首先，安装这个转玛器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g es6-module-transpiler</span><br></pre></td></tr></table></figure>
<p>然后，使用 compile-modules convert 命令，将 ES6 模块文件转码。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ compile-modules convert file1.js file2.js</span><br></pre></td></tr></table></figure>
<p>-o 参数可以指定转码后的文件名。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ compile-modules convert -o out.js file1.js</span><br></pre></td></tr></table></figure>
<h5 id="SystemJS"><a href="#SystemJS" class="headerlink" title="SystemJS"></a>SystemJS</h5><p>另一种解决方法是使用 SystemJS。它是一个垫片库（polyfill），可以在浏览器内加载 ES6 模块、AMD 模块和 CommonJS 模块，将其转为 ES5 格式。它在后台调用的是 Google 的 Traceur 转码器。</p>
<p>使用时，先在网页内载入 system.js 文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"system.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>然后，使用 System.import 方法加载模块文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  System.import(<span class="string">'./app.js'</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>上面代码中的./app，指的是当前目录下的 app.js 文件。它可以是 ES6 模块文件，System.import 会自动将其转码。</p>
<p>需要注意的是，System.import 使用异步加载，返回一个 Promise 对象，可以针对这个对象编程。下面是一个模块文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// app/es6-file.js:</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> class q &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    this.es6 = <span class="string">'hello'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，在网页内加载这个模块文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">System.import(<span class="string">'app/es6-file'</span>).<span class="keyword">then</span>(<span class="keyword">function</span>(m) &#123;</span><br><span class="line">  console.log(new m.q().es6); // hello</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>上面代码中，System.import 方法返回的是一个 Promise 对象，所以可以用 then 方法指定回调函数。</p>

        </div>

        <blockquote class="post-copyright">
    
    <footer>
        <a href="http://blog.bochunhao.cn">
            <img src="/img/loggo.png" alt="BCH">
            BCH
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es6/">es6</a></li></ul>


            


        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2019/04/12/redux/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">redux</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2019/04/09/es6-Decorator/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">es6_Decorator</h4>
      </a>
    </div>
  
</nav>



    




















</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        感谢支持
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/vx.png" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check" data-wechat="/img/vx.png" data-alipay="/img/zfb.png">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <p>个人博客 &copy; 2018</p>
    <p style="color:#fff;font-size: 16px;font-weight:bolder">
        不积跬步，无以至千里
    </p>
    <p style="color:#fff;font-size: 16px;font-weight:bolder">
        不积小流，无以成江海
    </p>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>


    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: false, REWARD: true };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>






<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '快回来看我呀！';
            clearTimeout(titleTime);
        } else {
            document.title = '个人博客';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
