<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>es6_Async | 个人博客 | BCH</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="es6">
    <meta name="description" content="ES6 异步操作和 async 函数异步编程对 JavaScript 语言太重要。Javascript 语言的执行环境是“单线程”的，如果没有异步编程，根本没法用，非卡死不可。 ES6 诞生以前，异步编程的方法，大概有下面四种。  回调函数 事件监听 发布/订阅 Promise 对象   ES6 将 JavaScript 异步编程带入了一个全新的阶段，ES7 的 Async 函数更是提出了异步编程">
<meta name="keywords" content="es6">
<meta property="og:type" content="article">
<meta property="og:title" content="es6_Async">
<meta property="og:url" content="http://blog.bochunhao.cn/2019/04/02/es6-Async/index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="ES6 异步操作和 async 函数异步编程对 JavaScript 语言太重要。Javascript 语言的执行环境是“单线程”的，如果没有异步编程，根本没法用，非卡死不可。 ES6 诞生以前，异步编程的方法，大概有下面四种。  回调函数 事件监听 发布/订阅 Promise 对象   ES6 将 JavaScript 异步编程带入了一个全新的阶段，ES7 的 Async 函数更是提出了异步编程">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-04-11T13:42:45.715Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="es6_Async">
<meta name="twitter:description" content="ES6 异步操作和 async 函数异步编程对 JavaScript 语言太重要。Javascript 语言的执行环境是“单线程”的，如果没有异步编程，根本没法用，非卡死不可。 ES6 诞生以前，异步编程的方法，大概有下面四种。  回调函数 事件监听 发布/订阅 Promise 对象   ES6 将 JavaScript 异步编程带入了一个全新的阶段，ES7 的 Async 函数更是提出了异步编程">
    
        <link rel="alternate" type="application/atom+xml" title="个人博客" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide">
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/loggo.png">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">BCH</h5>
          <a href="mailto:17600280987@163.com" title="17600280987@163.com" class="mail">17600280987@163.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/">
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories">
                <i class="icon icon-lg icon-archives"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags">
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/bch9479/blog" target="_blank">
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://weibo.com/5900743344/profile?rightmod=1&wvr=6&mod=personinfo" target="_blank">
                <i class="icon icon-lg icon-weibo"></i>
                微博
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">es6_Async</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">es6_Async</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-04-02T12:27:22.000Z" itemprop="datePublished" class="page-time">
  2019-04-02
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/es6/">es6</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ES6-异步操作和-async-函数"><span class="post-toc-number">1.</span> <span class="post-toc-text">ES6 异步操作和 async 函数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#基本概念"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">基本概念</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#异步"><span class="post-toc-number">1.1.1.</span> <span class="post-toc-text">异步</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#回调函数"><span class="post-toc-number">1.1.2.</span> <span class="post-toc-text">回调函数</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Promise"><span class="post-toc-number">1.1.3.</span> <span class="post-toc-text">Promise</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Generator-函数"><span class="post-toc-number">1.1.4.</span> <span class="post-toc-text">Generator 函数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#协程"><span class="post-toc-number">1.1.4.1.</span> <span class="post-toc-text">协程</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#Generator-函数的概念"><span class="post-toc-number">1.1.4.2.</span> <span class="post-toc-text">Generator 函数的概念</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#Generator-函数的数据交换和错误处理"><span class="post-toc-number">1.1.4.3.</span> <span class="post-toc-text">Generator 函数的数据交换和错误处理</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#异步任务的封装"><span class="post-toc-number">1.1.4.4.</span> <span class="post-toc-text">异步任务的封装</span></a></li></ol></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Thunk-函数"><span class="post-toc-number">1.1.5.</span> <span class="post-toc-text">Thunk 函数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#参数的求值策略"><span class="post-toc-number">1.1.5.1.</span> <span class="post-toc-text">参数的求值策略</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#Thunk-函数的含义"><span class="post-toc-number">1.1.5.2.</span> <span class="post-toc-text">Thunk 函数的含义</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#JavaScript-语言的-Thunk-函数"><span class="post-toc-number">1.1.5.3.</span> <span class="post-toc-text">JavaScript 语言的 Thunk 函数</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#Thunkify-模块"><span class="post-toc-number">1.1.5.4.</span> <span class="post-toc-text">Thunkify 模块</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#Generator-函数的流程管理"><span class="post-toc-number">1.1.5.5.</span> <span class="post-toc-text">Generator 函数的流程管理</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#Thunk-函数的自动流程管理"><span class="post-toc-number">1.1.5.6.</span> <span class="post-toc-text">Thunk 函数的自动流程管理</span></a></li></ol></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#co-模块"><span class="post-toc-number">1.1.6.</span> <span class="post-toc-text">co 模块</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#基本用法"><span class="post-toc-number">1.1.6.1.</span> <span class="post-toc-text">基本用法</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#co-模块的原理"><span class="post-toc-number">1.1.6.2.</span> <span class="post-toc-text">co 模块的原理</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#基于-Promise-对象的自动执行"><span class="post-toc-number">1.1.6.3.</span> <span class="post-toc-text">基于 Promise 对象的自动执行</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#co-模块的源码"><span class="post-toc-number">1.1.6.4.</span> <span class="post-toc-text">co 模块的源码</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#处理并发的异步操作"><span class="post-toc-number">1.1.6.5.</span> <span class="post-toc-text">处理并发的异步操作</span></a></li></ol></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#async-函数"><span class="post-toc-number">1.1.7.</span> <span class="post-toc-text">async 函数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#含义"><span class="post-toc-number">1.1.7.1.</span> <span class="post-toc-text">含义</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#语法"><span class="post-toc-number">1.1.7.2.</span> <span class="post-toc-text">语法</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#async-函数的实现"><span class="post-toc-number">1.1.7.3.</span> <span class="post-toc-text">async 函数的实现</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#async-函数的用法"><span class="post-toc-number">1.1.7.4.</span> <span class="post-toc-text">async 函数的用法</span></a></li></ol></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#注意点"><span class="post-toc-number">1.1.8.</span> <span class="post-toc-text">注意点</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#与-Promise、Generator-的比较"><span class="post-toc-number">1.1.9.</span> <span class="post-toc-text">与 Promise、Generator 的比较</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#实例：按顺序完成异步操作"><span class="post-toc-number">1.1.10.</span> <span class="post-toc-text">实例：按顺序完成异步操作</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#异步遍历器"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">异步遍历器</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#异步遍历的接口"><span class="post-toc-number">1.2.1.</span> <span class="post-toc-text">异步遍历的接口</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#for-await…of"><span class="post-toc-number">1.2.2.</span> <span class="post-toc-text">for await…of</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#异步-Generator-函数"><span class="post-toc-number">1.2.3.</span> <span class="post-toc-text">异步 Generator 函数</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#yield-语句"><span class="post-toc-number">1.2.4.</span> <span class="post-toc-text">yield* 语句</span></a></li></ol></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-es6-Async" class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">es6_Async</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-04-02 20:27:22" datetime="2019-04-02T12:27:22.000Z" itemprop="datePublished">2019-04-02</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/es6/">es6</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style="display:none">
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h3 id="ES6-异步操作和-async-函数"><a href="#ES6-异步操作和-async-函数" class="headerlink" title="ES6 异步操作和 async 函数"></a>ES6 异步操作和 async 函数</h3><p>异步编程对 JavaScript 语言太重要。Javascript 语言的执行环境是“单线程”的，如果没有异步编程，根本没法用，非卡死不可。</p>
<p>ES6 诞生以前，异步编程的方法，大概有下面四种。</p>
<pre>
回调函数
事件监听
发布/订阅
Promise 对象
</pre>

<p>ES6 将 JavaScript 异步编程带入了一个全新的阶段，ES7 的 Async 函数更是提出了异步编程的终极解决方案。</p>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><h5 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h5><p>所谓”异步”，简单说就是一个任务分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。</p>
<p>比如，有一个任务是读取文件进行处理，任务的第一段是向操作系统发出请求，要求读取文件。然后，程序执行其他任务，等到操作系统返回文件，再接着执行任务的第二段（处理文件）。这种不连续的执行，就叫做异步。</p>
<p>相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着。</p>
<h5 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h5><p>JavaScript 语言对异步编程的实现，就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。它的英语名字 callback，直译过来就是”重新调用”。</p>
<p>读取文件进行处理，是这样写的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">'/etc/passwd'</span>, <span class="keyword">function</span> (err, data) &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) throw err;</span><br><span class="line">  console.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中，readFile 函数的第二个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了/etc/passwd 这个文件以后，回调函数才会执行。</p>
<p>一个有趣的问题是，为什么 Node.js 约定，回调函数的第一个参数，必须是错误对象 err（如果没有错误，该参数就是 null）？原因是执行分成两段，在这两段之间抛出的错误，程序无法捕捉，只能当作参数，传入第二段。</p>
<h5 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h5><p>回调函数本身并没有问题，它的问题出现在多个回调函数嵌套。假定读取 A 文件之后，再读取 B 文件，代码如下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(fileA, <span class="keyword">function</span> (err, data) &#123;</span><br><span class="line">  fs.readFile(fileB, <span class="keyword">function</span> (err, data) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>不难想象，如果依次读取多个文件，就会出现多重嵌套。代码不是纵向发展，而是横向发展，很快就会乱成一团，无法管理。这种情况就称为”回调函数地狱”（callback hell）。</p>
<p>Promise 就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套，改成链式调用。采用 Promise，连续读取多个文件，写法如下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var readFile = require(<span class="string">'fs-readfile-promise'</span>);</span><br><span class="line"></span><br><span class="line">readFile(fileA)</span><br><span class="line">.<span class="keyword">then</span>(<span class="keyword">function</span>(data)&#123;</span><br><span class="line">  console.log(data.toString());</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">  <span class="built_in">return</span> readFile(fileB);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="keyword">then</span>(<span class="keyword">function</span>(data)&#123;</span><br><span class="line">  console.log(data.toString());</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="keyword">function</span>(err) &#123;</span><br><span class="line">  console.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中，我使用了 fs-readfile-promise 模块，它的作用就是返回一个 Promise 版本的 readFile 函数。Promise 提供 then 方法加载回调函数，catch 方法捕捉执行过程中抛出的错误。</p>
<p>可以看到，Promise 的写法只是回调函数的改进，使用 then 方法以后，异步任务的两段执行看得更清楚了，除此以外，并无新意。</p>
<p>Promise 的最大问题是代码冗余，原来的任务被 Promise 包装了一下，不管什么操作，一眼看去都是一堆 then，原来的语义变得很不清楚。</p>
<p>那么，有没有更好的写法呢？</p>
<h5 id="Generator-函数"><a href="#Generator-函数" class="headerlink" title="Generator 函数"></a>Generator 函数</h5><h6 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h6><p>传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中有一种叫做”协程”（coroutine），意思是多个线程互相协作，完成异步任务。</p>
<p>协程有点像函数，又有点像线程。它的运行流程大致如下。</p>
<pre>
第一步，协程A开始执行。
第二步，协程A执行到一半，进入暂停，执行权转移到协程B。
第三步，（一段时间后）协程B交还执行权。
第四步，协程A恢复执行。
</pre>

<p>上面流程的协程 A，就是异步任务，因为它分成两段（或多段）执行。</p>
<p>举例来说，读取文件的协程写法如下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> *<span class="function"><span class="title">asyncJob</span></span>() &#123;</span><br><span class="line">  // ...其他代码</span><br><span class="line">  var f = yield readFile(fileA);</span><br><span class="line">  // ...其他代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码的函数 asyncJob 是一个协程，它的奥妙就在其中的 yield 命令。它表示执行到此处，执行权将交给其他协程。也就是说，yield 命令是异步两个阶段的分界线。</p>
<p>协程遇到 yield 命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除 yield 命令，简直一模一样。</p>
<h6 id="Generator-函数的概念"><a href="#Generator-函数的概念" class="headerlink" title="Generator 函数的概念"></a>Generator 函数的概念</h6><p>Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。</p>
<p>整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用 yield 语句注明。Generator 函数的执行方法如下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* gen(x)&#123;</span><br><span class="line">  var y = yield x + 2;</span><br><span class="line">  <span class="built_in">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var g = gen(1);</span><br><span class="line">g.next() // &#123; value: 3, <span class="keyword">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">g.next() // &#123; value: undefined, <span class="keyword">done</span>: <span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，调用 Generator 函数，会返回一个内部指针（即遍历器）g 。这是 Generator 函数不同于普通函数的另一个地方，即执行它不会返回结果，返回的是指针对象。调用指针 g 的 next 方法，会移动内部指针（即执行异步任务的第一段），指向第一个遇到的 yield 语句，上例是执行到 x + 2 为止。</p>
<p>换言之，next 方法的作用是分阶段执行 Generator 函数。每次调用 next 方法，会返回一个对象，表示当前阶段的信息（value 属性和 done 属性）。value 属性是 yield 语句后面表达式的值，表示当前阶段的值；done 属性是一个布尔值，表示 Generator 函数是否执行完毕，即是否还有下一个阶段。</p>
<h6 id="Generator-函数的数据交换和错误处理"><a href="#Generator-函数的数据交换和错误处理" class="headerlink" title="Generator 函数的数据交换和错误处理"></a>Generator 函数的数据交换和错误处理</h6><p>Generator 函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。除此之外，它还有两个特性，使它可以作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制。</p>
<p>next 方法返回值的 value 属性，是 Generator 函数向外输出数据；next 方法还可以接受参数，这是向 Generator 函数体内输入数据。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* gen(x)&#123;</span><br><span class="line">  var y = yield x + 2;</span><br><span class="line">  <span class="built_in">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var g = gen(1);</span><br><span class="line">g.next() // &#123; value: 3, <span class="keyword">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">g.next(2) // &#123; value: 2, <span class="keyword">done</span>: <span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，第一个 next 方法的 value 属性，返回表达式 x + 2 的值（3）。第二个 next 方法带有参数 2，这个参数可以传入 Generator 函数，作为上个阶段异步任务的返回结果，被函数体内的变量 y 接收。因此，这一步的 value 属性，返回的就是 2（变量 y 的值）。</p>
<p>Generator 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* gen(x)&#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    var y = yield x + 2;</span><br><span class="line">  &#125; catch (e)&#123;</span><br><span class="line">    console.log(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var g = gen(1);</span><br><span class="line">g.next();</span><br><span class="line">g.throw(<span class="string">'出错了'</span>);</span><br><span class="line">// 出错了</span><br></pre></td></tr></table></figure>
<p>上面代码的最后一行，Generator 函数体外，使用指针对象的 throw 方法抛出的错误，可以被函数体内的 try …catch 代码块捕获。这意味着，出错的代码与处理错误的代码，实现了时间和空间上的分离，这对于异步编程无疑是很重要的。</p>
<h6 id="异步任务的封装"><a href="#异步任务的封装" class="headerlink" title="异步任务的封装"></a>异步任务的封装</h6><p>下面看看如何使用 Generator 函数，执行一个真实的异步任务。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var fetch = require(<span class="string">'node-fetch'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">gen</span></span>()&#123;</span><br><span class="line">  var url = <span class="string">'https://api.github.com/users/github'</span>;</span><br><span class="line">  var result = yield fetch(url);</span><br><span class="line">  console.log(result.bio);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，Generator 函数封装了一个异步操作，该操作先读取一个远程接口，然后从 JSON 格式的数据解析信息。就像前面说过的，这段代码非常像同步操作，除了加上了 yield 命令。</p>
<p>执行这段代码的方法如下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var g = gen();</span><br><span class="line">var result = g.next();</span><br><span class="line"></span><br><span class="line">result.value.then(<span class="keyword">function</span>(data)&#123;</span><br><span class="line">  <span class="built_in">return</span> data.json();</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="keyword">function</span>(data)&#123;</span><br><span class="line">  g.next(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中，首先执行 Generator 函数，获取遍历器对象，然后使用 next 方法（第二行），执行异步任务的第一阶段。由于 Fetch 模块返回的是一个 Promise 对象，因此要用 then 方法调用下一个 next 方法。</p>
<p>可以看到，虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。</p>
<h5 id="Thunk-函数"><a href="#Thunk-函数" class="headerlink" title="Thunk 函数"></a>Thunk 函数</h5><h6 id="参数的求值策略"><a href="#参数的求值策略" class="headerlink" title="参数的求值策略"></a>参数的求值策略</h6><p>Thunk 函数早在上个世纪 60 年代就诞生了。</p>
<p>那时，编程语言刚刚起步，计算机学家还在研究，编译器怎么写比较好。一个争论的焦点是”求值策略”，即函数的参数到底应该何时求值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var x = 1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> f(m)&#123;</span><br><span class="line">  <span class="built_in">return</span> m * 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(x + 5)</span><br></pre></td></tr></table></figure>
<p>上面代码先定义函数 f，然后向它传入表达式 x + 5。请问，这个表达式应该何时求值？</p>
<p>一种意见是”传值调用”（call by value），即在进入函数体之前，就计算 x + 5 的值（等于 6），再将这个值传入函数 f 。C 语言就采用这种策略。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(x + 5)</span><br><span class="line">// 传值调用时，等同于</span><br><span class="line">f(6)</span><br></pre></td></tr></table></figure>
<p>另一种意见是”传名调用”（call by name），即直接将表达式 x + 5 传入函数体，只在用到它的时候求值。Haskell 语言采用这种策略。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(x + 5)</span><br><span class="line">// 传名调用时，等同于</span><br><span class="line">(x + 5) * 2</span><br></pre></td></tr></table></figure>
<p>传值调用和传名调用，哪一种比较好？回答是各有利弊。传值调用比较简单，但是对参数求值的时候，实际上还没用到这个参数，有可能造成性能损失。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> f(a, b)&#123;</span><br><span class="line">  <span class="built_in">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(3 * x * x - 2 * x - 1, x);</span><br></pre></td></tr></table></figure>
<p>上面代码中，函数 f 的第一个参数是一个复杂的表达式，但是函数体内根本没用到。对这个参数求值，实际上是不必要的。因此，有一些计算机学家倾向于”传名调用”，即只在执行时求值。</p>
<h6 id="Thunk-函数的含义"><a href="#Thunk-函数的含义" class="headerlink" title="Thunk 函数的含义"></a>Thunk 函数的含义</h6><p>编译器的”传名调用”实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做 Thunk 函数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> f(m)&#123;</span><br><span class="line">  <span class="built_in">return</span> m * 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(x + 5);</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line"></span><br><span class="line">var thunk = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  <span class="built_in">return</span> x + 5;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> f(thunk)&#123;</span><br><span class="line">  <span class="built_in">return</span> thunk() * 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，函数 f 的参数 x + 5 被一个函数替换了。凡是用到原参数的地方，对 Thunk 函数求值即可。</p>
<p>这就是 Thunk 函数的定义，它是”传名调用”的一种实现策略，用来替换某个表达式。</p>
<h6 id="JavaScript-语言的-Thunk-函数"><a href="#JavaScript-语言的-Thunk-函数" class="headerlink" title="JavaScript 语言的 Thunk 函数"></a>JavaScript 语言的 Thunk 函数</h6><p>JavaScript 语言是传值调用，它的 Thunk 函数含义有所不同。在 JavaScript 语言中，Thunk 函数替换的不是表达式，而是多参数函数，将其替换成单参数的版本，且只接受回调函数作为参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 正常版本的readFile（多参数版本）</span><br><span class="line">fs.readFile(fileName, callback);</span><br><span class="line"></span><br><span class="line">// Thunk版本的readFile（单参数版本）</span><br><span class="line">var readFileThunk = Thunk(fileName);</span><br><span class="line">readFileThunk(callback);</span><br><span class="line"></span><br><span class="line">var Thunk = <span class="keyword">function</span> (fileName)&#123;</span><br><span class="line">  <span class="built_in">return</span> <span class="keyword">function</span> (callback)&#123;</span><br><span class="line">    <span class="built_in">return</span> fs.readFile(fileName, callback);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码中，fs 模块的 readFile 方法是一个多参数函数，两个参数分别为文件名和回调函数。经过转换器处理，它变成了一个单参数函数，只接受回调函数作为参数。这个单参数版本，就叫做 Thunk 函数。</p>
<p>任何函数，只要参数有回调函数，就能写成 Thunk 函数的形式。下面是一个简单的 Thunk 函数转换器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// ES5版本</span><br><span class="line">var Thunk = <span class="keyword">function</span>(fn)&#123;</span><br><span class="line">  <span class="built_in">return</span> <span class="function"><span class="title">function</span></span> ()&#123;</span><br><span class="line">    var args = Array.prototype.slice.call(arguments);</span><br><span class="line">    <span class="built_in">return</span> <span class="keyword">function</span> (callback)&#123;</span><br><span class="line">      args.push(callback);</span><br><span class="line">      <span class="built_in">return</span> fn.apply(this, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// ES6版本</span><br><span class="line">var Thunk = <span class="keyword">function</span>(fn) &#123;</span><br><span class="line">  <span class="built_in">return</span> <span class="keyword">function</span> (...args) &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="keyword">function</span> (callback) &#123;</span><br><span class="line">      <span class="built_in">return</span> fn.call(this, ...args, callback);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用上面的转换器，生成 fs.readFile 的 Thunk 函数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var readFileThunk = Thunk(fs.readFile);</span><br><span class="line">readFileThunk(fileA)(callback);</span><br></pre></td></tr></table></figure>
<p>下面是另一个完整的例子。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> f(a, cb) &#123;</span><br><span class="line">  cb(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> ft = Thunk(f);</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> <span class="built_in">log</span> = console.log.bind(console);</span><br><span class="line">ft(1)(<span class="built_in">log</span>) // 1</span><br></pre></td></tr></table></figure>
<h6 id="Thunkify-模块"><a href="#Thunkify-模块" class="headerlink" title="Thunkify 模块"></a>Thunkify 模块</h6><p>生产环境的转换器，建议使用 Thunkify 模块。</p>
<p>首先是安装。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install thunkify</span><br></pre></td></tr></table></figure>
<p>使用方式如下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var thunkify = require(<span class="string">'thunkify'</span>);</span><br><span class="line">var fs = require(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">var <span class="built_in">read</span> = thunkify(fs.readFile);</span><br><span class="line"><span class="built_in">read</span>(<span class="string">'package.json'</span>)(<span class="keyword">function</span>(err, str)&#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Thunkify 的源码与上一节那个简单的转换器非常像。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> thunkify(fn)&#123;</span><br><span class="line">  <span class="built_in">return</span> <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    var args = new Array(arguments.length);</span><br><span class="line">    var ctx = this;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(var i = 0; i &lt; args.length; ++i) &#123;</span><br><span class="line">      args[i] = arguments[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> <span class="keyword">function</span>(<span class="keyword">done</span>)&#123;</span><br><span class="line">      var called;</span><br><span class="line"></span><br><span class="line">      args.push(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        <span class="keyword">if</span> (called) <span class="built_in">return</span>;</span><br><span class="line">        called = <span class="literal">true</span>;</span><br><span class="line">        done.apply(null, arguments);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line">        fn.apply(ctx, args);</span><br><span class="line">      &#125; catch (err) &#123;</span><br><span class="line">        <span class="keyword">done</span>(err);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>它的源码主要多了一个检查机制，变量 called 确保回调函数只运行一次。这样的设计与下文的 Generator 函数相关。请看下面的例子。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> f(a, b, callback)&#123;</span><br><span class="line">  var sum = a + b;</span><br><span class="line">  callback(sum);</span><br><span class="line">  callback(sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var ft = thunkify(f);</span><br><span class="line">var <span class="built_in">print</span> = console.log.bind(console);</span><br><span class="line">ft(1, 2)(<span class="built_in">print</span>);</span><br><span class="line">// 3</span><br></pre></td></tr></table></figure>
<p>上面代码中，由于 thunkify 只允许回调函数执行一次，所以只输出一行结果。</p>
<h6 id="Generator-函数的流程管理"><a href="#Generator-函数的流程管理" class="headerlink" title="Generator 函数的流程管理"></a>Generator 函数的流程管理</h6><p>你可能会问， Thunk 函数有什么用？回答是以前确实没什么用，但是 ES6 有了 Generator 函数，Thunk 函数现在可以用于 Generator 函数的自动流程管理。</p>
<p>Generator 函数可以自动执行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">gen</span></span>() &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var g = gen();</span><br><span class="line">var res = g.next();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!res.done)&#123;</span><br><span class="line">  console.log(res.value);</span><br><span class="line">  res = g.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，Generator 函数 gen 会自动执行完所有步骤。</p>
<p>但是，这不适合异步操作。如果必须保证前一步执行完，才能执行后一步，上面的自动执行就不可行。这时，Thunk 函数就能派上用处。以读取文件为例。下面的 Generator 函数封装了两个异步操作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(<span class="string">'fs'</span>);</span><br><span class="line">var thunkify = require(<span class="string">'thunkify'</span>);</span><br><span class="line">var readFile = thunkify(fs.readFile);</span><br><span class="line"></span><br><span class="line">var gen = <span class="keyword">function</span>* ()&#123;</span><br><span class="line">  var r1 = yield readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  console.log(r1.toString());</span><br><span class="line">  var r2 = yield readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">  console.log(r2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码中，yield 命令用于将程序的执行权移出 Generator 函数，那么就需要一种方法，将执行权再交还给 Generator 函数。</p>
<p>这种方法就是 Thunk 函数，因为它可以在回调函数里，将执行权交还给 Generator 函数。为了便于理解，我们先看如何手动执行上面这个 Generator 函数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var g = gen();</span><br><span class="line"></span><br><span class="line">var r1 = g.next();</span><br><span class="line">r1.value(<span class="keyword">function</span>(err, data)&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) throw err;</span><br><span class="line">  var r2 = g.next(data);</span><br><span class="line">  r2.value(<span class="keyword">function</span>(err, data)&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) throw err;</span><br><span class="line">    g.next(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中，变量 g 是 Generator 函数的内部指针，表示目前执行到哪一步。next 方法负责将指针移动到下一步，并返回该步的信息（value 属性和 done 属性）。</p>
<p>仔细查看上面的代码，可以发现 Generator 函数的执行过程，其实是将同一个回调函数，反复传入 next 方法的 value 属性。这使得我们可以用递归来自动完成这个过程。</p>
<h6 id="Thunk-函数的自动流程管理"><a href="#Thunk-函数的自动流程管理" class="headerlink" title="Thunk 函数的自动流程管理"></a>Thunk 函数的自动流程管理</h6><p>Thunk 函数真正的威力，在于可以自动执行 Generator 函数。下面就是一个基于 Thunk 函数的 Generator 执行器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> run(fn) &#123;</span><br><span class="line">  var gen = fn();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> next(err, data) &#123;</span><br><span class="line">    var result = gen.next(data);</span><br><span class="line">    <span class="keyword">if</span> (result.done) <span class="built_in">return</span>;</span><br><span class="line">    result.value(next);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">g</span></span>() &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(g);</span><br></pre></td></tr></table></figure>
<p>上面代码的 run 函数，就是一个 Generator 函数的自动执行器。内部的 next 函数就是 Thunk 的回调函数。next 函数先将指针移到 Generator 函数的下一步（gen.next 方法），然后判断 Generator 函数是否结束（result.done 属性），如果没结束，就将 next 函数再传入 Thunk 函数（result.value 属性），否则就直接退出。</p>
<p>有了这个执行器，执行 Generator 函数方便多了。不管内部有多少个异步操作，直接把 Generator 函数传入 run 函数即可。当然，前提是每一个异步操作，都要是 Thunk 函数，也就是说，跟在 yield 命令后面的必须是 Thunk 函数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var g = <span class="keyword">function</span>* ()&#123;</span><br><span class="line">  var f1 = yield readFile(<span class="string">'fileA'</span>);</span><br><span class="line">  var f2 = yield readFile(<span class="string">'fileB'</span>);</span><br><span class="line">  // ...</span><br><span class="line">  var fn = yield readFile(<span class="string">'fileN'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">run(g);</span><br></pre></td></tr></table></figure>
<p>上面代码中，函数 g 封装了 n 个异步的读取文件操作，只要执行 run 函数，这些操作就会自动完成。这样一来，异步操作不仅可以写得像同步操作，而且一行代码就可以执行。</p>
<p>Thunk 函数并不是 Generator 函数自动执行的唯一方案。因为自动执行的关键是，必须有一种机制，自动控制 Generator 函数的流程，接收和交还程序的执行权。回调函数可以做到这一点，Promise 对象也可以做到这一点。</p>
<h5 id="co-模块"><a href="#co-模块" class="headerlink" title="co 模块"></a>co 模块</h5><h6 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h6><p>co 模块是著名程序员 TJ Holowaychuk 于 2013 年 6 月发布的一个小工具，用于 Generator 函数的自动执行。</p>
<p>比如，有一个 Generator 函数，用于依次读取两个文件。</p>
<p>var gen = function* (){<br>var f1 = yield readFile(‘/etc/fstab’);<br>var f2 = yield readFile(‘/etc/shells’);<br>console.log(f1.toString());<br>console.log(f2.toString());<br>};<br>co 模块可以让你不用编写 Generator 函数的执行器。</p>
<p>var co = require(‘co’);<br>co(gen);<br>上面代码中，Generator 函数只要传入 co 函数，就会自动执行。</p>
<p>co 函数返回一个 Promise 对象，因此可以用 then 方法添加回调函数。</p>
<p>co(gen).then(function (){<br>console.log(‘Generator 函数执行完成’);<br>});<br>上面代码中，等到 Generator 函数执行结束，就会输出一行提示。</p>
<h6 id="co-模块的原理"><a href="#co-模块的原理" class="headerlink" title="co 模块的原理"></a>co 模块的原理</h6><p>为什么 co 可以自动执行 Generator 函数？</p>
<p>前面说过，Generator 就是一个异步操作的容器。它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。</p>
<p>两种方法可以做到这一点。</p>
<p>（1）回调函数。将异步操作包装成 Thunk 函数，在回调函数里面交回执行权。</p>
<p>（2）Promise 对象。将异步操作包装成 Promise 对象，用 then 方法交回执行权。</p>
<p>co 模块其实就是将两种自动执行器（Thunk 函数和 Promise 对象），包装成一个模块。使用 co 的前提条件是，Generator 函数的 yield 命令后面，只能是 Thunk 函数或 Promise 对象。</p>
<p>上一节已经介绍了基于 Thunk 函数的自动执行器。下面来看，基于 Promise 对象的自动执行器。这是理解 co 模块必须的。</p>
<h6 id="基于-Promise-对象的自动执行"><a href="#基于-Promise-对象的自动执行" class="headerlink" title="基于 Promise 对象的自动执行"></a>基于 Promise 对象的自动执行</h6><p>还是沿用上面的例子。首先，把 fs 模块的 readFile 方法包装成一个 Promise 对象。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">var readFile = <span class="keyword">function</span> (fileName)&#123;</span><br><span class="line">  <span class="built_in">return</span> new Promise(<span class="keyword">function</span> (resolve, reject)&#123;</span><br><span class="line">    fs.readFile(fileName, <span class="keyword">function</span>(error, data)&#123;</span><br><span class="line">      <span class="keyword">if</span> (error) <span class="built_in">return</span> reject(error);</span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var gen = <span class="keyword">function</span>* ()&#123;</span><br><span class="line">  var f1 = yield readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  var f2 = yield readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">  console.log(f1.toString());</span><br><span class="line">  console.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后，手动执行上面的 Generator 函数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var g = gen();</span><br><span class="line"></span><br><span class="line">g.next().value.then(<span class="keyword">function</span>(data)&#123;</span><br><span class="line">  g.next(data).value.then(<span class="keyword">function</span>(data)&#123;</span><br><span class="line">    g.next(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>手动执行其实就是用 then 方法，层层添加回调函数。理解了这一点，就可以写出一个自动执行器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> run(gen)&#123;</span><br><span class="line">  var g = gen();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> next(data)&#123;</span><br><span class="line">    var result = g.next(data);</span><br><span class="line">    <span class="keyword">if</span> (result.done) <span class="built_in">return</span> result.value;</span><br><span class="line">    result.value.then(<span class="keyword">function</span>(data)&#123;</span><br><span class="line">      next(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(gen);</span><br></pre></td></tr></table></figure>
<p>上面代码中，只要 Generator 函数还没执行到最后一步，next 函数就调用自身，以此实现自动执行。</p>
<h6 id="co-模块的源码"><a href="#co-模块的源码" class="headerlink" title="co 模块的源码"></a>co 模块的源码</h6><p>co 就是上面那个自动执行器的扩展，它的源码只有几十行，非常简单。</p>
<p>首先，co 函数接受 Generator 函数作为参数，返回一个 Promise 对象。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> co(gen) &#123;</span><br><span class="line">  var ctx = this;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> new Promise(<span class="keyword">function</span>(resolve, reject) &#123;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在返回的 Promise 对象里面，co 先检查参数 gen 是否为 Generator 函数。如果是，就执行该函数，得到一个内部指针对象；如果不是就返回，并将 Promise 对象的状态改为 resolved。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> co(gen) &#123;</span><br><span class="line">  var ctx = this;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> new Promise(<span class="keyword">function</span>(resolve, reject) &#123;</span><br><span class="line">    <span class="keyword">if</span> (typeof gen === <span class="string">'function'</span>) gen = gen.call(ctx);</span><br><span class="line">    <span class="keyword">if</span> (!gen || typeof gen.next !== <span class="string">'function'</span>) <span class="built_in">return</span> resolve(gen);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着，co 将 Generator 函数的内部指针对象的 next 方法，包装成 onFulfilled 函数。这主要是为了能够捕捉抛出的错误。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> co(gen) &#123;</span><br><span class="line">  var ctx = this;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> new Promise(<span class="keyword">function</span>(resolve, reject) &#123;</span><br><span class="line">    <span class="keyword">if</span> (typeof gen === <span class="string">'function'</span>) gen = gen.call(ctx);</span><br><span class="line">    <span class="keyword">if</span> (!gen || typeof gen.next !== <span class="string">'function'</span>) <span class="built_in">return</span> resolve(gen);</span><br><span class="line"></span><br><span class="line">    onFulfilled();</span><br><span class="line">    <span class="keyword">function</span> onFulfilled(res) &#123;</span><br><span class="line">      var ret;</span><br><span class="line">      try &#123;</span><br><span class="line">        ret = gen.next(res);</span><br><span class="line">      &#125; catch (e) &#123;</span><br><span class="line">        <span class="built_in">return</span> reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">      next(ret);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，就是关键的 next 函数，它会反复调用自身。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> next(ret) &#123;</span><br><span class="line">  <span class="keyword">if</span> (ret.done) <span class="built_in">return</span> resolve(ret.value);</span><br><span class="line">  var value = toPromise.call(ctx, ret.value);</span><br><span class="line">  <span class="keyword">if</span> (value &amp;&amp; isPromise(value)) <span class="built_in">return</span> value.then(onFulfilled, onRejected);</span><br><span class="line">  <span class="built_in">return</span> onRejected(new TypeError(<span class="string">'You may only yield a function, promise, generator, array, or object, '</span></span><br><span class="line">    + <span class="string">'but the following object was passed: "'</span> + String(ret.value) + <span class="string">'"'</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，next 函数的内部代码，一共只有四行命令。</p>
<p>第一行，检查当前是否为 Generator 函数的最后一步，如果是就返回。</p>
<p>第二行，确保每一步的返回值，是 Promise 对象。</p>
<p>第三行，使用 then 方法，为返回值加上回调函数，然后通过 onFulfilled 函数再次调用 next 函数。</p>
<p>第四行，在参数不符合要求的情况下（参数非 Thunk 函数和 Promise 对象），将 Promise 对象的状态改为 rejected，从而终止执行。</p>
<h6 id="处理并发的异步操作"><a href="#处理并发的异步操作" class="headerlink" title="处理并发的异步操作"></a>处理并发的异步操作</h6><p>co 支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步。</p>
<p>这时，要把并发的操作都放在数组或对象里面，跟在 yield 语句后面。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 数组的写法</span><br><span class="line">co(<span class="keyword">function</span>* () &#123;</span><br><span class="line">  var res = yield [</span><br><span class="line">    Promise.resolve(1),</span><br><span class="line">    Promise.resolve(2)</span><br><span class="line">  ];</span><br><span class="line">  console.log(res);</span><br><span class="line">&#125;).catch(onerror);</span><br><span class="line"></span><br><span class="line">// 对象的写法</span><br><span class="line">co(<span class="keyword">function</span>* () &#123;</span><br><span class="line">  var res = yield &#123;</span><br><span class="line">    1: Promise.resolve(1),</span><br><span class="line">    2: Promise.resolve(2),</span><br><span class="line">  &#125;;</span><br><span class="line">  console.log(res);</span><br><span class="line">&#125;).catch(onerror);</span><br></pre></td></tr></table></figure>
<p>下面是另一个例子。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">co(<span class="keyword">function</span>* () &#123;</span><br><span class="line">  var values = [n1, n2, n3];</span><br><span class="line">  yield values.map(somethingAsync);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* somethingAsync(x) &#123;</span><br><span class="line">  // <span class="keyword">do</span> something async</span><br><span class="line">  <span class="built_in">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码允许并发三个 somethingAsync 异步操作，等到它们全部完成，才会进行下一步。</p>
<h5 id="async-函数"><a href="#async-函数" class="headerlink" title="async 函数"></a>async 函数</h5><h6 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h6><p>ES7 提供了 async 函数，使得异步操作变得更加方便。async 函数是什么？一句话，async 函数就是 Generator 函数的语法糖。</p>
<p>前文有一个 Generator 函数，依次读取两个文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">var readFile = <span class="keyword">function</span> (fileName) &#123;</span><br><span class="line">  <span class="built_in">return</span> new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">    fs.readFile(fileName, <span class="keyword">function</span>(error, data) &#123;</span><br><span class="line">      <span class="keyword">if</span> (error) reject(error);</span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var gen = <span class="keyword">function</span>* ()&#123;</span><br><span class="line">  var f1 = yield readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  var f2 = yield readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">  console.log(f1.toString());</span><br><span class="line">  console.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>写成 async 函数，就是下面这样。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var asyncReadFile = async <span class="function"><span class="title">function</span></span> ()&#123;</span><br><span class="line">  var f1 = await readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  var f2 = await readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">  console.log(f1.toString());</span><br><span class="line">  console.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一比较就会发现，async 函数就是将 Generator 函数的星号（*）替换成 async，将 yield 替换成 await，仅此而已。</p>
<p>async 函数对 Generator 函数的改进，体现在以下四点。</p>
<p>（1）内置执行器。Generator 函数的执行必须靠执行器，所以才有了 co 模块，而 async 函数自带执行器。也就是说，async 函数的执行，与普通函数一模一样，只要一行。</p>
<p>var result = asyncReadFile();<br>上面的代码调用了 asyncReadFile 函数，然后它就会自动执行，输出最后结果。这完全不像 Generator 函数，需要调用 next 方法，或者用 co 模块，才能得到真正执行，得到最后结果。</p>
<p>（2）更好的语义。async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。</p>
<p>（3）更广的适用性。 co 模块约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。</p>
<p>（4）返回值是 Promise。async 函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用 then 方法指定下一步的操作。</p>
<p>进一步说，async 函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而 await 命令就是内部 then 命令的语法糖。</p>
<h6 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h6><p>async 函数的语法规则总体上比较简单，难点是错误处理机制。</p>
<p>（1）async 函数返回一个 Promise 对象。</p>
<p>async 函数内部 return 语句返回的值，会成为 then 方法回调函数的参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> <span class="string">'hello world'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().<span class="keyword">then</span>(v =&gt; console.log(v))</span><br><span class="line">// <span class="string">"hello world"</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，函数 f 内部 return 命令返回的值，会被 then 方法回调函数接收到。</p>
<p>async 函数内部抛出错误，会导致返回的 Promise 对象变为 reject 状态。抛出的错误对象会被 catch 方法回调函数接收到。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  throw new Error(<span class="string">'出错了'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().<span class="keyword">then</span>(</span><br><span class="line">  v =&gt; console.log(v),</span><br><span class="line">  e =&gt; console.log(e)</span><br><span class="line">)</span><br><span class="line">// Error: 出错了</span><br></pre></td></tr></table></figure>
<p>（2）async 函数返回的 Promise 对象，必须等到内部所有 await 命令的 Promise 对象执行完，才会发生状态改变。也就是说，只有 async 函数内部的异步操作执行完，才会执行 then 方法指定的回调函数。</p>
<p>下面是一个例子。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> getTitle(url) &#123;</span><br><span class="line">  <span class="built_in">let</span> response = await fetch(url);</span><br><span class="line">  <span class="built_in">let</span> html = await response.text();</span><br><span class="line">  <span class="built_in">return</span> html.match(/&lt;title&gt;([\s\S]+)&lt;\/title&gt;/i)[1];</span><br><span class="line">&#125;</span><br><span class="line">getTitle(<span class="string">'https://tc39.github.io/ecma262/'</span>).<span class="keyword">then</span>(console.log)</span><br><span class="line">// <span class="string">"ECMAScript 2017 Language Specification"</span></span><br></pre></td></tr></table></figure>
<p>（3）正常情况下，await 命令后面是一个 Promise 对象。如果不是，会被转成一个立即 resolve 的 Promise 对象。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> await 123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().<span class="keyword">then</span>(v =&gt; console.log(v))</span><br><span class="line">// 123</span><br></pre></td></tr></table></figure>
<p>上面代码中，await 命令的参数是数值 123，它被转成 Promise 对象，并立即 resolve。</p>
<p>await 命令后面的 Promise 对象如果变为 reject 状态，则 reject 的参数会被 catch 方法的回调函数接收到。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  await Promise.reject(<span class="string">'出错了'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.<span class="keyword">then</span>(v =&gt; console.log(v))</span><br><span class="line">.catch(e =&gt; console.log(e))</span><br><span class="line">// 出错了</span><br></pre></td></tr></table></figure>
<p>注意，上面代码中，await 语句前面没有 return，但是 reject 方法的参数依然传入了 catch 方法的回调函数。这里如果在 await 前面加上 return，效果是一样的。</p>
<p>只要一个 await 语句后面的 Promise 变为 reject，那么整个 async 函数都会中断执行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  await Promise.reject(<span class="string">'出错了'</span>);</span><br><span class="line">  await Promise.resolve(<span class="string">'hello world'</span>); // 不会执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，第二个 await 语句是不会执行的，因为第一个 await 语句状态变成了 reject。</p>
<p>为了避免这个问题，可以将第一个 await 放在 try…catch 结构里面，这样第二个 await 就会执行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    await Promise.reject(<span class="string">'出错了'</span>);</span><br><span class="line">  &#125; catch(e) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> await Promise.resolve(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.<span class="keyword">then</span>(v =&gt; console.log(v))</span><br><span class="line">// hello world</span><br></pre></td></tr></table></figure>
<p>另一种方法是 await 后面的 Promise 对象再跟一个 catch 方面，处理前面可能出现的错误。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  await Promise.reject(<span class="string">'出错了'</span>)</span><br><span class="line">    .catch(e =&gt; console.log(e));</span><br><span class="line">  <span class="built_in">return</span> await Promise.resolve(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.<span class="keyword">then</span>(v =&gt; console.log(v))</span><br><span class="line">// 出错了</span><br><span class="line">// hello world</span><br></pre></td></tr></table></figure>
<p>如果有多个 await 命令，可以统一放在 try…catch 结构中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    var val1 = await firstStep();</span><br><span class="line">    var val2 = await secondStep(val1);</span><br><span class="line">    var val3 = await thirdStep(val1, val2);</span><br><span class="line"></span><br><span class="line">    console.log(<span class="string">'Final: '</span>, val3);</span><br><span class="line">  &#125;</span><br><span class="line">  catch (err) &#123;</span><br><span class="line">    console.error(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（4）如果 await 后面的异步操作出错，那么等同于 async 函数返回的 Promise 对象被 reject。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  await new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">    throw new Error(<span class="string">'出错了'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.<span class="keyword">then</span>(v =&gt; console.log(v))</span><br><span class="line">.catch(e =&gt; console.log(e))</span><br><span class="line">// Error：出错了</span><br></pre></td></tr></table></figure>
<p>上面代码中，async 函数 f 执行后，await 后面的 Promise 对象会抛出一个错误对象，导致 catch 方法的回调函数被调用，它的参数就是抛出的错误对象。具体的执行机制，可以参考后文的“async 函数的实现”。</p>
<p>防止出错的方法，也是将其放在 try…catch 代码块之中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    await new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">      throw new Error(<span class="string">'出错了'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; catch(e) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> await(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="async-函数的实现"><a href="#async-函数的实现" class="headerlink" title="async 函数的实现"></a>async 函数的实现</h6><p>async 函数的实现，就是将 Generator 函数和自动执行器，包装在一个函数里。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> fn(args)&#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> fn(args)&#123;</span><br><span class="line">  <span class="built_in">return</span> spawn(<span class="keyword">function</span>*() &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有的 async 函数都可以写成上面的第二种形式，其中的 spawn 函数就是自动执行器。</p>
<p>下面给出 spawn 函数的实现，基本就是前文自动执行器的翻版。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> spawn(genF) &#123;</span><br><span class="line">  <span class="built_in">return</span> new Promise(<span class="keyword">function</span>(resolve, reject) &#123;</span><br><span class="line">    var gen = genF();</span><br><span class="line">    <span class="keyword">function</span> step(nextF) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        var next = nextF();</span><br><span class="line">      &#125; catch(e) &#123;</span><br><span class="line">        <span class="built_in">return</span> reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(next.done) &#123;</span><br><span class="line">        <span class="built_in">return</span> resolve(next.value);</span><br><span class="line">      &#125;</span><br><span class="line">      Promise.resolve(next.value).<span class="keyword">then</span>(<span class="keyword">function</span>(v) &#123;</span><br><span class="line">        step(<span class="function"><span class="title">function</span></span>() &#123; <span class="built_in">return</span> gen.next(v); &#125;);</span><br><span class="line">      &#125;, <span class="keyword">function</span>(e) &#123;</span><br><span class="line">        step(<span class="function"><span class="title">function</span></span>() &#123; <span class="built_in">return</span> gen.throw(e); &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    step(<span class="function"><span class="title">function</span></span>() &#123; <span class="built_in">return</span> gen.next(undefined); &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>async 函数是非常新的语法功能，新到都不属于 ES6，而是属于 ES7。目前，它仍处于提案阶段，但是转码器 Babel 和 regenerator 都已经支持，转码后就能使用。</p>
<h6 id="async-函数的用法"><a href="#async-函数的用法" class="headerlink" title="async 函数的用法"></a>async 函数的用法</h6><p>async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数。当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再接着执行函数体内后面的语句。</p>
<p>下面是一个例子。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> getStockPriceByName(name) &#123;</span><br><span class="line">  var symbol = await getStockSymbol(name);</span><br><span class="line">  var stockPrice = await getStockPrice(symbol);</span><br><span class="line">  <span class="built_in">return</span> stockPrice;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getStockPriceByName(<span class="string">'goog'</span>).<span class="keyword">then</span>(<span class="keyword">function</span> (result) &#123;</span><br><span class="line">  console.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码是一个获取股票报价的函数，函数前面的 async 关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个 Promise 对象。</p>
<p>下面的例子，指定多少毫秒后输出一个值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> timeout(ms) &#123;</span><br><span class="line">  <span class="built_in">return</span> new Promise((resolve) =&gt; &#123;</span><br><span class="line">    setTimeout(resolve, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async <span class="keyword">function</span> asyncPrint(value, ms) &#123;</span><br><span class="line">  await timeout(ms);</span><br><span class="line">  console.log(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncPrint(<span class="string">'hello world'</span>, 50);</span><br></pre></td></tr></table></figure>
<p>上面代码指定 50 毫秒以后，输出”hello world”。</p>
<p>Async 函数有多种使用形式。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 函数声明</span><br><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 函数表达式</span><br><span class="line">const foo = async <span class="function"><span class="title">function</span></span> () &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// 对象的方法</span><br><span class="line"><span class="built_in">let</span> obj = &#123; async <span class="function"><span class="title">foo</span></span>() &#123;&#125; &#125;;</span><br><span class="line">obj.foo().<span class="keyword">then</span>(...)</span><br><span class="line"></span><br><span class="line">// Class 的方法</span><br><span class="line">class Storage &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    this.cachePromise = caches.open(<span class="string">'avatars'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  async getAvatar(name) &#123;</span><br><span class="line">    const cache = await this.cachePromise;</span><br><span class="line">    <span class="built_in">return</span> cache.match(`/avatars/<span class="variable">$&#123;name&#125;</span>.jpg`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const storage = new Storage();</span><br><span class="line">storage.getAvatar(<span class="string">'jake'</span>).<span class="keyword">then</span>(…);</span><br><span class="line"></span><br><span class="line">// 箭头函数</span><br><span class="line">const foo = async () =&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h5><p>第一点，await 命令后面的 Promise 对象，运行结果可能是 rejected，所以最好把 await 命令放在 try…catch 代码块中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">myFunction</span></span>() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    await somethingThatReturnsAPromise();</span><br><span class="line">  &#125; catch (err) &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 另一种写法</span><br><span class="line"></span><br><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">myFunction</span></span>() &#123;</span><br><span class="line">  await somethingThatReturnsAPromise()</span><br><span class="line">  .catch(<span class="keyword">function</span> (err) &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二点，多个 await 命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> foo = await getFoo();</span><br><span class="line"><span class="built_in">let</span> bar = await getBar();</span><br></pre></td></tr></table></figure>
<p>上面代码中，getFoo 和 getBar 是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有 getFoo 完成以后，才会执行 getBar，完全可以让它们同时触发。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 写法一</span><br><span class="line"><span class="built_in">let</span> [foo, bar] = await Promise.all([getFoo(), getBar()]);</span><br><span class="line"></span><br><span class="line">// 写法二</span><br><span class="line"><span class="built_in">let</span> fooPromise = getFoo();</span><br><span class="line"><span class="built_in">let</span> barPromise = getBar();</span><br><span class="line"><span class="built_in">let</span> foo = await fooPromise;</span><br><span class="line"><span class="built_in">let</span> bar = await barPromise;</span><br></pre></td></tr></table></figure>
<p>上面两种写法，getFoo 和 getBar 都是同时触发，这样就会缩短程序的执行时间。</p>
<p>第三点，await 命令只能用在 async 函数之中，如果用在普通函数，就会报错。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> dbFuc(db) &#123;</span><br><span class="line">  <span class="built_in">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  // 报错</span><br><span class="line">  docs.forEach(<span class="keyword">function</span> (doc) &#123;</span><br><span class="line">    await db.post(doc);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码会报错，因为 await 用在普通函数之中了。但是，如果将 forEach 方法的参数改成 async 函数，也有问题。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> dbFuc(db) &#123;</span><br><span class="line">  <span class="built_in">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  // 可能得到错误结果</span><br><span class="line">  docs.forEach(async <span class="keyword">function</span> (doc) &#123;</span><br><span class="line">    await db.post(doc);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码可能不会正常工作，原因是这时三个 db.post 操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用 for 循环。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> dbFuc(db) &#123;</span><br><span class="line">  <span class="built_in">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">let</span> doc of docs) &#123;</span><br><span class="line">    await db.post(doc);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果确实希望多个请求并发执行，可以使用 Promise.all 方法。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> dbFuc(db) &#123;</span><br><span class="line">  <span class="built_in">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line">  <span class="built_in">let</span> promises = docs.map((doc) =&gt; db.post(doc));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">let</span> results = await Promise.all(promises);</span><br><span class="line">  console.log(results);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 或者使用下面的写法</span><br><span class="line"></span><br><span class="line">async <span class="keyword">function</span> dbFuc(db) &#123;</span><br><span class="line">  <span class="built_in">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line">  <span class="built_in">let</span> promises = docs.map((doc) =&gt; db.post(doc));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">let</span> results = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">let</span> promise of promises) &#123;</span><br><span class="line">    results.push(await promise);</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(results);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ES6 将 await 增加为保留字。使用这个词作为标识符，在 ES5 是合法的，在 ES6 将抛出 SyntaxError。</p>
<h5 id="与-Promise、Generator-的比较"><a href="#与-Promise、Generator-的比较" class="headerlink" title="与 Promise、Generator 的比较"></a>与 Promise、Generator 的比较</h5><p>我们通过一个例子，来看 Async 函数与 Promise、Generator 函数的区别。</p>
<p>假定某个 DOM 元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。</p>
<p>首先是 Promise 的写法。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> chainAnimationsPromise(elem, animations) &#123;</span><br><span class="line"></span><br><span class="line">  // 变量ret用来保存上一个动画的返回值</span><br><span class="line">  var ret = null;</span><br><span class="line"></span><br><span class="line">  // 新建一个空的Promise</span><br><span class="line">  var p = Promise.resolve();</span><br><span class="line"></span><br><span class="line">  // 使用<span class="keyword">then</span>方法，添加所有动画</span><br><span class="line">  <span class="keyword">for</span>(var anim of animations) &#123;</span><br><span class="line">    p = p.then(<span class="keyword">function</span>(val) &#123;</span><br><span class="line">      ret = val;</span><br><span class="line">      <span class="built_in">return</span> anim(elem);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 返回一个部署了错误捕捉机制的Promise</span><br><span class="line">  <span class="built_in">return</span> p.catch(<span class="keyword">function</span>(e) &#123;</span><br><span class="line">    /* 忽略错误，继续执行 */</span><br><span class="line">  &#125;).<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> ret;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然 Promise 的写法比回调函数的写法大大改进，但是一眼看上去，代码完全都是 Promise 的 API（then、catch 等等），操作本身的语义反而不容易看出来。</p>
<p>接着是 Generator 函数的写法。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> chainAnimationsGenerator(elem, animations) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> spawn(<span class="keyword">function</span>*() &#123;</span><br><span class="line">    var ret = null;</span><br><span class="line">    try &#123;</span><br><span class="line">      <span class="keyword">for</span>(var anim of animations) &#123;</span><br><span class="line">        ret = yield anim(elem);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch(e) &#123;</span><br><span class="line">      /* 忽略错误，继续执行 */</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> ret;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码使用 Generator 函数遍历了每个动画，语义比 Promise 写法更清晰，用户定义的操作全部都出现在 spawn 函数的内部。这个写法的问题在于，必须有一个任务运行器，自动执行 Generator 函数，上面代码的 spawn 函数就是自动执行器，它返回一个 Promise 对象，而且必须保证 yield 语句后面的表达式，必须返回一个 Promise。</p>
<p>最后是 Async 函数的写法。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> chainAnimationsAsync(elem, animations) &#123;</span><br><span class="line">  var ret = null;</span><br><span class="line">  try &#123;</span><br><span class="line">    <span class="keyword">for</span>(var anim of animations) &#123;</span><br><span class="line">      ret = await anim(elem);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; catch(e) &#123;</span><br><span class="line">    /* 忽略错误，继续执行 */</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 Async 函数的实现最简洁，最符合语义，几乎没有语义不相关的代码。它将 Generator 写法中的自动执行器，改在语言层面提供，不暴露给用户，因此代码量最少。如果使用 Generator 写法，自动执行器需要用户自己提供。</p>
<h5 id="实例：按顺序完成异步操作"><a href="#实例：按顺序完成异步操作" class="headerlink" title="实例：按顺序完成异步操作"></a>实例：按顺序完成异步操作</h5><p>实际开发中，经常遇到一组异步操作，需要按照顺序完成。比如，依次远程读取一组 URL，然后按照读取的顺序输出结果。</p>
<p>Promise 的写法如下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> logInOrder(urls) &#123;</span><br><span class="line">  // 远程读取所有URL</span><br><span class="line">  const textPromises = urls.map(url =&gt; &#123;</span><br><span class="line">    <span class="built_in">return</span> fetch(url).<span class="keyword">then</span>(response =&gt; response.text());</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  // 按次序输出</span><br><span class="line">  textPromises.reduce((chain, textPromise) =&gt; &#123;</span><br><span class="line">    <span class="built_in">return</span> chain.then(() =&gt; textPromise)</span><br><span class="line">      .<span class="keyword">then</span>(text =&gt; console.log(text));</span><br><span class="line">  &#125;, Promise.resolve());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码使用 fetch 方法，同时远程读取一组 URL。每个 fetch 操作都返回一个 Promise 对象，放入 textPromises 数组。然后，reduce 方法依次处理每个 Promise 对象，然后使用 then，将所有 Promise 对象连起来，因此就可以依次输出结果。</p>
<p>这种写法不太直观，可读性比较差。下面是 async 函数实现。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> logInOrder(urls) &#123;</span><br><span class="line">  <span class="keyword">for</span> (const url of urls) &#123;</span><br><span class="line">    const response = await fetch(url);</span><br><span class="line">    console.log(await response.text());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码确实大大简化，问题是所有远程操作都是继发。只有前一个 URL 返回结果，才会去读取下一个 URL，这样做效率很差，非常浪费时间。我们需要的是并发发出远程请求。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> logInOrder(urls) &#123;</span><br><span class="line">  // 并发读取远程URL</span><br><span class="line">  const textPromises = urls.map(async url =&gt; &#123;</span><br><span class="line">    const response = await fetch(url);</span><br><span class="line">    <span class="built_in">return</span> response.text();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  // 按次序输出</span><br><span class="line">  <span class="keyword">for</span> (const textPromise of textPromises) &#123;</span><br><span class="line">    console.log(await textPromise);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，虽然 map 方法的参数是 async 函数，但它是并发执行的，因为只有 async 函数内部是继发执行，外部不受影响。后面的 for..of 循环内部使用了 await，因此实现了按顺序输出。</p>
<h4 id="异步遍历器"><a href="#异步遍历器" class="headerlink" title="异步遍历器"></a>异步遍历器</h4><p>《遍历器》一章说过，Iterator 接口是一种数据遍历的协议，只要调用遍历器对象的 next 方法，就会得到一个表示当前成员信息的对象{value, done}。其中，value 表示当前的数据的值，done 是一个布尔值，表示遍历是否结束。</p>
<p>这隐含着规定，next 方法是同步的，只要调用就必须立刻返回值。也就是说，一旦执行 next 方法，就必须同步地得到 value 和 done 这两方面的信息。这对于同步操作，当然没有问题，但对于异步操作，就不太合适了。目前的解决方法是，Generator 函数里面的异步操作，返回一个 Thunk 函数或者 Promise 对象，即 value 属性是一个 Thunk 函数或者 Promise 对象，等待以后返回真正的值，而 done 属性则还是同步产生的。</p>
<p>目前，有一个提案，为异步操作提供原生的遍历器接口，即 value 和 done 这两个属性都是异步产生，这称为”异步遍历器“（Async Iterator）。</p>
<h5 id="异步遍历的接口"><a href="#异步遍历的接口" class="headerlink" title="异步遍历的接口"></a>异步遍历的接口</h5><p>异步遍历器的最大的语法特点，就是调用遍历器的 next 方法，返回的是一个 Promise 对象。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">asyncIterator</span><br><span class="line">  .next()</span><br><span class="line">  .<span class="keyword">then</span>(</span><br><span class="line">    (&#123; value, <span class="keyword">done</span> &#125;) =&gt; /* ... */</span><br><span class="line">  );</span><br></pre></td></tr></table></figure>
<p>上面代码中，asyncIterator 是一个异步遍历器，调用 next 方法以后，返回一个 Promise 对象。因此，可以使用 then 方法指定，这个 Promise 对象的状态变为 resolve 以后的回调函数。回调函数的参数，则是一个具有 value 和 done 两个属性的对象，这个跟同步遍历器是一样的。</p>
<p>我们知道，一个对象的同步遍历器的接口，部署在 Symbol.iterator 属性上面。同样地，对象的异步遍历器接口，部署在 Symbol.asyncIterator 属性上面。不管是什么样的对象，只要它的 Symbol.asyncIterator 属性有值，就表示应该对它进行异步遍历。</p>
<p>下面是一个异步遍历器的例子。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const asyncIterable = createAsyncIterable([<span class="string">'a'</span>, <span class="string">'b'</span>]);</span><br><span class="line">const asyncIterator = someCollection[Symbol.asyncIterator]();</span><br><span class="line"></span><br><span class="line">asyncIterator.next()</span><br><span class="line">.<span class="keyword">then</span>(iterResult1 =&gt; &#123;</span><br><span class="line">  console.log(iterResult1); // &#123; value: <span class="string">'a'</span>, <span class="keyword">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">  <span class="built_in">return</span> asyncIterator.next();</span><br><span class="line">&#125;).<span class="keyword">then</span>(iterResult2 =&gt; &#123;</span><br><span class="line">  console.log(iterResult2); // &#123; value: <span class="string">'b'</span>, <span class="keyword">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">  <span class="built_in">return</span> asyncIterator.next();</span><br><span class="line">&#125;).<span class="keyword">then</span>(iterResult3 =&gt; &#123;</span><br><span class="line">  console.log(iterResult3); // &#123; value: undefined, <span class="keyword">done</span>: <span class="literal">true</span> &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中，异步遍历器其实返回了两次值。第一次调用的时候，返回一个 Promise 对象；等到 Promise 对象 resolve 了，再返回一个表示当前数据成员信息的对象。这就是说，异步遍历器与同步遍历器最终行为是一致的，只是会先返回 Promise 对象，作为中介。</p>
<p>由于异步遍历器的 next 方法，返回的是一个 Promise 对象。因此，可以把它放在 await 命令后面。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  const asyncIterable = createAsyncIterable([<span class="string">'a'</span>, <span class="string">'b'</span>]);</span><br><span class="line">  const asyncIterator = asyncIterable[Symbol.asyncIterator]();</span><br><span class="line">  console.log(await asyncIterator.next());</span><br><span class="line">  // &#123; value: <span class="string">'a'</span>, <span class="keyword">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">  console.log(await asyncIterator.next());</span><br><span class="line">  // &#123; value: <span class="string">'b'</span>, <span class="keyword">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">  console.log(await asyncIterator.next());</span><br><span class="line">  // &#123; value: undefined, <span class="keyword">done</span>: <span class="literal">true</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，next 方法用 await 处理以后，就不必使用 then 方法了。整个流程已经很接近同步处理了。</p>
<p>注意，异步遍历器的 next 方法是可以连续调用的，不必等到上一步产生的 Promise 对象 resolve 以后再调用。这种情况下，next 方法会累积起来，自动按照每一步的顺序运行下去。下面是一个例子，把所有的 next 方法放在 Promise.all 方法里面。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const asyncGenObj = createAsyncIterable([<span class="string">'a'</span>, <span class="string">'b'</span>]);</span><br><span class="line">const [&#123;value: v1&#125;, &#123;value: v2&#125;] = await Promise.all([</span><br><span class="line">  asyncGenObj.next(), asyncGenObj.next()</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">console.log(v1, v2); // a b</span><br></pre></td></tr></table></figure>
<p>另一种用法是一次性调用所有的 next 方法，然后 await 最后一步操作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const writer = openFile(<span class="string">'someFile.txt'</span>);</span><br><span class="line">writer.next(<span class="string">'hello'</span>);</span><br><span class="line">writer.next(<span class="string">'world'</span>);</span><br><span class="line">await writer.return();</span><br></pre></td></tr></table></figure>
<h5 id="for-await…of"><a href="#for-await…of" class="headerlink" title="for await…of"></a>for await…of</h5><p>前面介绍过，for…of 循环用于遍历同步的 Iterator 接口。新引入的 for await…of 循环，则是用于遍历异步的 Iterator 接口。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  <span class="keyword">for</span> await (const x of createAsyncIterable([<span class="string">'a'</span>, <span class="string">'b'</span>])) &#123;</span><br><span class="line">    console.log(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// a</span><br><span class="line">// b</span><br></pre></td></tr></table></figure>
<p>上面代码中，createAsyncIterable()返回一个异步遍历器，for…of 循环自动调用这个遍历器的 next 方法，会得到一个 Promise 对象。await 用来处理这个 Promise 对象，一旦 resolve，就把得到的值（x）传入 for…of 的循环体。</p>
<p>如果 next 方法返回的 Promise 对象被 reject，那么就要用 try…catch 捕捉。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">async <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    <span class="keyword">for</span> await (const x of createRejectingIterable()) &#123;</span><br><span class="line">      console.log(x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    console.error(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，for await…of 循环也可以用于同步遍历器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(async <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  <span class="keyword">for</span> await (const x of [<span class="string">'a'</span>, <span class="string">'b'</span>]) &#123;</span><br><span class="line">    console.log(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">// a</span><br><span class="line">// b</span><br></pre></td></tr></table></figure>
<h5 id="异步-Generator-函数"><a href="#异步-Generator-函数" class="headerlink" title="异步 Generator 函数"></a>异步 Generator 函数</h5><p>就像 Generator 函数返回一个同步遍历器对象一样，异步 Generator 函数的作用，是返回一个异步遍历器对象。</p>
<p>在语法上，异步 Generator 函数就是 async 函数与 Generator 函数的结合。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span>* readLines(path) &#123;</span><br><span class="line">  <span class="built_in">let</span> file = await fileOpen(path);</span><br><span class="line"></span><br><span class="line">  try &#123;</span><br><span class="line">    <span class="keyword">while</span> (!file.EOF) &#123;</span><br><span class="line">      yield await file.readLine();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    await file.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，异步操作前面使用 await 关键字标明，即 await 后面的操作，应该返回 Promise 对象。凡是使用 yield 关键字的地方，就是 next 方法的停下来的地方，它后面的表达式的值（即 await file.readLine()的值），会作为 next()返回对象的 value 属性，这一点是于同步 Generator 函数一致的。</p>
<p>可以像下面这样，使用上面代码定义的异步 Generator 函数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> await (const line of readLines(filePath)) &#123;</span><br><span class="line">  console.log(line);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>异步 Generator 函数可以与 for await…of 循环结合起来使用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span>* prefixLines(asyncIterable) &#123;</span><br><span class="line">  <span class="keyword">for</span> await (const line of asyncIterable) &#123;</span><br><span class="line">    yield <span class="string">'&gt; '</span> + line;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>yield 命令依然是立刻返回的，但是返回的是一个 Promise 对象。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span>* <span class="function"><span class="title">asyncGenerator</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">'Start'</span>);</span><br><span class="line">  const result = await doSomethingAsync(); // (A)</span><br><span class="line">  yield <span class="string">'Result: '</span>+ result; // (B)</span><br><span class="line">  console.log(<span class="string">'Done'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，调用 next 方法以后，会在 B 处暂停执行，yield 命令立刻返回一个 Promise 对象。这个 Promise 对象不同于 A 处 await 命令后面的那个 Promise 对象。主要有两点不同，一是 A 处的 Promise 对象 resolve 以后产生的值，会放入 result 变量；二是 B 处的 Promise 对象 resolve 以后产生的值，是表达式’Result： ‘ + result 的值；二是 A 处的 Promise 对象一定先于 B 处的 Promise 对象 resolve。</p>
<p>如果异步 Generator 函数抛出错误，会被 Promise 对象 reject，然后抛出的错误被 catch 方法捕获。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span>* <span class="function"><span class="title">asyncGenerator</span></span>() &#123;</span><br><span class="line">  throw new Error(<span class="string">'Problem!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncGenerator()</span><br><span class="line">.next()</span><br><span class="line">.catch(err =&gt; console.log(err)); // Error: Problem!</span><br></pre></td></tr></table></figure>
<p>注意，普通的 async 函数返回的是一个 Promise 对象，而异步 Generator 函数返回的是一个异步 Iterator 对象。基本上，可以这样理解，async 函数和异步 Generator 函数，是封装异步操作的两种方法，都用来达到同一种目的。区别在于，前者自带执行器，后者通过 for await…of 执行，或者自己编写执行器。下面就是一个异步 Generator 函数的执行器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> takeAsync(asyncIterable, count=Infinity) &#123;</span><br><span class="line">  const result = [];</span><br><span class="line">  const iterator = asyncIterable[Symbol.asyncIterator]();</span><br><span class="line">  <span class="keyword">while</span> (result.length &lt; count) &#123;</span><br><span class="line">    const &#123;value,<span class="keyword">done</span>&#125; = await iterator.next();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">done</span>) <span class="built_in">break</span>;</span><br><span class="line">    result.push(value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，异步 Generator 函数产生的异步遍历器，会通过 while 循环自动执行，每当 await iterator.next()完成，就会进入下一轮循环。</p>
<p>下面是这个自动执行器的一个使用实例。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  async <span class="keyword">function</span>* <span class="function"><span class="title">gen</span></span>() &#123;</span><br><span class="line">    yield <span class="string">'a'</span>;</span><br><span class="line">    yield <span class="string">'b'</span>;</span><br><span class="line">    yield <span class="string">'c'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> await takeAsync(gen());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().<span class="keyword">then</span>(<span class="keyword">function</span> (result) &#123;</span><br><span class="line">  console.log(result); // [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>异步 Generator 函数出现以后，JavaScript 就有了四种函数形式：普通函数、async 函数、Generator 函数和异步 Generator 函数。请注意区分每种函数的不同之处。</p>
<p>最后，同步的数据结构，也可以使用异步 Generator 函数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span>* createAsyncIterable(syncIterable) &#123;</span><br><span class="line">  <span class="keyword">for</span> (const elem of syncIterable) &#123;</span><br><span class="line">    yield elem;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，由于没有异步操作，所以也就没有使用 await 关键字。</p>
<h5 id="yield-语句"><a href="#yield-语句" class="headerlink" title="yield* 语句"></a>yield* 语句</h5><p>yield*语句也可以跟一个异步遍历器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span>* <span class="function"><span class="title">gen1</span></span>() &#123;</span><br><span class="line">  yield <span class="string">'a'</span>;</span><br><span class="line">  yield <span class="string">'b'</span>;</span><br><span class="line">  <span class="built_in">return</span> 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async <span class="keyword">function</span>* <span class="function"><span class="title">gen2</span></span>() &#123;</span><br><span class="line">  const result = yield* gen1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，gen2 函数里面的 result 变量，最后的值是 2。</p>
<p>与同步 Generator 函数一样，for await…of 循环会展开 yield*。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(async <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  <span class="keyword">for</span> await (const x of gen2()) &#123;</span><br><span class="line">    console.log(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">// a</span><br><span class="line">// b</span><br></pre></td></tr></table></figure>

        </div>

        <blockquote class="post-copyright">
    
    <footer>
        <a href="http://blog.bochunhao.cn">
            <img src="/img/loggo.png" alt="BCH">
            BCH
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es6/">es6</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://blog.bochunhao.cn/2019/04/02/es6-Async/&title=《es6_Async》 — 个人博客&pic=http://blog.bochunhao.cn/img/loggo.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://blog.bochunhao.cn/2019/04/02/es6-Async/&title=《es6_Async》 — 个人博客&source=bch_bk" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://blog.bochunhao.cn/2019/04/02/es6-Async/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《es6_Async》 — 个人博客&url=http://blog.bochunhao.cn/2019/04/02/es6-Async/&via=http://blog.bochunhao.cn" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://blog.bochunhao.cn/2019/04/02/es6-Async/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2019/04/05/es6-Class/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">es6_Class</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2019/03/30/es6-Promise/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">es6_Promise</h4>
      </a>
    </div>
  
</nav>



    




















</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        感谢支持
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/vx.png" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check" data-wechat="/img/vx.png" data-alipay="/img/zfb.png">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <p>个人博客 &copy; 2018</p>
    <p style="color:#fff;font-size: 16px;font-weight:bolder">
        不积跬步，无以至千里
    </p>
    <p style="color:#fff;font-size: 16px;font-weight:bolder">
        不积小流，无以成江海
    </p>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://blog.bochunhao.cn/2019/04/02/es6-Async/&title=《es6_Async》 — 个人博客&pic=http://blog.bochunhao.cn/img/loggo.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://blog.bochunhao.cn/2019/04/02/es6-Async/&title=《es6_Async》 — 个人博客&source=bch_bk" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://blog.bochunhao.cn/2019/04/02/es6-Async/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《es6_Async》 — 个人博客&url=http://blog.bochunhao.cn/2019/04/02/es6-Async/&via=http://blog.bochunhao.cn" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://blog.bochunhao.cn/2019/04/02/es6-Async/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACHUlEQVR42u3aMW7DMAwF0N7/0u5aoLDzSSqDpacpQBJbTwNBivz5idf1Z919+/+X+e+TtyxYGBgYr2Vcj+vuBdVXPj8hgX04IAwMjAMY1bB499/nb3NwvjcMDAyM3qOT0JwHXAwMDIzqtubhuJqAYmBgYORF7CT56z3zK7U4BgbGCxmTwvLbn7/S38DAwHgV4yquarpWbSdcrYWBgbE3Iw9wq5DVUYzC8AcGBsamjHzQoRpG8+0uGOnAwMDYmpFfx0/SvnkLITpiDAyMTRm9pDC5kutd6+eJ5iiXxMDAeBUj2cQzpprY5cE9Cd8YGBjnMPIStPeC/F952YyBgXEaI4/K1VJ2VasyL60xMDB2ZfQCZS98V8fOCs/EwMA4hpEkhZPQ3INFaSIGBsYBjOQSrVqIJhvN26UfkBgYGJsy8kv5yQBZchy9QY3bYQsMDIyNGD1Ar8GZY5L0EQMD4zRG3jLsnVAvTayGYAwMjL0ZeTOylzJWA26vnYmBgbE3I7f2gmkejiepJAYGxjmMJNjloxK9VuiCgIuBgXEAozfuUA27+ehGFNwxMDA2ZVzFlbymOnIxaTNgYGCcwMhX79GT1LA5bIGBgbEpo1c0Xq216sgwMDDOZMwv0Xrl7iokBgYGRn7dXyUVRr6SSzcMDAyM1oXdfIvRkWFgYBzASDaRD3X1kr/qeAcGBsY5jLx0zIPgfBPPR9ZsamJgYLyP8QtJ30HPfYJKagAAAABJRU5ErkJggg==" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>






<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '快回来看我呀！';
            clearTimeout(titleTime);
        } else {
            document.title = '个人博客';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
