<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>webpack</title>
      <link href="/2018/10/03/webpack/"/>
      <url>/2018/10/03/webpack/</url>
      
        <content type="html"><![CDATA[<h3 id="Webpack-性能优化"><a href="#Webpack-性能优化" class="headerlink" title="Webpack 性能优化"></a>Webpack 性能优化</h3><pre>有哪些方式可以减少 Webpack 的打包时间有哪些方式可以让 Webpack 打出来的包更小</pre><h4 id="减少-Webpack-打包时间"><a href="#减少-Webpack-打包时间" class="headerlink" title="减少 Webpack 打包时间"></a>减少 Webpack 打包时间</h4><h5 id="优化-Loader"><a href="#优化-Loader" class="headerlink" title="优化 Loader"></a>优化 Loader</h5><p>对于 Loader 来说，影响打包效率首当其冲必属 Babel 了。因为 Babel 会将代码转为字符串生成 AST，然后对 AST 继续进行转变最后再生成新的代码，项目越大，转换代码越多，效率就越低。当然了，我们是有办法优化的。</p><h6 id="首先我们可以优化-Loader-的文件搜索范围"><a href="#首先我们可以优化-Loader-的文件搜索范围" class="headerlink" title="首先我们可以优化 Loader 的文件搜索范围"></a>首先我们可以优化 Loader 的文件搜索范围</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        // js 文件才使用 babel</span><br><span class="line">        <span class="built_in">test</span>: /\.js\$/,</span><br><span class="line">        loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">        // 只在 src 文件夹下查找</span><br><span class="line">        include: [resolve(<span class="string">'src'</span>)],</span><br><span class="line">        // 不会去查找的路径</span><br><span class="line">        exclude: /node_modules/</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="对于-Babel-来说，我们肯定是希望只作用在-JS-代码上的，然后-node-modules-中使用的代码都是编译过的，所以我们也完全没有必要再去处理一遍。"><a href="#对于-Babel-来说，我们肯定是希望只作用在-JS-代码上的，然后-node-modules-中使用的代码都是编译过的，所以我们也完全没有必要再去处理一遍。" class="headerlink" title="对于 Babel 来说，我们肯定是希望只作用在 JS 代码上的，然后 node_modules 中使用的代码都是编译过的，所以我们也完全没有必要再去处理一遍。"></a>对于 Babel 来说，我们肯定是希望只作用在 JS 代码上的，然后 node_modules 中使用的代码都是编译过的，所以我们也完全没有必要再去处理一遍。</h6><h6 id="当然这样做还不够，我们还可以将-Babel-编译过的文件缓存起来，下次只需要编译更改过的代码文件即可，这样可以大幅度加快打包时间"><a href="#当然这样做还不够，我们还可以将-Babel-编译过的文件缓存起来，下次只需要编译更改过的代码文件即可，这样可以大幅度加快打包时间" class="headerlink" title="当然这样做还不够，我们还可以将 Babel 编译过的文件缓存起来，下次只需要编译更改过的代码文件即可，这样可以大幅度加快打包时间"></a>当然这样做还不够，我们还可以将 Babel 编译过的文件缓存起来，下次只需要编译更改过的代码文件即可，这样可以大幅度加快打包时间</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loader: <span class="string">'babel-loader?cacheDirectory=true'</span></span><br></pre></td></tr></table></figure><h3 id="HappyPack"><a href="#HappyPack" class="headerlink" title="HappyPack"></a>HappyPack</h3><p>受限于 Node 是单线程运行的，所以 Webpack 在打包的过程中也是单线程的，特别是在执行 Loader 的时候，长时间编译的任务很多，这样就会导致等待的情况。</p><h6 id="HappyPack-可以将-Loader-的同步执行转换为并行的，这样就能充分利用系统资源来加快打包效率了"><a href="#HappyPack-可以将-Loader-的同步执行转换为并行的，这样就能充分利用系统资源来加快打包效率了" class="headerlink" title="HappyPack 可以将 Loader 的同步执行转换为并行的，这样就能充分利用系统资源来加快打包效率了"></a>HappyPack 可以将 Loader 的同步执行转换为并行的，这样就能充分利用系统资源来加快打包效率了</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">  loaders: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">test</span>: /\.js\$/,</span><br><span class="line">      include: [resolve(<span class="string">'src'</span>)],</span><br><span class="line">      exclude: /node_modules/,</span><br><span class="line">      // id 后面的内容对应下面</span><br><span class="line">      loader: <span class="string">'happypack/loader?id=happybabel'</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br><span class="line">plugins: [</span><br><span class="line">  new HappyPack(&#123;</span><br><span class="line">    id: <span class="string">'happybabel'</span>,</span><br><span class="line">    loaders: [<span class="string">'babel-loader?cacheDirectory'</span>],</span><br><span class="line">    // 开启 4 个线程</span><br><span class="line">    threads: 4</span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="DllPlugin"><a href="#DllPlugin" class="headerlink" title="DllPlugin"></a>DllPlugin</h3><h5 id="DllPlugin-可以将特定的类库提前打包然后引入。这种方式可以极大的减少打包类库的次数，只有当类库更新版本才有需要重新打包，并且也实现了将公共代码抽离成单独文件的优化方案。"><a href="#DllPlugin-可以将特定的类库提前打包然后引入。这种方式可以极大的减少打包类库的次数，只有当类库更新版本才有需要重新打包，并且也实现了将公共代码抽离成单独文件的优化方案。" class="headerlink" title="DllPlugin 可以将特定的类库提前打包然后引入。这种方式可以极大的减少打包类库的次数，只有当类库更新版本才有需要重新打包，并且也实现了将公共代码抽离成单独文件的优化方案。"></a>DllPlugin 可以将特定的类库提前打包然后引入。这种方式可以极大的减少打包类库的次数，只有当类库更新版本才有需要重新打包，并且也实现了将公共代码抽离成单独文件的优化方案。</h5><h6 id="接下来我们就来学习如何使用-DllPlugin"><a href="#接下来我们就来学习如何使用-DllPlugin" class="headerlink" title="接下来我们就来学习如何使用 DllPlugin"></a>接下来我们就来学习如何使用 DllPlugin</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 单独配置在一个文件中</span><br><span class="line">// webpack.dll.conf.js</span><br><span class="line">const path = require(<span class="string">'path'</span>)</span><br><span class="line">const webpack = require(<span class="string">'webpack'</span>)</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">  // 想统一打包的类库</span><br><span class="line">  vendor: [<span class="string">'react'</span>]</span><br><span class="line">&#125;,</span><br><span class="line">output: &#123;</span><br><span class="line">  path: path.join(**dirname, <span class="string">'dist'</span>),</span><br><span class="line">  filename: <span class="string">'[name].dll.js'</span>,</span><br><span class="line">  library: <span class="string">'[name]-[hash]'</span></span><br><span class="line">&#125;,</span><br><span class="line">plugins: [</span><br><span class="line">  new webpack.DllPlugin(&#123;</span><br><span class="line">    // name 必须和 output.library 一致</span><br><span class="line">    name: <span class="string">'[name]-[hash]'</span>,</span><br><span class="line">    // 该属性需要与 DllReferencePlugin 中一致</span><br><span class="line">    context: **dirname,</span><br><span class="line">    path: path.join(\_\_dirname, <span class="string">'dist'</span>, <span class="string">'[name]-manifest.json'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="然后我们需要执行这个配置文件生成依赖文件，接下来我们需要使用-DllReferencePlugin-将依赖文件引入项目中"><a href="#然后我们需要执行这个配置文件生成依赖文件，接下来我们需要使用-DllReferencePlugin-将依赖文件引入项目中" class="headerlink" title="然后我们需要执行这个配置文件生成依赖文件，接下来我们需要使用 DllReferencePlugin 将依赖文件引入项目中"></a>然后我们需要执行这个配置文件生成依赖文件，接下来我们需要使用 DllReferencePlugin 将依赖文件引入项目中</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// webpack.conf.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  // ...省略其他配置</span><br><span class="line">  plugins: [</span><br><span class="line">    new webpack.DllReferencePlugin(&#123;</span><br><span class="line">      context: __dirname,</span><br><span class="line">      // manifest 就是之前打包出来的 json 文件</span><br><span class="line">      manifest: require(<span class="string">'./dist/vendor-manifest.json'</span>),</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码压缩"><a href="#代码压缩" class="headerlink" title="代码压缩"></a>代码压缩</h4><p>在 Webpack3 中，我们一般使用 UglifyJS 来压缩代码，但是这个是单线程运行的，为了加快效率，我们可以使用 webpack-parallel-uglify-plugin 来并行运行 UglifyJS，从而提高效率。</p><p>在 Webpack4 中，我们就不需要以上这些操作了，只需要将 mode 设置为 production 就可以默认开启以上功能。代码压缩也是我们必做的性能优化方案，当然我们不止可以压缩 JS 代码，还可以压缩 HTML、CSS 代码，并且在压缩 JS 代码的过程中，我们还可以通过配置实现比如删除 console.log 这类代码的功能。</p><h4 id="一些小的优化点"><a href="#一些小的优化点" class="headerlink" title="一些小的优化点"></a>一些小的优化点</h4><p>我们还可以通过一些小的优化点来加快打包速度</p><h5 id="resolve-extensions："><a href="#resolve-extensions：" class="headerlink" title="resolve.extensions："></a>resolve.extensions：</h5><p>用来表明文件后缀列表，默认查找顺序是 [‘.js’, ‘.json’]，如果你的导入文件没有添加后缀就会按照这个顺序查找文件。我们应该尽可能减少后缀列表长度，然后将出现频率高的后缀排在前面</p><h5 id="resolve-alias："><a href="#resolve-alias：" class="headerlink" title="resolve.alias："></a>resolve.alias：</h5><p>可以通过别名的方式来映射一个路径，能让 Webpack 更快找到路径</p><h5 id="module-noParse："><a href="#module-noParse：" class="headerlink" title="module.noParse："></a>module.noParse：</h5><p>如果你确定一个文件下没有其他依赖，就可以使用该属性让 Webpack 不扫描该文件，这种方式对于大型的类库很有帮助</p><h4 id="减少-Webpack-打包后的文件体积"><a href="#减少-Webpack-打包后的文件体积" class="headerlink" title="减少 Webpack 打包后的文件体积"></a>减少 Webpack 打包后的文件体积</h4><p>注意：该内容也属于性能优化领域。</p><h4 id="按需加载"><a href="#按需加载" class="headerlink" title="按需加载"></a>按需加载</h4><p>想必大家在开发 SPA 项目的时候，项目中都会存在十几甚至更多的路由页面。如果我们将这些页面全部打包进一个 JS 文件的话，虽然将多个请求合并了，但是同样也加载了很多并不需要的代码，耗费了更长的时间。那么为了首页能更快地呈现给用户，我们肯定是希望首页能加载的文件体积越小越好，这时候我们就可以使用按需加载，将每个路由页面单独打包为一个文件。当然不仅仅路由可以按需加载，对于 loadash 这种大型类库同样可以使用这个功能。</p><pre>按需加载的代码实现这里就不详细展开了，因为鉴于用的框架不同，实现起来都是不一样的。当然了，虽然他们的用法可能不同，但是底层的机制都是一样的。都是当使用的时候再去下载对应文件，返回一个 Promise，当 Promise 成功以后去执行回调。</pre><h5 id="Scope-Hoisting"><a href="#Scope-Hoisting" class="headerlink" title="Scope Hoisting"></a>Scope Hoisting</h5><p>Scope Hoisting 会分析出模块之间的依赖关系，尽可能的把打包出来的模块合并到一个函数中去。</p><p>比如我们希望打包两个文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// test.js</span><br><span class="line"><span class="built_in">export</span> const a = 1</span><br><span class="line">// index.js</span><br><span class="line">import &#123; a &#125; from <span class="string">'./test.js'</span></span><br></pre></td></tr></table></figure><p>对于这种情况，我们打包出来的代码会类似这样</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  /* 0 */</span><br><span class="line">  <span class="keyword">function</span> (module, exports, require) &#123;</span><br><span class="line">    //...</span><br><span class="line">  &#125;,</span><br><span class="line">  /* 1 */</span><br><span class="line">  <span class="keyword">function</span> (module, exports, require) &#123;</span><br><span class="line">    //...</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>但是如果我们使用 Scope Hoisting 的话，代码就会尽可能的合并到一个函数中去，也就变成了这样的类似代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  /* 0 */</span><br><span class="line">  <span class="keyword">function</span> (module, exports, require) &#123;</span><br><span class="line">    //...</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这样的打包方式生成的代码明显比之前的少多了。如果在 Webpack4 中你希望开启这个功能，只需要启用 optimization.concatenateModules 就可以了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    concatenateModules: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Tree-Shaking"><a href="#Tree-Shaking" class="headerlink" title="Tree Shaking"></a>Tree Shaking</h4><p>Tree Shaking 可以实现删除项目中未被引用的代码，比如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// test.js</span><br><span class="line"><span class="built_in">export</span> const a = 1</span><br><span class="line"><span class="built_in">export</span> const b = 2</span><br><span class="line">// index.js</span><br><span class="line">import &#123; a &#125; from <span class="string">'./test.js'</span></span><br></pre></td></tr></table></figure><p>对于以上情况，test 文件中的变量 b 如果没有在项目中使用到的话，就不会被打包到文件中。</p><p>如果你使用 Webpack 4 的话，开启生产环境就会自动启动这个优化功能。</p>]]></content>
      
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue_data</title>
      <link href="/2018/09/11/vue-data/"/>
      <url>/2018/09/11/vue-data/</url>
      
        <content type="html"><![CDATA[<h3 id="组件中-data-什么时候可以使用对象"><a href="#组件中-data-什么时候可以使用对象" class="headerlink" title="组件中 data 什么时候可以使用对象"></a>组件中 data 什么时候可以使用对象</h3><h5 id="组件复用时所有组件实例都会共享-data，如果-data-是对象的话，就会造成一个组件修改-data-以后会影响到其他所有组件，所以需要将-data-写成函数，每次用到就调用一次函数获得新的数据。"><a href="#组件复用时所有组件实例都会共享-data，如果-data-是对象的话，就会造成一个组件修改-data-以后会影响到其他所有组件，所以需要将-data-写成函数，每次用到就调用一次函数获得新的数据。" class="headerlink" title="组件复用时所有组件实例都会共享  data，如果  data  是对象的话，就会造成一个组件修改  data  以后会影响到其他所有组件，所以需要将  data  写成函数，每次用到就调用一次函数获得新的数据。"></a>组件复用时所有组件实例都会共享  data，如果  data  是对象的话，就会造成一个组件修改  data  以后会影响到其他所有组件，所以需要将  data  写成函数，每次用到就调用一次函数获得新的数据。</h5><h5 id="当我们使用-new-Vue-的方式的时候，无论我们将-data-设置为对象还是函数都是可以的，因为-new-Vue-的方式是生成一个根组件，该组件不会复用，也就不存在共享-data-的情况了。"><a href="#当我们使用-new-Vue-的方式的时候，无论我们将-data-设置为对象还是函数都是可以的，因为-new-Vue-的方式是生成一个根组件，该组件不会复用，也就不存在共享-data-的情况了。" class="headerlink" title="当我们使用  new Vue()  的方式的时候，无论我们将  data  设置为对象还是函数都是可以的，因为  new Vue()  的方式是生成一个根组件，该组件不会复用，也就不存在共享  data  的情况了。"></a>当我们使用  new Vue()  的方式的时候，无论我们将  data  设置为对象还是函数都是可以的，因为  new Vue()  的方式是生成一个根组件，该组件不会复用，也就不存在共享  data  的情况了。</h5>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue_keep-alive</title>
      <link href="/2018/06/16/vue-keep-alive/"/>
      <url>/2018/06/16/vue-keep-alive/</url>
      
        <content type="html"><![CDATA[<h3 id="keep-alive-组件有什么作用"><a href="#keep-alive-组件有什么作用" class="headerlink" title="keep-alive 组件有什么作用"></a>keep-alive 组件有什么作用</h3><h5 id="如果你需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用-keep-alive-组件包裹需要保存的组件。"><a href="#如果你需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用-keep-alive-组件包裹需要保存的组件。" class="headerlink" title="如果你需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用  keep-alive  组件包裹需要保存的组件。"></a>如果你需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用  keep-alive  组件包裹需要保存的组件。</h5><h5 id="对于-keep-alive-组件来说，它拥有两个独有的生命周期钩子函数，分别为-activated-和-deactivated-。用-keep-alive-包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行-deactivated-钩子函数，命中缓存渲染后会执行-actived-钩子函数。"><a href="#对于-keep-alive-组件来说，它拥有两个独有的生命周期钩子函数，分别为-activated-和-deactivated-。用-keep-alive-包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行-deactivated-钩子函数，命中缓存渲染后会执行-actived-钩子函数。" class="headerlink" title="对于  keep-alive  组件来说，它拥有两个独有的生命周期钩子函数，分别为  activated  和  deactivated 。用  keep-alive  包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行  deactivated  钩子函数，命中缓存渲染后会执行  actived  钩子函数。"></a>对于  keep-alive  组件来说，它拥有两个独有的生命周期钩子函数，分别为  activated  和  deactivated 。用  keep-alive  包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行  deactivated  钩子函数，命中缓存渲染后会执行  actived  钩子函数。</h5>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue_v-show_v-if</title>
      <link href="/2018/06/02/vue-v-show-v-if/"/>
      <url>/2018/06/02/vue-v-show-v-if/</url>
      
        <content type="html"><![CDATA[<h3 id="v-show-与-v-if-区别"><a href="#v-show-与-v-if-区别" class="headerlink" title="v-show 与 v-if 区别"></a>v-show 与 v-if 区别</h3><h4 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h4><h5 id="v-show-只是在-display-none-和-display-block-之间切换。无论初始条件是什么都会被渲染出来，后面只需要切换-CSS，DOM-还是一直保留着的。所以总的来说-v-show-在初始渲染时有更高的开销，但是切换开销很小，更适合于频繁切换的场景。"><a href="#v-show-只是在-display-none-和-display-block-之间切换。无论初始条件是什么都会被渲染出来，后面只需要切换-CSS，DOM-还是一直保留着的。所以总的来说-v-show-在初始渲染时有更高的开销，但是切换开销很小，更适合于频繁切换的场景。" class="headerlink" title="v-show 只是在  display: none  和  display: block  之间切换。无论初始条件是什么都会被渲染出来，后面只需要切换 CSS，DOM 还是一直保留着的。所以总的来说  v-show  在初始渲染时有更高的开销，但是切换开销很小，更适合于频繁切换的场景。"></a>v-show 只是在  display: none  和  display: block  之间切换。无论初始条件是什么都会被渲染出来，后面只需要切换 CSS，DOM 还是一直保留着的。所以总的来说  v-show  在初始渲染时有更高的开销，但是切换开销很小，更适合于频繁切换的场景。</h5><h4 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h4><h5 id="v-if-的话就得说到-Vue-底层的编译了。当属性初始为-false-时，组件就不会被渲染，直到条件为-true，并且切换条件时会触发销毁-挂载组件，所以总的来说在切换时开销更高，更适合不经常切换的场景。"><a href="#v-if-的话就得说到-Vue-底层的编译了。当属性初始为-false-时，组件就不会被渲染，直到条件为-true，并且切换条件时会触发销毁-挂载组件，所以总的来说在切换时开销更高，更适合不经常切换的场景。" class="headerlink" title="v-if 的话就得说到 Vue 底层的编译了。当属性初始为  false  时，组件就不会被渲染，直到条件为  true，并且切换条件时会触发销毁/挂载组件，所以总的来说在切换时开销更高，更适合不经常切换的场景。"></a>v-if 的话就得说到 Vue 底层的编译了。当属性初始为  false  时，组件就不会被渲染，直到条件为  true，并且切换条件时会触发销毁/挂载组件，所以总的来说在切换时开销更高，更适合不经常切换的场景。</h5><h4 id="并且基于-v-if-的这种惰性渲染机制，可以在必要的时候才去渲染组件，减少整个页面的初始渲染开销。"><a href="#并且基于-v-if-的这种惰性渲染机制，可以在必要的时候才去渲染组件，减少整个页面的初始渲染开销。" class="headerlink" title="并且基于  v-if  的这种惰性渲染机制，可以在必要的时候才去渲染组件，减少整个页面的初始渲染开销。"></a>并且基于  v-if  的这种惰性渲染机制，可以在必要的时候才去渲染组件，减少整个页面的初始渲染开销。</h4>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue_computed_watch</title>
      <link href="/2018/05/10/vue-computed-watch/"/>
      <url>/2018/05/10/vue-computed-watch/</url>
      
        <content type="html"><![CDATA[<h3 id="computed-和-watch-区别"><a href="#computed-和-watch-区别" class="headerlink" title="computed 和 watch 区别"></a>computed 和 watch 区别</h3><h4 id="computed-是计算属性，依赖其他属性计算值，并且-computed-的值有缓存，只有当计算值变化才会返回内容。"><a href="#computed-是计算属性，依赖其他属性计算值，并且-computed-的值有缓存，只有当计算值变化才会返回内容。" class="headerlink" title="computed  是计算属性，依赖其他属性计算值，并且  computed  的值有缓存，只有当计算值变化才会返回内容。"></a>computed  是计算属性，依赖其他属性计算值，并且  computed  的值有缓存，只有当计算值变化才会返回内容。</h4><h4 id="watch-监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。"><a href="#watch-监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。" class="headerlink" title="watch  监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。"></a>watch  监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。</h4><p>所以一般来说需要依赖别的属性来动态获得值的时候可以使用  computed，对于监听到值的变化需要做一些复杂业务逻辑的情况可以使用  watch。</p><h6 id="另外-computed-和-watch-还都支持对象的写法，这种方式知道的人并不多。"><a href="#另外-computed-和-watch-还都支持对象的写法，这种方式知道的人并不多。" class="headerlink" title="另外  computed  和  watch  还都支持对象的写法，这种方式知道的人并不多。"></a>另外  computed  和  watch  还都支持对象的写法，这种方式知道的人并不多。</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vm.<span class="variable">$watch</span>(<span class="string">'obj'</span>, &#123;</span><br><span class="line">    // 深度遍历</span><br><span class="line">    deep: <span class="literal">true</span>,</span><br><span class="line">    // 立即触发</span><br><span class="line">    immediate: <span class="literal">true</span>,</span><br><span class="line">    // 执行的函数</span><br><span class="line">    handler: <span class="keyword">function</span>(val, oldVal) &#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  data: &#123; a: 1 &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    aPlus: &#123;</span><br><span class="line">      // this.aPlus 时触发</span><br><span class="line">      get: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        <span class="built_in">return</span> this.a + 1</span><br><span class="line">      &#125;,</span><br><span class="line">      // this.aPlus = 1 时触发</span><br><span class="line">      <span class="built_in">set</span>: <span class="keyword">function</span> (v) &#123;</span><br><span class="line">        this.a = v - 1</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue_communication</title>
      <link href="/2018/04/08/vue-communication/"/>
      <url>/2018/04/08/vue-communication/</url>
      
        <content type="html"><![CDATA[<h3 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h3><h5 id="组件通信一般分为以下几种情况："><a href="#组件通信一般分为以下几种情况：" class="headerlink" title="组件通信一般分为以下几种情况："></a>组件通信一般分为以下几种情况：</h5><p>父子组件通信<br>兄弟组件通信<br>跨多层级组件通信<br>任意组件</p><h5 id="对于以上每种情况都有多种方式去实现，接下来就来学习下如何实现。"><a href="#对于以上每种情况都有多种方式去实现，接下来就来学习下如何实现。" class="headerlink" title="对于以上每种情况都有多种方式去实现，接下来就来学习下如何实现。"></a>对于以上每种情况都有多种方式去实现，接下来就来学习下如何实现。</h5><h4 id="父子通信"><a href="#父子通信" class="headerlink" title="父子通信"></a>父子通信</h4><h6 id="父组件通过-props-传递数据给子组件，子组件通过-emit-发送事件传递数据给父组件，这两种方式是最常用的父子通信实现办法。"><a href="#父组件通过-props-传递数据给子组件，子组件通过-emit-发送事件传递数据给父组件，这两种方式是最常用的父子通信实现办法。" class="headerlink" title="父组件通过  props  传递数据给子组件，子组件通过  emit  发送事件传递数据给父组件，这两种方式是最常用的父子通信实现办法。"></a>父组件通过  props  传递数据给子组件，子组件通过  emit  发送事件传递数据给父组件，这两种方式是最常用的父子通信实现办法。</h6><p>这种父子通信方式也就是典型的单向数据流，父组件通过  props  传递数据，子组件不能直接修改  props， 而是必须通过发送事件的方式告知父组件修改数据。</p><h6 id="另外这两种方式还可以使用语法糖-v-model-来直接实现，因为-v-model-默认会解析成名为-value-的-prop-和名为-input-的事件。这种语法糖的方式是典型的双向绑定，常用于-UI-控件上，但是究其根本，还是通过事件的方法让父组件修改数据。"><a href="#另外这两种方式还可以使用语法糖-v-model-来直接实现，因为-v-model-默认会解析成名为-value-的-prop-和名为-input-的事件。这种语法糖的方式是典型的双向绑定，常用于-UI-控件上，但是究其根本，还是通过事件的方法让父组件修改数据。" class="headerlink" title="另外这两种方式还可以使用语法糖  v-model  来直接实现，因为  v-model  默认会解析成名为  value  的  prop  和名为  input  的事件。这种语法糖的方式是典型的双向绑定，常用于 UI 控件上，但是究其根本，还是通过事件的方法让父组件修改数据。"></a>另外这两种方式还可以使用语法糖  v-model  来直接实现，因为  v-model  默认会解析成名为  value  的  prop  和名为  input  的事件。这种语法糖的方式是典型的双向绑定，常用于 UI 控件上，但是究其根本，还是通过事件的方法让父组件修改数据。</h6><p>当然我们还可以通过访问  $parent 或者 $children  对象来访问组件实例中的方法和数据。</p><p>另外如果你使用 Vue 2.3 及以上版本的话还可以使用  \$listeners  和  .sync  这两个属性。</p><h6 id="listeners-属性会将父组件中的-不含-native-修饰器的-v-on-事件监听器传递给子组件，子组件可以通过访问-listeners-来自定义监听器。"><a href="#listeners-属性会将父组件中的-不含-native-修饰器的-v-on-事件监听器传递给子组件，子组件可以通过访问-listeners-来自定义监听器。" class="headerlink" title="$listeners 属性会将父组件中的 (不含 .native 修饰器的) v-on 事件监听器传递给子组件，子组件可以通过访问 $listeners  来自定义监听器。"></a>$listeners 属性会将父组件中的 (不含 .native 修饰器的) v-on 事件监听器传递给子组件，子组件可以通过访问 $listeners  来自定义监听器。</h6><h6 id="sync-属性是个语法糖，可以很简单的实现子组件与父组件通信"><a href="#sync-属性是个语法糖，可以很简单的实现子组件与父组件通信" class="headerlink" title=".sync  属性是个语法糖，可以很简单的实现子组件与父组件通信"></a>.sync  属性是个语法糖，可以很简单的实现子组件与父组件通信</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--父组件中--&gt;</span><br><span class="line">&lt;input :value.sync=<span class="string">"value"</span> /&gt;</span><br><span class="line">&lt;!--以上写法等同于--&gt;</span><br><span class="line">&lt;input :value=<span class="string">"value"</span> @update:value=<span class="string">"v =&gt; value = v"</span>&gt;&lt;/comp&gt;</span><br><span class="line">&lt;!--子组件中--&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  this.<span class="variable">$emit</span>(<span class="string">'update:value'</span>, 1)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="兄弟组件通信"><a href="#兄弟组件通信" class="headerlink" title="兄弟组件通信"></a>兄弟组件通信</h4><h6 id="对于这种情况可以通过查找父组件中的子组件实现，也就是-this-parent-children，在-children-中可以通过组件-name-查询到需要的组件实例，然后进行通信。"><a href="#对于这种情况可以通过查找父组件中的子组件实现，也就是-this-parent-children，在-children-中可以通过组件-name-查询到需要的组件实例，然后进行通信。" class="headerlink" title="对于这种情况可以通过查找父组件中的子组件实现，也就是  this.$parent.$children，在  \$children 中可以通过组件  name  查询到需要的组件实例，然后进行通信。"></a>对于这种情况可以通过查找父组件中的子组件实现，也就是  this.$parent.$children，在  \$children 中可以通过组件  name  查询到需要的组件实例，然后进行通信。</h6><h4 id="跨多层次组件通信"><a href="#跨多层次组件通信" class="headerlink" title="跨多层次组件通信"></a>跨多层次组件通信</h4><h6 id="对于这种情况可以使用-Vue-2-2-新增的-API-provide-inject，虽然文档中不推荐直接使用在业务中，但是如果用得好的话还是很有用的。"><a href="#对于这种情况可以使用-Vue-2-2-新增的-API-provide-inject，虽然文档中不推荐直接使用在业务中，但是如果用得好的话还是很有用的。" class="headerlink" title="对于这种情况可以使用 Vue 2.2 新增的 API provide / inject，虽然文档中不推荐直接使用在业务中，但是如果用得好的话还是很有用的。"></a>对于这种情况可以使用 Vue 2.2 新增的 API provide / inject，虽然文档中不推荐直接使用在业务中，但是如果用得好的话还是很有用的。</h6><h5 id="假设有父组件-A，然后有一个跨多层级的子组件-B"><a href="#假设有父组件-A，然后有一个跨多层级的子组件-B" class="headerlink" title="假设有父组件 A，然后有一个跨多层级的子组件 B"></a>假设有父组件 A，然后有一个跨多层级的子组件 B</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 父组件 A</span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  provide: &#123;</span><br><span class="line">    data: 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 子组件 B</span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  inject: [<span class="string">'data'</span>],</span><br><span class="line">  <span class="function"><span class="title">mounted</span></span>() &#123;</span><br><span class="line">    // 无论跨几层都能获得父组件的 data 属性</span><br><span class="line">    console.log(this.data) // =&gt; 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="任意组件"><a href="#任意组件" class="headerlink" title="任意组件"></a>任意组件</h4><h6 id="这种方式可以通过-Vuex-或者-Event-Bus-解决，另外如果你不怕麻烦的话，可以使用这种方式解决上述所有的通信情况"><a href="#这种方式可以通过-Vuex-或者-Event-Bus-解决，另外如果你不怕麻烦的话，可以使用这种方式解决上述所有的通信情况" class="headerlink" title="这种方式可以通过 Vuex 或者 Event Bus 解决，另外如果你不怕麻烦的话，可以使用这种方式解决上述所有的通信情况"></a>这种方式可以通过 Vuex 或者 Event Bus 解决，另外如果你不怕麻烦的话，可以使用这种方式解决上述所有的通信情况</h6>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue_mixin_mixins</title>
      <link href="/2018/04/02/vue-mixin-mixins/"/>
      <url>/2018/04/02/vue-mixin-mixins/</url>
      
        <content type="html"><![CDATA[<h3 id="mixin-和-mixins-区别"><a href="#mixin-和-mixins-区别" class="headerlink" title="mixin 和 mixins 区别"></a>mixin 和 mixins 区别</h3><h6 id="mixin-用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的。"><a href="#mixin-用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的。" class="headerlink" title="mixin  用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的。"></a>mixin  用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的。</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.mixin(&#123;</span><br><span class="line">    <span class="function"><span class="title">beforeCreate</span></span>() &#123;</span><br><span class="line">        // ...逻辑</span><br><span class="line">        // 这种方式会影响到每个组件的 beforeCreate 钩子函数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="虽然文档不建议我们在应用中直接使用-mixin，但是如果不滥用的话也是很有帮助的，比如可以全局混入封装好的-ajax-或者一些工具函数等等。"><a href="#虽然文档不建议我们在应用中直接使用-mixin，但是如果不滥用的话也是很有帮助的，比如可以全局混入封装好的-ajax-或者一些工具函数等等。" class="headerlink" title="虽然文档不建议我们在应用中直接使用  mixin，但是如果不滥用的话也是很有帮助的，比如可以全局混入封装好的  ajax  或者一些工具函数等等。"></a>虽然文档不建议我们在应用中直接使用  mixin，但是如果不滥用的话也是很有帮助的，比如可以全局混入封装好的  ajax  或者一些工具函数等等。</h5><h6 id="mixins-应该是我们最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过-mixins-混入代码，比如上拉下拉加载数据这种逻辑等等。"><a href="#mixins-应该是我们最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过-mixins-混入代码，比如上拉下拉加载数据这种逻辑等等。" class="headerlink" title="mixins  应该是我们最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过  mixins  混入代码，比如上拉下拉加载数据这种逻辑等等。"></a>mixins  应该是我们最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过  mixins  混入代码，比如上拉下拉加载数据这种逻辑等等。</h6><h6 id="另外需要注意的是-mixins-混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并，具体可以阅读-文档。"><a href="#另外需要注意的是-mixins-混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并，具体可以阅读-文档。" class="headerlink" title="另外需要注意的是  mixins  混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并，具体可以阅读   文档。"></a>另外需要注意的是  mixins  混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并，具体可以阅读   文档。</h6>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue_lifecycle</title>
      <link href="/2018/03/26/vue-lifecycle/"/>
      <url>/2018/03/26/vue-lifecycle/</url>
      
        <content type="html"><![CDATA[<h3 id="生命周期钩子函数"><a href="#生命周期钩子函数" class="headerlink" title="生命周期钩子函数"></a>生命周期钩子函数</h3><h5 id="在-beforeCreate-钩子函数调用的时候，是获取不到-props-或者-data-中的数据的，因为这些数据的初始化都在-initState-中。"><a href="#在-beforeCreate-钩子函数调用的时候，是获取不到-props-或者-data-中的数据的，因为这些数据的初始化都在-initState-中。" class="headerlink" title="在  beforeCreate  钩子函数调用的时候，是获取不到  props  或者  data  中的数据的，因为这些数据的初始化都在  initState  中。"></a>在  beforeCreate  钩子函数调用的时候，是获取不到  props  或者  data  中的数据的，因为这些数据的初始化都在  initState  中。</h5><h5 id="然后会执行-created-钩子函数，在这一步的时候已经可以访问到之前不能访问到的数据，但是这时候组件还没被挂载，所以是看不到的。"><a href="#然后会执行-created-钩子函数，在这一步的时候已经可以访问到之前不能访问到的数据，但是这时候组件还没被挂载，所以是看不到的。" class="headerlink" title="然后会执行  created  钩子函数，在这一步的时候已经可以访问到之前不能访问到的数据，但是这时候组件还没被挂载，所以是看不到的。"></a>然后会执行  created  钩子函数，在这一步的时候已经可以访问到之前不能访问到的数据，但是这时候组件还没被挂载，所以是看不到的。</h5><h5 id="接下来会先执行-beforeMount-钩子函数，开始创建-VDOM，最后执行-mounted-钩子，并将-VDOM-渲染为真实-DOM-并且渲染数据。组件中如果有子组件的话，会递归挂载子组件，只有当所有子组件全部挂载完毕，才会执行根组件的挂载钩子。"><a href="#接下来会先执行-beforeMount-钩子函数，开始创建-VDOM，最后执行-mounted-钩子，并将-VDOM-渲染为真实-DOM-并且渲染数据。组件中如果有子组件的话，会递归挂载子组件，只有当所有子组件全部挂载完毕，才会执行根组件的挂载钩子。" class="headerlink" title="接下来会先执行  beforeMount  钩子函数，开始创建 VDOM，最后执行  mounted  钩子，并将 VDOM 渲染为真实 DOM 并且渲染数据。组件中如果有子组件的话，会递归挂载子组件，只有当所有子组件全部挂载完毕，才会执行根组件的挂载钩子。"></a>接下来会先执行  beforeMount  钩子函数，开始创建 VDOM，最后执行  mounted  钩子，并将 VDOM 渲染为真实 DOM 并且渲染数据。组件中如果有子组件的话，会递归挂载子组件，只有当所有子组件全部挂载完毕，才会执行根组件的挂载钩子。</h5><h5 id="接下来是数据更新时会调用的钩子函数-beforeUpdate-和-updated，这两个钩子函数没什么好说的，就是分别在数据更新前和更新后会调用。"><a href="#接下来是数据更新时会调用的钩子函数-beforeUpdate-和-updated，这两个钩子函数没什么好说的，就是分别在数据更新前和更新后会调用。" class="headerlink" title="接下来是数据更新时会调用的钩子函数  beforeUpdate  和  updated，这两个钩子函数没什么好说的，就是分别在数据更新前和更新后会调用。"></a>接下来是数据更新时会调用的钩子函数  beforeUpdate  和  updated，这两个钩子函数没什么好说的，就是分别在数据更新前和更新后会调用。</h5><h5 id="另外还有-keep-alive-独有的生命周期，分别为-activated-和-deactivated-。用-keep-alive-包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行-deactivated-钩子函数，命中缓存渲染后会执行-actived-钩子函数。"><a href="#另外还有-keep-alive-独有的生命周期，分别为-activated-和-deactivated-。用-keep-alive-包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行-deactivated-钩子函数，命中缓存渲染后会执行-actived-钩子函数。" class="headerlink" title="另外还有  keep-alive  独有的生命周期，分别为  activated  和  deactivated 。用  keep-alive  包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行  deactivated  钩子函数，命中缓存渲染后会执行  actived  钩子函数。"></a>另外还有  keep-alive  独有的生命周期，分别为  activated  和  deactivated 。用  keep-alive  包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行  deactivated  钩子函数，命中缓存渲染后会执行  actived  钩子函数。</h5><h5 id="最后就是销毁组件的钩子函数-beforeDestroy-和-destroyed。前者适合移除事件、定时器等等，否则可能会引起内存泄露的问题。然后进行一系列的销毁操作，如果有子组件的话，也会递归销毁子组件，所有子组件都销毁完毕后才会执行根组件的-destroyed-钩子函数。"><a href="#最后就是销毁组件的钩子函数-beforeDestroy-和-destroyed。前者适合移除事件、定时器等等，否则可能会引起内存泄露的问题。然后进行一系列的销毁操作，如果有子组件的话，也会递归销毁子组件，所有子组件都销毁完毕后才会执行根组件的-destroyed-钩子函数。" class="headerlink" title="最后就是销毁组件的钩子函数  beforeDestroy  和  destroyed。前者适合移除事件、定时器等等，否则可能会引起内存泄露的问题。然后进行一系列的销毁操作，如果有子组件的话，也会递归销毁子组件，所有子组件都销毁完毕后才会执行根组件的  destroyed  钩子函数。"></a>最后就是销毁组件的钩子函数  beforeDestroy  和  destroyed。前者适合移除事件、定时器等等，否则可能会引起内存泄露的问题。然后进行一系列的销毁操作，如果有子组件的话，也会递归销毁子组件，所有子组件都销毁完毕后才会执行根组件的  destroyed  钩子函数。</h5>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>REACT_组件通信</title>
      <link href="/2018/03/25/react_fscom/"/>
      <url>/2018/03/25/react_fscom/</url>
      
        <content type="html"><![CDATA[<h3 id="父子组件通信"><a href="#父子组件通信" class="headerlink" title="父子组件通信"></a>父子组件通信</h3><h5 id="父组件通过-props-传递数据给子组件，子组件通过调用父组件传来的函数传递数据给父组件，这两种方式是最常用的父子通信实现办法。这种父子通信方式也就是典型的单向数据流，父组件通过-props-传递数据，子组件不能直接修改-props，-而是必须通过调用父组件函数的方式告知父组件修改数据。"><a href="#父组件通过-props-传递数据给子组件，子组件通过调用父组件传来的函数传递数据给父组件，这两种方式是最常用的父子通信实现办法。这种父子通信方式也就是典型的单向数据流，父组件通过-props-传递数据，子组件不能直接修改-props，-而是必须通过调用父组件函数的方式告知父组件修改数据。" class="headerlink" title="父组件通过  props  传递数据给子组件，子组件通过调用父组件传来的函数传递数据给父组件，这两种方式是最常用的父子通信实现办法。这种父子通信方式也就是典型的单向数据流，父组件通过  props  传递数据，子组件不能直接修改  props， 而是必须通过调用父组件函数的方式告知父组件修改数据。"></a>父组件通过  props  传递数据给子组件，子组件通过调用父组件传来的函数传递数据给父组件，这两种方式是最常用的父子通信实现办法。这种父子通信方式也就是典型的单向数据流，父组件通过  props  传递数据，子组件不能直接修改  props， 而是必须通过调用父组件函数的方式告知父组件修改数据。</h5><h3 id="兄弟组件通信"><a href="#兄弟组件通信" class="headerlink" title="兄弟组件通信"></a>兄弟组件通信</h3><h5 id="对于这种情况可以通过共同的父组件来管理状态和事件函数。比如说其中一个兄弟组件调用父组件传递过来的事件函数修改父组件中的状态，然后父组件将状态传递给另一个兄弟组件。"><a href="#对于这种情况可以通过共同的父组件来管理状态和事件函数。比如说其中一个兄弟组件调用父组件传递过来的事件函数修改父组件中的状态，然后父组件将状态传递给另一个兄弟组件。" class="headerlink" title="对于这种情况可以通过共同的父组件来管理状态和事件函数。比如说其中一个兄弟组件调用父组件传递过来的事件函数修改父组件中的状态，然后父组件将状态传递给另一个兄弟组件。"></a>对于这种情况可以通过共同的父组件来管理状态和事件函数。比如说其中一个兄弟组件调用父组件传递过来的事件函数修改父组件中的状态，然后父组件将状态传递给另一个兄弟组件。</h5><h3 id="跨多层次组件通信"><a href="#跨多层次组件通信" class="headerlink" title="跨多层次组件通信"></a>跨多层次组件通信</h3><h5 id="如果你使用-16-3-以上版本的话，对于这种情况可以使用-Context-API。"><a href="#如果你使用-16-3-以上版本的话，对于这种情况可以使用-Context-API。" class="headerlink" title="如果你使用 16.3 以上版本的话，对于这种情况可以使用 Context API。"></a>如果你使用 16.3 以上版本的话，对于这种情况可以使用 Context API。</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 创建 Context，可以在开始就传入值</span><br><span class="line">const StateContext = React.createContext()</span><br><span class="line">class Parent extends React.Component &#123;</span><br><span class="line">  <span class="function"><span class="title">render</span></span> () &#123;</span><br><span class="line">    <span class="built_in">return</span> (</span><br><span class="line">      // value 就是传入 Context 中的值</span><br><span class="line">      &lt;StateContext.Provider value=<span class="string">'yck'</span>&gt;</span><br><span class="line">        &lt;Child /&gt;</span><br><span class="line">      &lt;/StateContext.Provider&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Child extends React.Component &#123;</span><br><span class="line">  <span class="function"><span class="title">render</span></span> () &#123;</span><br><span class="line">    <span class="built_in">return</span> (</span><br><span class="line">      &lt;ThemeContext.Consumer&gt;</span><br><span class="line">        // 取出值</span><br><span class="line">        &#123;context =&gt; (</span><br><span class="line">          name is &#123; context &#125;</span><br><span class="line">        )&#125;</span><br><span class="line">      &lt;/ThemeContext.Consumer&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>REACT_setState</title>
      <link href="/2018/03/22/setStarte/"/>
      <url>/2018/03/22/setStarte/</url>
      
        <content type="html"><![CDATA[<h2 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h2><h3 id="setState-在-React-中是经常使用的一个-API，但是它存在一些的问题经常会导致初学者出错，核心原因就是因为这个-API-是异步的。首先-setState-的调用并不会马上引起-state-的改变，并且如果你一次调用了多个-setState-，那么结果可能并不如你期待的一样。"><a href="#setState-在-React-中是经常使用的一个-API，但是它存在一些的问题经常会导致初学者出错，核心原因就是因为这个-API-是异步的。首先-setState-的调用并不会马上引起-state-的改变，并且如果你一次调用了多个-setState-，那么结果可能并不如你期待的一样。" class="headerlink" title="setState 在 React 中是经常使用的一个 API，但是它存在一些的问题经常会导致初学者出错，核心原因就是因为这个 API 是异步的。首先  setState  的调用并不会马上引起  state  的改变，并且如果你一次调用了多个  setState ，那么结果可能并不如你期待的一样。"></a>setState 在 React 中是经常使用的一个 API，但是它存在一些的问题经常会导致初学者出错，核心原因就是因为这个 API 是异步的。首先  setState  的调用并不会马上引起  state  的改变，并且如果你一次调用了多个  setState ，那么结果可能并不如你期待的一样。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">handle</span></span>() &#123;</span><br><span class="line">  // 初始化 `count` 为 0</span><br><span class="line">  console.log(this.state.count) // -&gt; 0</span><br><span class="line">  this.setState(&#123; count: this.state.count + 1 &#125;)</span><br><span class="line">  this.setState(&#123; count: this.state.count + 1 &#125;)</span><br><span class="line">  this.setState(&#123; count: this.state.count + 1 &#125;)</span><br><span class="line">  console.log(this.state.count) // -&gt; 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第一，两次的打印都为-0，因为-setState-是个异步-API，只有同步代码运行完毕才会执行。setState-异步的原因我认为在于，setState-可能会导致-DOM-的重绘，如果调用一次就马上去进行重绘，那么调用多次就会造成不必要的性能损失。设计成异步的话，就可以将多次调用放入一个队列中，在恰当的时候统一进行更新过程。"><a href="#第一，两次的打印都为-0，因为-setState-是个异步-API，只有同步代码运行完毕才会执行。setState-异步的原因我认为在于，setState-可能会导致-DOM-的重绘，如果调用一次就马上去进行重绘，那么调用多次就会造成不必要的性能损失。设计成异步的话，就可以将多次调用放入一个队列中，在恰当的时候统一进行更新过程。" class="headerlink" title="第一，两次的打印都为 0，因为  setState  是个异步 API，只有同步代码运行完毕才会执行。setState  异步的原因我认为在于，setState  可能会导致 DOM 的重绘，如果调用一次就马上去进行重绘，那么调用多次就会造成不必要的性能损失。设计成异步的话，就可以将多次调用放入一个队列中，在恰当的时候统一进行更新过程。"></a>第一，两次的打印都为 0，因为  setState  是个异步 API，只有同步代码运行完毕才会执行。setState  异步的原因我认为在于，setState  可能会导致 DOM 的重绘，如果调用一次就马上去进行重绘，那么调用多次就会造成不必要的性能损失。设计成异步的话，就可以将多次调用放入一个队列中，在恰当的时候统一进行更新过程。</h3><h3 id="第二，虽然调用了三次-setState-，但是-count-的值还是为-1。因为多次调用会合并为一次，只有当更新结束后-state-才会改变，三次调用等同于如下代码"><a href="#第二，虽然调用了三次-setState-，但是-count-的值还是为-1。因为多次调用会合并为一次，只有当更新结束后-state-才会改变，三次调用等同于如下代码" class="headerlink" title="第二，虽然调用了三次  setState ，但是  count  的值还是为 1。因为多次调用会合并为一次，只有当更新结束后  state  才会改变，三次调用等同于如下代码"></a>第二，虽然调用了三次  setState ，但是  count  的值还是为 1。因为多次调用会合并为一次，只有当更新结束后  state  才会改变，三次调用等同于如下代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object.assign(</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  &#123; count: this.state.count + 1 &#125;,</span><br><span class="line">  &#123; count: this.state.count + 1 &#125;,</span><br><span class="line">  &#123; count: this.state.count + 1 &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="当然你也可以通过以下方式来实现调用三次-setState-使得-count-为-3"><a href="#当然你也可以通过以下方式来实现调用三次-setState-使得-count-为-3" class="headerlink" title="当然你也可以通过以下方式来实现调用三次  setState  使得  count  为 3"></a>当然你也可以通过以下方式来实现调用三次  setState  使得  count  为 3</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">handle</span></span>() &#123;</span><br><span class="line">  this.setState((prevState) =&gt; (&#123; count: prevState.count + 1 &#125;))</span><br><span class="line">  this.setState((prevState) =&gt; (&#123; count: prevState.count + 1 &#125;))</span><br><span class="line">  this.setState((prevState) =&gt; (&#123; count: prevState.count + 1 &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如果你想在每次调用-setState-后获得正确的-state-，可以通过如下代码实现"><a href="#如果你想在每次调用-setState-后获得正确的-state-，可以通过如下代码实现" class="headerlink" title="如果你想在每次调用  setState  后获得正确的  state ，可以通过如下代码实现"></a>如果你想在每次调用  setState  后获得正确的  state ，可以通过如下代码实现</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">handle</span></span>() &#123;</span><br><span class="line">    this.setState((prevState) =&gt; (&#123; count: prevState.count + 1 &#125;), () =&gt; &#123;</span><br><span class="line">        console.log(this.state)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
