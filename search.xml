<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>es6_Decorator</title>
      <link href="/2019/04/11/es6-Decorator/"/>
      <url>/2019/04/11/es6-Decorator/</url>
      
        <content type="html"><![CDATA[<h3 id="ES6-修饰器"><a href="#ES6-修饰器" class="headerlink" title="ES6 修饰器"></a>ES6 修饰器</h3><h4 id="类的修饰"><a href="#类的修饰" class="headerlink" title="类的修饰"></a>类的修饰</h4><p>修饰器（Decorator）是一个函数，用来修改类的行为。这是 ES7 的一个提案，目前 Babel 转码器已经支持。</p><p>修饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。这意味着，修饰器能在编译阶段运行代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> testable(target) &#123;</span><br><span class="line">  target.isTestable = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@testable</span><br><span class="line">class MyTestableClass &#123;&#125;</span><br><span class="line"></span><br><span class="line">console.log(MyTestableClass.isTestable) // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>上面代码中，@testable 就是一个修饰器。它修改了 MyTestableClass 这个类的行为，为它加上了静态属性 isTestable。</p><p>基本上，修饰器的行为就是下面这样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@decorator</span><br><span class="line">class A &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line"></span><br><span class="line">class A &#123;&#125;</span><br><span class="line">A = decorator(A) || A;</span><br></pre></td></tr></table></figure><p>也就是说，修饰器本质就是编译时执行的函数。</p><p>修饰器函数的第一个参数，就是所要修饰的目标类。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> testable(target) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，testable 函数的参数 target，就是会被修饰的类。</p><p>如果觉得一个参数不够用，可以在修饰器外面再封装一层函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> testable(isTestable) &#123;</span><br><span class="line">  <span class="built_in">return</span> <span class="keyword">function</span>(target) &#123;</span><br><span class="line">    target.isTestable = isTestable;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@testable(<span class="literal">true</span>)</span><br><span class="line">class MyTestableClass &#123;&#125;</span><br><span class="line">MyTestableClass.isTestable // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">@testable(<span class="literal">false</span>)</span><br><span class="line">class MyClass &#123;&#125;</span><br><span class="line">MyClass.isTestable // <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>上面代码中，修饰器 testable 可以接受参数，这就等于可以修改修饰器的行为。</p><p>前面的例子是为类添加一个静态属性，如果想添加实例属性，可以通过目标类的 prototype 对象操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> testable(target) &#123;</span><br><span class="line">  target.prototype.isTestable = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@testable</span><br><span class="line">class MyTestableClass &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> obj = new MyTestableClass();</span><br><span class="line">obj.isTestable // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>上面代码中，修饰器函数 testable 是在目标类的 prototype 对象上添加属性，因此就可以在实例上调用。</p><p>下面是另外一个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// mixins.js</span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> mixins(...list) &#123;</span><br><span class="line">  <span class="built_in">return</span> <span class="keyword">function</span> (target) &#123;</span><br><span class="line">    Object.assign(target.prototype, ...list)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// main.js</span><br><span class="line">import &#123; mixins &#125; from <span class="string">'./mixins'</span></span><br><span class="line"></span><br><span class="line">const Foo = &#123;</span><br><span class="line">  <span class="function"><span class="title">foo</span></span>() &#123; console.log(<span class="string">'foo'</span>) &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@mixins(Foo)</span><br><span class="line">class MyClass &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> obj = new MyClass();</span><br><span class="line">obj.foo() // <span class="string">'foo'</span></span><br></pre></td></tr></table></figure><p>上面代码通过修饰器 mixins，把 Foo 类的方法添加到了 MyClass 的实例上面。可以用 Object.assign()模拟这个功能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const Foo = &#123;</span><br><span class="line">  <span class="function"><span class="title">foo</span></span>() &#123; console.log(<span class="string">'foo'</span>) &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class MyClass &#123;&#125;</span><br><span class="line"></span><br><span class="line">Object.assign(MyClass.prototype, Foo);</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> obj = new MyClass();</span><br><span class="line">obj.foo() // <span class="string">'foo'</span></span><br></pre></td></tr></table></figure><h4 id="方法的修饰"><a href="#方法的修饰" class="headerlink" title="方法的修饰"></a>方法的修饰</h4><p>修饰器不仅可以修饰类，还可以修饰类的属性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  @<span class="built_in">readonly</span></span><br><span class="line">  <span class="function"><span class="title">name</span></span>() &#123; <span class="built_in">return</span> `<span class="variable">$&#123;this.first&#125;</span> <span class="variable">$&#123;this.last&#125;</span>` &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，修饰器 readonly 用来修饰“类”的 name 方法。</p><p>此时，修饰器函数一共可以接受三个参数，第一个参数是所要修饰的目标对象，第二个参数是所要修饰的属性名，第三个参数是该属性的描述对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="built_in">readonly</span>(target, name, descriptor)&#123;</span><br><span class="line">  // descriptor对象原来的值如下</span><br><span class="line">  // &#123;</span><br><span class="line">  //   value: specifiedFunction,</span><br><span class="line">  //   enumerable: <span class="literal">false</span>,</span><br><span class="line">  //   configurable: <span class="literal">true</span>,</span><br><span class="line">  //   writable: <span class="literal">true</span></span><br><span class="line">  // &#125;;</span><br><span class="line">  descriptor.writable = <span class="literal">false</span>;</span><br><span class="line">  <span class="built_in">return</span> descriptor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">readonly</span>(Person.prototype, <span class="string">'name'</span>, descriptor);</span><br><span class="line">// 类似于</span><br><span class="line">Object.defineProperty(Person.prototype, <span class="string">'name'</span>, descriptor);</span><br></pre></td></tr></table></figure><p>上面代码说明，修饰器（readonly）会修改属性的描述对象（descriptor），然后被修改的描述对象再用来定义属性。</p><p>下面是另一个例子，修改属性描述对象的 enumerable 属性，使得该属性不可遍历。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  @nonenumerable</span><br><span class="line">  get <span class="function"><span class="title">kidCount</span></span>() &#123; <span class="built_in">return</span> this.children.length; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> nonenumerable(target, name, descriptor) &#123;</span><br><span class="line">  descriptor.enumerable = <span class="literal">false</span>;</span><br><span class="line">  <span class="built_in">return</span> descriptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的@log 修饰器，可以起到输出日志的作用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Math &#123;</span><br><span class="line">  @<span class="built_in">log</span></span><br><span class="line">  add(a, b) &#123;</span><br><span class="line">    <span class="built_in">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="built_in">log</span>(target, name, descriptor) &#123;</span><br><span class="line">  var oldValue = descriptor.value;</span><br><span class="line"></span><br><span class="line">  descriptor.value = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log(`Calling <span class="string">"<span class="variable">$&#123;name&#125;</span>"</span> with`, arguments);</span><br><span class="line">    <span class="built_in">return</span> oldValue.apply(null, arguments);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> descriptor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const math = new Math();</span><br><span class="line"></span><br><span class="line">// passed parameters should get logged now</span><br><span class="line">math.add(2, 4);</span><br></pre></td></tr></table></figure><p>上面代码中，@log 修饰器的作用就是在执行原始的操作之前，执行一次 console.log，从而达到输出日志的目的。</p><p>修饰器有注释的作用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@testable</span><br><span class="line">class Person &#123;</span><br><span class="line">  @<span class="built_in">readonly</span></span><br><span class="line">  @nonenumerable</span><br><span class="line">  <span class="function"><span class="title">name</span></span>() &#123; <span class="built_in">return</span> `<span class="variable">$&#123;this.first&#125;</span> <span class="variable">$&#123;this.last&#125;</span>` &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码中，我们一眼就能看出，Person 类是可测试的，而 name 方法是只读和不可枚举的。</p><p>如果同一个方法有多个修饰器，会像剥洋葱一样，先从外到内进入，然后由内向外执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> dec(id)&#123;</span><br><span class="line">    console.log(<span class="string">'evaluated'</span>, id);</span><br><span class="line">    <span class="built_in">return</span> (target, property, descriptor) =&gt; console.log(<span class="string">'executed'</span>, id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Example &#123;</span><br><span class="line">    @dec(1)</span><br><span class="line">    @dec(2)</span><br><span class="line">    <span class="function"><span class="title">method</span></span>()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">// evaluated 1</span><br><span class="line">// evaluated 2</span><br><span class="line">// executed 2</span><br><span class="line">// executed 1</span><br></pre></td></tr></table></figure><p>上面代码中，外层修饰器@dec(1)先进入，但是内层修饰器@dec(2)先执行。</p><p>除了注释，修饰器还能用来类型检查。所以，对于类来说，这项功能相当有用。从长期来看，它将是 JavaScript 代码静态分析的重要工具。</p><h4 id="为什么修饰器不能用于函数？"><a href="#为什么修饰器不能用于函数？" class="headerlink" title="为什么修饰器不能用于函数？"></a>为什么修饰器不能用于函数？</h4><p>修饰器只能用于类和类的方法，不能用于函数，因为存在函数提升。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var counter = 0;</span><br><span class="line"></span><br><span class="line">var add = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@add</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码，意图是执行后 counter 等于 1，但是实际上结果是 counter 等于 0。因为函数提升，使得实际执行的代码是下面这样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var counter;</span><br><span class="line">var add;</span><br><span class="line"></span><br><span class="line">@add</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">counter = 0;</span><br><span class="line"></span><br><span class="line">add = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面是另一个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var readOnly = require(<span class="string">"some-decorator"</span>);</span><br><span class="line"></span><br><span class="line">@readOnly</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码也有问题，因为实际执行是下面这样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var readOnly;</span><br><span class="line"></span><br><span class="line">@readOnly</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">readOnly = require(<span class="string">"some-decorator"</span>);</span><br></pre></td></tr></table></figure><p>总之，由于存在函数提升，使得修饰器不能用于函数。类是不会提升的，所以就没有这方面的问题。</p><h4 id="core-decorators-js"><a href="#core-decorators-js" class="headerlink" title="core-decorators.js"></a>core-decorators.js</h4><p>core-decorators.js 是一个第三方模块，提供了几个常见的修饰器，通过它可以更好地理解修饰器。</p><h5 id="autobind"><a href="#autobind" class="headerlink" title="@autobind"></a>@autobind</h5><p>autobind 修饰器使得方法中的 this 对象，绑定原始对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import &#123; autobind &#125; from <span class="string">'core-decorators'</span>;</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">  @autobind</span><br><span class="line">  <span class="function"><span class="title">getPerson</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> this;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> person = new Person();</span><br><span class="line"><span class="built_in">let</span> getPerson = person.getPerson;</span><br><span class="line"></span><br><span class="line">getPerson() === person;</span><br><span class="line">// <span class="literal">true</span></span><br></pre></td></tr></table></figure><h5 id="readonly"><a href="#readonly" class="headerlink" title="@readonly"></a>@readonly</h5><p>readonly 修饰器使得属性或方法不可写。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#123; <span class="built_in">readonly</span> &#125; from <span class="string">'core-decorators'</span>;</span><br><span class="line"></span><br><span class="line">class Meal &#123;</span><br><span class="line">  @<span class="built_in">readonly</span></span><br><span class="line">  entree = <span class="string">'steak'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var dinner = new Meal();</span><br><span class="line">dinner.entree = <span class="string">'salmon'</span>;</span><br><span class="line">// Cannot assign to <span class="built_in">read</span> only property <span class="string">'entree'</span> of [object Object]</span><br></pre></td></tr></table></figure><h5 id="override"><a href="#override" class="headerlink" title="@override"></a>@override</h5><p>override 修饰器检查子类的方法，是否正确覆盖了父类的同名方法，如果不正确会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import &#123; override &#125; from <span class="string">'core-decorators'</span>;</span><br><span class="line"></span><br><span class="line">class Parent &#123;</span><br><span class="line">  speak(first, second) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Parent &#123;</span><br><span class="line">  @override</span><br><span class="line">  <span class="function"><span class="title">speak</span></span>() &#123;&#125;</span><br><span class="line">  // SyntaxError: Child<span class="comment">#speak() does not properly override Parent#speak(first, second)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// or</span><br><span class="line"></span><br><span class="line">class Child extends Parent &#123;</span><br><span class="line">@override</span><br><span class="line"><span class="function"><span class="title">speaks</span></span>() &#123;&#125;</span><br><span class="line">// SyntaxError: No descriptor matching Child<span class="comment">#speaks() was found on the prototype chain.</span></span><br><span class="line">//</span><br><span class="line">// Did you mean <span class="string">"speak"</span>?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="deprecate-别名-deprecated"><a href="#deprecate-别名-deprecated" class="headerlink" title="@deprecate (别名@deprecated)"></a>@deprecate (别名@deprecated)</h5><p>deprecate 或 deprecated 修饰器在控制台显示一条警告，表示该方法将废除。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import &#123; deprecate &#125; from <span class="string">'core-decorators'</span>;</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">  @deprecate</span><br><span class="line">  <span class="function"><span class="title">facepalm</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  @deprecate(<span class="string">'We stopped facepalming'</span>)</span><br><span class="line">  <span class="function"><span class="title">facepalmHard</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  @deprecate(<span class="string">'We stopped facepalming'</span>, &#123; url: <span class="string">'http://knowyourmeme.com/memes/facepalm'</span> &#125;)</span><br><span class="line">  <span class="function"><span class="title">facepalmHarder</span></span>() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> person = new Person();</span><br><span class="line"></span><br><span class="line">person.facepalm();</span><br><span class="line">// DEPRECATION Person<span class="comment">#facepalm: This function will be removed in future versions.</span></span><br><span class="line"></span><br><span class="line">person.facepalmHard();</span><br><span class="line">// DEPRECATION Person<span class="comment">#facepalmHard: We stopped facepalming</span></span><br><span class="line"></span><br><span class="line">person.facepalmHarder();</span><br><span class="line">// DEPRECATION Person<span class="comment">#facepalmHarder: We stopped facepalming</span></span><br><span class="line">//</span><br><span class="line">// See http://knowyourmeme.com/memes/facepalm <span class="keyword">for</span> more details.</span><br><span class="line">//</span><br></pre></td></tr></table></figure><h5 id="suppressWarnings"><a href="#suppressWarnings" class="headerlink" title="@suppressWarnings"></a>@suppressWarnings</h5><p>suppressWarnings 修饰器抑制 decorated 修饰器导致的 console.warn()调用。但是，异步代码发出的调用除外。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import &#123; suppressWarnings &#125; from <span class="string">'core-decorators'</span>;</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">  @deprecated</span><br><span class="line">  <span class="function"><span class="title">facepalm</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  @suppressWarnings</span><br><span class="line">  <span class="function"><span class="title">facepalmWithoutWarning</span></span>() &#123;</span><br><span class="line">    this.facepalm();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> person = new Person();</span><br><span class="line"></span><br><span class="line">person.facepalmWithoutWarning();</span><br><span class="line">// no warning is logged</span><br></pre></td></tr></table></figure><h4 id="使用修饰器实现自动发布事件"><a href="#使用修饰器实现自动发布事件" class="headerlink" title="使用修饰器实现自动发布事件"></a>使用修饰器实现自动发布事件</h4><p>我们可以使用修饰器，使得对象的方法被调用时，自动发出一个事件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import postal from <span class="string">"postal/lib/postal.lodash"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default <span class="keyword">function</span> publish(topic, channel) &#123;</span><br><span class="line">  <span class="built_in">return</span> <span class="keyword">function</span>(target, name, descriptor) &#123;</span><br><span class="line">    const fn = descriptor.value;</span><br><span class="line"></span><br><span class="line">    descriptor.value = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">      <span class="built_in">let</span> value = fn.apply(this, arguments);</span><br><span class="line">      postal.channel(channel || target.channel || <span class="string">"/"</span>).publish(topic, value);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码定义了一个名为 publish 的修饰器，它通过改写 descriptor.value，使得原方法被调用时，会自动发出一个事件。它使用的事件“发布/订阅”库是 Postal.js。</p><p>它的用法如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import publish from <span class="string">"path/to/decorators/publish"</span>;</span><br><span class="line"></span><br><span class="line">class FooComponent &#123;</span><br><span class="line">  @publish(<span class="string">"foo.some.message"</span>, <span class="string">"component"</span>)</span><br><span class="line">  <span class="function"><span class="title">someMethod</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">      my: <span class="string">"data"</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  @publish(<span class="string">"foo.some.other"</span>)</span><br><span class="line">  <span class="function"><span class="title">anotherMethod</span></span>() &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以后，只要调用 someMethod 或者 anotherMethod，就会自动发出一个事件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> foo = new FooComponent();</span><br><span class="line"></span><br><span class="line">foo.someMethod() // 在<span class="string">"component"</span>频道发布<span class="string">"foo.some.message"</span>事件，附带的数据是&#123; my: <span class="string">"data"</span> &#125;</span><br><span class="line">foo.anotherMethod() // 在<span class="string">"/"</span>频道发布<span class="string">"foo.some.other"</span>事件，不附带数据</span><br></pre></td></tr></table></figure><h4 id="Mixin"><a href="#Mixin" class="headerlink" title="Mixin"></a>Mixin</h4><p>在修饰器的基础上，可以实现 Mixin 模式。所谓 Mixin 模式，就是对象继承的一种替代方案，中文译为“混入”（mix in），意为在一个对象之中混入另外一个对象的方法。</p><p>请看下面的例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const Foo = &#123;</span><br><span class="line">  <span class="function"><span class="title">foo</span></span>() &#123; console.log(<span class="string">'foo'</span>) &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class MyClass &#123;&#125;</span><br><span class="line"></span><br><span class="line">Object.assign(MyClass.prototype, Foo);</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> obj = new MyClass();</span><br><span class="line">obj.foo() // <span class="string">'foo'</span></span><br></pre></td></tr></table></figure><p>上面代码之中，对象 Foo 有一个 foo 方法，通过 Object.assign 方法，可以将 foo 方法“混入”MyClass 类，导致 MyClass 的实例 obj 对象都具有 foo 方法。这就是“混入”模式的一个简单实现。</p><p>下面，我们部署一个通用脚本 mixins.js，将 mixin 写成一个修饰器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> mixins(...list) &#123;</span><br><span class="line">  <span class="built_in">return</span> <span class="keyword">function</span> (target) &#123;</span><br><span class="line">    Object.assign(target.prototype, ...list);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，就可以使用上面这个修饰器，为类“混入”各种方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mixins &#125; from <span class="string">'./mixins'</span>;</span><br><span class="line"></span><br><span class="line">const Foo = &#123;</span><br><span class="line">  <span class="function"><span class="title">foo</span></span>() &#123; console.log(<span class="string">'foo'</span>) &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@mixins(Foo)</span><br><span class="line">class MyClass &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> obj = new MyClass();</span><br><span class="line">obj.foo() // <span class="string">"foo"</span></span><br></pre></td></tr></table></figure><p>通过 mixins 这个修饰器，实现了在 MyClass 类上面“混入”Foo 对象的 foo 方法。</p><p>不过，上面的方法会改写 MyClass 类的 prototype 对象，如果不喜欢这一点，也可以通过类的继承实现 mixin。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class MyClass extends MyBaseClass &#123;</span><br><span class="line">  /* ... */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，MyClass 继承了 MyBaseClass。如果我们想在 MyClass 里面“混入”一个 foo 方法，一个办法是在 MyClass 和 MyBaseClass 之间插入一个混入类，这个类具有 foo 方法，并且继承了 MyBaseClass 的所有方法，然后 MyClass 再继承这个类。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> MyMixin = (superclass) =&gt; class extends superclass &#123;</span><br><span class="line">  <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'foo from MyMixin'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，MyMixin 是一个混入类生成器，接受 superclass 作为参数，然后返回一个继承 superclass 的子类，该子类包含一个 foo 方法。</p><p>接着，目标类再去继承这个混入类，就达到了“混入”foo 方法的目的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class MyClass extends MyMixin(MyBaseClass) &#123;</span><br><span class="line">  /* ... */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> c = new MyClass();</span><br><span class="line">c.foo(); // <span class="string">"foo from MyMixin"</span></span><br></pre></td></tr></table></figure><p>如果需要“混入”多个方法，就生成多个混入类。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class MyClass extends Mixin1(Mixin2(MyBaseClass)) &#123;</span><br><span class="line">  /* ... */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法的一个好处，是可以调用 super，因此可以避免在“混入”过程中覆盖父类的同名方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> Mixin1 = (superclass) =&gt; class extends superclass &#123;</span><br><span class="line">  <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'foo from Mixin1'</span>);</span><br><span class="line">    <span class="keyword">if</span> (super.foo) super.foo();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> Mixin2 = (superclass) =&gt; class extends superclass &#123;</span><br><span class="line">  <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'foo from Mixin2'</span>);</span><br><span class="line">    <span class="keyword">if</span> (super.foo) super.foo();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class S &#123;</span><br><span class="line">  <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'foo from S'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C extends Mixin1(Mixin2(S)) &#123;</span><br><span class="line">  <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'foo from C'</span>);</span><br><span class="line">    super.foo();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，每一次混入发生时，都调用了父类的 super.foo 方法，导致父类的同名方法没有被覆盖，行为被保留了下来。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new C().foo()</span><br><span class="line">// foo from C</span><br><span class="line">// foo from Mixin1</span><br><span class="line">// foo from Mixin2</span><br><span class="line">// foo from S</span><br></pre></td></tr></table></figure><h4 id="Trait"><a href="#Trait" class="headerlink" title="Trait"></a>Trait</h4><p>Trait 也是一种修饰器，效果与 Mixin 类似，但是提供更多功能，比如防止同名方法的冲突、排除混入某些方法、为混入的方法起别名等等。</p><p>下面采用 traits-decorator 这个第三方模块作为例子。这个模块提供的 traits 修饰器，不仅可以接受对象，还可以接受 ES6 类作为参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import &#123; traits &#125; from <span class="string">'traits-decorator'</span>;</span><br><span class="line"></span><br><span class="line">class TFoo &#123;</span><br><span class="line">  <span class="function"><span class="title">foo</span></span>() &#123; console.log(<span class="string">'foo'</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const TBar = &#123;</span><br><span class="line">  <span class="function"><span class="title">bar</span></span>() &#123; console.log(<span class="string">'bar'</span>) &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@traits(TFoo, TBar)</span><br><span class="line">class MyClass &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> obj = new MyClass();</span><br><span class="line">obj.foo() // foo</span><br><span class="line">obj.bar() // bar</span><br></pre></td></tr></table></figure><p>上面代码中，通过 traits 修饰器，在 MyClass 类上面“混入”了 TFoo 类的 foo 方法和 TBar 对象的 bar 方法。</p><p>Trait 不允许“混入”同名方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import &#123; traits &#125; from <span class="string">'traits-decorator'</span>;</span><br><span class="line"></span><br><span class="line">class TFoo &#123;</span><br><span class="line">  <span class="function"><span class="title">foo</span></span>() &#123; console.log(<span class="string">'foo'</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const TBar = &#123;</span><br><span class="line">  <span class="function"><span class="title">bar</span></span>() &#123; console.log(<span class="string">'bar'</span>) &#125;,</span><br><span class="line">  <span class="function"><span class="title">foo</span></span>() &#123; console.log(<span class="string">'foo'</span>) &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@traits(TFoo, TBar)</span><br><span class="line">class MyClass &#123; &#125;</span><br><span class="line">// 报错</span><br><span class="line">// throw new Error(<span class="string">'Method named: '</span> + methodName + <span class="string">' is defined twice.'</span>);</span><br><span class="line">//        ^</span><br><span class="line">// Error: Method named: foo is defined twice.</span><br></pre></td></tr></table></figure><p>上面代码中，TFoo 和 TBar 都有 foo 方法，结果 traits 修饰器报错。</p><p>一种解决方法是排除 TBar 的 foo 方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import &#123; traits, excludes &#125; from <span class="string">'traits-decorator'</span>;</span><br><span class="line"></span><br><span class="line">class TFoo &#123;</span><br><span class="line">  <span class="function"><span class="title">foo</span></span>() &#123; console.log(<span class="string">'foo'</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const TBar = &#123;</span><br><span class="line">  <span class="function"><span class="title">bar</span></span>() &#123; console.log(<span class="string">'bar'</span>) &#125;,</span><br><span class="line">  <span class="function"><span class="title">foo</span></span>() &#123; console.log(<span class="string">'foo'</span>) &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@traits(TFoo, TBar::excludes(<span class="string">'foo'</span>))</span><br><span class="line">class MyClass &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> obj = new MyClass();</span><br><span class="line">obj.foo() // foo</span><br><span class="line">obj.bar() // bar</span><br></pre></td></tr></table></figure><p>上面代码使用绑定运算符（::）在 TBar 上排除 foo 方法，混入时就不会报错了。</p><p>另一种方法是为 TBar 的 foo 方法起一个别名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import &#123; traits, <span class="built_in">alias</span> &#125; from <span class="string">'traits-decorator'</span>;</span><br><span class="line"></span><br><span class="line">class TFoo &#123;</span><br><span class="line">  <span class="function"><span class="title">foo</span></span>() &#123; console.log(<span class="string">'foo'</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const TBar = &#123;</span><br><span class="line">  <span class="function"><span class="title">bar</span></span>() &#123; console.log(<span class="string">'bar'</span>) &#125;,</span><br><span class="line">  <span class="function"><span class="title">foo</span></span>() &#123; console.log(<span class="string">'foo'</span>) &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@traits(TFoo, TBar::<span class="built_in">alias</span>(&#123;foo: <span class="string">'aliasFoo'</span>&#125;))</span><br><span class="line">class MyClass &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> obj = new MyClass();</span><br><span class="line">obj.foo() // foo</span><br><span class="line">obj.aliasFoo() // foo</span><br><span class="line">obj.bar() // bar</span><br></pre></td></tr></table></figure><p>上面代码为 TBar 的 foo 方法起了别名 aliasFoo，于是 MyClass 也可以混入 TBar 的 foo 方法了。</p><p>alias 和 excludes 方法，可以结合起来使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@traits(TExample::excludes(<span class="string">'foo'</span>,<span class="string">'bar'</span>)::<span class="built_in">alias</span>(&#123;baz:<span class="string">'exampleBaz'</span>&#125;))</span><br><span class="line">class MyClass &#123;&#125;</span><br></pre></td></tr></table></figure><p>上面代码排除了 TExample 的 foo 方法和 bar 方法，为 baz 方法起了别名 exampleBaz。</p><p>as 方法则为上面的代码提供了另一种写法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@traits(TExample::as(&#123;excludes:[<span class="string">'foo'</span>, <span class="string">'bar'</span>], <span class="built_in">alias</span>: &#123;baz: <span class="string">'exampleBaz'</span>&#125;&#125;))</span><br><span class="line">class MyClass &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="Babel-转码器的支持"><a href="#Babel-转码器的支持" class="headerlink" title="Babel 转码器的支持"></a>Babel 转码器的支持</h4><p>目前，Babel 转码器已经支持 Decorator。</p><p>首先，安装 babel-core 和 babel-plugin-transform-decorators。由于后者包括在 babel-preset-stage-0 之中，所以改为安装 babel-preset-stage-0 亦可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install babel-core babel-plugin-transform-decorators</span><br></pre></td></tr></table></figure><p>然后，设置配置文件.babelrc。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"plugins"</span>: [<span class="string">"transform-decorators"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时，Babel 就可以对 Decorator 转码了。</p><p>脚本中打开的命令如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">babel.transform(<span class="string">"code"</span>, &#123;plugins: [<span class="string">"transform-decorators"</span>]&#125;)</span><br></pre></td></tr></table></figure><p>Babel 的官方网站提供一个在线转码器，只要勾选 Experimental，就能支持 Decorator 的在线转码。</p>]]></content>
      
      
      <categories>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6_Class</title>
      <link href="/2019/04/08/es6-Class/"/>
      <url>/2019/04/08/es6-Class/</url>
      
        <content type="html"><![CDATA[<h3 id="ES6-class"><a href="#ES6-class" class="headerlink" title="ES6 class"></a>ES6 class</h3><h4 id="Class-基本语法"><a href="#Class-基本语法" class="headerlink" title="Class 基本语法"></a>Class 基本语法</h4><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p>JavaScript 语言的传统方法是通过构造函数，定义并生成新对象。下面是一个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Point(x, y) &#123;</span><br><span class="line">  this.x = x;</span><br><span class="line">  this.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point.prototype.toString = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  <span class="built_in">return</span> <span class="string">'('</span> + this.x + <span class="string">', '</span> + this.y + <span class="string">')'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var p = new Point(1, 2);</span><br></pre></td></tr></table></figure><p>上面这种写法跟传统的面向对象语言（比如 C++和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑。</p><p>ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过 class 关键字，可以定义类。基本上，ES6 的 class 可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的 class 写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的“类”改写，就是下面这样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//定义类</span><br><span class="line">class Point &#123;</span><br><span class="line">  constructor(x, y) &#123;</span><br><span class="line">    this.x = x;</span><br><span class="line">    this.y = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">'('</span> + this.x + <span class="string">', '</span> + this.y + <span class="string">')'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码定义了一个“类”，可以看到里面有一个 constructor 方法，这就是构造方法，而 this 关键字则代表实例对象。也就是说，ES5 的构造函数 Point，对应 ES6 的 Point 类的构造方法。</p><p>Point 类除了构造方法，还定义了一个 toString 方法。注意，定义“类”的方法的时候，前面不需要加上 function 这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。</p><p>ES6 的类，完全可以看作构造函数的另一种写法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typeof Point // <span class="string">"function"</span></span><br><span class="line">Point === Point.prototype.constructor // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>上面代码表明，类的数据类型就是函数，类本身就指向构造函数。</p><p>使用的时候，也是直接对类使用 new 命令，跟构造函数的用法完全一致。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Bar &#123;</span><br><span class="line">  <span class="function"><span class="title">doStuff</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'stuff'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var b = new Bar();</span><br><span class="line">b.doStuff() // <span class="string">"stuff"</span></span><br></pre></td></tr></table></figure><p>构造函数的 prototype 属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的 prototype 属性上面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>()&#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">toString</span></span>()&#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">toValue</span></span>()&#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line"></span><br><span class="line">Point.prototype = &#123;</span><br><span class="line">  <span class="function"><span class="title">toString</span></span>()&#123;&#125;,</span><br><span class="line">  <span class="function"><span class="title">toValue</span></span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在类的实例上面调用方法，其实就是调用原型上的方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class B &#123;&#125;</span><br><span class="line"><span class="built_in">let</span> b = new B();</span><br><span class="line"></span><br><span class="line">b.constructor === B.prototype.constructor // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>上面代码中，b 是 B 类的实例，它的 constructor 方法就是 B 类原型的 constructor 方法。</p><p>由于类的方法都定义在 prototype 对象上面，所以类的新方法可以添加在 prototype 对象上面。Object.assign 方法可以很方便地一次向类添加多个方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>()&#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object.assign(Point.prototype, &#123;</span><br><span class="line">  <span class="function"><span class="title">toString</span></span>()&#123;&#125;,</span><br><span class="line">  <span class="function"><span class="title">toValue</span></span>()&#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>prototype 对象的 constructor 属性，直接指向“类”的本身，这与 ES5 的行为是一致的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point.prototype.constructor === Point // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  constructor(x, y) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object.keys(Point.prototype)</span><br><span class="line">// []</span><br><span class="line">Object.getOwnPropertyNames(Point.prototype)</span><br><span class="line">// [<span class="string">"constructor"</span>,<span class="string">"toString"</span>]</span><br></pre></td></tr></table></figure><p>上面代码中，toString 方法是 Point 类内部定义的方法，它是不可枚举的。这一点与 ES5 的行为不一致。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var Point = <span class="keyword">function</span> (x, y) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point.prototype.toString = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.keys(Point.prototype)</span><br><span class="line">// [<span class="string">"toString"</span>]</span><br><span class="line">Object.getOwnPropertyNames(Point.prototype)</span><br><span class="line">// [<span class="string">"constructor"</span>,<span class="string">"toString"</span>]</span><br></pre></td></tr></table></figure><p>上面代码采用 ES5 的写法，toString 方法就是可枚举的。</p><p>类的属性名，可以采用表达式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> methodName = <span class="string">"getArea"</span>;</span><br><span class="line">class Square&#123;</span><br><span class="line">  constructor(length) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [methodName]() &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，Square 类的方法名 getArea，是从表达式得到的。</p><h5 id="constructor-方法"><a href="#constructor-方法" class="headerlink" title="constructor 方法"></a>constructor 方法</h5><p>constructor 方法是类的默认方法，通过 new 命令生成对象实例时，自动调用该方法。一个类必须有 constructor 方法，如果没有显式定义，一个空的 constructor 方法会被默认添加。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure><p>constructor 方法默认返回实例对象（即 this），完全可以指定返回另外一个对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> Object.create(null);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new Foo() instanceof Foo</span><br><span class="line">// <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>上面代码中，constructor 函数返回一个全新的对象，结果导致实例对象不是 Foo 类的实例。</p><p>类的构造函数，不使用 new 是没法调用的，会报错。这是它跟普通构造函数的一个主要区别，后者不用 new 也可以执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> Object.create(null);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo()</span><br><span class="line">// TypeError: Class constructor Foo cannot be invoked without <span class="string">'new'</span></span><br></pre></td></tr></table></figure><h5 id="类的实例对象"><a href="#类的实例对象" class="headerlink" title="类的实例对象"></a>类的实例对象</h5><p>生成类的实例对象的写法，与 ES5 完全一样，也是使用 new 命令。如果忘记加上 new，像函数那样调用 Class，将会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line">var point = Point(2, 3);</span><br><span class="line"></span><br><span class="line">// 正确</span><br><span class="line">var point = new Point(2, 3);</span><br></pre></td></tr></table></figure><p>与 ES5 一样，实例的属性除非显式定义在其本身（即定义在 this 对象上），否则都是定义在原型上（即定义在 class 上）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//定义类</span><br><span class="line">class Point &#123;</span><br><span class="line"></span><br><span class="line">  constructor(x, y) &#123;</span><br><span class="line">    this.x = x;</span><br><span class="line">    this.y = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">'('</span> + this.x + <span class="string">', '</span> + this.y + <span class="string">')'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var point = new Point(2, 3);</span><br><span class="line"></span><br><span class="line">point.toString() // (2, 3)</span><br><span class="line"></span><br><span class="line">point.hasOwnProperty(<span class="string">'x'</span>) // <span class="literal">true</span></span><br><span class="line">point.hasOwnProperty(<span class="string">'y'</span>) // <span class="literal">true</span></span><br><span class="line">point.hasOwnProperty(<span class="string">'toString'</span>) // <span class="literal">false</span></span><br><span class="line">point.__proto__.hasOwnProperty(<span class="string">'toString'</span>) // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>上面代码中，x 和 y 都是实例对象 point 自身的属性（因为定义在 this 变量上），所以 hasOwnProperty 方法返回 true，而 toString 是原型对象的属性（因为定义在 Point 类上），所以 hasOwnProperty 方法返回 false。这些都与 ES5 的行为保持一致。</p><p>与 ES5 一样，类的所有实例共享一个原型对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var p1 = new Point(2,3);</span><br><span class="line">var p2 = new Point(3,2);</span><br><span class="line"></span><br><span class="line">p1.__proto__ === p2.__proto__</span><br><span class="line">//<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>上面代码中，p1 和 p2 都是 Point 的实例，它们的原型都是 Point.prototype，所以<strong>proto</strong>属性是相等的。</p><p>这也意味着，可以通过实例的<strong>proto</strong>属性为 Class 添加方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var p1 = new Point(2,3);</span><br><span class="line">var p2 = new Point(3,2);</span><br><span class="line"></span><br><span class="line">p1.__proto__.printName = <span class="function"><span class="title">function</span></span> () &#123; <span class="built_in">return</span> <span class="string">'Oops'</span> &#125;;</span><br><span class="line"></span><br><span class="line">p1.printName() // <span class="string">"Oops"</span></span><br><span class="line">p2.printName() // <span class="string">"Oops"</span></span><br><span class="line"></span><br><span class="line">var p3 = new Point(4,2);</span><br><span class="line">p3.printName() // <span class="string">"Oops"</span></span><br></pre></td></tr></table></figure><p>上面代码在 p1 的原型上添加了一个 printName 方法，由于 p1 的原型就是 p2 的原型，因此 p2 也可以调用这个方法。而且，此后新建的实例 p3 也可以调用这个方法。这意味着，使用实例的<strong>proto</strong>属性改写原型，必须相当谨慎，不推荐使用，因为这会改变 Class 的原始定义，影响到所有实例。</p><h5 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h5><p>Class 不存在变量提升（hoist），这一点与 ES5 完全不同。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new Foo(); // ReferenceError</span><br><span class="line">class Foo &#123;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，Foo 类使用在前，定义在后，这样会报错，因为 ES6 不会把类的声明提升到代码头部。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="built_in">let</span> Foo = class &#123;&#125;;</span><br><span class="line">  class Bar extends Foo &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码不会报错，因为 Bar 继承 Foo 的时候，Foo 已经有定义了。但是，如果存在 class 的提升，上面代码就会报错，因为 class 会被提升到代码头部，而 let 命令是不提升的，所以导致 Bar 继承 Foo 的时候，Foo 还没有定义。</p><h5 id="Class-表达式"><a href="#Class-表达式" class="headerlink" title="Class 表达式"></a>Class 表达式</h5><p>与函数一样，类也可以使用表达式的形式定义。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const MyClass = class Me &#123;</span><br><span class="line">  <span class="function"><span class="title">getClassName</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> Me.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是 MyClass 而不是 Me，Me 只在 Class 的内部代码可用，指代当前类。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> inst = new MyClass();</span><br><span class="line">inst.getClassName() // Me</span><br><span class="line">Me.name // ReferenceError: Me is not defined</span><br></pre></td></tr></table></figure><p>上面代码表示，Me 只在 Class 内部有定义。</p><p>如果类的内部没用到的话，可以省略 Me，也就是可以写成下面的形式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const MyClass = class &#123; /* ... */ &#125;;</span><br></pre></td></tr></table></figure><p>采用 Class 表达式，可以写出立即执行的 Class。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> person = new class &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">sayName</span></span>() &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;(<span class="string">'张三'</span>);</span><br><span class="line"></span><br><span class="line">person.sayName(); // <span class="string">"张三"</span></span><br></pre></td></tr></table></figure><p>上面代码中，person 是一个立即执行的类的实例。</p><h5 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h5><p>私有方法是常见需求，但 ES6 不提供，只能通过变通方法模拟实现。</p><p>一种做法是在命名上加以区别。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Widget &#123;</span><br><span class="line"></span><br><span class="line">  // 公有方法</span><br><span class="line">  foo (baz) &#123;</span><br><span class="line">    this._bar(baz);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 私有方法</span><br><span class="line">  _bar(baz) &#123;</span><br><span class="line">    <span class="built_in">return</span> this.snaf = baz;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，_bar 方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是，这种命名是不保险的，在类的外部，还是可以调用到这个方法。</p><p>另一种方法就是索性将私有方法移出模块，因为模块内部的所有方法都是对外可见的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Widget &#123;</span><br><span class="line">  foo (baz) &#123;</span><br><span class="line">    bar.call(this, baz);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> bar(baz) &#123;</span><br><span class="line">  <span class="built_in">return</span> this.snaf = baz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，foo 是公有方法，内部调用了 bar.call(this, baz)。这使得 bar 实际上成为了当前模块的私有方法。</p><p>还有一种方法是利用 Symbol 值的唯一性，将私有方法的名字命名为一个 Symbol 值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const bar = Symbol(<span class="string">'bar'</span>);</span><br><span class="line">const snaf = Symbol(<span class="string">'snaf'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default class myClass&#123;</span><br><span class="line"></span><br><span class="line">  // 公有方法</span><br><span class="line">  foo(baz) &#123;</span><br><span class="line">    this[bar](baz);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 私有方法</span><br><span class="line">  [bar](baz) &#123;</span><br><span class="line">    <span class="built_in">return</span> this[snaf] = baz;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，bar 和 snaf 都是 Symbol 值，导致第三方无法获取到它们，因此达到了私有方法和私有属性的效果。</p><h5 id="this-的指向"><a href="#this-的指向" class="headerlink" title="this 的指向"></a>this 的指向</h5><p>类的方法内部如果含有 this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Logger &#123;</span><br><span class="line">  printName(name = <span class="string">'there'</span>) &#123;</span><br><span class="line">    this.print(`Hello <span class="variable">$&#123;name&#125;</span>`);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(text) &#123;</span><br><span class="line">    console.log(text);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const logger = new Logger();</span><br><span class="line">const &#123; printName &#125; = logger;</span><br><span class="line">printName(); // TypeError: Cannot <span class="built_in">read</span> property <span class="string">'print'</span> of undefined</span><br></pre></td></tr></table></figure><p>上面代码中，printName 方法中的 this，默认指向 Logger 类的实例。但是，如果将这个方法提取出来单独使用，this 会指向该方法运行时所在的环境，因为找不到 print 方法而导致报错。</p><p>一个比较简单的解决方法是，在构造方法中绑定 this，这样就不会找不到 print 方法了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Logger &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    this.printName = this.printName.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种解决方法是使用箭头函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Logger &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    this.printName = (name = <span class="string">'there'</span>) =&gt; &#123;</span><br><span class="line">      this.print(`Hello <span class="variable">$&#123;name&#125;</span>`);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种解决方法是使用 Proxy，获取方法的时候，自动绑定 this。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> selfish (target) &#123;</span><br><span class="line">  const cache = new WeakMap();</span><br><span class="line">  const handler = &#123;</span><br><span class="line">    get (target, key) &#123;</span><br><span class="line">      const value = Reflect.get(target, key);</span><br><span class="line">      <span class="keyword">if</span> (typeof value !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="built_in">return</span> value;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!cache.has(value)) &#123;</span><br><span class="line">        cache.set(value, value.bind(target));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">return</span> cache.get(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  const proxy = new Proxy(target, handler);</span><br><span class="line">  <span class="built_in">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const logger = selfish(new Logger());</span><br></pre></td></tr></table></figure><h5 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h5><p>类和模块的内部，默认就是严格模式，所以不需要使用 use strict 指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。</p><p>考虑到未来所有的代码，其实都是运行在模块之中，所以 ES6 实际上把整个语言升级到了严格模式。</p><h5 id="name-属性"><a href="#name-属性" class="headerlink" title="name 属性"></a>name 属性</h5><p>由于本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被 Class 继承，包括 name 属性。</p><p>class Point {}<br>Point.name // “Point”<br>name 属性总是返回紧跟在 class 关键字后面的类名。</p><h4 id="Class-的继承"><a href="#Class-的继承" class="headerlink" title="Class 的继承"></a>Class 的继承</h4><h5 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h5><p>Class 之间可以通过 extends 关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class ColorPoint extends Point &#123;&#125;</span><br></pre></td></tr></table></figure><p>上面代码定义了一个 ColorPoint 类，该类通过 extends 关键字，继承了 Point 类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个 Point 类。下面，我们在 ColorPoint 内部加上代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class ColorPoint extends Point &#123;</span><br><span class="line">  constructor(x, y, color) &#123;</span><br><span class="line">    super(x, y); // 调用父类的constructor(x, y)</span><br><span class="line">    this.color = color;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> this.color + <span class="string">' '</span> + super.toString(); // 调用父类的toString()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，constructor 方法和 toString 方法之中，都出现了 super 关键字，它在这里表示父类的构造函数，用来新建父类的 this 对象。</p><p>子类必须在 constructor 方法中调用 super 方法，否则新建实例时会报错。这是因为子类没有自己的 this 对象，而是继承父类的 this 对象，然后对其进行加工。如果不调用 super 方法，子类就得不到 this 对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123; /* ... */ &#125;</span><br><span class="line"></span><br><span class="line">class ColorPoint extends Point &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> cp = new ColorPoint(); // ReferenceError</span><br></pre></td></tr></table></figure><p>上面代码中，ColorPoint 继承了父类 Point，但是它的构造函数没有调用 super 方法，导致新建实例时报错。</p><p>ES5 的继承，实质是先创造子类的实例对象 this，然后再将父类的方法添加到 this 上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先创造父类的实例对象 this（所以必须先调用 super 方法），然后再用子类的构造函数修改 this。</p><p>如果子类没有定义 constructor 方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有 constructor 方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">constructor(...args) &#123;</span><br><span class="line">  super(...args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个需要注意的地方是，在子类的构造函数中，只有调用 super 之后，才可以使用 this 关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有 super 方法才能返回父类实例。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  constructor(x, y) &#123;</span><br><span class="line">    this.x = x;</span><br><span class="line">    this.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ColorPoint extends Point &#123;</span><br><span class="line">  constructor(x, y, color) &#123;</span><br><span class="line">    this.color = color; // ReferenceError</span><br><span class="line">    super(x, y);</span><br><span class="line">    this.color = color; // 正确</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，子类的 constructor 方法没有调用 super 之前，就使用 this 关键字，结果报错，而放在 super 方法之后就是正确的。</p><p>下面是生成子类实例的代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> cp = new ColorPoint(25, 8, <span class="string">'green'</span>);</span><br><span class="line"></span><br><span class="line">cp instanceof ColorPoint // <span class="literal">true</span></span><br><span class="line">cp instanceof Point // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>上面代码中，实例对象 cp 同时是 ColorPoint 和 Point 两个类的实例，这与 ES5 的行为完全一致。</p><h5 id="类的-prototype-属性和proto属性"><a href="#类的-prototype-属性和proto属性" class="headerlink" title="类的 prototype 属性和proto属性"></a>类的 prototype 属性和<strong>proto</strong>属性</h5><p>大多数浏览器的 ES5 实现之中，每一个对象都有<strong>proto</strong>属性，指向对应的构造函数的 prototype 属性。Class 作为构造函数的语法糖，同时有 prototype 属性和<strong>proto</strong>属性，因此同时存在两条继承链。</p><p>（1）子类的<strong>proto</strong>属性，表示构造函数的继承，总是指向父类。</p><p>（2）子类 prototype 属性的<strong>proto</strong>属性，表示方法的继承，总是指向父类的 prototype 属性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.__proto__ === A // <span class="literal">true</span></span><br><span class="line">B.prototype.__proto__ === A.prototype // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>上面代码中，子类 B 的<strong>proto</strong>属性指向父类 A，子类 B 的 prototype 属性的<strong>proto</strong>属性指向父类 A 的 prototype 属性。</p><p>这样的结果是因为，类的继承是按照下面的模式实现的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// B的实例继承A的实例</span><br><span class="line">Object.setPrototypeOf(B.prototype, A.prototype);</span><br><span class="line"></span><br><span class="line">// B继承A的静态属性</span><br><span class="line">Object.setPrototypeOf(B, A);</span><br></pre></td></tr></table></figure><p>《对象的扩展》一章给出过 Object.setPrototypeOf 方法的实现。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object.setPrototypeOf = <span class="keyword">function</span> (obj, proto) &#123;</span><br><span class="line">  obj.__proto__ = proto;</span><br><span class="line">  <span class="built_in">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，就得到了上面的结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Object.setPrototypeOf(B.prototype, A.prototype);</span><br><span class="line">// 等同于</span><br><span class="line">B.prototype.__proto__ = A.prototype;</span><br><span class="line"></span><br><span class="line">Object.setPrototypeOf(B, A);</span><br><span class="line">// 等同于</span><br><span class="line">B.__proto__ = A;</span><br></pre></td></tr></table></figure><p>这两条继承链，可以这样理解：作为一个对象，子类（B）的原型（<strong>proto</strong>属性）是父类（A）；作为一个构造函数，子类（B）的原型（prototype 属性）是父类的实例。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object.create(A.prototype);</span><br><span class="line">// 等同于</span><br><span class="line">B.prototype.__proto__ = A.prototype;</span><br></pre></td></tr></table></figure><h5 id="Extends-的继承目标"><a href="#Extends-的继承目标" class="headerlink" title="Extends 的继承目标"></a>Extends 的继承目标</h5><p>extends 关键字后面可以跟多种类型的值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class B extends A &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的 A，只要是一个有 prototype 属性的函数，就能被 B 继承。由于函数都有 prototype 属性（除了 Function.prototype 函数），因此 A 可以是任意函数。</p><p>下面，讨论三种特殊情况。</p><p>第一种特殊情况，子类继承 Object 类。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class A extends Object &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A.__proto__ === Object // <span class="literal">true</span></span><br><span class="line">A.prototype.__proto__ === Object.prototype // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>这种情况下，A 其实就是构造函数 Object 的复制，A 的实例就是 Object 的实例。</p><p>第二种特殊情况，不存在任何继承。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A.__proto__ === Function.prototype // <span class="literal">true</span></span><br><span class="line">A.prototype.__proto__ === Object.prototype // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>这种情况下，A 作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承 Funciton.prototype。但是，A 调用后返回一个空对象（即 Object 实例），所以 A.prototype.<strong>proto</strong>指向构造函数（Object）的 prototype 属性。</p><p>第三种特殊情况，子类继承 null。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class A extends null &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A.__proto__ === Function.prototype // <span class="literal">true</span></span><br><span class="line">A.prototype.__proto__ === undefined // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>这种情况与第二种情况非常像。A 也是一个普通函数，所以直接继承 Funciton.prototype。但是，A 调用后返回的对象不继承任何方法，所以它的<strong>proto</strong>指向 Function.prototype，即实质上执行了下面的代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class C extends null &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123; <span class="built_in">return</span> Object.create(null); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h5><p>Object.getPrototypeOf 方法可以用来从子类上获取父类。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.getPrototypeOf(ColorPoint) === Point</span><br><span class="line">// <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>因此，可以使用这个方法判断，一个类是否继承了另一个类。</p><h5 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h5><p>super 这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。</p><p>第一种情况，super 作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次 super 函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    super();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，子类 B 的构造函数之中的 super()，代表调用父类的构造函数。这是必须的，否则 JavaScript 引擎会报错。</p><p>注意，super 虽然代表了父类 A 的构造函数，但是返回的是子类 B 的实例，即 super 内部的 this 指的是 B，因此 super()在这里相当于 A.prototype.constructor.call(this)。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    console.log(new.target.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class B extends A &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    super();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">new A() // A</span><br><span class="line">new B() // B</span><br></pre></td></tr></table></figure><p>上面代码中，new.target 指向当前正在执行的函数。可以看到，在 super()执行时，它指向的是子类 B 的构造函数，而不是父类 A 的构造函数。也就是说，super()内部的 this 指向的是 B。</p><p>作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">  <span class="function"><span class="title">m</span></span>() &#123;</span><br><span class="line">    super(); // 报错</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，super()用在 B 类的 m 方法之中，就会造成句法错误。</p><p>第二种情况，super 作为对象时，指向父类的原型对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  <span class="function"><span class="title">p</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> 2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    super();</span><br><span class="line">    console.log(super.p()); // 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> b = new B();</span><br></pre></td></tr></table></figure><p>上面代码中，子类 B 当中的 super.p()，就是将 super 当作一个对象使用。这时，super 指向 A.prototype，所以 super.p()就相当于 A.prototype.p()。</p><p>这里需要注意，由于 super 指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过 super 调用的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    this.p = 2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">  get <span class="function"><span class="title">m</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> super.p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> b = new B();</span><br><span class="line">b.m // undefined</span><br></pre></td></tr></table></figure><p>上面代码中，p 是父类 A 实例的属性，super.p 就引用不到它。</p><p>如果属性定义在父类的原型对象上，super 就可以取到。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;&#125;</span><br><span class="line">A.prototype.x = 2;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    super();</span><br><span class="line">    console.log(super.x) // 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> b = new B();</span><br></pre></td></tr></table></figure><p>上面代码中，属性 x 是定义在 A.prototype 上面的，所以 super.x 可以取到它的值。</p><p>ES6 规定，通过 super 调用父类的方法时，super 会绑定子类的 this。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    this.x = 1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">print</span></span>() &#123;</span><br><span class="line">    console.log(this.x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.x = 2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">m</span></span>() &#123;</span><br><span class="line">    super.print();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> b = new B();</span><br><span class="line">b.m() // 2</span><br></pre></td></tr></table></figure><p>上面代码中，super.print()虽然调用的是 A.prototype.print()，但是 A.prototype.print()会绑定子类 B 的 this，导致输出的是 2，而不是 1。也就是说，实际上执行的是 super.print.call(this)。</p><p>由于绑定子类的 this，所以如果通过 super 对某个属性赋值，这时 super 就是 this，赋值的属性会变成子类实例的属性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    this.x = 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.x = 2;</span><br><span class="line">    super.x = 3;</span><br><span class="line">    console.log(super.x); // undefined</span><br><span class="line">    console.log(this.x); // 3</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> b = new B();</span><br></pre></td></tr></table></figure><p>上面代码中，super.x 赋值为 3，这时等同于对 this.x 赋值为 3。而当读取 super.x 的时候，读的是 A.prototype.x，所以返回 undefined。</p><p>注意，使用 super 的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    super();</span><br><span class="line">    console.log(super); // 报错</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，console.log(super)当中的 super，无法看出是作为函数使用，还是作为对象使用，所以 JavaScript 引擎解析代码的时候就会报错。这时，如果能清晰地表明 super 的数据类型，就不会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    super();</span><br><span class="line">    console.log(super.valueOf() instanceof B); // <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> b = new B();</span><br></pre></td></tr></table></figure><p>上面代码中，super.valueOf()表明 super 是一个对象，因此就不会报错。同时，由于 super 绑定 B 的 this，所以 super.valueOf()返回的是一个 B 的实例。</p><p>最后，由于对象总是继承其他对象的，所以可以在任意一个对象中，使用 super 关键字。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">"MyObject: "</span> + super.toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.toString(); // MyObject: [object Object]</span><br></pre></td></tr></table></figure><h5 id="实例的proto属性"><a href="#实例的proto属性" class="headerlink" title="实例的proto属性"></a>实例的<strong>proto</strong>属性</h5><p>子类实例的<strong>proto</strong>属性的<strong>proto</strong>属性，指向父类实例的<strong>proto</strong>属性。也就是说，子类的原型的原型，是父类的原型。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var p1 = new Point(2, 3);</span><br><span class="line">var p2 = new ColorPoint(2, 3, <span class="string">'red'</span>);</span><br><span class="line"></span><br><span class="line">p2.__proto__ === p1.__proto__ // <span class="literal">false</span></span><br><span class="line">p2.__proto__.__proto__ === p1.__proto__ // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>上面代码中，ColorPoint 继承了 Point，导致前者原型的原型是后者的原型。</p><p>因此，通过子类实例的<strong>proto</strong>.<strong>proto</strong>属性，可以修改父类实例的行为。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p2.__proto__.__proto__.printName = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  console.log(<span class="string">'Ha'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">p1.printName() // <span class="string">"Ha"</span></span><br></pre></td></tr></table></figure><p>上面代码在 ColorPoint 的实例 p2 上向 Point 类添加方法，结果影响到了 Point 的实例 p1。</p><h5 id="原生构造函数的继承"><a href="#原生构造函数的继承" class="headerlink" title="原生构造函数的继承"></a>原生构造函数的继承</h5><p>原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript 的原生构造函数大致有下面这些。</p><pre>Boolean()Number()String()Array()Date()Function()RegExp()Error()Object()</pre><p>以前，这些原生构造函数是无法继承的，比如，不能自己定义一个 Array 的子类。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">MyArray</span></span>() &#123;</span><br><span class="line">  Array.apply(this, arguments);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyArray.prototype = Object.create(Array.prototype, &#123;</span><br><span class="line">  constructor: &#123;</span><br><span class="line">    value: MyArray,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码定义了一个继承 Array 的 MyArray 类。但是，这个类的行为与 Array 完全不一致。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var colors = new MyArray();</span><br><span class="line">colors[0] = <span class="string">"red"</span>;</span><br><span class="line">colors.length  // 0</span><br><span class="line"></span><br><span class="line">colors.length = 0;</span><br><span class="line">colors[0]  // <span class="string">"red"</span></span><br></pre></td></tr></table></figure><p>之所以会发生这种情况，是因为子类无法获得原生构造函数的内部属性，通过 Array.apply()或者分配给原型对象都不行。原生构造函数会忽略 apply 方法传入的 this，也就是说，原生构造函数的 this 无法绑定，导致拿不到内部属性。</p><p>ES5 是先新建子类的实例对象 this，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。比如，Array 构造函数有一个内部属性[[DefineOwnProperty]]，用来定义新属性时，更新 length 属性，这个内部属性无法在子类获取，导致子类的 length 属性行为不正常。</p><p>下面的例子中，我们想让一个普通对象继承 Error 对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var e = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Object.getOwnPropertyNames(Error.call(e))</span><br><span class="line">// [ <span class="string">'stack'</span> ]</span><br><span class="line"></span><br><span class="line">Object.getOwnPropertyNames(e)</span><br><span class="line">// []</span><br></pre></td></tr></table></figure><p>上面代码中，我们想通过 Error.call(e)这种写法，让普通对象 e 具有 Error 对象的实例属性。但是，Error.call()完全忽略传入的第一个参数，而是返回一个新对象，e 本身没有任何变化。这证明了 Error.call(e)这种写法，无法继承原生构造函数。</p><p>ES6 允许继承原生构造函数定义子类，因为 ES6 是先新建父类的实例对象 this，然后再用子类的构造函数修饰 this，使得父类的所有行为都可以继承。下面是一个继承 Array 的例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class MyArray extends Array &#123;</span><br><span class="line">  constructor(...args) &#123;</span><br><span class="line">    super(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr = new MyArray();</span><br><span class="line">arr[0] = 12;</span><br><span class="line">arr.length // 1</span><br><span class="line"></span><br><span class="line">arr.length = 0;</span><br><span class="line">arr[0] // undefined</span><br></pre></td></tr></table></figure><p>上面代码定义了一个 MyArray 类，继承了 Array 构造函数，因此就可以从 MyArray 生成数组的实例。这意味着，ES6 可以自定义原生数据结构（比如 Array、String 等）的子类，这是 ES5 无法做到的。</p><p>上面这个例子也说明，extends 关键字不仅可以用来继承类，还可以用来继承原生的构造函数。因此可以在原生数据结构的基础上，定义自己的数据结构。下面就是定义了一个带版本功能的数组。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class VersionedArray extends Array &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.history = [[]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">commit</span></span>() &#123;</span><br><span class="line">    this.history.push(this.slice());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">revert</span></span>() &#123;</span><br><span class="line">    this.splice(0, this.length, ...this.history[this.history.length - 1]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var x = new VersionedArray();</span><br><span class="line"></span><br><span class="line">x.push(1);</span><br><span class="line">x.push(2);</span><br><span class="line">x // [1, 2]</span><br><span class="line">x.history // [[]]</span><br><span class="line"></span><br><span class="line">x.commit();</span><br><span class="line">x.history // [[], [1, 2]]</span><br><span class="line">x.push(3);</span><br><span class="line">x // [1, 2, 3]</span><br><span class="line"></span><br><span class="line">x.revert();</span><br><span class="line">x // [1, 2]</span><br></pre></td></tr></table></figure><p>上面代码中，VersionedArray 结构会通过 commit 方法，将自己的当前状态存入 history 属性，然后通过 revert 方法，可以撤销当前版本，回到上一个版本。除此之外，VersionedArray 依然是一个数组，所有原生的数组方法都可以在它上面调用。</p><p>下面是一个自定义 Error 子类的例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class ExtendableError extends Error &#123;</span><br><span class="line">  constructor(message) &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.message = message;</span><br><span class="line">    this.stack = (new Error()).stack;</span><br><span class="line">    this.name = this.constructor.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyError extends ExtendableError &#123;</span><br><span class="line">  constructor(m) &#123;</span><br><span class="line">    super(m);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var myerror = new MyError(<span class="string">'ll'</span>);</span><br><span class="line">myerror.message // <span class="string">"ll"</span></span><br><span class="line">myerror instanceof Error // <span class="literal">true</span></span><br><span class="line">myerror.name // <span class="string">"MyError"</span></span><br><span class="line">myerror.stack</span><br><span class="line">// Error</span><br><span class="line">//     at MyError.ExtendableError</span><br><span class="line">//     ...</span><br></pre></td></tr></table></figure><p>注意，继承 Object 的子类，有一个行为差异。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class NewObj extends Object&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>()&#123;</span><br><span class="line">    super(...arguments);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var o = new NewObj(&#123;attr: <span class="literal">true</span>&#125;);</span><br><span class="line">console.log(o.attr === <span class="literal">true</span>);  // <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>上面代码中，NewObj 继承了 Object，但是无法通过 super 方法向父类 Object 传参。这是因为 ES6 改变了 Object 构造函数的行为，一旦发现 Object 方法不是通过 new Object()这种形式调用，ES6 规定 Object 构造函数会忽略参数。</p><h4 id="Class-的取值函数（getter）和存值函数（setter）"><a href="#Class-的取值函数（getter）和存值函数（setter）" class="headerlink" title="Class 的取值函数（getter）和存值函数（setter）"></a>Class 的取值函数（getter）和存值函数（setter）</h4><p>与 ES5 一样，在 Class 内部可以使用 get 和 set 关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">  get <span class="function"><span class="title">prop</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">'getter'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">set</span> prop(value) &#123;</span><br><span class="line">    console.log(<span class="string">'setter: '</span>+value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> inst = new MyClass();</span><br><span class="line"></span><br><span class="line">inst.prop = 123;</span><br><span class="line">// setter: 123</span><br><span class="line"></span><br><span class="line">inst.prop</span><br><span class="line">// <span class="string">'getter'</span></span><br></pre></td></tr></table></figure><p>上面代码中，prop 属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。</p><p>存值函数和取值函数是设置在属性的 descriptor 对象上的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class CustomHTMLElement &#123;</span><br><span class="line">  constructor(element) &#123;</span><br><span class="line">    this.element = element;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get <span class="function"><span class="title">html</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> this.element.innerHTML;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">set</span> html(value) &#123;</span><br><span class="line">    this.element.innerHTML = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var descriptor = Object.getOwnPropertyDescriptor(</span><br><span class="line">  CustomHTMLElement.prototype, <span class="string">"html"</span>);</span><br><span class="line"><span class="string">"get"</span> <span class="keyword">in</span> descriptor  // <span class="literal">true</span></span><br><span class="line"><span class="string">"set"</span> <span class="keyword">in</span> descriptor  // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>上面代码中，存值函数和取值函数是定义在 html 属性的描述对象上面，这与 ES5 完全一致。</p><h4 id="Class-的-Generator-方法"><a href="#Class-的-Generator-方法" class="headerlink" title="Class 的 Generator 方法"></a>Class 的 Generator 方法</h4><p>如果某个方法之前加上星号（*），就表示该方法是一个 Generator 函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">  constructor(...args) &#123;</span><br><span class="line">    this.args = args;</span><br><span class="line">  &#125;</span><br><span class="line">  * [Symbol.iterator]() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">let</span> arg of this.args) &#123;</span><br><span class="line">      yield arg;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> x of new Foo(<span class="string">'hello'</span>, <span class="string">'world'</span>)) &#123;</span><br><span class="line">  console.log(x);</span><br><span class="line">&#125;</span><br><span class="line">// hello</span><br><span class="line">// world</span><br></pre></td></tr></table></figure><p>上面代码中，Foo 类的 Symbol.iterator 方法前有一个星号，表示该方法是一个 Generator 函数。Symbol.iterator 方法返回一个 Foo 类的默认遍历器，for…of 循环会自动调用这个遍历器。</p><h4 id="Class-的静态方法"><a href="#Class-的静态方法" class="headerlink" title="Class 的静态方法"></a>Class 的静态方法</h4><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上 static 关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">  static <span class="function"><span class="title">classMethod</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">'hello'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.classMethod() // <span class="string">'hello'</span></span><br><span class="line"></span><br><span class="line">var foo = new Foo();</span><br><span class="line">foo.classMethod()</span><br><span class="line">// TypeError: foo.classMethod is not a <span class="keyword">function</span></span><br></pre></td></tr></table></figure><p>上面代码中，Foo 类的 classMethod 方法前有 static 关键字，表明该方法是一个静态方法，可以直接在 Foo 类上调用（Foo.classMethod()），而不是在 Foo 类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。</p><p>父类的静态方法，可以被子类继承。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">  static <span class="function"><span class="title">classMethod</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">'hello'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Bar extends Foo &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Bar.classMethod(); // <span class="string">'hello'</span></span><br></pre></td></tr></table></figure><p>上面代码中，父类 Foo 有一个静态方法，子类 Bar 可以调用这个方法。</p><p>静态方法也是可以从 super 对象上调用的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">  static <span class="function"><span class="title">classMethod</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">'hello'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Bar extends Foo &#123;</span><br><span class="line">  static <span class="function"><span class="title">classMethod</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> super.classMethod() + <span class="string">', too'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Bar.classMethod();</span><br></pre></td></tr></table></figure><h4 id="Class-的静态属性和实例属性"><a href="#Class-的静态属性和实例属性" class="headerlink" title="Class 的静态属性和实例属性"></a>Class 的静态属性和实例属性</h4><p>静态属性指的是 Class 本身的属性，即 Class.propname，而不是定义在实例对象（this）上的属性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prop = 1;</span><br><span class="line">Foo.prop // 1</span><br></pre></td></tr></table></figure><p>上面的写法为 Foo 类定义了一个静态属性 prop。</p><p>目前，只有这种写法可行，因为 ES6 明确规定，Class 内部只有静态方法，没有静态属性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 以下两种写法都无效</span><br><span class="line">class Foo &#123;</span><br><span class="line">  // 写法一</span><br><span class="line">  prop: 2</span><br><span class="line"></span><br><span class="line">  // 写法二</span><br><span class="line">  static prop: 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prop // undefined</span><br></pre></td></tr></table></figure><p>ES7 有一个静态属性的提案，目前 Babel 转码器支持。</p><p>这个提案对实例属性和静态属性，都规定了新的写法。</p><p>（1）类的实例属性</p><p>类的实例属性可以用等式，写入类的定义之中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">  myProp = 42;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    console.log(this.myProp); // 42</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，myProp 就是 MyClass 的实例属性。在 MyClass 的实例上，可以读取这个属性。</p><p>以前，我们定义实例属性，只能写在类的 constructor 方法里面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class ReactCounter extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      count: 0</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，构造方法 constructor 里面，定义了 this.state 属性。</p><p>有了新的写法以后，可以不在 constructor 方法里面定义。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class ReactCounter extends React.Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    count: 0</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法比以前更清晰。</p><p>为了可读性的目的，对于那些在 constructor 里面已经定义的实例属性，新写法允许直接列出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class ReactCounter extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      count: 0</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）类的静态属性</p><p>类的静态属性只要在上面的实例属性写法前面，加上 static 关键字就可以了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">  static myStaticProp = 42;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    console.log(MyClass.myProp); // 42</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，这个新写法大大方便了静态属性的表达。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 老写法</span><br><span class="line">class Foo &#123;</span><br><span class="line">&#125;</span><br><span class="line">Foo.prop = 1;</span><br><span class="line"></span><br><span class="line">// 新写法</span><br><span class="line">class Foo &#123;</span><br><span class="line">  static prop = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，老写法的静态属性定义在类的外部。整个类生成以后，再生成静态属性。这样让人很容易忽略这个静态属性，也不符合相关代码应该放在一起的代码组织原则。另外，新写法是显式声明（declarative），而不是赋值处理，语义更好。</p><h4 id="new-target-属性"><a href="#new-target-属性" class="headerlink" title="new.target 属性"></a>new.target 属性</h4><p>new 是从构造函数生成实例的命令。ES6 为 new 命令引入了一个 new.target 属性，（在构造函数中）返回 new 命令作用于的那个构造函数。如果构造函数不是通过 new 命令调用的，new.target 会返回 undefined，因此这个属性可以用来确定构造函数是怎么调用的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Person(name) &#123;</span><br><span class="line">  <span class="keyword">if</span> (new.target !== undefined) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    throw new Error(<span class="string">'必须使用new生成实例'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 另一种写法</span><br><span class="line"><span class="keyword">function</span> Person(name) &#123;</span><br><span class="line">  <span class="keyword">if</span> (new.target === Person) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    throw new Error(<span class="string">'必须使用new生成实例'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = new Person(<span class="string">'张三'</span>); // 正确</span><br><span class="line">var notAPerson = Person.call(person, <span class="string">'张三'</span>);  // 报错</span><br></pre></td></tr></table></figure><p>上面代码确保构造函数只能通过 new 命令调用。</p><p>Class 内部调用 new.target，返回当前 Class。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Rectangle &#123;</span><br><span class="line">  constructor(length, width) &#123;</span><br><span class="line">    console.log(new.target === Rectangle);</span><br><span class="line">    this.length = length;</span><br><span class="line">    this.width = width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = new Rectangle(3, 4); // 输出 <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>需要注意的是，子类继承父类时，new.target 会返回子类。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Rectangle &#123;</span><br><span class="line">  constructor(length, width) &#123;</span><br><span class="line">    console.log(new.target === Rectangle);</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Square extends Rectangle &#123;</span><br><span class="line">  constructor(length) &#123;</span><br><span class="line">    super(length, length);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = new Square(3); // 输出 <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>上面代码中，new.target 会返回子类。</p><p>利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Shape &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (new.target === Shape) &#123;</span><br><span class="line">      throw new Error(<span class="string">'本类不能实例化'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Rectangle extends Shape &#123;</span><br><span class="line">  constructor(length, width) &#123;</span><br><span class="line">    super();</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var x = new Shape();  // 报错</span><br><span class="line">var y = new Rectangle(3, 4);  // 正确</span><br></pre></td></tr></table></figure><p>上面代码中，Shape 类不能被实例化，只能用于继承。</p><p>注意，在函数外部，使用 new.target 会报错。</p><h4 id="Mixin-模式的实现"><a href="#Mixin-模式的实现" class="headerlink" title="Mixin 模式的实现"></a>Mixin 模式的实现</h4><p>Mixin 模式指的是，将多个类的接口“混入”（mix in）另一个类。它在 ES6 的实现如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> mix(...mixins) &#123;</span><br><span class="line">  class Mix &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">let</span> mixin of mixins) &#123;</span><br><span class="line">    copyProperties(Mix, mixin);</span><br><span class="line">    copyProperties(Mix.prototype, mixin.prototype);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> Mix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> copyProperties(target, <span class="built_in">source</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">let</span> key of Reflect.ownKeys(<span class="built_in">source</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( key !== <span class="string">"constructor"</span></span><br><span class="line">      &amp;&amp; key !== <span class="string">"prototype"</span></span><br><span class="line">      &amp;&amp; key !== <span class="string">"name"</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="built_in">let</span> desc = Object.getOwnPropertyDescriptor(<span class="built_in">source</span>, key);</span><br><span class="line">      Object.defineProperty(target, key, desc);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的 mix 函数，可以将多个对象合成为一个类。使用的时候，只要继承这个类即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class DistributedEdit extends mix(Loggable, Serializable) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6_Async</title>
      <link href="/2019/04/05/es6-Async/"/>
      <url>/2019/04/05/es6-Async/</url>
      
        <content type="html"><![CDATA[<h3 id="ES6-异步操作和-async-函数"><a href="#ES6-异步操作和-async-函数" class="headerlink" title="ES6 异步操作和 async 函数"></a>ES6 异步操作和 async 函数</h3><p>异步编程对 JavaScript 语言太重要。Javascript 语言的执行环境是“单线程”的，如果没有异步编程，根本没法用，非卡死不可。</p><p>ES6 诞生以前，异步编程的方法，大概有下面四种。</p><pre>回调函数事件监听发布/订阅Promise 对象</pre><p>ES6 将 JavaScript 异步编程带入了一个全新的阶段，ES7 的 Async 函数更是提出了异步编程的终极解决方案。</p><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><h5 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h5><p>所谓”异步”，简单说就是一个任务分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。</p><p>比如，有一个任务是读取文件进行处理，任务的第一段是向操作系统发出请求，要求读取文件。然后，程序执行其他任务，等到操作系统返回文件，再接着执行任务的第二段（处理文件）。这种不连续的执行，就叫做异步。</p><p>相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着。</p><h5 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h5><p>JavaScript 语言对异步编程的实现，就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。它的英语名字 callback，直译过来就是”重新调用”。</p><p>读取文件进行处理，是这样写的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">'/etc/passwd'</span>, <span class="keyword">function</span> (err, data) &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) throw err;</span><br><span class="line">  console.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，readFile 函数的第二个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了/etc/passwd 这个文件以后，回调函数才会执行。</p><p>一个有趣的问题是，为什么 Node.js 约定，回调函数的第一个参数，必须是错误对象 err（如果没有错误，该参数就是 null）？原因是执行分成两段，在这两段之间抛出的错误，程序无法捕捉，只能当作参数，传入第二段。</p><h5 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h5><p>回调函数本身并没有问题，它的问题出现在多个回调函数嵌套。假定读取 A 文件之后，再读取 B 文件，代码如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(fileA, <span class="keyword">function</span> (err, data) &#123;</span><br><span class="line">  fs.readFile(fileB, <span class="keyword">function</span> (err, data) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>不难想象，如果依次读取多个文件，就会出现多重嵌套。代码不是纵向发展，而是横向发展，很快就会乱成一团，无法管理。这种情况就称为”回调函数地狱”（callback hell）。</p><p>Promise 就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套，改成链式调用。采用 Promise，连续读取多个文件，写法如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var readFile = require(<span class="string">'fs-readfile-promise'</span>);</span><br><span class="line"></span><br><span class="line">readFile(fileA)</span><br><span class="line">.<span class="keyword">then</span>(<span class="keyword">function</span>(data)&#123;</span><br><span class="line">  console.log(data.toString());</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">  <span class="built_in">return</span> readFile(fileB);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="keyword">then</span>(<span class="keyword">function</span>(data)&#123;</span><br><span class="line">  console.log(data.toString());</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="keyword">function</span>(err) &#123;</span><br><span class="line">  console.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，我使用了 fs-readfile-promise 模块，它的作用就是返回一个 Promise 版本的 readFile 函数。Promise 提供 then 方法加载回调函数，catch 方法捕捉执行过程中抛出的错误。</p><p>可以看到，Promise 的写法只是回调函数的改进，使用 then 方法以后，异步任务的两段执行看得更清楚了，除此以外，并无新意。</p><p>Promise 的最大问题是代码冗余，原来的任务被 Promise 包装了一下，不管什么操作，一眼看去都是一堆 then，原来的语义变得很不清楚。</p><p>那么，有没有更好的写法呢？</p><h5 id="Generator-函数"><a href="#Generator-函数" class="headerlink" title="Generator 函数"></a>Generator 函数</h5><h6 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h6><p>传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中有一种叫做”协程”（coroutine），意思是多个线程互相协作，完成异步任务。</p><p>协程有点像函数，又有点像线程。它的运行流程大致如下。</p><pre>第一步，协程A开始执行。第二步，协程A执行到一半，进入暂停，执行权转移到协程B。第三步，（一段时间后）协程B交还执行权。第四步，协程A恢复执行。</pre><p>上面流程的协程 A，就是异步任务，因为它分成两段（或多段）执行。</p><p>举例来说，读取文件的协程写法如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> *<span class="function"><span class="title">asyncJob</span></span>() &#123;</span><br><span class="line">  // ...其他代码</span><br><span class="line">  var f = yield readFile(fileA);</span><br><span class="line">  // ...其他代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的函数 asyncJob 是一个协程，它的奥妙就在其中的 yield 命令。它表示执行到此处，执行权将交给其他协程。也就是说，yield 命令是异步两个阶段的分界线。</p><p>协程遇到 yield 命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除 yield 命令，简直一模一样。</p><h6 id="Generator-函数的概念"><a href="#Generator-函数的概念" class="headerlink" title="Generator 函数的概念"></a>Generator 函数的概念</h6><p>Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。</p><p>整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用 yield 语句注明。Generator 函数的执行方法如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* gen(x)&#123;</span><br><span class="line">  var y = yield x + 2;</span><br><span class="line">  <span class="built_in">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var g = gen(1);</span><br><span class="line">g.next() // &#123; value: 3, <span class="keyword">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">g.next() // &#123; value: undefined, <span class="keyword">done</span>: <span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure><p>上面代码中，调用 Generator 函数，会返回一个内部指针（即遍历器）g 。这是 Generator 函数不同于普通函数的另一个地方，即执行它不会返回结果，返回的是指针对象。调用指针 g 的 next 方法，会移动内部指针（即执行异步任务的第一段），指向第一个遇到的 yield 语句，上例是执行到 x + 2 为止。</p><p>换言之，next 方法的作用是分阶段执行 Generator 函数。每次调用 next 方法，会返回一个对象，表示当前阶段的信息（value 属性和 done 属性）。value 属性是 yield 语句后面表达式的值，表示当前阶段的值；done 属性是一个布尔值，表示 Generator 函数是否执行完毕，即是否还有下一个阶段。</p><h6 id="Generator-函数的数据交换和错误处理"><a href="#Generator-函数的数据交换和错误处理" class="headerlink" title="Generator 函数的数据交换和错误处理"></a>Generator 函数的数据交换和错误处理</h6><p>Generator 函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。除此之外，它还有两个特性，使它可以作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制。</p><p>next 方法返回值的 value 属性，是 Generator 函数向外输出数据；next 方法还可以接受参数，这是向 Generator 函数体内输入数据。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* gen(x)&#123;</span><br><span class="line">  var y = yield x + 2;</span><br><span class="line">  <span class="built_in">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var g = gen(1);</span><br><span class="line">g.next() // &#123; value: 3, <span class="keyword">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">g.next(2) // &#123; value: 2, <span class="keyword">done</span>: <span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure><p>上面代码中，第一个 next 方法的 value 属性，返回表达式 x + 2 的值（3）。第二个 next 方法带有参数 2，这个参数可以传入 Generator 函数，作为上个阶段异步任务的返回结果，被函数体内的变量 y 接收。因此，这一步的 value 属性，返回的就是 2（变量 y 的值）。</p><p>Generator 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* gen(x)&#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    var y = yield x + 2;</span><br><span class="line">  &#125; catch (e)&#123;</span><br><span class="line">    console.log(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var g = gen(1);</span><br><span class="line">g.next();</span><br><span class="line">g.throw(<span class="string">'出错了'</span>);</span><br><span class="line">// 出错了</span><br></pre></td></tr></table></figure><p>上面代码的最后一行，Generator 函数体外，使用指针对象的 throw 方法抛出的错误，可以被函数体内的 try …catch 代码块捕获。这意味着，出错的代码与处理错误的代码，实现了时间和空间上的分离，这对于异步编程无疑是很重要的。</p><h6 id="异步任务的封装"><a href="#异步任务的封装" class="headerlink" title="异步任务的封装"></a>异步任务的封装</h6><p>下面看看如何使用 Generator 函数，执行一个真实的异步任务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var fetch = require(<span class="string">'node-fetch'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">gen</span></span>()&#123;</span><br><span class="line">  var url = <span class="string">'https://api.github.com/users/github'</span>;</span><br><span class="line">  var result = yield fetch(url);</span><br><span class="line">  console.log(result.bio);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，Generator 函数封装了一个异步操作，该操作先读取一个远程接口，然后从 JSON 格式的数据解析信息。就像前面说过的，这段代码非常像同步操作，除了加上了 yield 命令。</p><p>执行这段代码的方法如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var g = gen();</span><br><span class="line">var result = g.next();</span><br><span class="line"></span><br><span class="line">result.value.then(<span class="keyword">function</span>(data)&#123;</span><br><span class="line">  <span class="built_in">return</span> data.json();</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="keyword">function</span>(data)&#123;</span><br><span class="line">  g.next(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，首先执行 Generator 函数，获取遍历器对象，然后使用 next 方法（第二行），执行异步任务的第一阶段。由于 Fetch 模块返回的是一个 Promise 对象，因此要用 then 方法调用下一个 next 方法。</p><p>可以看到，虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。</p><h5 id="Thunk-函数"><a href="#Thunk-函数" class="headerlink" title="Thunk 函数"></a>Thunk 函数</h5><h6 id="参数的求值策略"><a href="#参数的求值策略" class="headerlink" title="参数的求值策略"></a>参数的求值策略</h6><p>Thunk 函数早在上个世纪 60 年代就诞生了。</p><p>那时，编程语言刚刚起步，计算机学家还在研究，编译器怎么写比较好。一个争论的焦点是”求值策略”，即函数的参数到底应该何时求值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var x = 1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> f(m)&#123;</span><br><span class="line">  <span class="built_in">return</span> m * 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(x + 5)</span><br></pre></td></tr></table></figure><p>上面代码先定义函数 f，然后向它传入表达式 x + 5。请问，这个表达式应该何时求值？</p><p>一种意见是”传值调用”（call by value），即在进入函数体之前，就计算 x + 5 的值（等于 6），再将这个值传入函数 f 。C 语言就采用这种策略。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(x + 5)</span><br><span class="line">// 传值调用时，等同于</span><br><span class="line">f(6)</span><br></pre></td></tr></table></figure><p>另一种意见是”传名调用”（call by name），即直接将表达式 x + 5 传入函数体，只在用到它的时候求值。Haskell 语言采用这种策略。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(x + 5)</span><br><span class="line">// 传名调用时，等同于</span><br><span class="line">(x + 5) * 2</span><br></pre></td></tr></table></figure><p>传值调用和传名调用，哪一种比较好？回答是各有利弊。传值调用比较简单，但是对参数求值的时候，实际上还没用到这个参数，有可能造成性能损失。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> f(a, b)&#123;</span><br><span class="line">  <span class="built_in">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(3 * x * x - 2 * x - 1, x);</span><br></pre></td></tr></table></figure><p>上面代码中，函数 f 的第一个参数是一个复杂的表达式，但是函数体内根本没用到。对这个参数求值，实际上是不必要的。因此，有一些计算机学家倾向于”传名调用”，即只在执行时求值。</p><h6 id="Thunk-函数的含义"><a href="#Thunk-函数的含义" class="headerlink" title="Thunk 函数的含义"></a>Thunk 函数的含义</h6><p>编译器的”传名调用”实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做 Thunk 函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> f(m)&#123;</span><br><span class="line">  <span class="built_in">return</span> m * 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(x + 5);</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line"></span><br><span class="line">var thunk = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  <span class="built_in">return</span> x + 5;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> f(thunk)&#123;</span><br><span class="line">  <span class="built_in">return</span> thunk() * 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，函数 f 的参数 x + 5 被一个函数替换了。凡是用到原参数的地方，对 Thunk 函数求值即可。</p><p>这就是 Thunk 函数的定义，它是”传名调用”的一种实现策略，用来替换某个表达式。</p><h6 id="JavaScript-语言的-Thunk-函数"><a href="#JavaScript-语言的-Thunk-函数" class="headerlink" title="JavaScript 语言的 Thunk 函数"></a>JavaScript 语言的 Thunk 函数</h6><p>JavaScript 语言是传值调用，它的 Thunk 函数含义有所不同。在 JavaScript 语言中，Thunk 函数替换的不是表达式，而是多参数函数，将其替换成单参数的版本，且只接受回调函数作为参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 正常版本的readFile（多参数版本）</span><br><span class="line">fs.readFile(fileName, callback);</span><br><span class="line"></span><br><span class="line">// Thunk版本的readFile（单参数版本）</span><br><span class="line">var readFileThunk = Thunk(fileName);</span><br><span class="line">readFileThunk(callback);</span><br><span class="line"></span><br><span class="line">var Thunk = <span class="keyword">function</span> (fileName)&#123;</span><br><span class="line">  <span class="built_in">return</span> <span class="keyword">function</span> (callback)&#123;</span><br><span class="line">    <span class="built_in">return</span> fs.readFile(fileName, callback);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，fs 模块的 readFile 方法是一个多参数函数，两个参数分别为文件名和回调函数。经过转换器处理，它变成了一个单参数函数，只接受回调函数作为参数。这个单参数版本，就叫做 Thunk 函数。</p><p>任何函数，只要参数有回调函数，就能写成 Thunk 函数的形式。下面是一个简单的 Thunk 函数转换器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// ES5版本</span><br><span class="line">var Thunk = <span class="keyword">function</span>(fn)&#123;</span><br><span class="line">  <span class="built_in">return</span> <span class="function"><span class="title">function</span></span> ()&#123;</span><br><span class="line">    var args = Array.prototype.slice.call(arguments);</span><br><span class="line">    <span class="built_in">return</span> <span class="keyword">function</span> (callback)&#123;</span><br><span class="line">      args.push(callback);</span><br><span class="line">      <span class="built_in">return</span> fn.apply(this, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// ES6版本</span><br><span class="line">var Thunk = <span class="keyword">function</span>(fn) &#123;</span><br><span class="line">  <span class="built_in">return</span> <span class="keyword">function</span> (...args) &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="keyword">function</span> (callback) &#123;</span><br><span class="line">      <span class="built_in">return</span> fn.call(this, ...args, callback);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用上面的转换器，生成 fs.readFile 的 Thunk 函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var readFileThunk = Thunk(fs.readFile);</span><br><span class="line">readFileThunk(fileA)(callback);</span><br></pre></td></tr></table></figure><p>下面是另一个完整的例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> f(a, cb) &#123;</span><br><span class="line">  cb(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> ft = Thunk(f);</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> <span class="built_in">log</span> = console.log.bind(console);</span><br><span class="line">ft(1)(<span class="built_in">log</span>) // 1</span><br></pre></td></tr></table></figure><h6 id="Thunkify-模块"><a href="#Thunkify-模块" class="headerlink" title="Thunkify 模块"></a>Thunkify 模块</h6><p>生产环境的转换器，建议使用 Thunkify 模块。</p><p>首先是安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install thunkify</span><br></pre></td></tr></table></figure><p>使用方式如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var thunkify = require(<span class="string">'thunkify'</span>);</span><br><span class="line">var fs = require(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">var <span class="built_in">read</span> = thunkify(fs.readFile);</span><br><span class="line"><span class="built_in">read</span>(<span class="string">'package.json'</span>)(<span class="keyword">function</span>(err, str)&#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Thunkify 的源码与上一节那个简单的转换器非常像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> thunkify(fn)&#123;</span><br><span class="line">  <span class="built_in">return</span> <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    var args = new Array(arguments.length);</span><br><span class="line">    var ctx = this;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(var i = 0; i &lt; args.length; ++i) &#123;</span><br><span class="line">      args[i] = arguments[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> <span class="keyword">function</span>(<span class="keyword">done</span>)&#123;</span><br><span class="line">      var called;</span><br><span class="line"></span><br><span class="line">      args.push(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        <span class="keyword">if</span> (called) <span class="built_in">return</span>;</span><br><span class="line">        called = <span class="literal">true</span>;</span><br><span class="line">        done.apply(null, arguments);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line">        fn.apply(ctx, args);</span><br><span class="line">      &#125; catch (err) &#123;</span><br><span class="line">        <span class="keyword">done</span>(err);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>它的源码主要多了一个检查机制，变量 called 确保回调函数只运行一次。这样的设计与下文的 Generator 函数相关。请看下面的例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> f(a, b, callback)&#123;</span><br><span class="line">  var sum = a + b;</span><br><span class="line">  callback(sum);</span><br><span class="line">  callback(sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var ft = thunkify(f);</span><br><span class="line">var <span class="built_in">print</span> = console.log.bind(console);</span><br><span class="line">ft(1, 2)(<span class="built_in">print</span>);</span><br><span class="line">// 3</span><br></pre></td></tr></table></figure><p>上面代码中，由于 thunkify 只允许回调函数执行一次，所以只输出一行结果。</p><h6 id="Generator-函数的流程管理"><a href="#Generator-函数的流程管理" class="headerlink" title="Generator 函数的流程管理"></a>Generator 函数的流程管理</h6><p>你可能会问， Thunk 函数有什么用？回答是以前确实没什么用，但是 ES6 有了 Generator 函数，Thunk 函数现在可以用于 Generator 函数的自动流程管理。</p><p>Generator 函数可以自动执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">gen</span></span>() &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var g = gen();</span><br><span class="line">var res = g.next();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!res.done)&#123;</span><br><span class="line">  console.log(res.value);</span><br><span class="line">  res = g.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，Generator 函数 gen 会自动执行完所有步骤。</p><p>但是，这不适合异步操作。如果必须保证前一步执行完，才能执行后一步，上面的自动执行就不可行。这时，Thunk 函数就能派上用处。以读取文件为例。下面的 Generator 函数封装了两个异步操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(<span class="string">'fs'</span>);</span><br><span class="line">var thunkify = require(<span class="string">'thunkify'</span>);</span><br><span class="line">var readFile = thunkify(fs.readFile);</span><br><span class="line"></span><br><span class="line">var gen = <span class="keyword">function</span>* ()&#123;</span><br><span class="line">  var r1 = yield readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  console.log(r1.toString());</span><br><span class="line">  var r2 = yield readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">  console.log(r2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，yield 命令用于将程序的执行权移出 Generator 函数，那么就需要一种方法，将执行权再交还给 Generator 函数。</p><p>这种方法就是 Thunk 函数，因为它可以在回调函数里，将执行权交还给 Generator 函数。为了便于理解，我们先看如何手动执行上面这个 Generator 函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var g = gen();</span><br><span class="line"></span><br><span class="line">var r1 = g.next();</span><br><span class="line">r1.value(<span class="keyword">function</span>(err, data)&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) throw err;</span><br><span class="line">  var r2 = g.next(data);</span><br><span class="line">  r2.value(<span class="keyword">function</span>(err, data)&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) throw err;</span><br><span class="line">    g.next(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，变量 g 是 Generator 函数的内部指针，表示目前执行到哪一步。next 方法负责将指针移动到下一步，并返回该步的信息（value 属性和 done 属性）。</p><p>仔细查看上面的代码，可以发现 Generator 函数的执行过程，其实是将同一个回调函数，反复传入 next 方法的 value 属性。这使得我们可以用递归来自动完成这个过程。</p><h6 id="Thunk-函数的自动流程管理"><a href="#Thunk-函数的自动流程管理" class="headerlink" title="Thunk 函数的自动流程管理"></a>Thunk 函数的自动流程管理</h6><p>Thunk 函数真正的威力，在于可以自动执行 Generator 函数。下面就是一个基于 Thunk 函数的 Generator 执行器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> run(fn) &#123;</span><br><span class="line">  var gen = fn();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> next(err, data) &#123;</span><br><span class="line">    var result = gen.next(data);</span><br><span class="line">    <span class="keyword">if</span> (result.done) <span class="built_in">return</span>;</span><br><span class="line">    result.value(next);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">g</span></span>() &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(g);</span><br></pre></td></tr></table></figure><p>上面代码的 run 函数，就是一个 Generator 函数的自动执行器。内部的 next 函数就是 Thunk 的回调函数。next 函数先将指针移到 Generator 函数的下一步（gen.next 方法），然后判断 Generator 函数是否结束（result.done 属性），如果没结束，就将 next 函数再传入 Thunk 函数（result.value 属性），否则就直接退出。</p><p>有了这个执行器，执行 Generator 函数方便多了。不管内部有多少个异步操作，直接把 Generator 函数传入 run 函数即可。当然，前提是每一个异步操作，都要是 Thunk 函数，也就是说，跟在 yield 命令后面的必须是 Thunk 函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var g = <span class="keyword">function</span>* ()&#123;</span><br><span class="line">  var f1 = yield readFile(<span class="string">'fileA'</span>);</span><br><span class="line">  var f2 = yield readFile(<span class="string">'fileB'</span>);</span><br><span class="line">  // ...</span><br><span class="line">  var fn = yield readFile(<span class="string">'fileN'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">run(g);</span><br></pre></td></tr></table></figure><p>上面代码中，函数 g 封装了 n 个异步的读取文件操作，只要执行 run 函数，这些操作就会自动完成。这样一来，异步操作不仅可以写得像同步操作，而且一行代码就可以执行。</p><p>Thunk 函数并不是 Generator 函数自动执行的唯一方案。因为自动执行的关键是，必须有一种机制，自动控制 Generator 函数的流程，接收和交还程序的执行权。回调函数可以做到这一点，Promise 对象也可以做到这一点。</p><h5 id="co-模块"><a href="#co-模块" class="headerlink" title="co 模块"></a>co 模块</h5><h6 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h6><p>co 模块是著名程序员 TJ Holowaychuk 于 2013 年 6 月发布的一个小工具，用于 Generator 函数的自动执行。</p><p>比如，有一个 Generator 函数，用于依次读取两个文件。</p><p>var gen = function* (){<br>var f1 = yield readFile(‘/etc/fstab’);<br>var f2 = yield readFile(‘/etc/shells’);<br>console.log(f1.toString());<br>console.log(f2.toString());<br>};<br>co 模块可以让你不用编写 Generator 函数的执行器。</p><p>var co = require(‘co’);<br>co(gen);<br>上面代码中，Generator 函数只要传入 co 函数，就会自动执行。</p><p>co 函数返回一个 Promise 对象，因此可以用 then 方法添加回调函数。</p><p>co(gen).then(function (){<br>console.log(‘Generator 函数执行完成’);<br>});<br>上面代码中，等到 Generator 函数执行结束，就会输出一行提示。</p><h6 id="co-模块的原理"><a href="#co-模块的原理" class="headerlink" title="co 模块的原理"></a>co 模块的原理</h6><p>为什么 co 可以自动执行 Generator 函数？</p><p>前面说过，Generator 就是一个异步操作的容器。它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。</p><p>两种方法可以做到这一点。</p><p>（1）回调函数。将异步操作包装成 Thunk 函数，在回调函数里面交回执行权。</p><p>（2）Promise 对象。将异步操作包装成 Promise 对象，用 then 方法交回执行权。</p><p>co 模块其实就是将两种自动执行器（Thunk 函数和 Promise 对象），包装成一个模块。使用 co 的前提条件是，Generator 函数的 yield 命令后面，只能是 Thunk 函数或 Promise 对象。</p><p>上一节已经介绍了基于 Thunk 函数的自动执行器。下面来看，基于 Promise 对象的自动执行器。这是理解 co 模块必须的。</p><h6 id="基于-Promise-对象的自动执行"><a href="#基于-Promise-对象的自动执行" class="headerlink" title="基于 Promise 对象的自动执行"></a>基于 Promise 对象的自动执行</h6><p>还是沿用上面的例子。首先，把 fs 模块的 readFile 方法包装成一个 Promise 对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">var readFile = <span class="keyword">function</span> (fileName)&#123;</span><br><span class="line">  <span class="built_in">return</span> new Promise(<span class="keyword">function</span> (resolve, reject)&#123;</span><br><span class="line">    fs.readFile(fileName, <span class="keyword">function</span>(error, data)&#123;</span><br><span class="line">      <span class="keyword">if</span> (error) <span class="built_in">return</span> reject(error);</span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var gen = <span class="keyword">function</span>* ()&#123;</span><br><span class="line">  var f1 = yield readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  var f2 = yield readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">  console.log(f1.toString());</span><br><span class="line">  console.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后，手动执行上面的 Generator 函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var g = gen();</span><br><span class="line"></span><br><span class="line">g.next().value.then(<span class="keyword">function</span>(data)&#123;</span><br><span class="line">  g.next(data).value.then(<span class="keyword">function</span>(data)&#123;</span><br><span class="line">    g.next(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>手动执行其实就是用 then 方法，层层添加回调函数。理解了这一点，就可以写出一个自动执行器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> run(gen)&#123;</span><br><span class="line">  var g = gen();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> next(data)&#123;</span><br><span class="line">    var result = g.next(data);</span><br><span class="line">    <span class="keyword">if</span> (result.done) <span class="built_in">return</span> result.value;</span><br><span class="line">    result.value.then(<span class="keyword">function</span>(data)&#123;</span><br><span class="line">      next(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(gen);</span><br></pre></td></tr></table></figure><p>上面代码中，只要 Generator 函数还没执行到最后一步，next 函数就调用自身，以此实现自动执行。</p><h6 id="co-模块的源码"><a href="#co-模块的源码" class="headerlink" title="co 模块的源码"></a>co 模块的源码</h6><p>co 就是上面那个自动执行器的扩展，它的源码只有几十行，非常简单。</p><p>首先，co 函数接受 Generator 函数作为参数，返回一个 Promise 对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> co(gen) &#123;</span><br><span class="line">  var ctx = this;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> new Promise(<span class="keyword">function</span>(resolve, reject) &#123;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在返回的 Promise 对象里面，co 先检查参数 gen 是否为 Generator 函数。如果是，就执行该函数，得到一个内部指针对象；如果不是就返回，并将 Promise 对象的状态改为 resolved。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> co(gen) &#123;</span><br><span class="line">  var ctx = this;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> new Promise(<span class="keyword">function</span>(resolve, reject) &#123;</span><br><span class="line">    <span class="keyword">if</span> (typeof gen === <span class="string">'function'</span>) gen = gen.call(ctx);</span><br><span class="line">    <span class="keyword">if</span> (!gen || typeof gen.next !== <span class="string">'function'</span>) <span class="built_in">return</span> resolve(gen);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，co 将 Generator 函数的内部指针对象的 next 方法，包装成 onFulfilled 函数。这主要是为了能够捕捉抛出的错误。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> co(gen) &#123;</span><br><span class="line">  var ctx = this;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> new Promise(<span class="keyword">function</span>(resolve, reject) &#123;</span><br><span class="line">    <span class="keyword">if</span> (typeof gen === <span class="string">'function'</span>) gen = gen.call(ctx);</span><br><span class="line">    <span class="keyword">if</span> (!gen || typeof gen.next !== <span class="string">'function'</span>) <span class="built_in">return</span> resolve(gen);</span><br><span class="line"></span><br><span class="line">    onFulfilled();</span><br><span class="line">    <span class="keyword">function</span> onFulfilled(res) &#123;</span><br><span class="line">      var ret;</span><br><span class="line">      try &#123;</span><br><span class="line">        ret = gen.next(res);</span><br><span class="line">      &#125; catch (e) &#123;</span><br><span class="line">        <span class="built_in">return</span> reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">      next(ret);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，就是关键的 next 函数，它会反复调用自身。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> next(ret) &#123;</span><br><span class="line">  <span class="keyword">if</span> (ret.done) <span class="built_in">return</span> resolve(ret.value);</span><br><span class="line">  var value = toPromise.call(ctx, ret.value);</span><br><span class="line">  <span class="keyword">if</span> (value &amp;&amp; isPromise(value)) <span class="built_in">return</span> value.then(onFulfilled, onRejected);</span><br><span class="line">  <span class="built_in">return</span> onRejected(new TypeError(<span class="string">'You may only yield a function, promise, generator, array, or object, '</span></span><br><span class="line">    + <span class="string">'but the following object was passed: "'</span> + String(ret.value) + <span class="string">'"'</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，next 函数的内部代码，一共只有四行命令。</p><p>第一行，检查当前是否为 Generator 函数的最后一步，如果是就返回。</p><p>第二行，确保每一步的返回值，是 Promise 对象。</p><p>第三行，使用 then 方法，为返回值加上回调函数，然后通过 onFulfilled 函数再次调用 next 函数。</p><p>第四行，在参数不符合要求的情况下（参数非 Thunk 函数和 Promise 对象），将 Promise 对象的状态改为 rejected，从而终止执行。</p><h6 id="处理并发的异步操作"><a href="#处理并发的异步操作" class="headerlink" title="处理并发的异步操作"></a>处理并发的异步操作</h6><p>co 支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步。</p><p>这时，要把并发的操作都放在数组或对象里面，跟在 yield 语句后面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 数组的写法</span><br><span class="line">co(<span class="keyword">function</span>* () &#123;</span><br><span class="line">  var res = yield [</span><br><span class="line">    Promise.resolve(1),</span><br><span class="line">    Promise.resolve(2)</span><br><span class="line">  ];</span><br><span class="line">  console.log(res);</span><br><span class="line">&#125;).catch(onerror);</span><br><span class="line"></span><br><span class="line">// 对象的写法</span><br><span class="line">co(<span class="keyword">function</span>* () &#123;</span><br><span class="line">  var res = yield &#123;</span><br><span class="line">    1: Promise.resolve(1),</span><br><span class="line">    2: Promise.resolve(2),</span><br><span class="line">  &#125;;</span><br><span class="line">  console.log(res);</span><br><span class="line">&#125;).catch(onerror);</span><br></pre></td></tr></table></figure><p>下面是另一个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">co(<span class="keyword">function</span>* () &#123;</span><br><span class="line">  var values = [n1, n2, n3];</span><br><span class="line">  yield values.map(somethingAsync);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* somethingAsync(x) &#123;</span><br><span class="line">  // <span class="keyword">do</span> something async</span><br><span class="line">  <span class="built_in">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码允许并发三个 somethingAsync 异步操作，等到它们全部完成，才会进行下一步。</p><h5 id="async-函数"><a href="#async-函数" class="headerlink" title="async 函数"></a>async 函数</h5><h6 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h6><p>ES7 提供了 async 函数，使得异步操作变得更加方便。async 函数是什么？一句话，async 函数就是 Generator 函数的语法糖。</p><p>前文有一个 Generator 函数，依次读取两个文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">var readFile = <span class="keyword">function</span> (fileName) &#123;</span><br><span class="line">  <span class="built_in">return</span> new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">    fs.readFile(fileName, <span class="keyword">function</span>(error, data) &#123;</span><br><span class="line">      <span class="keyword">if</span> (error) reject(error);</span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var gen = <span class="keyword">function</span>* ()&#123;</span><br><span class="line">  var f1 = yield readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  var f2 = yield readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">  console.log(f1.toString());</span><br><span class="line">  console.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>写成 async 函数，就是下面这样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var asyncReadFile = async <span class="function"><span class="title">function</span></span> ()&#123;</span><br><span class="line">  var f1 = await readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  var f2 = await readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">  console.log(f1.toString());</span><br><span class="line">  console.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一比较就会发现，async 函数就是将 Generator 函数的星号（*）替换成 async，将 yield 替换成 await，仅此而已。</p><p>async 函数对 Generator 函数的改进，体现在以下四点。</p><p>（1）内置执行器。Generator 函数的执行必须靠执行器，所以才有了 co 模块，而 async 函数自带执行器。也就是说，async 函数的执行，与普通函数一模一样，只要一行。</p><p>var result = asyncReadFile();<br>上面的代码调用了 asyncReadFile 函数，然后它就会自动执行，输出最后结果。这完全不像 Generator 函数，需要调用 next 方法，或者用 co 模块，才能得到真正执行，得到最后结果。</p><p>（2）更好的语义。async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。</p><p>（3）更广的适用性。 co 模块约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。</p><p>（4）返回值是 Promise。async 函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用 then 方法指定下一步的操作。</p><p>进一步说，async 函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而 await 命令就是内部 then 命令的语法糖。</p><h6 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h6><p>async 函数的语法规则总体上比较简单，难点是错误处理机制。</p><p>（1）async 函数返回一个 Promise 对象。</p><p>async 函数内部 return 语句返回的值，会成为 then 方法回调函数的参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> <span class="string">'hello world'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().<span class="keyword">then</span>(v =&gt; console.log(v))</span><br><span class="line">// <span class="string">"hello world"</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数 f 内部 return 命令返回的值，会被 then 方法回调函数接收到。</p><p>async 函数内部抛出错误，会导致返回的 Promise 对象变为 reject 状态。抛出的错误对象会被 catch 方法回调函数接收到。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  throw new Error(<span class="string">'出错了'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().<span class="keyword">then</span>(</span><br><span class="line">  v =&gt; console.log(v),</span><br><span class="line">  e =&gt; console.log(e)</span><br><span class="line">)</span><br><span class="line">// Error: 出错了</span><br></pre></td></tr></table></figure><p>（2）async 函数返回的 Promise 对象，必须等到内部所有 await 命令的 Promise 对象执行完，才会发生状态改变。也就是说，只有 async 函数内部的异步操作执行完，才会执行 then 方法指定的回调函数。</p><p>下面是一个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> getTitle(url) &#123;</span><br><span class="line">  <span class="built_in">let</span> response = await fetch(url);</span><br><span class="line">  <span class="built_in">let</span> html = await response.text();</span><br><span class="line">  <span class="built_in">return</span> html.match(/&lt;title&gt;([\s\S]+)&lt;\/title&gt;/i)[1];</span><br><span class="line">&#125;</span><br><span class="line">getTitle(<span class="string">'https://tc39.github.io/ecma262/'</span>).<span class="keyword">then</span>(console.log)</span><br><span class="line">// <span class="string">"ECMAScript 2017 Language Specification"</span></span><br></pre></td></tr></table></figure><p>（3）正常情况下，await 命令后面是一个 Promise 对象。如果不是，会被转成一个立即 resolve 的 Promise 对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> await 123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().<span class="keyword">then</span>(v =&gt; console.log(v))</span><br><span class="line">// 123</span><br></pre></td></tr></table></figure><p>上面代码中，await 命令的参数是数值 123，它被转成 Promise 对象，并立即 resolve。</p><p>await 命令后面的 Promise 对象如果变为 reject 状态，则 reject 的参数会被 catch 方法的回调函数接收到。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  await Promise.reject(<span class="string">'出错了'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.<span class="keyword">then</span>(v =&gt; console.log(v))</span><br><span class="line">.catch(e =&gt; console.log(e))</span><br><span class="line">// 出错了</span><br></pre></td></tr></table></figure><p>注意，上面代码中，await 语句前面没有 return，但是 reject 方法的参数依然传入了 catch 方法的回调函数。这里如果在 await 前面加上 return，效果是一样的。</p><p>只要一个 await 语句后面的 Promise 变为 reject，那么整个 async 函数都会中断执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  await Promise.reject(<span class="string">'出错了'</span>);</span><br><span class="line">  await Promise.resolve(<span class="string">'hello world'</span>); // 不会执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，第二个 await 语句是不会执行的，因为第一个 await 语句状态变成了 reject。</p><p>为了避免这个问题，可以将第一个 await 放在 try…catch 结构里面，这样第二个 await 就会执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    await Promise.reject(<span class="string">'出错了'</span>);</span><br><span class="line">  &#125; catch(e) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> await Promise.resolve(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.<span class="keyword">then</span>(v =&gt; console.log(v))</span><br><span class="line">// hello world</span><br></pre></td></tr></table></figure><p>另一种方法是 await 后面的 Promise 对象再跟一个 catch 方面，处理前面可能出现的错误。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  await Promise.reject(<span class="string">'出错了'</span>)</span><br><span class="line">    .catch(e =&gt; console.log(e));</span><br><span class="line">  <span class="built_in">return</span> await Promise.resolve(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.<span class="keyword">then</span>(v =&gt; console.log(v))</span><br><span class="line">// 出错了</span><br><span class="line">// hello world</span><br></pre></td></tr></table></figure><p>如果有多个 await 命令，可以统一放在 try…catch 结构中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    var val1 = await firstStep();</span><br><span class="line">    var val2 = await secondStep(val1);</span><br><span class="line">    var val3 = await thirdStep(val1, val2);</span><br><span class="line"></span><br><span class="line">    console.log(<span class="string">'Final: '</span>, val3);</span><br><span class="line">  &#125;</span><br><span class="line">  catch (err) &#123;</span><br><span class="line">    console.error(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）如果 await 后面的异步操作出错，那么等同于 async 函数返回的 Promise 对象被 reject。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  await new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">    throw new Error(<span class="string">'出错了'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.<span class="keyword">then</span>(v =&gt; console.log(v))</span><br><span class="line">.catch(e =&gt; console.log(e))</span><br><span class="line">// Error：出错了</span><br></pre></td></tr></table></figure><p>上面代码中，async 函数 f 执行后，await 后面的 Promise 对象会抛出一个错误对象，导致 catch 方法的回调函数被调用，它的参数就是抛出的错误对象。具体的执行机制，可以参考后文的“async 函数的实现”。</p><p>防止出错的方法，也是将其放在 try…catch 代码块之中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    await new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">      throw new Error(<span class="string">'出错了'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; catch(e) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> await(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="async-函数的实现"><a href="#async-函数的实现" class="headerlink" title="async 函数的实现"></a>async 函数的实现</h6><p>async 函数的实现，就是将 Generator 函数和自动执行器，包装在一个函数里。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> fn(args)&#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> fn(args)&#123;</span><br><span class="line">  <span class="built_in">return</span> spawn(<span class="keyword">function</span>*() &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有的 async 函数都可以写成上面的第二种形式，其中的 spawn 函数就是自动执行器。</p><p>下面给出 spawn 函数的实现，基本就是前文自动执行器的翻版。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> spawn(genF) &#123;</span><br><span class="line">  <span class="built_in">return</span> new Promise(<span class="keyword">function</span>(resolve, reject) &#123;</span><br><span class="line">    var gen = genF();</span><br><span class="line">    <span class="keyword">function</span> step(nextF) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        var next = nextF();</span><br><span class="line">      &#125; catch(e) &#123;</span><br><span class="line">        <span class="built_in">return</span> reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(next.done) &#123;</span><br><span class="line">        <span class="built_in">return</span> resolve(next.value);</span><br><span class="line">      &#125;</span><br><span class="line">      Promise.resolve(next.value).<span class="keyword">then</span>(<span class="keyword">function</span>(v) &#123;</span><br><span class="line">        step(<span class="function"><span class="title">function</span></span>() &#123; <span class="built_in">return</span> gen.next(v); &#125;);</span><br><span class="line">      &#125;, <span class="keyword">function</span>(e) &#123;</span><br><span class="line">        step(<span class="function"><span class="title">function</span></span>() &#123; <span class="built_in">return</span> gen.throw(e); &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    step(<span class="function"><span class="title">function</span></span>() &#123; <span class="built_in">return</span> gen.next(undefined); &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>async 函数是非常新的语法功能，新到都不属于 ES6，而是属于 ES7。目前，它仍处于提案阶段，但是转码器 Babel 和 regenerator 都已经支持，转码后就能使用。</p><h6 id="async-函数的用法"><a href="#async-函数的用法" class="headerlink" title="async 函数的用法"></a>async 函数的用法</h6><p>async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数。当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再接着执行函数体内后面的语句。</p><p>下面是一个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> getStockPriceByName(name) &#123;</span><br><span class="line">  var symbol = await getStockSymbol(name);</span><br><span class="line">  var stockPrice = await getStockPrice(symbol);</span><br><span class="line">  <span class="built_in">return</span> stockPrice;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getStockPriceByName(<span class="string">'goog'</span>).<span class="keyword">then</span>(<span class="keyword">function</span> (result) &#123;</span><br><span class="line">  console.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码是一个获取股票报价的函数，函数前面的 async 关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个 Promise 对象。</p><p>下面的例子，指定多少毫秒后输出一个值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> timeout(ms) &#123;</span><br><span class="line">  <span class="built_in">return</span> new Promise((resolve) =&gt; &#123;</span><br><span class="line">    setTimeout(resolve, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async <span class="keyword">function</span> asyncPrint(value, ms) &#123;</span><br><span class="line">  await timeout(ms);</span><br><span class="line">  console.log(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncPrint(<span class="string">'hello world'</span>, 50);</span><br></pre></td></tr></table></figure><p>上面代码指定 50 毫秒以后，输出”hello world”。</p><p>Async 函数有多种使用形式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 函数声明</span><br><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 函数表达式</span><br><span class="line">const foo = async <span class="function"><span class="title">function</span></span> () &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// 对象的方法</span><br><span class="line"><span class="built_in">let</span> obj = &#123; async <span class="function"><span class="title">foo</span></span>() &#123;&#125; &#125;;</span><br><span class="line">obj.foo().<span class="keyword">then</span>(...)</span><br><span class="line"></span><br><span class="line">// Class 的方法</span><br><span class="line">class Storage &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    this.cachePromise = caches.open(<span class="string">'avatars'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  async getAvatar(name) &#123;</span><br><span class="line">    const cache = await this.cachePromise;</span><br><span class="line">    <span class="built_in">return</span> cache.match(`/avatars/<span class="variable">$&#123;name&#125;</span>.jpg`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const storage = new Storage();</span><br><span class="line">storage.getAvatar(<span class="string">'jake'</span>).<span class="keyword">then</span>(…);</span><br><span class="line"></span><br><span class="line">// 箭头函数</span><br><span class="line">const foo = async () =&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure><h5 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h5><p>第一点，await 命令后面的 Promise 对象，运行结果可能是 rejected，所以最好把 await 命令放在 try…catch 代码块中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">myFunction</span></span>() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    await somethingThatReturnsAPromise();</span><br><span class="line">  &#125; catch (err) &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 另一种写法</span><br><span class="line"></span><br><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">myFunction</span></span>() &#123;</span><br><span class="line">  await somethingThatReturnsAPromise()</span><br><span class="line">  .catch(<span class="keyword">function</span> (err) &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二点，多个 await 命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> foo = await getFoo();</span><br><span class="line"><span class="built_in">let</span> bar = await getBar();</span><br></pre></td></tr></table></figure><p>上面代码中，getFoo 和 getBar 是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有 getFoo 完成以后，才会执行 getBar，完全可以让它们同时触发。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 写法一</span><br><span class="line"><span class="built_in">let</span> [foo, bar] = await Promise.all([getFoo(), getBar()]);</span><br><span class="line"></span><br><span class="line">// 写法二</span><br><span class="line"><span class="built_in">let</span> fooPromise = getFoo();</span><br><span class="line"><span class="built_in">let</span> barPromise = getBar();</span><br><span class="line"><span class="built_in">let</span> foo = await fooPromise;</span><br><span class="line"><span class="built_in">let</span> bar = await barPromise;</span><br></pre></td></tr></table></figure><p>上面两种写法，getFoo 和 getBar 都是同时触发，这样就会缩短程序的执行时间。</p><p>第三点，await 命令只能用在 async 函数之中，如果用在普通函数，就会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> dbFuc(db) &#123;</span><br><span class="line">  <span class="built_in">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  // 报错</span><br><span class="line">  docs.forEach(<span class="keyword">function</span> (doc) &#123;</span><br><span class="line">    await db.post(doc);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码会报错，因为 await 用在普通函数之中了。但是，如果将 forEach 方法的参数改成 async 函数，也有问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> dbFuc(db) &#123;</span><br><span class="line">  <span class="built_in">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  // 可能得到错误结果</span><br><span class="line">  docs.forEach(async <span class="keyword">function</span> (doc) &#123;</span><br><span class="line">    await db.post(doc);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码可能不会正常工作，原因是这时三个 db.post 操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用 for 循环。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> dbFuc(db) &#123;</span><br><span class="line">  <span class="built_in">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">let</span> doc of docs) &#123;</span><br><span class="line">    await db.post(doc);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果确实希望多个请求并发执行，可以使用 Promise.all 方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> dbFuc(db) &#123;</span><br><span class="line">  <span class="built_in">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line">  <span class="built_in">let</span> promises = docs.map((doc) =&gt; db.post(doc));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">let</span> results = await Promise.all(promises);</span><br><span class="line">  console.log(results);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 或者使用下面的写法</span><br><span class="line"></span><br><span class="line">async <span class="keyword">function</span> dbFuc(db) &#123;</span><br><span class="line">  <span class="built_in">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line">  <span class="built_in">let</span> promises = docs.map((doc) =&gt; db.post(doc));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">let</span> results = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">let</span> promise of promises) &#123;</span><br><span class="line">    results.push(await promise);</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(results);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES6 将 await 增加为保留字。使用这个词作为标识符，在 ES5 是合法的，在 ES6 将抛出 SyntaxError。</p><h5 id="与-Promise、Generator-的比较"><a href="#与-Promise、Generator-的比较" class="headerlink" title="与 Promise、Generator 的比较"></a>与 Promise、Generator 的比较</h5><p>我们通过一个例子，来看 Async 函数与 Promise、Generator 函数的区别。</p><p>假定某个 DOM 元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。</p><p>首先是 Promise 的写法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> chainAnimationsPromise(elem, animations) &#123;</span><br><span class="line"></span><br><span class="line">  // 变量ret用来保存上一个动画的返回值</span><br><span class="line">  var ret = null;</span><br><span class="line"></span><br><span class="line">  // 新建一个空的Promise</span><br><span class="line">  var p = Promise.resolve();</span><br><span class="line"></span><br><span class="line">  // 使用<span class="keyword">then</span>方法，添加所有动画</span><br><span class="line">  <span class="keyword">for</span>(var anim of animations) &#123;</span><br><span class="line">    p = p.then(<span class="keyword">function</span>(val) &#123;</span><br><span class="line">      ret = val;</span><br><span class="line">      <span class="built_in">return</span> anim(elem);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 返回一个部署了错误捕捉机制的Promise</span><br><span class="line">  <span class="built_in">return</span> p.catch(<span class="keyword">function</span>(e) &#123;</span><br><span class="line">    /* 忽略错误，继续执行 */</span><br><span class="line">  &#125;).<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> ret;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然 Promise 的写法比回调函数的写法大大改进，但是一眼看上去，代码完全都是 Promise 的 API（then、catch 等等），操作本身的语义反而不容易看出来。</p><p>接着是 Generator 函数的写法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> chainAnimationsGenerator(elem, animations) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> spawn(<span class="keyword">function</span>*() &#123;</span><br><span class="line">    var ret = null;</span><br><span class="line">    try &#123;</span><br><span class="line">      <span class="keyword">for</span>(var anim of animations) &#123;</span><br><span class="line">        ret = yield anim(elem);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch(e) &#123;</span><br><span class="line">      /* 忽略错误，继续执行 */</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> ret;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码使用 Generator 函数遍历了每个动画，语义比 Promise 写法更清晰，用户定义的操作全部都出现在 spawn 函数的内部。这个写法的问题在于，必须有一个任务运行器，自动执行 Generator 函数，上面代码的 spawn 函数就是自动执行器，它返回一个 Promise 对象，而且必须保证 yield 语句后面的表达式，必须返回一个 Promise。</p><p>最后是 Async 函数的写法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> chainAnimationsAsync(elem, animations) &#123;</span><br><span class="line">  var ret = null;</span><br><span class="line">  try &#123;</span><br><span class="line">    <span class="keyword">for</span>(var anim of animations) &#123;</span><br><span class="line">      ret = await anim(elem);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; catch(e) &#123;</span><br><span class="line">    /* 忽略错误，继续执行 */</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 Async 函数的实现最简洁，最符合语义，几乎没有语义不相关的代码。它将 Generator 写法中的自动执行器，改在语言层面提供，不暴露给用户，因此代码量最少。如果使用 Generator 写法，自动执行器需要用户自己提供。</p><h5 id="实例：按顺序完成异步操作"><a href="#实例：按顺序完成异步操作" class="headerlink" title="实例：按顺序完成异步操作"></a>实例：按顺序完成异步操作</h5><p>实际开发中，经常遇到一组异步操作，需要按照顺序完成。比如，依次远程读取一组 URL，然后按照读取的顺序输出结果。</p><p>Promise 的写法如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> logInOrder(urls) &#123;</span><br><span class="line">  // 远程读取所有URL</span><br><span class="line">  const textPromises = urls.map(url =&gt; &#123;</span><br><span class="line">    <span class="built_in">return</span> fetch(url).<span class="keyword">then</span>(response =&gt; response.text());</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  // 按次序输出</span><br><span class="line">  textPromises.reduce((chain, textPromise) =&gt; &#123;</span><br><span class="line">    <span class="built_in">return</span> chain.then(() =&gt; textPromise)</span><br><span class="line">      .<span class="keyword">then</span>(text =&gt; console.log(text));</span><br><span class="line">  &#125;, Promise.resolve());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码使用 fetch 方法，同时远程读取一组 URL。每个 fetch 操作都返回一个 Promise 对象，放入 textPromises 数组。然后，reduce 方法依次处理每个 Promise 对象，然后使用 then，将所有 Promise 对象连起来，因此就可以依次输出结果。</p><p>这种写法不太直观，可读性比较差。下面是 async 函数实现。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> logInOrder(urls) &#123;</span><br><span class="line">  <span class="keyword">for</span> (const url of urls) &#123;</span><br><span class="line">    const response = await fetch(url);</span><br><span class="line">    console.log(await response.text());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码确实大大简化，问题是所有远程操作都是继发。只有前一个 URL 返回结果，才会去读取下一个 URL，这样做效率很差，非常浪费时间。我们需要的是并发发出远程请求。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> logInOrder(urls) &#123;</span><br><span class="line">  // 并发读取远程URL</span><br><span class="line">  const textPromises = urls.map(async url =&gt; &#123;</span><br><span class="line">    const response = await fetch(url);</span><br><span class="line">    <span class="built_in">return</span> response.text();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  // 按次序输出</span><br><span class="line">  <span class="keyword">for</span> (const textPromise of textPromises) &#123;</span><br><span class="line">    console.log(await textPromise);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，虽然 map 方法的参数是 async 函数，但它是并发执行的，因为只有 async 函数内部是继发执行，外部不受影响。后面的 for..of 循环内部使用了 await，因此实现了按顺序输出。</p><h4 id="异步遍历器"><a href="#异步遍历器" class="headerlink" title="异步遍历器"></a>异步遍历器</h4><p>《遍历器》一章说过，Iterator 接口是一种数据遍历的协议，只要调用遍历器对象的 next 方法，就会得到一个表示当前成员信息的对象{value, done}。其中，value 表示当前的数据的值，done 是一个布尔值，表示遍历是否结束。</p><p>这隐含着规定，next 方法是同步的，只要调用就必须立刻返回值。也就是说，一旦执行 next 方法，就必须同步地得到 value 和 done 这两方面的信息。这对于同步操作，当然没有问题，但对于异步操作，就不太合适了。目前的解决方法是，Generator 函数里面的异步操作，返回一个 Thunk 函数或者 Promise 对象，即 value 属性是一个 Thunk 函数或者 Promise 对象，等待以后返回真正的值，而 done 属性则还是同步产生的。</p><p>目前，有一个提案，为异步操作提供原生的遍历器接口，即 value 和 done 这两个属性都是异步产生，这称为”异步遍历器“（Async Iterator）。</p><h5 id="异步遍历的接口"><a href="#异步遍历的接口" class="headerlink" title="异步遍历的接口"></a>异步遍历的接口</h5><p>异步遍历器的最大的语法特点，就是调用遍历器的 next 方法，返回的是一个 Promise 对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">asyncIterator</span><br><span class="line">  .next()</span><br><span class="line">  .<span class="keyword">then</span>(</span><br><span class="line">    (&#123; value, <span class="keyword">done</span> &#125;) =&gt; /* ... */</span><br><span class="line">  );</span><br></pre></td></tr></table></figure><p>上面代码中，asyncIterator 是一个异步遍历器，调用 next 方法以后，返回一个 Promise 对象。因此，可以使用 then 方法指定，这个 Promise 对象的状态变为 resolve 以后的回调函数。回调函数的参数，则是一个具有 value 和 done 两个属性的对象，这个跟同步遍历器是一样的。</p><p>我们知道，一个对象的同步遍历器的接口，部署在 Symbol.iterator 属性上面。同样地，对象的异步遍历器接口，部署在 Symbol.asyncIterator 属性上面。不管是什么样的对象，只要它的 Symbol.asyncIterator 属性有值，就表示应该对它进行异步遍历。</p><p>下面是一个异步遍历器的例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const asyncIterable = createAsyncIterable([<span class="string">'a'</span>, <span class="string">'b'</span>]);</span><br><span class="line">const asyncIterator = someCollection[Symbol.asyncIterator]();</span><br><span class="line"></span><br><span class="line">asyncIterator.next()</span><br><span class="line">.<span class="keyword">then</span>(iterResult1 =&gt; &#123;</span><br><span class="line">  console.log(iterResult1); // &#123; value: <span class="string">'a'</span>, <span class="keyword">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">  <span class="built_in">return</span> asyncIterator.next();</span><br><span class="line">&#125;).<span class="keyword">then</span>(iterResult2 =&gt; &#123;</span><br><span class="line">  console.log(iterResult2); // &#123; value: <span class="string">'b'</span>, <span class="keyword">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">  <span class="built_in">return</span> asyncIterator.next();</span><br><span class="line">&#125;).<span class="keyword">then</span>(iterResult3 =&gt; &#123;</span><br><span class="line">  console.log(iterResult3); // &#123; value: undefined, <span class="keyword">done</span>: <span class="literal">true</span> &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，异步遍历器其实返回了两次值。第一次调用的时候，返回一个 Promise 对象；等到 Promise 对象 resolve 了，再返回一个表示当前数据成员信息的对象。这就是说，异步遍历器与同步遍历器最终行为是一致的，只是会先返回 Promise 对象，作为中介。</p><p>由于异步遍历器的 next 方法，返回的是一个 Promise 对象。因此，可以把它放在 await 命令后面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  const asyncIterable = createAsyncIterable([<span class="string">'a'</span>, <span class="string">'b'</span>]);</span><br><span class="line">  const asyncIterator = asyncIterable[Symbol.asyncIterator]();</span><br><span class="line">  console.log(await asyncIterator.next());</span><br><span class="line">  // &#123; value: <span class="string">'a'</span>, <span class="keyword">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">  console.log(await asyncIterator.next());</span><br><span class="line">  // &#123; value: <span class="string">'b'</span>, <span class="keyword">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">  console.log(await asyncIterator.next());</span><br><span class="line">  // &#123; value: undefined, <span class="keyword">done</span>: <span class="literal">true</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，next 方法用 await 处理以后，就不必使用 then 方法了。整个流程已经很接近同步处理了。</p><p>注意，异步遍历器的 next 方法是可以连续调用的，不必等到上一步产生的 Promise 对象 resolve 以后再调用。这种情况下，next 方法会累积起来，自动按照每一步的顺序运行下去。下面是一个例子，把所有的 next 方法放在 Promise.all 方法里面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const asyncGenObj = createAsyncIterable([<span class="string">'a'</span>, <span class="string">'b'</span>]);</span><br><span class="line">const [&#123;value: v1&#125;, &#123;value: v2&#125;] = await Promise.all([</span><br><span class="line">  asyncGenObj.next(), asyncGenObj.next()</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">console.log(v1, v2); // a b</span><br></pre></td></tr></table></figure><p>另一种用法是一次性调用所有的 next 方法，然后 await 最后一步操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const writer = openFile(<span class="string">'someFile.txt'</span>);</span><br><span class="line">writer.next(<span class="string">'hello'</span>);</span><br><span class="line">writer.next(<span class="string">'world'</span>);</span><br><span class="line">await writer.return();</span><br></pre></td></tr></table></figure><h5 id="for-await…of"><a href="#for-await…of" class="headerlink" title="for await…of"></a>for await…of</h5><p>前面介绍过，for…of 循环用于遍历同步的 Iterator 接口。新引入的 for await…of 循环，则是用于遍历异步的 Iterator 接口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  <span class="keyword">for</span> await (const x of createAsyncIterable([<span class="string">'a'</span>, <span class="string">'b'</span>])) &#123;</span><br><span class="line">    console.log(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// a</span><br><span class="line">// b</span><br></pre></td></tr></table></figure><p>上面代码中，createAsyncIterable()返回一个异步遍历器，for…of 循环自动调用这个遍历器的 next 方法，会得到一个 Promise 对象。await 用来处理这个 Promise 对象，一旦 resolve，就把得到的值（x）传入 for…of 的循环体。</p><p>如果 next 方法返回的 Promise 对象被 reject，那么就要用 try…catch 捕捉。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">async <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    <span class="keyword">for</span> await (const x of createRejectingIterable()) &#123;</span><br><span class="line">      console.log(x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    console.error(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，for await…of 循环也可以用于同步遍历器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(async <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  <span class="keyword">for</span> await (const x of [<span class="string">'a'</span>, <span class="string">'b'</span>]) &#123;</span><br><span class="line">    console.log(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">// a</span><br><span class="line">// b</span><br></pre></td></tr></table></figure><h5 id="异步-Generator-函数"><a href="#异步-Generator-函数" class="headerlink" title="异步 Generator 函数"></a>异步 Generator 函数</h5><p>就像 Generator 函数返回一个同步遍历器对象一样，异步 Generator 函数的作用，是返回一个异步遍历器对象。</p><p>在语法上，异步 Generator 函数就是 async 函数与 Generator 函数的结合。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span>* readLines(path) &#123;</span><br><span class="line">  <span class="built_in">let</span> file = await fileOpen(path);</span><br><span class="line"></span><br><span class="line">  try &#123;</span><br><span class="line">    <span class="keyword">while</span> (!file.EOF) &#123;</span><br><span class="line">      yield await file.readLine();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    await file.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，异步操作前面使用 await 关键字标明，即 await 后面的操作，应该返回 Promise 对象。凡是使用 yield 关键字的地方，就是 next 方法的停下来的地方，它后面的表达式的值（即 await file.readLine()的值），会作为 next()返回对象的 value 属性，这一点是于同步 Generator 函数一致的。</p><p>可以像下面这样，使用上面代码定义的异步 Generator 函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> await (const line of readLines(filePath)) &#123;</span><br><span class="line">  console.log(line);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异步 Generator 函数可以与 for await…of 循环结合起来使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span>* prefixLines(asyncIterable) &#123;</span><br><span class="line">  <span class="keyword">for</span> await (const line of asyncIterable) &#123;</span><br><span class="line">    yield <span class="string">'&gt; '</span> + line;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>yield 命令依然是立刻返回的，但是返回的是一个 Promise 对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span>* <span class="function"><span class="title">asyncGenerator</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">'Start'</span>);</span><br><span class="line">  const result = await doSomethingAsync(); // (A)</span><br><span class="line">  yield <span class="string">'Result: '</span>+ result; // (B)</span><br><span class="line">  console.log(<span class="string">'Done'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，调用 next 方法以后，会在 B 处暂停执行，yield 命令立刻返回一个 Promise 对象。这个 Promise 对象不同于 A 处 await 命令后面的那个 Promise 对象。主要有两点不同，一是 A 处的 Promise 对象 resolve 以后产生的值，会放入 result 变量；二是 B 处的 Promise 对象 resolve 以后产生的值，是表达式’Result： ‘ + result 的值；二是 A 处的 Promise 对象一定先于 B 处的 Promise 对象 resolve。</p><p>如果异步 Generator 函数抛出错误，会被 Promise 对象 reject，然后抛出的错误被 catch 方法捕获。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span>* <span class="function"><span class="title">asyncGenerator</span></span>() &#123;</span><br><span class="line">  throw new Error(<span class="string">'Problem!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncGenerator()</span><br><span class="line">.next()</span><br><span class="line">.catch(err =&gt; console.log(err)); // Error: Problem!</span><br></pre></td></tr></table></figure><p>注意，普通的 async 函数返回的是一个 Promise 对象，而异步 Generator 函数返回的是一个异步 Iterator 对象。基本上，可以这样理解，async 函数和异步 Generator 函数，是封装异步操作的两种方法，都用来达到同一种目的。区别在于，前者自带执行器，后者通过 for await…of 执行，或者自己编写执行器。下面就是一个异步 Generator 函数的执行器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> takeAsync(asyncIterable, count=Infinity) &#123;</span><br><span class="line">  const result = [];</span><br><span class="line">  const iterator = asyncIterable[Symbol.asyncIterator]();</span><br><span class="line">  <span class="keyword">while</span> (result.length &lt; count) &#123;</span><br><span class="line">    const &#123;value,<span class="keyword">done</span>&#125; = await iterator.next();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">done</span>) <span class="built_in">break</span>;</span><br><span class="line">    result.push(value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，异步 Generator 函数产生的异步遍历器，会通过 while 循环自动执行，每当 await iterator.next()完成，就会进入下一轮循环。</p><p>下面是这个自动执行器的一个使用实例。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  async <span class="keyword">function</span>* <span class="function"><span class="title">gen</span></span>() &#123;</span><br><span class="line">    yield <span class="string">'a'</span>;</span><br><span class="line">    yield <span class="string">'b'</span>;</span><br><span class="line">    yield <span class="string">'c'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> await takeAsync(gen());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().<span class="keyword">then</span>(<span class="keyword">function</span> (result) &#123;</span><br><span class="line">  console.log(result); // [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>异步 Generator 函数出现以后，JavaScript 就有了四种函数形式：普通函数、async 函数、Generator 函数和异步 Generator 函数。请注意区分每种函数的不同之处。</p><p>最后，同步的数据结构，也可以使用异步 Generator 函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span>* createAsyncIterable(syncIterable) &#123;</span><br><span class="line">  <span class="keyword">for</span> (const elem of syncIterable) &#123;</span><br><span class="line">    yield elem;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，由于没有异步操作，所以也就没有使用 await 关键字。</p><h5 id="yield-语句"><a href="#yield-语句" class="headerlink" title="yield* 语句"></a>yield* 语句</h5><p>yield*语句也可以跟一个异步遍历器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span>* <span class="function"><span class="title">gen1</span></span>() &#123;</span><br><span class="line">  yield <span class="string">'a'</span>;</span><br><span class="line">  yield <span class="string">'b'</span>;</span><br><span class="line">  <span class="built_in">return</span> 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async <span class="keyword">function</span>* <span class="function"><span class="title">gen2</span></span>() &#123;</span><br><span class="line">  const result = yield* gen1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，gen2 函数里面的 result 变量，最后的值是 2。</p><p>与同步 Generator 函数一样，for await…of 循环会展开 yield*。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(async <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  <span class="keyword">for</span> await (const x of gen2()) &#123;</span><br><span class="line">    console.log(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">// a</span><br><span class="line">// b</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6_Promise</title>
      <link href="/2019/03/30/es6-Promise/"/>
      <url>/2019/03/30/es6-Promise/</url>
      
        <content type="html"><![CDATA[<h3 id="ES6-promise-对象"><a href="#ES6-promise-对象" class="headerlink" title="ES6 promise 对象"></a>ES6 promise 对象</h3><h4 id="Promise-的含义"><a href="#Promise-的含义" class="headerlink" title="Promise 的含义"></a>Promise 的含义</h4><p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了 Promise 对象。</p><p>所谓 Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p><p>Promise 对象有以下两个特点。</p><p>（1）对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和 Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 Promise 这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p><p>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise 对象的状态改变，只有两种可能：从 Pending 变为 Resolved 和从 Pending 变为 Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p><p>有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise 对象提供统一的接口，使得控制异步操作更加容易。</p><p>Promise 也有一些缺点。首先，无法取消 Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。第三，当处于 Pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p><p>如果某些事件不断地反复发生，一般来说，使用 stream 模式是比部署 Promise 更好的选择。</p><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>ES6 规定，Promise 对象是一个构造函数，用来生成 Promise 实例。</p><p>下面代码创造了一个 Promise 实例。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var promise = new Promise(<span class="keyword">function</span>(resolve, reject) &#123;</span><br><span class="line">  // ... some code</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (/* 异步操作成功 */)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Promise 构造函数接受一个函数作为参数，该函数的两个参数分别是 resolve 和 reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p><p>resolve 函数的作用是，将 Promise 对象的状态从“未完成”变为“成功”（即从 Pending 变为 Resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject 函数的作用是，将 Promise 对象的状态从“未完成”变为“失败”（即从 Pending 变为 Rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p><p>Promise 实例生成以后，可以用 then 方法分别指定 Resolved 状态和 Reject 状态的回调函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise.then(<span class="keyword">function</span>(value) &#123;</span><br><span class="line">  // success</span><br><span class="line">&#125;, <span class="keyword">function</span>(error) &#123;</span><br><span class="line">  // failure</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>then 方法可以接受两个回调函数作为参数。第一个回调函数是 Promise 对象的状态变为 Resolved 时调用，第二个回调函数是 Promise 对象的状态变为 Reject 时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受 Promise 对象传出的值作为参数。</p><p>下面是一个 Promise 对象的简单例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> timeout(ms) &#123;</span><br><span class="line">  <span class="built_in">return</span> new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(resolve, ms, <span class="string">'done'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timeout(100).<span class="keyword">then</span>((value) =&gt; &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，timeout 方法返回一个 Promise 实例，表示一段时间以后才会发生的结果。过了指定的时间（ms 参数）以后，Promise 实例的状态变为 Resolved，就会触发 then 方法绑定的回调函数。</p><p>Promise 新建后就会立即执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> promise = new Promise(<span class="keyword">function</span>(resolve, reject) &#123;</span><br><span class="line">  console.log(<span class="string">'Promise'</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">'Resolved.'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(<span class="string">'Hi!'</span>);</span><br><span class="line"></span><br><span class="line">// Promise</span><br><span class="line">// Hi!</span><br><span class="line">// Resolved</span><br></pre></td></tr></table></figure><p>上面代码中，Promise 新建后立即执行，所以首先输出的是“Promise”。然后，then 方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以“Resolved”最后输出。</p><p>下面是异步加载图片的例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> loadImageAsync(url) &#123;</span><br><span class="line">  <span class="built_in">return</span> new Promise(<span class="keyword">function</span>(resolve, reject) &#123;</span><br><span class="line">    var image = new Image();</span><br><span class="line"></span><br><span class="line">    image.onload = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">      resolve(image);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    image.onerror = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">      reject(new Error(<span class="string">'Could not load image at '</span> + url));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    image.src = url;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，使用 Promise 包装了一个图片加载的异步操作。如果加载成功，就调用 resolve 方法，否则就调用 reject 方法。</p><p>下面是一个用 Promise 对象实现的 Ajax 操作的例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">var getJSON = <span class="keyword">function</span>(url) &#123;</span><br><span class="line">  var promise = new Promise(<span class="keyword">function</span>(resolve, reject)&#123;</span><br><span class="line">    var client = new XMLHttpRequest();</span><br><span class="line">    client.open(<span class="string">"GET"</span>, url);</span><br><span class="line">    client.onreadystatechange = handler;</span><br><span class="line">    client.responseType = <span class="string">"json"</span>;</span><br><span class="line">    client.setRequestHeader(<span class="string">"Accept"</span>, <span class="string">"application/json"</span>);</span><br><span class="line">    client.send();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">handler</span></span>() &#123;</span><br><span class="line">      <span class="keyword">if</span> (this.readyState !== 4) &#123;</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (this.status === 200) &#123;</span><br><span class="line">        resolve(this.response);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(new Error(this.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> promise;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">getJSON(<span class="string">"/posts.json"</span>).<span class="keyword">then</span>(<span class="keyword">function</span>(json) &#123;</span><br><span class="line">  console.log(<span class="string">'Contents: '</span> + json);</span><br><span class="line">&#125;, <span class="keyword">function</span>(error) &#123;</span><br><span class="line">  console.error(<span class="string">'出错了'</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，getJSON 是对 XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个 Promise 对象。需要注意的是，在 getJSON 内部，resolve 函数和 reject 函数调用时，都带有参数。</p><p>如果调用 resolve 函数和 reject 函数时带有参数，那么它们的参数会被传递给回调函数。reject 函数的参数通常是 Error 对象的实例，表示抛出的错误；resolve 函数的参数除了正常的值以外，还可能是另一个 Promise 实例，表示异步操作的结果有可能是一个值，也有可能是另一个异步操作，比如像下面这样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var p1 = new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var p2 = new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">  // ...</span><br><span class="line">  resolve(p1);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面代码中，p1 和 p2 都是 Promise 的实例，但是 p2 的 resolve 方法将 p1 作为参数，即一个异步操作的结果是返回另一个异步操作。</p><p>注意，这时 p1 的状态就会传递给 p2，也就是说，p1 的状态决定了 p2 的状态。如果 p1 的状态是 Pending，那么 p2 的回调函数就会等待 p1 的状态改变；如果 p1 的状态已经是 Resolved 或者 Rejected，那么 p2 的回调函数将会立刻执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var p1 = new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">  setTimeout(() =&gt; reject(new Error(<span class="string">'fail'</span>)), 3000)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">var p2 = new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">  setTimeout(() =&gt; resolve(p1), 1000)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p2</span><br><span class="line">  .<span class="keyword">then</span>(result =&gt; console.log(result))</span><br><span class="line">  .catch(error =&gt; console.log(error))</span><br><span class="line">// Error: fail</span><br></pre></td></tr></table></figure><p>上面代码中，p1 是一个 Promise，3 秒之后变为 rejected。p2 的状态在 1 秒之后改变，resolve 方法返回的是 p1。此时，由于 p2 返回的是另一个 Promise，所以后面的 then 语句都变成针对后者（p1）。又过了 2 秒，p1 变为 rejected，导致触发 catch 方法指定的回调函数。</p><h5 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h5><p>Promise 实例具有 then 方法，也就是说，then 方法是定义在原型对象 Promise.prototype 上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，then 方法的第一个参数是 Resolved 状态的回调函数，第二个参数（可选）是 Rejected 状态的回调函数。</p><p>then 方法返回的是一个新的 Promise 实例（注意，不是原来那个 Promise 实例）。因此可以采用链式写法，即 then 方法后面再调用另一个 then 方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">"/posts.json"</span>).<span class="keyword">then</span>(<span class="keyword">function</span>(json) &#123;</span><br><span class="line">  <span class="built_in">return</span> json.post;</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="keyword">function</span>(post) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的代码使用 then 方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p><p>采用链式的 then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个 Promise 对象（即有异步操作），这时后一个回调函数，就会等待该 Promise 对象的状态发生变化，才会被调用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">"/post/1.json"</span>).<span class="keyword">then</span>(<span class="keyword">function</span>(post) &#123;</span><br><span class="line">  <span class="built_in">return</span> getJSON(post.commentURL);</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="keyword">function</span> funcA(comments) &#123;</span><br><span class="line">  console.log(<span class="string">"Resolved: "</span>, comments);</span><br><span class="line">&#125;, <span class="keyword">function</span> funcB(err)&#123;</span><br><span class="line">  console.log(<span class="string">"Rejected: "</span>, err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，第一个 then 方法指定的回调函数，返回的是另一个 Promise 对象。这时，第二个 then 方法指定的回调函数，就会等待这个新的 Promise 对象状态发生变化。如果变为 Resolved，就调用 funcA，如果状态变为 Rejected，就调用 funcB。</p><p>如果采用箭头函数，上面的代码可以写得更简洁。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">"/post/1.json"</span>).<span class="keyword">then</span>(</span><br><span class="line">  post =&gt; getJSON(post.commentURL)</span><br><span class="line">).<span class="keyword">then</span>(</span><br><span class="line">  comments =&gt; console.log(<span class="string">"Resolved: "</span>, comments),</span><br><span class="line">  err =&gt; console.log(<span class="string">"Rejected: "</span>, err)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h5><p>Promise.prototype.catch 方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">"/posts.json"</span>).<span class="keyword">then</span>(<span class="keyword">function</span>(posts) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;).catch(<span class="keyword">function</span>(error) &#123;</span><br><span class="line">  // 处理 getJSON 和 前一个回调函数运行时发生的错误</span><br><span class="line">  console.log(<span class="string">'发生错误！'</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，getJSON 方法返回一个 Promise 对象，如果该对象状态变为 Resolved，则会调用 then 方法指定的回调函数；如果异步操作抛出错误，状态就会变为 Rejected，就会调用 catch 方法指定的回调函数，处理这个错误。另外，then 方法指定的回调函数，如果运行中抛出错误，也会被 catch 方法捕获。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p.then((val) =&gt; console.log(<span class="string">"fulfilled:"</span>, val))</span><br><span class="line">  .catch((err) =&gt; console.log(<span class="string">"rejected:"</span>, err));</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">p.then((val) =&gt; console.log(<span class="string">"fulfilled:"</span>, val))</span><br><span class="line">  .<span class="keyword">then</span>(null, (err) =&gt; console.log(<span class="string">"rejected:"</span>, err));</span><br></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var promise = new Promise(<span class="keyword">function</span>(resolve, reject) &#123;</span><br><span class="line">  throw new Error(<span class="string">'test'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise.catch(<span class="keyword">function</span>(error) &#123;</span><br><span class="line">  console.log(error);</span><br><span class="line">&#125;);</span><br><span class="line">// Error: <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>上面代码中，promise 抛出一个错误，就被 catch 方法指定的回调函数捕获。注意，上面的写法与下面两种写法是等价的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 写法一</span><br><span class="line">var promise = new Promise(<span class="keyword">function</span>(resolve, reject) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    throw new Error(<span class="string">'test'</span>);</span><br><span class="line">  &#125; catch(e) &#123;</span><br><span class="line">    reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">promise.catch(<span class="keyword">function</span>(error) &#123;</span><br><span class="line">  console.log(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 写法二</span><br><span class="line">var promise = new Promise(<span class="keyword">function</span>(resolve, reject) &#123;</span><br><span class="line">  reject(new Error(<span class="string">'test'</span>));</span><br><span class="line">&#125;);</span><br><span class="line">promise.catch(<span class="keyword">function</span>(error) &#123;</span><br><span class="line">  console.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>比较上面两种写法，可以发现 reject 方法的作用，等同于抛出错误。</p><p>如果 Promise 状态已经变成 Resolved，再抛出错误是无效的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var promise = new Promise(<span class="keyword">function</span>(resolve, reject) &#123;</span><br><span class="line">  resolve(<span class="string">'ok'</span>);</span><br><span class="line">  throw new Error(<span class="string">'test'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise</span><br><span class="line">  .<span class="keyword">then</span>(<span class="keyword">function</span>(value) &#123; console.log(value) &#125;)</span><br><span class="line">  .catch(<span class="keyword">function</span>(error) &#123; console.log(error) &#125;);</span><br><span class="line">// ok</span><br></pre></td></tr></table></figure><p>上面代码中，Promise 在 resolve 语句后面，再抛出错误，不会被捕获，等于没有抛出。</p><p>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个 catch 语句捕获。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">"/post/1.json"</span>).<span class="keyword">then</span>(<span class="keyword">function</span>(post) &#123;</span><br><span class="line">  <span class="built_in">return</span> getJSON(post.commentURL);</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="keyword">function</span>(comments) &#123;</span><br><span class="line">  // some code</span><br><span class="line">&#125;).catch(<span class="keyword">function</span>(error) &#123;</span><br><span class="line">  // 处理前面三个Promise产生的错误</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，一共有三个 Promise 对象：一个由 getJSON 产生，两个由 then 产生。它们之中任何一个抛出的错误，都会被最后一个 catch 捕获。</p><p>一般来说，不要在 then 方法里面定义 Reject 状态的回调函数（即 then 的第二个参数），总是使用 catch 方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">promise</span><br><span class="line">  .<span class="keyword">then</span>(<span class="keyword">function</span>(data) &#123;</span><br><span class="line">    // success</span><br><span class="line">  &#125;, <span class="keyword">function</span>(err) &#123;</span><br><span class="line">    // error</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">promise</span><br><span class="line">  .<span class="keyword">then</span>(<span class="keyword">function</span>(data) &#123; //cb</span><br><span class="line">    // success</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="keyword">function</span>(err) &#123;</span><br><span class="line">    // error</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面 then 方法执行中的错误，也更接近同步的写法（try/catch）。因此，建议总是使用 catch 方法，而不使用 then 方法的第二个参数。</p><p>跟传统的 try/catch 代码块不同的是，如果没有使用 catch 方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var someAsyncThing = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> new Promise(<span class="keyword">function</span>(resolve, reject) &#123;</span><br><span class="line">    // 下面一行会报错，因为x没有声明</span><br><span class="line">    resolve(x + 2);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">someAsyncThing().<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">'everything is great'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，someAsyncThing 函数产生的 Promise 对象会报错，但是由于没有指定 catch 方法，这个错误不会被捕获，也不会传递到外层代码，导致运行后没有任何输出。注意，Chrome 浏览器不遵守这条规定，它会抛出错误“ReferenceError: x is not defined”。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var promise = new Promise(<span class="keyword">function</span>(resolve, reject) &#123;</span><br><span class="line">  resolve(<span class="string">"ok"</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="title">function</span></span>() &#123; throw new Error(<span class="string">'test'</span>) &#125;, 0)</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(<span class="keyword">function</span>(value) &#123; console.log(value) &#125;);</span><br><span class="line">// ok</span><br><span class="line">// Uncaught Error: <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>上面代码中，Promise 指定在下一轮“事件循环”再抛出错误，结果由于没有指定使用 try…catch 语句，就冒泡到最外层，成了未捕获的错误。因为此时，Promise 的函数体已经运行结束了，所以这个错误是在 Promise 函数体外抛出的。</p><p>Node.js 有一个 unhandledRejection 事件，专门监听未捕获的 reject 错误。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">process.on(<span class="string">'unhandledRejection'</span>, <span class="keyword">function</span> (err, p) &#123;</span><br><span class="line">  console.error(err.stack)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，unhandledRejection 事件的监听函数有两个参数，第一个是错误对象，第二个是报错的 Promise 实例，它可以用来了解发生错误的环境信息。。</p><p>需要注意的是，catch 方法返回的还是一个 Promise 对象，因此后面还可以接着调用 then 方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var someAsyncThing = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> new Promise(<span class="keyword">function</span>(resolve, reject) &#123;</span><br><span class="line">    // 下面一行会报错，因为x没有声明</span><br><span class="line">    resolve(x + 2);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">someAsyncThing()</span><br><span class="line">.catch(<span class="keyword">function</span>(error) &#123;</span><br><span class="line">  console.log(<span class="string">'oh no'</span>, error);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">'carry on'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">// oh no [ReferenceError: x is not defined]</span><br><span class="line">// carry on</span><br></pre></td></tr></table></figure><p>上面代码运行完 catch 方法指定的回调函数，会接着运行后面那个 then 方法指定的回调函数。如果没有报错，则会跳过 catch 方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve()</span><br><span class="line">.catch(<span class="keyword">function</span>(error) &#123;</span><br><span class="line">  console.log(<span class="string">'oh no'</span>, error);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">'carry on'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">// carry on</span><br></pre></td></tr></table></figure><p>上面的代码因为没有报错，跳过了 catch 方法，直接执行后面的 then 方法。此时，要是 then 方法里面报错，就与前面的 catch 无关了。</p><p>catch 方法之中，还能再抛出错误。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var someAsyncThing = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> new Promise(<span class="keyword">function</span>(resolve, reject) &#123;</span><br><span class="line">    // 下面一行会报错，因为x没有声明</span><br><span class="line">    resolve(x + 2);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">someAsyncThing().<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> someOtherAsyncThing();</span><br><span class="line">&#125;).catch(<span class="keyword">function</span>(error) &#123;</span><br><span class="line">  console.log(<span class="string">'oh no'</span>, error);</span><br><span class="line">  // 下面一行会报错，因为y没有声明</span><br><span class="line">  y + 2;</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">'carry on'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">// oh no [ReferenceError: x is not defined]</span><br></pre></td></tr></table></figure><p>上面代码中，catch 方法抛出一个错误，因为后面没有别的 catch 方法了，导致这个错误不会被捕获，也不会传递到外层。如果改写一下，结果就不一样了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">someAsyncThing().<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> someOtherAsyncThing();</span><br><span class="line">&#125;).catch(<span class="keyword">function</span>(error) &#123;</span><br><span class="line">  console.log(<span class="string">'oh no'</span>, error);</span><br><span class="line">  // 下面一行会报错，因为y没有声明</span><br><span class="line">  y + 2;</span><br><span class="line">&#125;).catch(<span class="keyword">function</span>(error) &#123;</span><br><span class="line">  console.log(<span class="string">'carry on'</span>, error);</span><br><span class="line">&#125;);</span><br><span class="line">// oh no [ReferenceError: x is not defined]</span><br><span class="line">// carry on [ReferenceError: y is not defined]</span><br></pre></td></tr></table></figure><p>上面代码中，第二个 catch 方法用来捕获，前一个 catch 方法抛出的错误。</p><h5 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h5><p>Promise.all 方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var p = Promise.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure><p>上面代码中，Promise.all 方法接受一个数组作为参数，p1、p2、p3 都是 Promise 对象的实例，如果不是，就会先调用下面讲到的 Promise.resolve 方法，将参数转为 Promise 实例，再进一步处理。（Promise.all 方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。）</p><p>p 的状态由 p1、p2、p3 决定，分成两种情况。</p><p>（1）只有 p1、p2、p3 的状态都变成 fulfilled，p 的状态才会变成 fulfilled，此时 p1、p2、p3 的返回值组成一个数组，传递给 p 的回调函数。</p><p>（2）只要 p1、p2、p3 之中有一个被 rejected，p 的状态就变成 rejected，此时第一个被 reject 的实例的返回值，会传递给 p 的回调函数。</p><p>下面是一个具体的例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 生成一个Promise对象的数组</span><br><span class="line">var promises = [2, 3, 5, 7, 11, 13].map(<span class="keyword">function</span> (id) &#123;</span><br><span class="line">  <span class="built_in">return</span> getJSON(<span class="string">"/post/"</span> + id + <span class="string">".json"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Promise.all(promises).<span class="keyword">then</span>(<span class="keyword">function</span> (posts) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;).catch(<span class="keyword">function</span>(reason)&#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，promises 是包含 6 个 Promise 实例的数组，只有这 6 个实例的状态都变成 fulfilled，或者其中有一个变为 rejected，才会调用 Promise.all 方法后面的回调函数。</p><p>下面是另一个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const databasePromise = connectDatabase();</span><br><span class="line"></span><br><span class="line">const booksPromise = databaseProimse</span><br><span class="line">  .<span class="keyword">then</span>(findAllBooks);</span><br><span class="line"></span><br><span class="line">const userPromise = databasePromise</span><br><span class="line">  .<span class="keyword">then</span>(getCurrentUser);</span><br><span class="line"></span><br><span class="line">Promise.all([</span><br><span class="line">  booksPromise,</span><br><span class="line">  userPromise</span><br><span class="line">])</span><br><span class="line">.<span class="keyword">then</span>(([books, user]) =&gt; pickTopRecommentations(books, user));</span><br></pre></td></tr></table></figure><p>上面代码中，booksPromise 和 userPromise 是两个异步操作，只有等到它们的结果都返回了，才会触发 pickTopRecommentations 这个回调函数。</p><h5 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h5><p>Promise.race 方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var p = Promise.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure><p>上面代码中，只要 p1、p2、p3 之中有一个实例率先改变状态，p 的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给 p 的回调函数。</p><p>Promise.race 方法的参数与 Promise.all 方法一样，如果不是 Promise 实例，就会先调用下面讲到的 Promise.resolve 方法，将参数转为 Promise 实例，再进一步处理。</p><p>下面是一个例子，如果指定时间内没有获得结果，就将 Promise 的状态变为 reject，否则变为 resolve。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var p = Promise.race([</span><br><span class="line">  fetch(<span class="string">'/resource-that-may-take-a-while'</span>),</span><br><span class="line">  new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">    setTimeout(() =&gt; reject(new Error(<span class="string">'request timeout'</span>)), 5000)</span><br><span class="line">  &#125;)</span><br><span class="line">])</span><br><span class="line">p.then(response =&gt; console.log(response))</span><br><span class="line">p.catch(error =&gt; console.log(error))</span><br></pre></td></tr></table></figure><p>上面代码中，如果 5 秒之内 fetch 方法无法返回结果，变量 p 的状态就会变为 rejected，从而触发 catch 方法指定的回调函数。</p><h5 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h5><p>有时需要将现有对象转为 Promise 对象，Promise.resolve 方法就起到这个作用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var jsPromise = Promise.resolve($.ajax(<span class="string">'/whatever.json'</span>));</span><br></pre></td></tr></table></figure><p>上面代码将 jQuery 生成的 deferred 对象，转为一个新的 Promise 对象。</p><p>Promise.resolve 等价于下面的写法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(<span class="string">'foo'</span>)</span><br><span class="line">// 等价于</span><br><span class="line">new Promise(resolve =&gt; resolve(<span class="string">'foo'</span>))</span><br></pre></td></tr></table></figure><p>Promise.resolve 方法的参数分成四种情况。</p><p>（1）参数是一个 Promise 实例</p><p>如果参数是 Promise 实例，那么 Promise.resolve 将不做任何修改、原封不动地返回这个实例。</p><p>（2）参数是一个 thenable 对象</p><p>thenable 对象指的是具有 then 方法的对象，比如下面这个对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> thenable = &#123;</span><br><span class="line">  <span class="keyword">then</span>: <span class="keyword">function</span>(resolve, reject) &#123;</span><br><span class="line">    resolve(42);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Promise.resolve 方法会将这个对象转为 Promise 对象，然后就立即执行 thenable 对象的 then 方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> thenable = &#123;</span><br><span class="line">  <span class="keyword">then</span>: <span class="keyword">function</span>(resolve, reject) &#123;</span><br><span class="line">    resolve(42);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> p1 = Promise.resolve(thenable);</span><br><span class="line">p1.then(<span class="keyword">function</span>(value) &#123;</span><br><span class="line">  console.log(value);  // 42</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，thenable 对象的 then 方法执行后，对象 p1 的状态就变为 resolved，从而立即执行最后那个 then 方法指定的回调函数，输出 42。</p><p>（3）参数不是具有 then 方法的对象，或根本就不是对象</p><p>如果参数是一个原始值，或者是一个不具有 then 方法的对象，则 Promise.resolve 方法返回一个新的 Promise 对象，状态为 Resolved。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var p = Promise.resolve(<span class="string">'Hello'</span>);</span><br><span class="line"></span><br><span class="line">p.then(<span class="keyword">function</span> (s)&#123;</span><br><span class="line">  console.log(s)</span><br><span class="line">&#125;);</span><br><span class="line">// Hello</span><br></pre></td></tr></table></figure><p>上面代码生成一个新的 Promise 对象的实例 p。由于字符串 Hello 不属于异步操作（判断方法是它不是具有 then 方法的对象），返回 Promise 实例的状态从一生成就是 Resolved，所以回调函数会立即执行。Promise.resolve 方法的参数，会同时传给回调函数。</p><p>（4）不带有任何参数</p><p>Promise.resolve 方法允许调用时不带参数，直接返回一个 Resolved 状态的 Promise 对象。</p><p>所以，如果希望得到一个 Promise 对象，比较方便的方法就是直接调用 Promise.resolve 方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var p = Promise.resolve();</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码的变量 p 就是一个 Promise 对象。</p><p>需要注意的是，立即 resolve 的 Promise 对象，是在本轮“事件循环”（event loop）的结束时，而不是在下一轮“事件循环”的开始时。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  console.log(<span class="string">'three'</span>);</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">Promise.resolve().<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  console.log(<span class="string">'two'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(<span class="string">'one'</span>);</span><br><span class="line"></span><br><span class="line">// one</span><br><span class="line">// two</span><br><span class="line">// three</span><br></pre></td></tr></table></figure><p>上面代码中，setTimeout(fn, 0)在下一轮“事件循环”开始时执行，Promise.resolve()在本轮“事件循环”结束时执行，console.log(’one‘)则是立即执行，因此最先输出。</p><h5 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h5><p>Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为 rejected。它的参数用法与 Promise.resolve 方法完全一致。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var p = Promise.reject(<span class="string">'出错了'</span>);</span><br><span class="line">// 等同于</span><br><span class="line">var p = new Promise((resolve, reject) =&gt; reject(<span class="string">'出错了'</span>))</span><br><span class="line"></span><br><span class="line">p.then(null, <span class="keyword">function</span> (s)&#123;</span><br><span class="line">  console.log(s)</span><br><span class="line">&#125;);</span><br><span class="line">// 出错了</span><br></pre></td></tr></table></figure><p>上面代码生成一个 Promise 对象的实例 p，状态为 rejected，回调函数会立即执行。</p><h4 id="两个有用的附加方法"><a href="#两个有用的附加方法" class="headerlink" title="两个有用的附加方法"></a>两个有用的附加方法</h4><p>ES6 的 Promise API 提供的方法不是很多，有些有用的方法可以自己部署。下面介绍如何部署两个不在 ES6 之中、但很有用的方法。</p><h5 id="done"><a href="#done" class="headerlink" title="done()"></a>done()</h5><p>Promise 对象的回调链，不管以 then 方法或 catch 方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为 Promise 内部的错误不会冒泡到全局）。因此，我们可以提供一个 done 方法，总是处于回调链的尾端，保证抛出任何可能出现的错误。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">asyncFunc()</span><br><span class="line">  .<span class="keyword">then</span>(f1)</span><br><span class="line">  .catch(r1)</span><br><span class="line">  .<span class="keyword">then</span>(f2)</span><br><span class="line">  .<span class="keyword">done</span>();</span><br></pre></td></tr></table></figure><p>它的实现代码相当简单。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Promise.prototype.done = <span class="keyword">function</span> (onFulfilled, onRejected) &#123;</span><br><span class="line">  this.then(onFulfilled, onRejected)</span><br><span class="line">    .catch(<span class="keyword">function</span> (reason) &#123;</span><br><span class="line">      // 抛出一个全局错误</span><br><span class="line">      setTimeout(() =&gt; &#123; throw reason &#125;, 0);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从上面代码可见，done 方法的使用，可以像 then 方法那样用，提供 Fulfilled 和 Rejected 状态的回调函数，也可以不提供任何参数。但不管怎样，done 都会捕捉到任何可能出现的错误，并向全局抛出。</p><h5 id="finally"><a href="#finally" class="headerlink" title="finally()"></a>finally()</h5><p>finally 方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。它与 done 方法的最大区别，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。</p><p>下面是一个例子，服务器使用 Promise 处理请求，然后使用 finally 方法关掉服务器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server.listen(0)</span><br><span class="line">  .<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    // run <span class="built_in">test</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .finally(server.stop);</span><br></pre></td></tr></table></figure><p>它的实现也很简单。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Promise.prototype.finally = <span class="keyword">function</span> (callback) &#123;</span><br><span class="line">  <span class="built_in">let</span> P = this.constructor;</span><br><span class="line">  <span class="built_in">return</span> this.then(</span><br><span class="line">    value  =&gt; P.resolve(callback()).<span class="keyword">then</span>(() =&gt; value),</span><br><span class="line">    reason =&gt; P.resolve(callback()).<span class="keyword">then</span>(() =&gt; &#123; throw reason &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，不管前面的 Promise 是 fulfilled 还是 rejected，都会执行回调函数 callback。</p><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><h5 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h5><p>我们可以将图片的加载写成一个 Promise，一旦加载完成，Promise 的状态就发生变化。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const preloadImage = <span class="keyword">function</span> (path) &#123;</span><br><span class="line">  <span class="built_in">return</span> new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">    var image = new Image();</span><br><span class="line">    image.onload  = resolve;</span><br><span class="line">    image.onerror = reject;</span><br><span class="line">    image.src = path;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="Generator-函数与-Promise-的结合"><a href="#Generator-函数与-Promise-的结合" class="headerlink" title="Generator 函数与 Promise 的结合"></a>Generator 函数与 Promise 的结合</h5><p>使用 Generator 函数管理流程，遇到异步操作的时候，通常返回一个 Promise 对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">getFoo</span></span> () &#123;</span><br><span class="line">  <span class="built_in">return</span> new Promise(<span class="keyword">function</span> (resolve, reject)&#123;</span><br><span class="line">    resolve(<span class="string">'foo'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var g = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    var foo = yield getFoo();</span><br><span class="line">    console.log(foo);</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    console.log(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> run (generator) &#123;</span><br><span class="line">  var it = generator();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> go(result) &#123;</span><br><span class="line">    <span class="keyword">if</span> (result.done) <span class="built_in">return</span> result.value;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> result.value.then(<span class="keyword">function</span> (value) &#123;</span><br><span class="line">      <span class="built_in">return</span> go(it.next(value));</span><br><span class="line">    &#125;, <span class="keyword">function</span> (error) &#123;</span><br><span class="line">      <span class="built_in">return</span> go(it.throw(error));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  go(it.next());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(g);</span><br></pre></td></tr></table></figure><p>上面代码的 Generator 函数 g 之中，有一个异步操作 getFoo，它返回的就是一个 Promise 对象。函数 run 用来处理这个 Promise 对象，并调用下一个 next 方法。</p><h5 id="Promise-try"><a href="#Promise-try" class="headerlink" title="Promise.try()"></a>Promise.try()</h5><p>实际开发中，经常遇到一种情况：不知道或者不想区分，函数 f 是同步函数还是异步操作，但是想用 Promise 来处理它。因为这样就可以不管 f 是否包含异步操作，都用 then 方法指定下一步流程，用 catch 方法处理 f 抛出的错误。一般就会采用下面的写法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve().<span class="keyword">then</span>(f)</span><br></pre></td></tr></table></figure><p>上面的写法有一个缺点，就是如果 f 是同步函数，那么它会在下一轮事件循环执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const f = () =&gt; console.log(<span class="string">'now'</span>);</span><br><span class="line">Promise.resolve().<span class="keyword">then</span>(f);</span><br><span class="line">console.log(<span class="string">'next'</span>);</span><br><span class="line">// next</span><br><span class="line">// now</span><br></pre></td></tr></table></figure><p>上面代码中，函数 f 是同步的，但是用 Promise 包装了以后，就变成异步执行了。</p><p>那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API 呢？回答是可以的，并且还有两种写法。第一种写法是用 async 函数来写。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const f = () =&gt; console.log(<span class="string">'now'</span>);</span><br><span class="line">(async () =&gt; f())();</span><br><span class="line">console.log(<span class="string">'next'</span>);</span><br><span class="line">// now</span><br><span class="line">// next</span><br></pre></td></tr></table></figure><p>上面代码中，第一行是一个立即执行的匿名函数，会立即执行里面的 async 函数，因此如果 f 是同步的，就会得到同步的结果；如果 f 是异步的，就可以用 then 指定下一步，就像下面的写法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(async () =&gt; f())()</span><br><span class="line">.<span class="keyword">then</span>(...)</span><br></pre></td></tr></table></figure><p>需要注意的是，async () =&gt; f()会吃掉 f()抛出的错误。所以，如果想捕获错误，要使用 promise.catch 方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(async () =&gt; f())()</span><br><span class="line">.<span class="keyword">then</span>(...)</span><br><span class="line">.catch(...)</span><br></pre></td></tr></table></figure><p>第二种写法是使用 new Promise()。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const f = () =&gt; console.log(<span class="string">'now'</span>);</span><br><span class="line">(</span><br><span class="line">  () =&gt; new Promise(</span><br><span class="line">    resolve =&gt; resolve(f())</span><br><span class="line">  )</span><br><span class="line">)();</span><br><span class="line">console.log(<span class="string">'next'</span>);</span><br><span class="line">// now</span><br><span class="line">// next</span><br></pre></td></tr></table></figure><p>上面代码也是使用立即执行的匿名函数，执行 new Promise()。这种情况下，同步函数也是同步执行的。</p><p>鉴于这是一个很常见的需求，所以现在有一个提案，提供 Promise.try 方法替代上面的写法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const f = () =&gt; console.log(<span class="string">'now'</span>);</span><br><span class="line">Promise.try(f);</span><br><span class="line">console.log(<span class="string">'next'</span>);</span><br><span class="line">// now</span><br><span class="line">// next</span><br></pre></td></tr></table></figure><p>事实上，Promise.try 存在已久，Promise 库 Bluebird、Q 和 when，早就提供了这个方法。</p><p>由于 Promise.try 为所有操作提供了统一的处理机制，所以如果想用 then 方法管理流程，最好都用 Promise.try 包装一下。这样有许多好处，其中一点就是可以更好地管理异常。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> getUsername(userId) &#123;</span><br><span class="line">  <span class="built_in">return</span> database.users.get(&#123;id: userId&#125;)</span><br><span class="line">  .<span class="keyword">then</span>(<span class="keyword">function</span>(user) &#123;</span><br><span class="line">    <span class="built_in">return</span> user.name;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，database.users.get()返回一个 Promise 对象，如果抛出异步错误，可以用 catch 方法捕获，就像下面这样写。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">database.users.get(&#123;id: userId&#125;)</span><br><span class="line">.<span class="keyword">then</span>(...)</span><br><span class="line">.catch(...)</span><br></pre></td></tr></table></figure><p>但是 database.users.get()可能还会抛出同步错误（比如数据库连接错误，具体要看实现方法），这时你就不得不用 try…catch 去捕获。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  database.users.get(&#123;id: userId&#125;)</span><br><span class="line">  .<span class="keyword">then</span>(...)</span><br><span class="line">  .catch(...)</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这样的写法就很笨拙了，这时就可以统一用 promise.catch()捕获所有同步和异步的错误。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Promise.try(database.users.get(&#123;id: userId&#125;))</span><br><span class="line">  .<span class="keyword">then</span>(...)</span><br><span class="line">  .catch(...)</span><br></pre></td></tr></table></figure><p>事实上，Promise.try 就是模拟 try 代码块，就像 promise.catch 模拟的是 catch 代码块。</p>]]></content>
      
      
      <categories>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6_Generator</title>
      <link href="/2019/03/22/es6-Generator/"/>
      <url>/2019/03/22/es6-Generator/</url>
      
        <content type="html"><![CDATA[<h3 id="Generator-函数"><a href="#Generator-函数" class="headerlink" title="Generator 函数"></a>Generator 函数</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><p>Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。本章详细介绍 Generator 函数的语法和 API，它的异步编程应用请看《异步操作》一章。</p><p>Generator 函数有多种理解角度。从语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。</p><p>执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p><p>形式上，Generator 函数是一个普通函数，但是有两个特征。一是，function 关键字与函数名之间有一个星号；二是，函数体内部使用 yield 语句，定义不同的内部状态（yield 语句在英语里的意思就是“产出”）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">helloWorldGenerator</span></span>() &#123;</span><br><span class="line">  yield <span class="string">'hello'</span>;</span><br><span class="line">  yield <span class="string">'world'</span>;</span><br><span class="line">  <span class="built_in">return</span> <span class="string">'ending'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var hw = helloWorldGenerator();</span><br></pre></td></tr></table></figure><p>上面代码定义了一个 Generator 函数 helloWorldGenerator，它内部有两个 yield 语句“hello”和“world”，即该函数有三个状态：hello，world 和 return 语句（结束执行）。</p><p>然后，Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上一章介绍的遍历器对象（Iterator Object）。</p><p>下一步，必须调用遍历器对象的 next 方法，使得指针移向下一个状态。也就是说，每次调用 next 方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个 yield 语句（或 return 语句）为止。换言之，Generator 函数是分段执行的，yield 语句是暂停执行的标记，而 next 方法可以恢复执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hw.next()</span><br><span class="line">// &#123; value: <span class="string">'hello'</span>, <span class="keyword">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line"></span><br><span class="line">hw.next()</span><br><span class="line">// &#123; value: <span class="string">'world'</span>, <span class="keyword">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line"></span><br><span class="line">hw.next()</span><br><span class="line">// &#123; value: <span class="string">'ending'</span>, <span class="keyword">done</span>: <span class="literal">true</span> &#125;</span><br><span class="line"></span><br><span class="line">hw.next()</span><br><span class="line">// &#123; value: undefined, <span class="keyword">done</span>: <span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure><p>上面代码一共调用了四次 next 方法。</p><p>第一次调用，Generator 函数开始执行，直到遇到第一个 yield 语句为止。next 方法返回一个对象，它的 value 属性就是当前 yield 语句的值 hello，done 属性的值 false，表示遍历还没有结束。</p><p>第二次调用，Generator 函数从上次 yield 语句停下的地方，一直执行到下一个 yield 语句。next 方法返回的对象的 value 属性就是当前 yield 语句的值 world，done 属性的值 false，表示遍历还没有结束。</p><p>第三次调用，Generator 函数从上次 yield 语句停下的地方，一直执行到 return 语句（如果没有 return 语句，就执行到函数结束）。next 方法返回的对象的 value 属性，就是紧跟在 return 语句后面的表达式的值（如果没有 return 语句，则 value 属性的值为 undefined），done 属性的值 true，表示遍历已经结束。</p><p>第四次调用，此时 Generator 函数已经运行完毕，next 方法返回对象的 value 属性为 undefined，done 属性为 true。以后再调用 next 方法，返回的都是这个值。</p><p>总结一下，调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的 next 方法，就会返回一个有着 value 和 done 两个属性的对象。value 属性表示当前的内部状态的值，是 yield 语句后面那个表达式的值；done 属性是一个布尔值，表示是否遍历结束。</p><p>ES6 没有规定，function 关键字与函数名之间的星号，写在哪个位置。这导致下面的写法都能通过。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> * foo(x, y) &#123; ··· &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> *foo(x, y) &#123; ··· &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* foo(x, y) &#123; ··· &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>*foo(x, y) &#123; ··· &#125;</span><br></pre></td></tr></table></figure><p>由于 Generator 函数仍然是普通函数，所以一般的写法是上面的第三种，即星号紧跟在 function 关键字后面。本书也采用这种写法。</p><h5 id="yield-语句"><a href="#yield-语句" class="headerlink" title="yield 语句"></a>yield 语句</h5><p>由于 Generator 函数返回的遍历器对象，只有调用 next 方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield 语句就是暂停标志。</p><p>遍历器对象的 next 方法的运行逻辑如下。</p><p>（1）遇到 yield 语句，就暂停执行后面的操作，并将紧跟在 yield 后面的那个表达式的值，作为返回的对象的 value 属性值。</p><p>（2）下一次调用 next 方法时，再继续往下执行，直到遇到下一个 yield 语句。</p><p>（3）如果没有再遇到新的 yield 语句，就一直运行到函数结束，直到 return 语句为止，并将 return 语句后面的表达式的值，作为返回的对象的 value 属性值。</p><p>（4）如果该函数没有 return 语句，则返回的对象的 value 属性值为 undefined。</p><p>需要注意的是，yield 语句后面的表达式，只有当调用 next 方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">gen</span></span>() &#123;</span><br><span class="line">  yield  123 + 456;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，yield 后面的表达式 123 + 456，不会立即求值，只会在 next 方法将指针移到这一句时，才会求值。</p><p>yield 语句与 return 语句既有相似之处，也有区别。相似之处在于，都能返回紧跟在语句后面的那个表达式的值。区别在于每次遇到 yield，函数暂停执行，下一次再从该位置继续向后执行，而 return 语句不具备位置记忆的功能。一个函数里面，只能执行一次（或者说一个）return 语句，但是可以执行多次（或者说多个）yield 语句。正常函数只能返回一个值，因为只能执行一次 return；Generator 函数可以返回一系列的值，因为可以有任意多个 yield。从另一个角度看，也可以说 Generator 生成了一系列的值，这也就是它的名称的来历（在英语中，generator 这个词是“生成器”的意思）。</p><p>Generator 函数可以不用 yield 语句，这时就变成了一个单纯的暂缓执行函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">'执行了！'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var generator = f();</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  generator.next()</span><br><span class="line">&#125;, 2000);</span><br></pre></td></tr></table></figure><p>上面代码中，函数 f 如果是普通函数，在为变量 generator 赋值时就会执行。但是，函数 f 是一个 Generator 函数，就变成只有调用 next 方法时，函数 f 才会执行。</p><p>另外需要注意，yield 语句不能用在普通函数中，否则会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="title">function</span></span> ()&#123;</span><br><span class="line">  yield 1;</span><br><span class="line">&#125;)()</span><br><span class="line">// SyntaxError: Unexpected number</span><br></pre></td></tr></table></figure><p>上面代码在一个普通函数中使用 yield 语句，结果产生一个句法错误。</p><p>下面是另外一个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, [[2, 3], 4], [5, 6]];</span><br><span class="line"></span><br><span class="line">var flat = <span class="keyword">function</span>* (a) &#123;</span><br><span class="line">  a.forEach(<span class="keyword">function</span> (item) &#123;</span><br><span class="line">    <span class="keyword">if</span> (typeof item !== <span class="string">'number'</span>) &#123;</span><br><span class="line">      yield* flat(item);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      yield item;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (var f of flat(arr))&#123;</span><br><span class="line">  console.log(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码也会产生句法错误，因为 forEach 方法的参数是一个普通函数，但是在里面使用了 yield 语句（这个函数里面还使用了 yield*语句，这里可以不用理会，详细说明见后文）。一种修改方法是改用 for 循环。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, [[2, 3], 4], [5, 6]];</span><br><span class="line"></span><br><span class="line">var flat = <span class="keyword">function</span>* (a) &#123;</span><br><span class="line">  var length = a.length;</span><br><span class="line">  <span class="keyword">for</span> (var i = 0; i &lt; length; i++) &#123;</span><br><span class="line">    var item = a[i];</span><br><span class="line">    <span class="keyword">if</span> (typeof item !== <span class="string">'number'</span>) &#123;</span><br><span class="line">      yield* flat(item);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      yield item;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (var f of flat(arr)) &#123;</span><br><span class="line">  console.log(f);</span><br><span class="line">&#125;</span><br><span class="line">// 1, 2, 3, 4, 5, 6</span><br></pre></td></tr></table></figure><p>另外，yield 语句如果用在一个表达式之中，必须放在圆括号里面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(<span class="string">'Hello'</span> + yield); // SyntaxError</span><br><span class="line">console.log(<span class="string">'Hello'</span> + yield 123); // SyntaxError</span><br><span class="line"></span><br><span class="line">console.log(<span class="string">'Hello'</span> + (yield)); // OK</span><br><span class="line">console.log(<span class="string">'Hello'</span> + (yield 123)); // OK</span><br></pre></td></tr></table></figure><p>yield 语句用作函数参数或赋值表达式的右边，可以不加括号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo(yield <span class="string">'a'</span>, yield <span class="string">'b'</span>); // OK</span><br><span class="line"><span class="built_in">let</span> input = yield; // OK</span><br></pre></td></tr></table></figure><h5 id="与-Iterator-接口的关系"><a href="#与-Iterator-接口的关系" class="headerlink" title="与 Iterator 接口的关系"></a>与 Iterator 接口的关系</h5><p>上一章说过，任意一个对象的 Symbol.iterator 方法，等于该对象的遍历器生成函数，调用该函数会返回该对象的一个遍历器对象。</p><p>由于 Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的 Symbol.iterator 属性，从而使得该对象具有 Iterator 接口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var myIterable = &#123;&#125;;</span><br><span class="line">myIterable[Symbol.iterator] = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  yield 2;</span><br><span class="line">  yield 3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[...myIterable] // [1, 2, 3]</span><br></pre></td></tr></table></figure><p>上面代码中，Generator 函数赋值给 Symbol.iterator 属性，从而使得 myIterable 对象具有了 Iterator 接口，可以被…运算符遍历了。</p><p>Generator 函数执行后，返回一个遍历器对象。该对象本身也具有 Symbol.iterator 属性，执行后返回自身。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">gen</span></span>()&#123;</span><br><span class="line">  // some code</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var g = gen();</span><br><span class="line"></span><br><span class="line">g[Symbol.iterator]() === g</span><br><span class="line">// <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>上面代码中，gen 是一个 Generator 函数，调用它会生成一个遍历器对象 g。它的 Symbol.iterator 属性，也是一个遍历器对象生成函数，执行后返回它自己。</p><h5 id="next-方法的参数"><a href="#next-方法的参数" class="headerlink" title="next 方法的参数"></a>next 方法的参数</h5><p>yield 句本身没有返回值，或者说总是返回 undefined。next 方法可以带一个参数，该参数就会被当作上一个 yield 语句的返回值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  <span class="keyword">for</span>(var i=0; <span class="literal">true</span>; i++) &#123;</span><br><span class="line">    var reset = yield i;</span><br><span class="line">    <span class="keyword">if</span>(reset) &#123; i = -1; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var g = f();</span><br><span class="line"></span><br><span class="line">g.next() // &#123; value: 0, <span class="keyword">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">g.next() // &#123; value: 1, <span class="keyword">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">g.next(<span class="literal">true</span>) // &#123; value: 0, <span class="keyword">done</span>: <span class="literal">false</span> &#125;</span><br></pre></td></tr></table></figure><p>上面代码先定义了一个可以无限运行的 Generator 函数 f，如果 next 方法没有参数，每次运行到 yield 语句，变量 reset 的值总是 undefined。当 next 方法带一个参数 true 时，当前的变量 reset 就被重置为这个参数（即 true），因此 i 会等于-1，下一轮循环就会从-1 开始递增。</p><p>这个功能有很重要的语法意义。Generator 函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。通过 next 方法的参数，就有办法在 Generator 函数开始运行之后，继续向函数体内部注入值。也就是说，可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。</p><p>再看一个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* foo(x) &#123;</span><br><span class="line">  var y = 2 * (yield (x + 1));</span><br><span class="line">  var z = yield (y / 3);</span><br><span class="line">  <span class="built_in">return</span> (x + y + z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = foo(5);</span><br><span class="line">a.next() // Object&#123;value:6, <span class="keyword">done</span>:<span class="literal">false</span>&#125;</span><br><span class="line">a.next() // Object&#123;value:NaN, <span class="keyword">done</span>:<span class="literal">false</span>&#125;</span><br><span class="line">a.next() // Object&#123;value:NaN, <span class="keyword">done</span>:<span class="literal">true</span>&#125;</span><br><span class="line"></span><br><span class="line">var b = foo(5);</span><br><span class="line">b.next() // &#123; value:6, <span class="keyword">done</span>:<span class="literal">false</span> &#125;</span><br><span class="line">b.next(12) // &#123; value:8, <span class="keyword">done</span>:<span class="literal">false</span> &#125;</span><br><span class="line">b.next(13) // &#123; value:42, <span class="keyword">done</span>:<span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure><p>上面代码中，第二次运行 next 方法的时候不带参数，导致 y 的值等于 2 * undefined（即 NaN），除以 3 以后还是 NaN，因此返回对象的 value 属性也等于 NaN。第三次运行 Next 方法的时候不带参数，所以 z 等于 undefined，返回对象的 value 属性等于 5 + NaN + undefined，即 NaN。</p><p>如果向 next 方法提供参数，返回结果就完全不一样了。上面代码第一次调用 b 的 next 方法时，返回 x+1 的值 6；第二次调用 next 方法，将上一次 yield 语句的值设为 12，因此 y 等于 24，返回 y / 3 的值 8；第三次调用 next 方法，将上一次 yield 语句的值设为 13，因此 z 等于 13，这时 x 等于 5，y 等于 24，所以 return 语句的值等于 42。</p><p>注意，由于 next 方法的参数表示上一个 yield 语句的返回值，所以第一次使用 next 方法时，不能带有参数。V8 引擎直接忽略第一次使用 next 方法时的参数，只有从第二次使用 next 方法开始，参数才是有效的。从语义上讲，第一个 next 方法用来启动遍历器对象，所以不用带有参数。</p><p>如果想要第一次调用 next 方法时，就能够输入值，可以在 Generator 函数外面再包一层。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> wrapper(generatorFunction) &#123;</span><br><span class="line">  <span class="built_in">return</span> <span class="keyword">function</span> (...args) &#123;</span><br><span class="line">    <span class="built_in">let</span> generatorObject = generatorFunction(...args);</span><br><span class="line">    generatorObject.next();</span><br><span class="line">    <span class="built_in">return</span> generatorObject;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const wrapped = wrapper(<span class="keyword">function</span>* () &#123;</span><br><span class="line">  console.log(`First input: <span class="variable">$&#123;yield&#125;</span>`);</span><br><span class="line">  <span class="built_in">return</span> <span class="string">'DONE'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">wrapped().next(<span class="string">'hello!'</span>)</span><br><span class="line">// First input: hello!</span><br></pre></td></tr></table></figure><p>上面代码中，Generator 函数如果不用 wrapper 先包一层，是无法第一次调用 next 方法，就输入参数的。</p><p>再看一个通过 next 方法的参数，向 Generator 函数内部输入值的例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">dataConsumer</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">'Started'</span>);</span><br><span class="line">  console.log(`1. <span class="variable">$&#123;yield&#125;</span>`);</span><br><span class="line">  console.log(`2. <span class="variable">$&#123;yield&#125;</span>`);</span><br><span class="line">  <span class="built_in">return</span> <span class="string">'result'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> genObj = dataConsumer();</span><br><span class="line">genObj.next();</span><br><span class="line">// Started</span><br><span class="line">genObj.next(<span class="string">'a'</span>)</span><br><span class="line">// 1. a</span><br><span class="line">genObj.next(<span class="string">'b'</span>)</span><br><span class="line">// 2. b</span><br></pre></td></tr></table></figure><p>上面代码是一个很直观的例子，每次通过 next 方法向 Generator 函数输入值，然后打印出来。</p><h5 id="for…of-循环"><a href="#for…of-循环" class="headerlink" title="for…of 循环"></a>for…of 循环</h5><p>for…of 循环可以自动遍历 Generator 函数时生成的 Iterator 对象，且此时不再需要调用 next 方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> *<span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  yield 2;</span><br><span class="line">  yield 3;</span><br><span class="line">  yield 4;</span><br><span class="line">  yield 5;</span><br><span class="line">  <span class="built_in">return</span> 6;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> v of foo()) &#123;</span><br><span class="line">  console.log(v);</span><br><span class="line">&#125;</span><br><span class="line">// 1 2 3 4 5</span><br></pre></td></tr></table></figure><p>上面代码使用 for…of 循环，依次显示 5 个 yield 语句的值。这里需要注意，一旦 next 方法的返回对象的 done 属性为 true，for…of 循环就会中止，且不包含该返回对象，所以上面代码的 return 语句返回的 6，不包括在 for…of 循环之中。</p><p>下面是一个利用 Generator 函数和 for…of 循环，实现斐波那契数列的例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">fibonacci</span></span>() &#123;</span><br><span class="line">  <span class="built_in">let</span> [prev, curr] = [0, 1];</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    [prev, curr] = [curr, prev + curr];</span><br><span class="line">    yield curr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> n of fibonacci()) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; 1000) <span class="built_in">break</span>;</span><br><span class="line">  console.log(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码可见，使用 for…of 语句时不需要使用 next 方法。</p><p>利用 for…of 循环，可以写出遍历任意对象（object）的方法。原生的 JavaScript 对象没有遍历接口，无法使用 for…of 循环，通过 Generator 函数为它加上这个接口，就可以用了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* objectEntries(obj) &#123;</span><br><span class="line">  <span class="built_in">let</span> propKeys = Reflect.ownKeys(obj);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">let</span> propKey of propKeys) &#123;</span><br><span class="line">    yield [propKey, obj[propKey]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> jane = &#123; first: <span class="string">'Jane'</span>, last: <span class="string">'Doe'</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> [key, value] of objectEntries(jane)) &#123;</span><br><span class="line">  console.log(`<span class="variable">$&#123;key&#125;</span>: <span class="variable">$&#123;value&#125;</span>`);</span><br><span class="line">&#125;</span><br><span class="line">// first: Jane</span><br><span class="line">// last: Doe</span><br></pre></td></tr></table></figure><p>上面代码中，对象 jane 原生不具备 Iterator 接口，无法用 for…of 遍历。这时，我们通过 Generator 函数 objectEntries 为它加上遍历器接口，就可以用 for…of 遍历了。加上遍历器接口的另一种写法是，将 Generator 函数加到对象的 Symbol.iterator 属性上面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">objectEntries</span></span>() &#123;</span><br><span class="line">  <span class="built_in">let</span> propKeys = Object.keys(this);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">let</span> propKey of propKeys) &#123;</span><br><span class="line">    yield [propKey, this[propKey]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> jane = &#123; first: <span class="string">'Jane'</span>, last: <span class="string">'Doe'</span> &#125;;</span><br><span class="line"></span><br><span class="line">jane[Symbol.iterator] = objectEntries;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> [key, value] of jane) &#123;</span><br><span class="line">  console.log(`<span class="variable">$&#123;key&#125;</span>: <span class="variable">$&#123;value&#125;</span>`);</span><br><span class="line">&#125;</span><br><span class="line">// first: Jane</span><br><span class="line">// last: Doe</span><br></pre></td></tr></table></figure><p>除了 for…of 循环以外，扩展运算符（…）、解构赋值和 Array.from 方法内部调用的，都是遍历器接口。这意味着，它们都可以将 Generator 函数返回的 Iterator 对象，作为参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">numbers</span></span> () &#123;</span><br><span class="line">  yield 1</span><br><span class="line">  yield 2</span><br><span class="line">  <span class="built_in">return</span> 3</span><br><span class="line">  yield 4</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 扩展运算符</span><br><span class="line">[...numbers()] // [1, 2]</span><br><span class="line"></span><br><span class="line">// Array.from 方法</span><br><span class="line">Array.from(numbers()) // [1, 2]</span><br><span class="line"></span><br><span class="line">// 解构赋值</span><br><span class="line"><span class="built_in">let</span> [x, y] = numbers();</span><br><span class="line">x // 1</span><br><span class="line">y // 2</span><br><span class="line"></span><br><span class="line">// for...of 循环</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> n of numbers()) &#123;</span><br><span class="line">  console.log(n)</span><br><span class="line">&#125;</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br></pre></td></tr></table></figure><h5 id="Generator-prototype-throw"><a href="#Generator-prototype-throw" class="headerlink" title="Generator.prototype.throw()"></a>Generator.prototype.throw()</h5><p>Generator 函数返回的遍历器对象，都有一个 throw 方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var g = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    yield;</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    console.log(<span class="string">'内部捕获'</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var i = g();</span><br><span class="line">i.next();</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">  i.throw(<span class="string">'a'</span>);</span><br><span class="line">  i.throw(<span class="string">'b'</span>);</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">  console.log(<span class="string">'外部捕获'</span>, e);</span><br><span class="line">&#125;</span><br><span class="line">// 内部捕获 a</span><br><span class="line">// 外部捕获 b</span><br></pre></td></tr></table></figure><p>上面代码中，遍历器对象 i 连续抛出两个错误。第一个错误被 Generator 函数体内的 catch 语句捕获。i 第二次抛出错误，由于 Generator 函数内部的 catch 语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了 Generator 函数体，被函数体外的 catch 语句捕获。</p><p>throw 方法可以接受一个参数，该参数会被 catch 语句接收，建议抛出 Error 对象的实例。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var g = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    yield;</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    console.log(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var i = g();</span><br><span class="line">i.next();</span><br><span class="line">i.throw(new Error(<span class="string">'出错了！'</span>));</span><br><span class="line">// Error: 出错了！(…)</span><br></pre></td></tr></table></figure><p>注意，不要混淆遍历器对象的 throw 方法和全局的 throw 命令。上面代码的错误，是用遍历器对象的 throw 方法抛出的，而不是用 throw 命令抛出的。后者只能被函数体外的 catch 语句捕获。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var g = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      yield;</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (e != <span class="string">'a'</span>) throw e;</span><br><span class="line">      console.log(<span class="string">'内部捕获'</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var i = g();</span><br><span class="line">i.next();</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">  throw new Error(<span class="string">'a'</span>);</span><br><span class="line">  throw new Error(<span class="string">'b'</span>);</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">  console.log(<span class="string">'外部捕获'</span>, e);</span><br><span class="line">&#125;</span><br><span class="line">// 外部捕获 [Error: a]</span><br></pre></td></tr></table></figure><p>上面代码之所以只捕获了 a，是因为函数体外的 catch 语句块，捕获了抛出的 a 错误以后，就不会再继续 try 代码块里面剩余的语句了。</p><p>如果 Generator 函数内部没有部署 try…catch 代码块，那么 throw 方法抛出的错误，将被外部 try…catch 代码块捕获。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var g = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    yield;</span><br><span class="line">    console.log(<span class="string">'内部捕获'</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var i = g();</span><br><span class="line">i.next();</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">  i.throw(<span class="string">'a'</span>);</span><br><span class="line">  i.throw(<span class="string">'b'</span>);</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">  console.log(<span class="string">'外部捕获'</span>, e);</span><br><span class="line">&#125;</span><br><span class="line">// 外部捕获 a</span><br></pre></td></tr></table></figure><p>上面代码中，Generator 函数 g 内部没有部署 try…catch 代码块，所以抛出的错误直接被外部 catch 代码块捕获。</p><p>如果 Generator 函数内部和外部，都没有部署 try…catch 代码块，那么程序将报错，直接中断执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var gen = <span class="keyword">function</span>* <span class="function"><span class="title">gen</span></span>()&#123;</span><br><span class="line">  yield console.log(<span class="string">'hello'</span>);</span><br><span class="line">  yield console.log(<span class="string">'world'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var g = gen();</span><br><span class="line">g.next();</span><br><span class="line">g.throw();</span><br><span class="line">// hello</span><br><span class="line">// Uncaught undefined</span><br></pre></td></tr></table></figure><p>上面代码中，g.throw 抛出错误以后，没有任何 try…catch 代码块可以捕获这个错误，导致程序报错，中断执行。</p><p>throw 方法被捕获以后，会附带执行下一条 yield 语句。也就是说，会附带执行一次 next 方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var gen = <span class="keyword">function</span>* <span class="function"><span class="title">gen</span></span>()&#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    yield console.log(<span class="string">'a'</span>);</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">  yield console.log(<span class="string">'b'</span>);</span><br><span class="line">  yield console.log(<span class="string">'c'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var g = gen();</span><br><span class="line">g.next() // a</span><br><span class="line">g.throw() // b</span><br><span class="line">g.next() // c</span><br></pre></td></tr></table></figure><p>上面代码中，g.throw 方法被捕获以后，自动执行了一次 next 方法，所以会打印 b。另外，也可以看到，只要 Generator 函数内部部署了 try…catch 代码块，那么遍历器的 throw 方法抛出的错误，不影响下一次遍历。</p><p>另外，throw 命令与 g.throw 方法是无关的，两者互不影响。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var gen = <span class="keyword">function</span>* <span class="function"><span class="title">gen</span></span>()&#123;</span><br><span class="line">  yield console.log(<span class="string">'hello'</span>);</span><br><span class="line">  yield console.log(<span class="string">'world'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var g = gen();</span><br><span class="line">g.next();</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">  throw new Error();</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">  g.next();</span><br><span class="line">&#125;</span><br><span class="line">// hello</span><br><span class="line">// world</span><br></pre></td></tr></table></figure><p>上面代码中，throw 命令抛出的错误不会影响到遍历器的状态，所以两次执行 next 方法，都进行了正确的操作。</p><p>这种函数体内捕获错误的机制，大大方便了对错误的处理。多个 yield 语句，可以只用一个 try…catch 代码块来捕获错误。如果使用回调函数的写法，想要捕获多个错误，就不得不为每个函数内部写一个错误处理语句，现在只在 Generator 函数内部写一次 catch 语句就可以了。</p><p>Generator 函数体外抛出的错误，可以在函数体内捕获；反过来，Generator 函数体内抛出的错误，也可以被函数体外的 catch 捕获。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> *<span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">  var x = yield 3;</span><br><span class="line">  var y = x.toUpperCase();</span><br><span class="line">  yield y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var it = foo();</span><br><span class="line"></span><br><span class="line">it.next(); // &#123; value:3, <span class="keyword">done</span>:<span class="literal">false</span> &#125;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">  it.next(42);</span><br><span class="line">&#125; catch (err) &#123;</span><br><span class="line">  console.log(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，第二个 next 方法向函数体内传入一个参数 42，数值是没有 toUpperCase 方法的，所以会抛出一个 TypeError 错误，被函数体外的 catch 捕获。</p><p>一旦 Generator 执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了。如果此后还调用 next 方法，将返回一个 value 属性等于 undefined、done 属性等于 true 的对象，即 JavaScript 引擎认为这个 Generator 已经运行结束了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">g</span></span>() &#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  console.log(<span class="string">'throwing an exception'</span>);</span><br><span class="line">  throw new Error(<span class="string">'generator broke!'</span>);</span><br><span class="line">  yield 2;</span><br><span class="line">  yield 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="built_in">log</span>(generator) &#123;</span><br><span class="line">  var v;</span><br><span class="line">  console.log(<span class="string">'starting generator'</span>);</span><br><span class="line">  try &#123;</span><br><span class="line">    v = generator.next();</span><br><span class="line">    console.log(<span class="string">'第一次运行next方法'</span>, v);</span><br><span class="line">  &#125; catch (err) &#123;</span><br><span class="line">    console.log(<span class="string">'捕捉错误'</span>, v);</span><br><span class="line">  &#125;</span><br><span class="line">  try &#123;</span><br><span class="line">    v = generator.next();</span><br><span class="line">    console.log(<span class="string">'第二次运行next方法'</span>, v);</span><br><span class="line">  &#125; catch (err) &#123;</span><br><span class="line">    console.log(<span class="string">'捕捉错误'</span>, v);</span><br><span class="line">  &#125;</span><br><span class="line">  try &#123;</span><br><span class="line">    v = generator.next();</span><br><span class="line">    console.log(<span class="string">'第三次运行next方法'</span>, v);</span><br><span class="line">  &#125; catch (err) &#123;</span><br><span class="line">    console.log(<span class="string">'捕捉错误'</span>, v);</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(<span class="string">'caller done'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">log</span>(g());</span><br><span class="line">// starting generator</span><br><span class="line">// 第一次运行next方法 &#123; value: 1, <span class="keyword">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">// throwing an exception</span><br><span class="line">// 捕捉错误 &#123; value: 1, <span class="keyword">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">// 第三次运行next方法 &#123; value: undefined, <span class="keyword">done</span>: <span class="literal">true</span> &#125;</span><br><span class="line">// <span class="built_in">caller</span> <span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>上面代码一共三次运行 next 方法，第二次运行的时候会抛出错误，然后第三次运行的时候，Generator 函数就已经结束了，不再执行下去了。</p><h5 id="Generator-prototype-return"><a href="#Generator-prototype-return" class="headerlink" title="Generator.prototype.return()"></a>Generator.prototype.return()</h5><p>Generator 函数返回的遍历器对象，还有一个 return 方法，可以返回给定的值，并且终结遍历 Generator 函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">gen</span></span>() &#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  yield 2;</span><br><span class="line">  yield 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var g = gen();</span><br><span class="line"></span><br><span class="line">g.next()        // &#123; value: 1, <span class="keyword">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">g.return(<span class="string">'foo'</span>) // &#123; value: <span class="string">"foo"</span>, <span class="keyword">done</span>: <span class="literal">true</span> &#125;</span><br><span class="line">g.next()        // &#123; value: undefined, <span class="keyword">done</span>: <span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure><p>上面代码中，遍历器对象 g 调用 return 方法后，返回值的 value 属性就是 return 方法的参数 foo。并且，Generator 函数的遍历就终止了，返回值的 done 属性为 true，以后再调用 next 方法，done 属性总是返回 true。</p><p>如果 return 方法调用时，不提供参数，则返回值的 value 属性为 undefined。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">gen</span></span>() &#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  yield 2;</span><br><span class="line">  yield 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var g = gen();</span><br><span class="line"></span><br><span class="line">g.next()        // &#123; value: 1, <span class="keyword">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">g.return() // &#123; value: undefined, <span class="keyword">done</span>: <span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure><p>如果 Generator 函数内部有 try…finally 代码块，那么 return 方法会推迟到 finally 代码块执行完再执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">numbers</span></span> () &#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  try &#123;</span><br><span class="line">    yield 2;</span><br><span class="line">    yield 3;</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    yield 4;</span><br><span class="line">    yield 5;</span><br><span class="line">  &#125;</span><br><span class="line">  yield 6;</span><br><span class="line">&#125;</span><br><span class="line">var g = numbers()</span><br><span class="line">g.next() // &#123; <span class="keyword">done</span>: <span class="literal">false</span>, value: 1 &#125;</span><br><span class="line">g.next() // &#123; <span class="keyword">done</span>: <span class="literal">false</span>, value: 2 &#125;</span><br><span class="line">g.return(7) // &#123; <span class="keyword">done</span>: <span class="literal">false</span>, value: 4 &#125;</span><br><span class="line">g.next() // &#123; <span class="keyword">done</span>: <span class="literal">false</span>, value: 5 &#125;</span><br><span class="line">g.next() // &#123; <span class="keyword">done</span>: <span class="literal">true</span>, value: 7 &#125;</span><br></pre></td></tr></table></figure><p>上面代码中，调用 return 方法后，就开始执行 finally 代码块，然后等到 finally 代码块执行完，再执行 return 方法。</p><h5 id="yield-语句-1"><a href="#yield-语句-1" class="headerlink" title="yield*语句"></a>yield*语句</h5><p>如果在 Generater 函数内部，调用另一个 Generator 函数，默认情况下是没有效果的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">  yield <span class="string">'a'</span>;</span><br><span class="line">  yield <span class="string">'b'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">bar</span></span>() &#123;</span><br><span class="line">  yield <span class="string">'x'</span>;</span><br><span class="line">  foo();</span><br><span class="line">  yield <span class="string">'y'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> v of bar())&#123;</span><br><span class="line">  console.log(v);</span><br><span class="line">&#125;</span><br><span class="line">// <span class="string">"x"</span></span><br><span class="line">// <span class="string">"y"</span></span><br></pre></td></tr></table></figure><p>上面代码中，foo 和 bar 都是 Generator 函数，在 bar 里面调用 foo，是不会有效果的。</p><p>这个就需要用到 yield*语句，用来在一个 Generator 函数里面执行另一个 Generator 函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">bar</span></span>() &#123;</span><br><span class="line">  yield <span class="string">'x'</span>;</span><br><span class="line">  yield* foo();</span><br><span class="line">  yield <span class="string">'y'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">bar</span></span>() &#123;</span><br><span class="line">  yield <span class="string">'x'</span>;</span><br><span class="line">  yield <span class="string">'a'</span>;</span><br><span class="line">  yield <span class="string">'b'</span>;</span><br><span class="line">  yield <span class="string">'y'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">bar</span></span>() &#123;</span><br><span class="line">  yield <span class="string">'x'</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">let</span> v of foo()) &#123;</span><br><span class="line">    yield v;</span><br><span class="line">  &#125;</span><br><span class="line">  yield <span class="string">'y'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> v of bar())&#123;</span><br><span class="line">  console.log(v);</span><br><span class="line">&#125;</span><br><span class="line">// <span class="string">"x"</span></span><br><span class="line">// <span class="string">"a"</span></span><br><span class="line">// <span class="string">"b"</span></span><br><span class="line">// <span class="string">"y"</span></span><br></pre></td></tr></table></figure><p>再来看一个对比的例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">inner</span></span>() &#123;</span><br><span class="line">  yield <span class="string">'hello!'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">outer1</span></span>() &#123;</span><br><span class="line">  yield <span class="string">'open'</span>;</span><br><span class="line">  yield inner();</span><br><span class="line">  yield <span class="string">'close'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var gen = outer1()</span><br><span class="line">gen.next().value // <span class="string">"open"</span></span><br><span class="line">gen.next().value // 返回一个遍历器对象</span><br><span class="line">gen.next().value // <span class="string">"close"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">outer2</span></span>() &#123;</span><br><span class="line">  yield <span class="string">'open'</span></span><br><span class="line">  yield* inner()</span><br><span class="line">  yield <span class="string">'close'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var gen = outer2()</span><br><span class="line">gen.next().value // <span class="string">"open"</span></span><br><span class="line">gen.next().value // <span class="string">"hello!"</span></span><br><span class="line">gen.next().value // <span class="string">"close"</span></span><br></pre></td></tr></table></figure><p>上面例子中，outer2 使用了 yield*，outer1 没使用。结果就是，outer1 返回一个遍历器对象，outer2 返回该遍历器对象的内部值。</p><p>从语法角度看，如果 yield 命令后面跟的是一个遍历器对象，需要在 yield 命令后面加上星号，表明它返回的是一个遍历器对象。这被称为 yield*语句。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> delegatedIterator = (<span class="keyword">function</span>* () &#123;</span><br><span class="line">  yield <span class="string">'Hello!'</span>;</span><br><span class="line">  yield <span class="string">'Bye!'</span>;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> delegatingIterator = (<span class="keyword">function</span>* () &#123;</span><br><span class="line">  yield <span class="string">'Greetings!'</span>;</span><br><span class="line">  yield* delegatedIterator;</span><br><span class="line">  yield <span class="string">'Ok, bye.'</span>;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">let</span> value of delegatingIterator) &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;</span><br><span class="line">// <span class="string">"Greetings!</span></span><br><span class="line"><span class="string">// "</span>Hello!<span class="string">"</span></span><br><span class="line"><span class="string">// "</span>Bye!<span class="string">"</span></span><br><span class="line"><span class="string">// "</span>Ok, <span class="built_in">bye</span>.<span class="string">"</span></span><br></pre></td></tr></table></figure><p>上面代码中，delegatingIterator 是代理者，delegatedIterator 是被代理者。由于 yield* delegatedIterator 语句得到的值，是一个遍历器，所以要用星号表示。运行结果就是使用一个遍历器，遍历了多个 Generator 函数，有递归的效果。</p><p>yield*后面的 Generator 函数（没有 return 语句时），等同于在 Generator 函数内部，部署一个 for…of 循环。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* concat(iter1, iter2) &#123;</span><br><span class="line">  yield* iter1;</span><br><span class="line">  yield* iter2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* concat(iter1, iter2) &#123;</span><br><span class="line">  <span class="keyword">for</span> (var value of iter1) &#123;</span><br><span class="line">    yield value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (var value of iter2) &#123;</span><br><span class="line">    yield value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码说明，yield<em>后面的 Generator 函数（没有 return 语句时），不过是 for…of 的一种简写形式，完全可以用后者替代前者。反之，则需要用 var value = yield</em> iterator 的形式获取 return 语句的值。</p><p>如果 yield*后面跟着一个数组，由于数组原生支持遍历器，因此就会遍历数组成员。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">gen</span></span>()&#123;</span><br><span class="line">  yield* [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gen().next() // &#123; value:<span class="string">"a"</span>, <span class="keyword">done</span>:<span class="literal">false</span> &#125;</span><br></pre></td></tr></table></figure><p>上面代码中，yield 命令后面如果不加星号，返回的是整个数组，加了星号就表示返回的是数组的遍历器对象。</p><p>实际上，任何数据结构只要有 Iterator 接口，就可以被 yield*遍历。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> <span class="built_in">read</span> = (<span class="keyword">function</span>* () &#123;</span><br><span class="line">  yield <span class="string">'hello'</span>;</span><br><span class="line">  yield* <span class="string">'hello'</span>;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">read.next().value // <span class="string">"hello"</span></span><br><span class="line">read.next().value // <span class="string">"h"</span></span><br></pre></td></tr></table></figure><p>上面代码中，yield 语句返回整个字符串，yield<em>语句返回单个字符。因为字符串具有 Iterator 接口，所以被 yield</em>遍历。</p><p>如果被代理的 Generator 函数有 return 语句，那么就可以向代理它的 Generator 函数返回数据。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> *<span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">  yield 2;</span><br><span class="line">  yield 3;</span><br><span class="line">  <span class="built_in">return</span> <span class="string">"foo"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> *<span class="function"><span class="title">bar</span></span>() &#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  var v = yield *foo();</span><br><span class="line">  console.log( <span class="string">"v: "</span> + v );</span><br><span class="line">  yield 4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var it = bar();</span><br><span class="line"></span><br><span class="line">it.next()</span><br><span class="line">// &#123;value: 1, <span class="keyword">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">it.next()</span><br><span class="line">// &#123;value: 2, <span class="keyword">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">it.next()</span><br><span class="line">// &#123;value: 3, <span class="keyword">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">it.next();</span><br><span class="line">// <span class="string">"v: foo"</span></span><br><span class="line">// &#123;value: 4, <span class="keyword">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">it.next()</span><br><span class="line">// &#123;value: undefined, <span class="keyword">done</span>: <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure><p>上面代码在第四次调用 next 方法的时候，屏幕上会有输出，这是因为函数 foo 的 return 语句，向函数 bar 提供了返回值。</p><p>再看一个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">genFuncWithReturn</span></span>() &#123;</span><br><span class="line">  yield <span class="string">'a'</span>;</span><br><span class="line">  yield <span class="string">'b'</span>;</span><br><span class="line">  <span class="built_in">return</span> <span class="string">'The result'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span>* logReturned(genObj) &#123;</span><br><span class="line">  <span class="built_in">let</span> result = yield* genObj;</span><br><span class="line">  console.log(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[...logReturned(genFuncWithReturn())]</span><br><span class="line">// The result</span><br><span class="line">// 值为 [ <span class="string">'a'</span>, <span class="string">'b'</span> ]</span><br></pre></td></tr></table></figure><p>上面代码中，存在两次遍历。第一次是扩展运算符遍历函数 logReturned 返回的遍历器对象，第二次是 yield*语句遍历函数 genFuncWithReturn 返回的遍历器对象。这两次遍历的效果是叠加的，最终表现为扩展运算符遍历函数 genFuncWithReturn 返回的遍历器对象。所以，最后的数据表达式得到的值等于[ ‘a’, ‘b’ ]。但是，函数 genFuncWithReturn 的 return 语句的返回值 The result，会返回给函数 logReturned 内部的 result 变量，因此会有终端输出。</p><p>yield*命令可以很方便地取出嵌套数组的所有成员。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* iterTree(tree) &#123;</span><br><span class="line">  <span class="keyword">if</span> (Array.isArray(tree)) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">let</span> i=0; i &lt; tree.length; i++) &#123;</span><br><span class="line">      yield* iterTree(tree[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    yield tree;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const tree = [ <span class="string">'a'</span>, [<span class="string">'b'</span>, <span class="string">'c'</span>], [<span class="string">'d'</span>, <span class="string">'e'</span>] ];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">let</span> x of iterTree(tree)) &#123;</span><br><span class="line">  console.log(x);</span><br><span class="line">&#125;</span><br><span class="line">// a</span><br><span class="line">// b</span><br><span class="line">// c</span><br><span class="line">// d</span><br><span class="line">// e</span><br></pre></td></tr></table></figure><p>下面是一个稍微复杂的例子，使用 yield*语句遍历完全二叉树。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// 下面是二叉树的构造函数，</span><br><span class="line">// 三个参数分别是左树、当前节点和右树</span><br><span class="line"><span class="keyword">function</span> Tree(left, label, right) &#123;</span><br><span class="line">  this.left = left;</span><br><span class="line">  this.label = label;</span><br><span class="line">  this.right = right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 下面是中序（inorder）遍历函数。</span><br><span class="line">// 由于返回的是一个遍历器，所以要用generator函数。</span><br><span class="line">// 函数体内采用递归算法，所以左树和右树要用yield*遍历</span><br><span class="line"><span class="keyword">function</span>* inorder(t) &#123;</span><br><span class="line">  <span class="keyword">if</span> (t) &#123;</span><br><span class="line">    yield* inorder(t.left);</span><br><span class="line">    yield t.label;</span><br><span class="line">    yield* inorder(t.right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 下面生成二叉树</span><br><span class="line"><span class="keyword">function</span> make(array) &#123;</span><br><span class="line">  // 判断是否为叶节点</span><br><span class="line">  <span class="keyword">if</span> (array.length == 1) <span class="built_in">return</span> new Tree(null, array[0], null);</span><br><span class="line">  <span class="built_in">return</span> new Tree(make(array[0]), array[1], make(array[2]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> tree = make([[[<span class="string">'a'</span>], <span class="string">'b'</span>, [<span class="string">'c'</span>]], <span class="string">'d'</span>, [[<span class="string">'e'</span>], <span class="string">'f'</span>, [<span class="string">'g'</span>]]]);</span><br><span class="line"></span><br><span class="line">// 遍历二叉树</span><br><span class="line">var result = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> node of inorder(tree)) &#123;</span><br><span class="line">  result.push(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result</span><br><span class="line">// [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>, <span class="string">'g'</span>]</span><br></pre></td></tr></table></figure><h5 id="作为对象属性的-Generator-函数"><a href="#作为对象属性的-Generator-函数" class="headerlink" title="作为对象属性的 Generator 函数"></a>作为对象属性的 Generator 函数</h5><p>如果一个对象的属性是 Generator 函数，可以简写成下面的形式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> obj = &#123;</span><br><span class="line">  * <span class="function"><span class="title">myGeneratorMethod</span></span>() &#123;</span><br><span class="line">    ···</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，myGeneratorMethod 属性前面有一个星号，表示这个属性是一个 Generator 函数。</p><p>它的完整形式如下，与上面的写法是等价的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> obj = &#123;</span><br><span class="line">  myGeneratorMethod: <span class="keyword">function</span>* () &#123;</span><br><span class="line">    // ···</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="Generator-函数的-this"><a href="#Generator-函数的-this" class="headerlink" title="Generator 函数的 this"></a>Generator 函数的 this</h5><p>Generator 函数总是返回一个遍历器，ES6 规定这个遍历器是 Generator 函数的实例，也继承了 Generator 函数的 prototype 对象上的方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">g</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">g.prototype.hello = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  <span class="built_in">return</span> <span class="string">'hi!'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> obj = g();</span><br><span class="line"></span><br><span class="line">obj instanceof g // <span class="literal">true</span></span><br><span class="line">obj.hello() // <span class="string">'hi!'</span></span><br></pre></td></tr></table></figure><p>上面代码表明，Generator 函数 g 返回的遍历器 obj，是 g 的实例，而且继承了 g.prototype。但是，如果把 g 当作普通的构造函数，并不会生效，因为 g 返回的总是遍历器对象，而不是 this 对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">g</span></span>() &#123;</span><br><span class="line">  this.a = 11;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> obj = g();</span><br><span class="line">obj.a // undefined</span><br></pre></td></tr></table></figure><p>上面代码中，Generator 函数 g 在 this 对象上面添加了一个属性 a，但是 obj 对象拿不到这个属性。</p><p>Generator 函数也不能跟 new 命令一起用，会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">F</span></span>() &#123;</span><br><span class="line">  yield this.x = 2;</span><br><span class="line">  yield this.y = 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new F()</span><br><span class="line">// TypeError: F is not a constructor</span><br></pre></td></tr></table></figure><p>上面代码中，new 命令跟构造函数 F 一起使用，结果报错，因为 F 不是构造函数。</p><p>那么，有没有办法让 Generator 函数返回一个正常的对象实例，既可以用 next 方法，又可以获得正常的 this？</p><p>下面是一个变通方法。首先，生成一个空对象，使用 call 方法绑定 Generator 函数内部的 this。这样，构造函数调用以后，这个空对象就是 Generator 函数的实例对象了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">F</span></span>() &#123;</span><br><span class="line">  this.a = 1;</span><br><span class="line">  yield this.b = 2;</span><br><span class="line">  yield this.c = 3;</span><br><span class="line">&#125;</span><br><span class="line">var obj = &#123;&#125;;</span><br><span class="line">var f = F.call(obj);</span><br><span class="line"></span><br><span class="line">f.next();  // Object &#123;value: 2, <span class="keyword">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">f.next();  // Object &#123;value: 3, <span class="keyword">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">f.next();  // Object &#123;value: undefined, <span class="keyword">done</span>: <span class="literal">true</span>&#125;</span><br><span class="line"></span><br><span class="line">obj.a // 1</span><br><span class="line">obj.b // 2</span><br><span class="line">obj.c // 3</span><br></pre></td></tr></table></figure><p>上面代码中，首先是 F 内部的 this 对象绑定 obj 对象，然后调用它，返回一个 Iterator 对象。这个对象执行三次 next 方法（因为 F 内部有两个 yield 语句），完成 F 内部所有代码的运行。这时，所有内部属性都绑定在 obj 对象上了，因此 obj 对象也就成了 F 的实例。</p><p>上面代码中，执行的是遍历器对象 f，但是生成的对象实例是 obj，有没有办法将这两个对象统一呢？</p><p>一个办法就是将 obj 换成 F.prototype。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">F</span></span>() &#123;</span><br><span class="line">  this.a = 1;</span><br><span class="line">  yield this.b = 2;</span><br><span class="line">  yield this.c = 3;</span><br><span class="line">&#125;</span><br><span class="line">var f = F.call(F.prototype);</span><br><span class="line"></span><br><span class="line">f.next();  // Object &#123;value: 2, <span class="keyword">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">f.next();  // Object &#123;value: 3, <span class="keyword">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">f.next();  // Object &#123;value: undefined, <span class="keyword">done</span>: <span class="literal">true</span>&#125;</span><br><span class="line"></span><br><span class="line">f.a // 1</span><br><span class="line">f.b // 2</span><br><span class="line">f.c // 3</span><br></pre></td></tr></table></figure><p>再将 F 改成构造函数，就可以对它执行 new 命令了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">gen</span></span>() &#123;</span><br><span class="line">  this.a = 1;</span><br><span class="line">  yield this.b = 2;</span><br><span class="line">  yield this.c = 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">F</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> gen.call(gen.prototype);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var f = new F();</span><br><span class="line"></span><br><span class="line">f.next();  // Object &#123;value: 2, <span class="keyword">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">f.next();  // Object &#123;value: 3, <span class="keyword">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">f.next();  // Object &#123;value: undefined, <span class="keyword">done</span>: <span class="literal">true</span>&#125;</span><br><span class="line"></span><br><span class="line">f.a // 1</span><br><span class="line">f.b // 2</span><br><span class="line">f.c // 3</span><br></pre></td></tr></table></figure><h4 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h4><h5 id="Generator-与状态机"><a href="#Generator-与状态机" class="headerlink" title="Generator 与状态机"></a>Generator 与状态机</h5><p>Generator 是实现状态机的最佳结构。比如，下面的 clock 函数就是一个状态机。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var ticking = <span class="literal">true</span>;</span><br><span class="line">var clock = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> (ticking)</span><br><span class="line">    console.log(<span class="string">'Tick!'</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    console.log(<span class="string">'Tock!'</span>);</span><br><span class="line">  ticking = !ticking;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的 clock 函数一共有两种状态（Tick 和 Tock），每运行一次，就改变一次状态。这个函数如果用 Generator 实现，就是下面这样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var clock = <span class="keyword">function</span>*() &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    console.log(<span class="string">'Tick!'</span>);</span><br><span class="line">    yield;</span><br><span class="line">    console.log(<span class="string">'Tock!'</span>);</span><br><span class="line">    yield;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的 Generator 实现与 ES5 实现对比，可以看到少了用来保存状态的外部变量 ticking，这样就更简洁，更安全（状态不会被非法篡改）、更符合函数式编程的思想，在写法上也更优雅。Generator 之所以可以不用外部变量保存状态，是因为它本身就包含了一个状态信息，即目前是否处于暂停态。</p><h5 id="Generator-与协程"><a href="#Generator-与协程" class="headerlink" title="Generator 与协程"></a>Generator 与协程</h5><p>协程（coroutine）是一种程序运行的方式，可以理解成“协作的线程”或“协作的函数”。协程既可以用单线程实现，也可以用多线程实现。前者是一种特殊的子例程，后者是一种特殊的线程。</p><h6 id="协程与子例程的差异"><a href="#协程与子例程的差异" class="headerlink" title="协程与子例程的差异"></a>协程与子例程的差异</h6><p>传统的“子例程”（subroutine）采用堆栈式“后进先出”的执行方式，只有当调用的子函数完全执行完毕，才会结束执行父函数。协程与其不同，多个线程（单线程情况下，即多个函数）可以并行执行，但是只有一个线程（或函数）处于正在运行的状态，其他线程（或函数）都处于暂停态（suspended），线程（或函数）之间可以交换执行权。也就是说，一个线程（或函数）执行到一半，可以暂停执行，将执行权交给另一个线程（或函数），等到稍后收回执行权的时候，再恢复执行。这种可以并行执行、交换执行权的线程（或函数），就称为协程。</p><p>从实现上看，在内存中，子例程只使用一个栈（stack），而协程是同时存在多个栈，但只有一个栈是在运行状态，也就是说，协程是以多占用内存为代价，实现多任务的并行。</p><h6 id="协程与普通线程的差异"><a href="#协程与普通线程的差异" class="headerlink" title="协程与普通线程的差异"></a>协程与普通线程的差异</h6><p>不难看出，协程适合用于多任务运行的环境。在这个意义上，它与普通的线程很相似，都有自己的执行上下文、可以分享全局变量。它们的不同之处在于，同一时间可以有多个线程处于运行状态，但是运行的协程只能有一个，其他协程都处于暂停状态。此外，普通的线程是抢先式的，到底哪个线程优先得到资源，必须由运行环境决定，但是协程是合作式的，执行权由协程自己分配。</p><p>由于 ECMAScript 是单线程语言，只能保持一个调用栈。引入协程以后，每个任务可以保持自己的调用栈。这样做的最大好处，就是抛出错误的时候，可以找到原始的调用栈。不至于像异步操作的回调函数那样，一旦出错，原始的调用栈早就结束。</p><p>Generator 函数是 ECMAScript 6 对协程的实现，但属于不完全实现。Generator 函数被称为“半协程”（semi-coroutine），意思是只有 Generator 函数的调用者，才能将程序的执行权还给 Generator 函数。如果是完全执行的协程，任何函数都可以让暂停的协程继续执行。</p><p>如果将 Generator 函数当作协程，完全可以将多个需要互相协作的任务写成 Generator 函数，它们之间使用 yield 语句交换控制权。</p><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>Generator 可以暂停函数执行，返回任意表达式的值。这种特点使得 Generator 有多种应用场景。</p><h5 id="异步操作的同步化表达"><a href="#异步操作的同步化表达" class="headerlink" title="异步操作的同步化表达"></a>异步操作的同步化表达</h5><p>Generator 函数的暂停执行的效果，意味着可以把异步操作写在 yield 语句里面，等到调用 next 方法时再往后执行。这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在 yield 语句下面，反正要等到调用 next 方法时再执行。所以，Generator 函数的一个重要实际意义就是用来处理异步操作，改写回调函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">loadUI</span></span>() &#123;</span><br><span class="line">  showLoadingScreen();</span><br><span class="line">  yield loadUIDataAsynchronously();</span><br><span class="line">  hideLoadingScreen();</span><br><span class="line">&#125;</span><br><span class="line">var loader = loadUI();</span><br><span class="line">// 加载UI</span><br><span class="line">loader.next()</span><br><span class="line"></span><br><span class="line">// 卸载UI</span><br><span class="line">loader.next()</span><br></pre></td></tr></table></figure><p>上面代码表示，第一次调用 loadUI 函数时，该函数不会执行，仅返回一个遍历器。下一次对该遍历器调用 next 方法，则会显示 Loading 界面，并且异步加载数据。等到数据加载完成，再一次使用 next 方法，则会隐藏 Loading 界面。可以看到，这种写法的好处是所有 Loading 界面的逻辑，都被封装在一个函数，按部就班非常清晰。</p><p>Ajax 是典型的异步操作，通过 Generator 函数部署 Ajax 操作，可以用同步的方式表达。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">  var result = yield request(<span class="string">"http://some.url"</span>);</span><br><span class="line">  var resp = JSON.parse(result);</span><br><span class="line">    console.log(resp.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> request(url) &#123;</span><br><span class="line">  makeAjaxCall(url, <span class="keyword">function</span>(response)&#123;</span><br><span class="line">    it.next(response);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var it = main();</span><br><span class="line">it.next();</span><br></pre></td></tr></table></figure><p>上面代码的 main 函数，就是通过 Ajax 操作获取数据。可以看到，除了多了一个 yield，它几乎与同步操作的写法完全一样。注意，makeAjaxCall 函数中的 next 方法，必须加上 response 参数，因为 yield 语句构成的表达式，本身是没有值的，总是等于 undefined。</p><p>下面是另一个例子，通过 Generator 函数逐行读取文本文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">numbers</span></span>() &#123;</span><br><span class="line">  <span class="built_in">let</span> file = new FileReader(<span class="string">"numbers.txt"</span>);</span><br><span class="line">  try &#123;</span><br><span class="line">    <span class="keyword">while</span>(!file.eof) &#123;</span><br><span class="line">      yield parseInt(file.readLine(), 10);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    file.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码打开文本文件，使用 yield 语句可以手动逐行读取文件。</p><h5 id="控制流管理"><a href="#控制流管理" class="headerlink" title="控制流管理"></a>控制流管理</h5><p>如果有一个多步操作非常耗时，采用回调函数，可能会写成下面这样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">step1(<span class="keyword">function</span> (value1) &#123;</span><br><span class="line">  step2(value1, <span class="keyword">function</span>(value2) &#123;</span><br><span class="line">    step3(value2, <span class="keyword">function</span>(value3) &#123;</span><br><span class="line">      step4(value3, <span class="keyword">function</span>(value4) &#123;</span><br><span class="line">        // Do something with value4</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>采用 Promise 改写上面的代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(step1)</span><br><span class="line">  .<span class="keyword">then</span>(step2)</span><br><span class="line">  .<span class="keyword">then</span>(step3)</span><br><span class="line">  .<span class="keyword">then</span>(step4)</span><br><span class="line">  .<span class="keyword">then</span>(<span class="keyword">function</span> (value4) &#123;</span><br><span class="line">    // Do something with value4</span><br><span class="line">  &#125;, <span class="keyword">function</span> (error) &#123;</span><br><span class="line">    // Handle any error from step1 through step4</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="keyword">done</span>();</span><br></pre></td></tr></table></figure><p>上面代码已经把回调函数，改成了直线执行的形式，但是加入了大量 Promise 的语法。Generator 函数可以进一步改善代码运行流程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* longRunningTask(value1) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    var value2 = yield step1(value1);</span><br><span class="line">    var value3 = yield step2(value2);</span><br><span class="line">    var value4 = yield step3(value3);</span><br><span class="line">    var value5 = yield step4(value4);</span><br><span class="line">    // Do something with value4</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    // Handle any error from step1 through step4</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，使用一个函数，按次序自动执行所有步骤。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">scheduler(longRunningTask(initialValue));</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> scheduler(task) &#123;</span><br><span class="line">  var taskObj = task.next(task.value);</span><br><span class="line">  // 如果Generator函数未结束，就继续调用</span><br><span class="line">  <span class="keyword">if</span> (!taskObj.done) &#123;</span><br><span class="line">    task.value = taskObj.value</span><br><span class="line">    scheduler(task);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，上面这种做法，只适合同步操作，即所有的 task 都必须是同步的，不能有异步操作。因为这里的代码一得到返回值，就继续往下执行，没有判断异步操作何时完成。如果要控制异步的操作流程，详见后面的《异步操作》一章。</p><p>下面，利用 for…of 循环会自动依次执行 yield 命令的特性，提供一种更一般的控制流管理的方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> steps = [step1Func, step2Func, step3Func];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> *iterateSteps(steps)&#123;</span><br><span class="line">  <span class="keyword">for</span> (var i=0; i&lt; steps.length; i++)&#123;</span><br><span class="line">    var step = steps[i];</span><br><span class="line">    yield step();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，数组 steps 封装了一个任务的多个步骤，Generator 函数 iterateSteps 则是依次为这些步骤加上 yield 命令。</p><p>将任务分解成步骤之后，还可以将项目分解成多个依次执行的任务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> <span class="built_in">jobs</span> = [job1, job2, job3];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> *iterateJobs(<span class="built_in">jobs</span>)&#123;</span><br><span class="line">  <span class="keyword">for</span> (var i=0; i&lt; jobs.length; i++)&#123;</span><br><span class="line">    var job = <span class="built_in">jobs</span>[i];</span><br><span class="line">    yield *iterateSteps(job.steps);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，数组 jobs 封装了一个项目的多个任务，Generator 函数 iterateJobs 则是依次为这些任务加上 yield *命令。</p><p>最后，就可以用 for…of 循环一次性依次执行所有任务的所有步骤。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (var step of iterateJobs(<span class="built_in">jobs</span>))&#123;</span><br><span class="line">  console.log(step.id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次提醒，上面的做法只能用于所有步骤都是同步操作的情况，不能有异步操作的步骤。如果想要依次执行异步的步骤，必须使用后面的《异步操作》一章介绍的方法。</p><p>for…of 的本质是一个 while 循环，所以上面的代码实质上执行的是下面的逻辑。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var it = iterateJobs(<span class="built_in">jobs</span>);</span><br><span class="line">var res = it.next();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!res.done)&#123;</span><br><span class="line">  var result = res.value;</span><br><span class="line">  // ...</span><br><span class="line">  res = it.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="部署-Iterator-接口"><a href="#部署-Iterator-接口" class="headerlink" title="部署 Iterator 接口"></a>部署 Iterator 接口</h5><p>利用 Generator 函数，可以在任意对象上部署 Iterator 接口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* iterEntries(obj) &#123;</span><br><span class="line">  <span class="built_in">let</span> keys = Object.keys(obj);</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">let</span> i=0; i &lt; keys.length; i++) &#123;</span><br><span class="line">    <span class="built_in">let</span> key = keys[i];</span><br><span class="line">    yield [key, obj[key]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> myObj = &#123; foo: 3, bar: 7 &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> [key, value] of iterEntries(myObj)) &#123;</span><br><span class="line">  console.log(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// foo 3</span><br><span class="line">// bar 7</span><br></pre></td></tr></table></figure><p>上述代码中，myObj 是一个普通对象，通过 iterEntries 函数，就有了 Iterator 接口。也就是说，可以在任意对象上部署 next 方法。</p><p>下面是一个对数组部署 Iterator 接口的例子，尽管数组原生具有这个接口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* makeSimpleGenerator(array)&#123;</span><br><span class="line">  var nextIndex = 0;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(nextIndex &lt; array.length)&#123;</span><br><span class="line">    yield array[nextIndex++];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var gen = makeSimpleGenerator([<span class="string">'yo'</span>, <span class="string">'ya'</span>]);</span><br><span class="line"></span><br><span class="line">gen.next().value // <span class="string">'yo'</span></span><br><span class="line">gen.next().value // <span class="string">'ya'</span></span><br><span class="line">gen.next().<span class="keyword">done</span>  // <span class="literal">true</span></span><br></pre></td></tr></table></figure><h5 id="作为数据结构"><a href="#作为数据结构" class="headerlink" title="作为数据结构"></a>作为数据结构</h5><p>Generator 可以看作是数据结构，更确切地说，可以看作是一个数组结构，因为 Generator 函数可以返回一系列的值，这意味着它可以对任意表达式，提供类似数组的接口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> *<span class="function"><span class="title">doStuff</span></span>() &#123;</span><br><span class="line">  yield fs.readFile.bind(null, <span class="string">'hello.txt'</span>);</span><br><span class="line">  yield fs.readFile.bind(null, <span class="string">'world.txt'</span>);</span><br><span class="line">  yield fs.readFile.bind(null, <span class="string">'and-such.txt'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码就是依次返回三个函数，但是由于使用了 Generator 函数，导致可以像处理数组那样，处理这三个返回的函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (task of doStuff()) &#123;</span><br><span class="line">  // task是一个函数，可以像回调函数那样使用它</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，如果用 ES5 表达，完全可以用数组模拟 Generator 的这种用法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">doStuff</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> [</span><br><span class="line">    fs.readFile.bind(null, <span class="string">'hello.txt'</span>),</span><br><span class="line">    fs.readFile.bind(null, <span class="string">'world.txt'</span>),</span><br><span class="line">    fs.readFile.bind(null, <span class="string">'and-such.txt'</span>)</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数，可以用一模一样的 for…of 循环处理！两相一比较，就不难看出 Generator 使得数据或者操作，具备了类似数组的接口。</p>]]></content>
      
      
      <categories>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6_Iterator</title>
      <link href="/2019/03/15/es6-Iterator/"/>
      <url>/2019/03/15/es6-Iterator/</url>
      
        <content type="html"><![CDATA[<h3 id="Iterator-和-for…of-循环"><a href="#Iterator-和-for…of-循环" class="headerlink" title="Iterator 和 for…of 循环"></a>Iterator 和 for…of 循环</h3><h4 id="Iterator（遍历器）的概念"><a href="#Iterator（遍历器）的概念" class="headerlink" title="Iterator（遍历器）的概念"></a>Iterator（遍历器）的概念</h4><p>JavaScript 原有的表示“集合”的数据结构，主要是数组（Array）和对象（Object），ES6 又添加了 Map 和 Set。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是 Map，Map 的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。</p><p>遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</p><p>Iterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令 for…of 循环，Iterator 接口主要供 for…of 消费。</p><p>Iterator 的遍历过程是这样的。</p><p>（1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</p><p>（2）第一次调用指针对象的 next 方法，可以将指针指向数据结构的第一个成员。</p><p>（3）第二次调用指针对象的 next 方法，指针就指向数据结构的第二个成员。</p><p>（4）不断调用指针对象的 next 方法，直到它指向数据结构的结束位置。</p><p>每一次调用 next 方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含 value 和 done 两个属性的对象。其中，value 属性是当前成员的值，done 属性是一个布尔值，表示遍历是否结束。</p><p>下面是一个模拟 next 方法返回值的例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var it = makeIterator([<span class="string">'a'</span>, <span class="string">'b'</span>]);</span><br><span class="line"></span><br><span class="line">it.next() // &#123; value: <span class="string">"a"</span>, <span class="keyword">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">it.next() // &#123; value: <span class="string">"b"</span>, <span class="keyword">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">it.next() // &#123; value: undefined, <span class="keyword">done</span>: <span class="literal">true</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> makeIterator(array) &#123;</span><br><span class="line">  var nextIndex = 0;</span><br><span class="line">  <span class="built_in">return</span> &#123;</span><br><span class="line">    next: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">      <span class="built_in">return</span> nextIndex &lt; array.length ?</span><br><span class="line">        &#123;value: array[nextIndex++], <span class="keyword">done</span>: <span class="literal">false</span>&#125; :</span><br><span class="line">        &#123;value: undefined, <span class="keyword">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码定义了一个 makeIterator 函数，它是一个遍历器生成函数，作用就是返回一个遍历器对象。对数组[‘a’, ‘b’]执行这个函数，就会返回该数组的遍历器对象（即指针对象）it。</p><p>指针对象的 next 方法，用来移动指针。开始时，指针指向数组的开始位置。然后，每次调用 next 方法，指针就会指向数组的下一个成员。第一次调用，指向 a；第二次调用，指向 b。</p><p>next 方法返回一个对象，表示当前数据成员的信息。这个对象具有 value 和 done 两个属性，value 属性返回当前位置的成员，done 属性是一个布尔值，表示遍历是否结束，即是否还有必要再一次调用 next 方法。</p><p>总之，调用指针对象的 next 方法，就可以遍历事先给定的数据结构。</p><p>对于遍历器对象来说，done: false 和 value: undefined 属性都是可以省略的，因此上面的 makeIterator 函数可以简写成下面的形式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> makeIterator(array) &#123;</span><br><span class="line">  var nextIndex = 0;</span><br><span class="line">  <span class="built_in">return</span> &#123;</span><br><span class="line">    next: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">      <span class="built_in">return</span> nextIndex &lt; array.length ?</span><br><span class="line">        &#123;value: array[nextIndex++]&#125; :</span><br><span class="line">        &#123;<span class="keyword">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 Iterator 只是把接口规格加到数据结构之上，所以，遍历器与它所遍历的那个数据结构，实际上是分开的，完全可以写出没有对应数据结构的遍历器对象，或者说用遍历器对象模拟出数据结构。下面是一个无限运行的遍历器对象的例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var it = idMaker();</span><br><span class="line"></span><br><span class="line">it.next().value // <span class="string">'0'</span></span><br><span class="line">it.next().value // <span class="string">'1'</span></span><br><span class="line">it.next().value // <span class="string">'2'</span></span><br><span class="line">// ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">idMaker</span></span>() &#123;</span><br><span class="line">  var index = 0;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> &#123;</span><br><span class="line">    next: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">      <span class="built_in">return</span> &#123;value: index++, <span class="keyword">done</span>: <span class="literal">false</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中，遍历器生成函数 idMaker，返回一个遍历器对象（即指针对象）。但是并没有对应的数据结构，或者说，遍历器对象自己描述了一个数据结构出来。</p><p>在 ES6 中，有些数据结构原生具备 Iterator 接口（比如数组），即不用任何处理，就可以被 for…of 循环遍历，有些就不行（比如对象）。原因在于，这些数据结构原生部署了 Symbol.iterator 属性（详见下文），另外一些数据结构没有。凡是部署了 Symbol.iterator 属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象。</p><p>如果使用 TypeScript 的写法，遍历器接口（Iterable）、指针对象（Iterator）和 next 方法返回值的规格可以描述如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">interface Iterable &#123;</span><br><span class="line">  [Symbol.iterator]() : Iterator,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Iterator &#123;</span><br><span class="line">  next(value?: any) : IterationResult,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IterationResult &#123;</span><br><span class="line">  value: any,</span><br><span class="line">  <span class="keyword">done</span>: boolean,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数据结构的默认-Iterator-接口"><a href="#数据结构的默认-Iterator-接口" class="headerlink" title="数据结构的默认 Iterator 接口"></a>数据结构的默认 Iterator 接口</h4><p>Iterator 接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即 for…of 循环（详见下文）。当使用 for…of 循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口。</p><p>一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是”可遍历的“（iterable）。</p><p>ES6 规定，默认的 Iterator 接口部署在数据结构的 Symbol.iterator 属性，或者说，一个数据结构只要具有 Symbol.iterator 属性，就可以认为是“可遍历的”（iterable）。Symbol.iterator 属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。至于属性名 Symbol.iterator，它是一个表达式，返回 Symbol 对象的 iterator 属性，这是一个预定义好的、类型为 Symbol 的特殊值，所以要放在方括号内。（参见 Symbol 一章）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line">  [Symbol.iterator] : <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">      next: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        <span class="built_in">return</span> &#123;</span><br><span class="line">          value: 1,</span><br><span class="line">          <span class="keyword">done</span>: <span class="literal">true</span></span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，对象 obj 是可遍历的（iterable），因为具有 Symbol.iterator 属性。执行这个属性，会返回一个遍历器对象。该对象的根本特征就是具有 next 方法。每次调用 next 方法，都会返回一个代表当前成员的信息对象，具有 value 和 done 两个属性。</p><p>在 ES6 中，有三类数据结构原生具备 Iterator 接口：数组、某些类似数组的对象、Set 和 Map 结构。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="built_in">let</span> iter = arr[Symbol.iterator]();</span><br><span class="line"></span><br><span class="line">iter.next() // &#123; value: <span class="string">'a'</span>, <span class="keyword">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">iter.next() // &#123; value: <span class="string">'b'</span>, <span class="keyword">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">iter.next() // &#123; value: <span class="string">'c'</span>, <span class="keyword">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">iter.next() // &#123; value: undefined, <span class="keyword">done</span>: <span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure><p>上面代码中，变量 arr 是一个数组，原生就具有遍历器接口，部署在 arr 的 Symbol.iterator 属性上面。所以，调用这个属性，就得到遍历器对象。</p><p>上面提到，原生就部署 Iterator 接口的数据结构有三类，对于这三类数据结构，不用自己写遍历器生成函数，for…of 循环会自动遍历它们。除此之外，其他数据结构（主要是对象）的 Iterator 接口，都需要自己在 Symbol.iterator 属性上面部署，这样才会被 for…of 循环遍历。</p><p>对象（Object）之所以没有默认部署 Iterator 接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。本质上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口，就等于部署一种线性转换。不过，严格地说，对象部署遍历器接口并不是很必要，因为这时对象实际上被当作 Map 结构使用，ES5 没有 Map 结构，而 ES6 原生提供了。</p><p>一个对象如果要有可被 for…of 循环调用的 Iterator 接口，就必须在 Symbol.iterator 的属性上部署遍历器生成方法（原型链上的对象具有该方法也可）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class RangeIterator &#123;</span><br><span class="line">  constructor(start, stop) &#123;</span><br><span class="line">    this.value = start;</span><br><span class="line">    this.stop = stop;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [Symbol.iterator]() &#123; <span class="built_in">return</span> this; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">next</span></span>() &#123;</span><br><span class="line">    var value = this.value;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; this.stop) &#123;</span><br><span class="line">      this.value++;</span><br><span class="line">      <span class="built_in">return</span> &#123;<span class="keyword">done</span>: <span class="literal">false</span>, value: value&#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">return</span> &#123;<span class="keyword">done</span>: <span class="literal">true</span>, value: undefined&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> range(start, stop) &#123;</span><br><span class="line">  <span class="built_in">return</span> new RangeIterator(start, stop);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (var value of range(0, 3)) &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码是一个类部署 Iterator 接口的写法。Symbol.iterator 属性对应一个函数，执行后返回当前对象的遍历器对象。</p><p>下面是通过遍历器实现指针结构的例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Obj(value) &#123;</span><br><span class="line">  this.value = value;</span><br><span class="line">  this.next = null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Obj.prototype[Symbol.iterator] = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  var iterator = &#123;</span><br><span class="line">    next: next</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  var current = this;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">next</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (current) &#123;</span><br><span class="line">      var value = current.value;</span><br><span class="line">      current = current.next;</span><br><span class="line">      <span class="built_in">return</span> &#123;</span><br><span class="line">        <span class="keyword">done</span>: <span class="literal">false</span>,</span><br><span class="line">        value: value</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">return</span> &#123;</span><br><span class="line">        <span class="keyword">done</span>: <span class="literal">true</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> iterator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var one = new Obj(1);</span><br><span class="line">var two = new Obj(2);</span><br><span class="line">var three = new Obj(3);</span><br><span class="line"></span><br><span class="line">one.next = two;</span><br><span class="line">two.next = three;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (var i of one)&#123;</span><br><span class="line">  console.log(i);</span><br><span class="line">&#125;</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line">// 3</span><br></pre></td></tr></table></figure><p>上面代码首先在构造函数的原型链上部署 Symbol.iterator 方法，调用该方法会返回遍历器对象 iterator，调用该对象的 next 方法，在返回一个值的同时，自动将内部指针移到下一个实例。</p><p>下面是另一个为对象添加 Iterator 接口的例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> obj = &#123;</span><br><span class="line">  data: [ <span class="string">'hello'</span>, <span class="string">'world'</span> ],</span><br><span class="line">  [Symbol.iterator]() &#123;</span><br><span class="line">    const self = this;</span><br><span class="line">    <span class="built_in">let</span> index = 0;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">      <span class="function"><span class="title">next</span></span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; self.data.length) &#123;</span><br><span class="line">          <span class="built_in">return</span> &#123;</span><br><span class="line">            value: self.data[index++],</span><br><span class="line">            <span class="keyword">done</span>: <span class="literal">false</span></span><br><span class="line">          &#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">return</span> &#123; value: undefined, <span class="keyword">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于类似数组的对象（存在数值键名和 length 属性），部署 Iterator 接口，有一个简便方法，就是 Symbol.iterator 方法直接引用数组的 Iterator 接口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NodeList.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator];</span><br><span class="line">// 或者</span><br><span class="line">NodeList.prototype[Symbol.iterator] = [][Symbol.iterator];</span><br><span class="line"></span><br><span class="line">[...document.querySelectorAll(<span class="string">'div'</span>)] // 可以执行了</span><br></pre></td></tr></table></figure><p>下面是类似数组的对象调用数组的 Symbol.iterator 方法的例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> iterable = &#123;</span><br><span class="line">  0: <span class="string">'a'</span>,</span><br><span class="line">  1: <span class="string">'b'</span>,</span><br><span class="line">  2: <span class="string">'c'</span>,</span><br><span class="line">  length: 3,</span><br><span class="line">  [Symbol.iterator]: Array.prototype[Symbol.iterator]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> item of iterable) &#123;</span><br><span class="line">  console.log(item); // <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，普通对象部署数组的 Symbol.iterator 方法，并无效果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> iterable = &#123;</span><br><span class="line">  a: <span class="string">'a'</span>,</span><br><span class="line">  b: <span class="string">'b'</span>,</span><br><span class="line">  c: <span class="string">'c'</span>,</span><br><span class="line">  length: 3,</span><br><span class="line">  [Symbol.iterator]: Array.prototype[Symbol.iterator]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> item of iterable) &#123;</span><br><span class="line">  console.log(item); // undefined, undefined, undefined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 Symbol.iterator 方法对应的不是遍历器生成函数（即会返回一个遍历器对象），解释引擎将会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj[Symbol.iterator] = () =&gt; 1;</span><br><span class="line"></span><br><span class="line">[...obj] // TypeError: [] is not a <span class="keyword">function</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量 obj 的 Symbol.iterator 方法对应的不是遍历器生成函数，因此报错。</p><p>有了遍历器接口，数据结构就可以用 for…of 循环遍历（详见下文），也可以使用 while 循环遍历。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var <span class="variable">$iterator</span> = ITERABLE[Symbol.iterator]();</span><br><span class="line">var <span class="variable">$result</span> = <span class="variable">$iterator</span>.next();</span><br><span class="line"><span class="keyword">while</span> (!<span class="variable">$result</span>.<span class="keyword">done</span>) &#123;</span><br><span class="line">  var x = <span class="variable">$result</span>.value;</span><br><span class="line">  // ...</span><br><span class="line">  <span class="variable">$result</span> = <span class="variable">$iterator</span>.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，ITERABLE 代表某种可遍历的数据结构，\$iterator 是它的遍历器对象。遍历器对象每次移动指针（next 方法），都检查一下返回值的 done 属性，如果遍历还没结束，就移动遍历器对象的指针到下一步（next 方法），不断循环。</p><h4 id="调用-Iterator-接口的场合"><a href="#调用-Iterator-接口的场合" class="headerlink" title="调用 Iterator 接口的场合"></a>调用 Iterator 接口的场合</h4><p>有一些场合会默认调用 Iterator 接口（即 Symbol.iterator 方法），除了下文会介绍的 for…of 循环，还有几个别的场合。</p><h5 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h5><p>对数组和 Set 结构进行解构赋值时，会默认调用 Symbol.iterator 方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> <span class="built_in">set</span> = new Set().add(<span class="string">'a'</span>).add(<span class="string">'b'</span>).add(<span class="string">'c'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> [x,y] = <span class="built_in">set</span>;</span><br><span class="line">// x=<span class="string">'a'</span>; y=<span class="string">'b'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> [first, ...rest] = <span class="built_in">set</span>;</span><br><span class="line">// first=<span class="string">'a'</span>; rest=[<span class="string">'b'</span>,<span class="string">'c'</span>];</span><br></pre></td></tr></table></figure><h5 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h5><p>扩展运算符（…）也会调用默认的 iterator 接口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 例一</span><br><span class="line">var str = <span class="string">'hello'</span>;</span><br><span class="line">[...str] //  [<span class="string">'h'</span>,<span class="string">'e'</span>,<span class="string">'l'</span>,<span class="string">'l'</span>,<span class="string">'o'</span>]</span><br><span class="line"></span><br><span class="line">// 例二</span><br><span class="line"><span class="built_in">let</span> arr = [<span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line">[<span class="string">'a'</span>, ...arr, <span class="string">'d'</span>]</span><br><span class="line">// [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</span><br></pre></td></tr></table></figure><p>上面代码的扩展运算符内部就调用 Iterator 接口。</p><p>实际上，这提供了一种简便机制，可以将任何部署了 Iterator 接口的数据结构，转为数组。也就是说，只要某个数据结构部署了 Iterator 接口，就可以对它使用扩展运算符，将其转为数组。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arr = [...iterable];</span><br></pre></td></tr></table></figure><h5 id="yield"><a href="#yield" class="headerlink" title="yield*"></a>yield*</h5><p>yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> generator = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  yield* [2,3,4];</span><br><span class="line">  yield 5;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var iterator = generator();</span><br><span class="line"></span><br><span class="line">iterator.next() // &#123; value: 1, <span class="keyword">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">iterator.next() // &#123; value: 2, <span class="keyword">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">iterator.next() // &#123; value: 3, <span class="keyword">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">iterator.next() // &#123; value: 4, <span class="keyword">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">iterator.next() // &#123; value: 5, <span class="keyword">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">iterator.next() // &#123; value: undefined, <span class="keyword">done</span>: <span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure><h5 id="其他场合"><a href="#其他场合" class="headerlink" title="其他场合"></a>其他场合</h5><p>由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。下面是一些例子。</p><pre>for...ofArray.from()Map(), Set(), WeakMap(), WeakSet()（比如new Map([['a',1],['b',2]])）Promise.all()Promise.race()</pre><h4 id="字符串的-Iterator-接口"><a href="#字符串的-Iterator-接口" class="headerlink" title="字符串的 Iterator 接口"></a>字符串的 Iterator 接口</h4><p>字符串是一个类似数组的对象，也原生具有 Iterator 接口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var someString = <span class="string">"hi"</span>;</span><br><span class="line">typeof someString[Symbol.iterator]</span><br><span class="line">// <span class="string">"function"</span></span><br><span class="line"></span><br><span class="line">var iterator = someString[Symbol.iterator]();</span><br><span class="line"></span><br><span class="line">iterator.next()  // &#123; value: <span class="string">"h"</span>, <span class="keyword">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">iterator.next()  // &#123; value: <span class="string">"i"</span>, <span class="keyword">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">iterator.next()  // &#123; value: undefined, <span class="keyword">done</span>: <span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure><p>上面代码中，调用 Symbol.iterator 方法返回一个遍历器对象，在这个遍历器上可以调用 next 方法，实现对于字符串的遍历。</p><p>可以覆盖原生的 Symbol.iterator 方法，达到修改遍历器行为的目的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var str = new String(<span class="string">"hi"</span>);</span><br><span class="line"></span><br><span class="line">[...str] // [<span class="string">"h"</span>, <span class="string">"i"</span>]</span><br><span class="line"></span><br><span class="line">str[Symbol.iterator] = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> &#123;</span><br><span class="line">    next: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">      <span class="keyword">if</span> (this._first) &#123;</span><br><span class="line">        this._first = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">return</span> &#123; value: <span class="string">"bye"</span>, <span class="keyword">done</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">return</span> &#123; <span class="keyword">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    _first: <span class="literal">true</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[...str] // [<span class="string">"bye"</span>]</span><br><span class="line">str // <span class="string">"hi"</span></span><br></pre></td></tr></table></figure><p>上面代码中，字符串 str 的 Symbol.iterator 方法被修改了，所以扩展运算符（…）返回的值变成了 bye，而字符串本身还是 hi。</p><h4 id="Iterator-接口与-Generator-函数"><a href="#Iterator-接口与-Generator-函数" class="headerlink" title="Iterator 接口与 Generator 函数"></a>Iterator 接口与 Generator 函数</h4><p>Symbol.iterator 方法的最简单实现，还是使用下一章要介绍的 Generator 函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var myIterable = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">myIterable[Symbol.iterator] = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  yield 2;</span><br><span class="line">  yield 3;</span><br><span class="line">&#125;;</span><br><span class="line">[...myIterable] // [1, 2, 3]</span><br><span class="line"></span><br><span class="line">// 或者采用下面的简洁写法</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> obj = &#123;</span><br><span class="line">  * [Symbol.iterator]() &#123;</span><br><span class="line">    yield <span class="string">'hello'</span>;</span><br><span class="line">    yield <span class="string">'world'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> x of obj) &#123;</span><br><span class="line">  console.log(x);</span><br><span class="line">&#125;</span><br><span class="line">// hello</span><br><span class="line">// world</span><br></pre></td></tr></table></figure><p>上面代码中，Symbol.iterator 方法几乎不用部署任何代码，只要用 yield 命令给出每一步的返回值即可。</p><h4 id="遍历器对象的-return-，throw"><a href="#遍历器对象的-return-，throw" class="headerlink" title="遍历器对象的 return()，throw()"></a>遍历器对象的 return()，throw()</h4><p>遍历器对象除了具有 next 方法，还可以具有 return 方法和 throw 方法。如果你自己写遍历器对象生成函数，那么 next 方法是必须部署的，return 方法和 throw 方法是否部署是可选的。</p><p>return 方法的使用场合是，如果 for…of 循环提前退出（通常是因为出错，或者有 break 语句或 continue 语句），就会调用 return 方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署 return 方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> readLinesSync(file) &#123;</span><br><span class="line">  <span class="built_in">return</span> &#123;</span><br><span class="line">    <span class="function"><span class="title">next</span></span>() &#123;</span><br><span class="line">      <span class="keyword">if</span> (file.isAtEndOfFile()) &#123;</span><br><span class="line">        file.close();</span><br><span class="line">        <span class="built_in">return</span> &#123; <span class="keyword">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">return</span></span>() &#123;</span><br><span class="line">      file.close();</span><br><span class="line">      <span class="built_in">return</span> &#123; <span class="keyword">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，函数 readLinesSync 接受一个文件对象作为参数，返回一个遍历器对象，其中除了 next 方法，还部署了 return 方法。下面，我们让文件的遍历提前返回，这样就会触发执行 return 方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> line of readLinesSync(fileName)) &#123;</span><br><span class="line">  console.log(line);</span><br><span class="line">  <span class="built_in">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，return 方法必须返回一个对象，这是 Generator 规格决定的。</p><p>throw 方法主要是配合 Generator 函数使用，一般的遍历器对象用不到这个方法。请参阅《Generator 函数》一章。</p><h4 id="for…of-循环"><a href="#for…of-循环" class="headerlink" title="for…of 循环"></a>for…of 循环</h4><p>ES6 借鉴 C++、Java、C# 和 Python 语言，引入了 for…of 循环，作为遍历所有数据结构的统一的方法。</p><p>一个数据结构只要部署了 Symbol.iterator 属性，就被视为具有 iterator 接口，就可以用 for…of 循环遍历它的成员。也就是说，for…of 循环内部调用的是数据结构的 Symbol.iterator 方法。</p><p>for…of 循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如 arguments 对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串。</p><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组原生具备 iterator 接口（即默认部署了 Symbol.iterator 属性），for…of 循环本质上就是调用这个接口产生的遍历器，可以用下面的代码证明。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const arr = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">let</span> v of arr) &#123;</span><br><span class="line">  console.log(v); // red green blue</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const obj = &#123;&#125;;</span><br><span class="line">obj[Symbol.iterator] = arr[Symbol.iterator].<span class="built_in">bind</span>(arr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">let</span> v of obj) &#123;</span><br><span class="line">  console.log(v); // red green blue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，空对象 obj 部署了数组 arr 的 Symbol.iterator 属性，结果 obj 的 for…of 循环，产生了与 arr 完全一样的结果。</p><p>for…of 循环可以代替数组实例的 forEach 方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const arr = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>];</span><br><span class="line"></span><br><span class="line">arr.forEach(<span class="keyword">function</span> (element, index) &#123;</span><br><span class="line">  console.log(element); // red green blue</span><br><span class="line">  console.log(index);   // 0 1 2</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>JavaScript 原有的 for…in 循环，只能获得对象的键名，不能直接获取键值。ES6 提供 for…of 循环，允许遍历获得键值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> a <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  console.log(a); // 0 1 2 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> a of arr) &#123;</span><br><span class="line">  console.log(a); // a b c d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码表明，for…in 循环读取键名，for…of 循环读取键值。如果要通过 for…of 循环，获取数组的索引，可以借助数组实例的 entries 方法和 keys 方法，参见《数组的扩展》章节。</p><p>for…of 循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。这一点跟 for…in 循环也不一样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arr = [3, 5, 7];</span><br><span class="line">arr.foo = <span class="string">'hello'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  console.log(i); // <span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"foo"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i of arr) &#123;</span><br><span class="line">  console.log(i); //  <span class="string">"3"</span>, <span class="string">"5"</span>, <span class="string">"7"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，for…of 循环不会返回数组 arr 的 foo 属性。</p><h4 id="Set-和-Map-结构"><a href="#Set-和-Map-结构" class="headerlink" title="Set 和 Map 结构"></a>Set 和 Map 结构</h4><p>Set 和 Map 结构也原生具有 Iterator 接口，可以直接使用 for…of 循环。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var engines = new Set([<span class="string">"Gecko"</span>, <span class="string">"Trident"</span>, <span class="string">"Webkit"</span>, <span class="string">"Webkit"</span>]);</span><br><span class="line"><span class="keyword">for</span> (var e of engines) &#123;</span><br><span class="line">  console.log(e);</span><br><span class="line">&#125;</span><br><span class="line">// Gecko</span><br><span class="line">// Trident</span><br><span class="line">// Webkit</span><br><span class="line"></span><br><span class="line">var es6 = new Map();</span><br><span class="line">es6.set(<span class="string">"edition"</span>, 6);</span><br><span class="line">es6.set(<span class="string">"committee"</span>, <span class="string">"TC39"</span>);</span><br><span class="line">es6.set(<span class="string">"standard"</span>, <span class="string">"ECMA-262"</span>);</span><br><span class="line"><span class="keyword">for</span> (var [name, value] of es6) &#123;</span><br><span class="line">  console.log(name + <span class="string">": "</span> + value);</span><br><span class="line">&#125;</span><br><span class="line">// edition: 6</span><br><span class="line">// committee: TC39</span><br><span class="line">// standard: ECMA-262</span><br></pre></td></tr></table></figure><p>上面代码演示了如何遍历 Set 结构和 Map 结构。值得注意的地方有两个，首先，遍历的顺序是按照各个成员被添加进数据结构的顺序。其次，Set 结构遍历时，返回的是一个值，而 Map 结构遍历时，返回的是一个数组，该数组的两个成员分别为当前 Map 成员的键名和键值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> map = new Map().<span class="built_in">set</span>(<span class="string">'a'</span>, 1).<span class="built_in">set</span>(<span class="string">'b'</span>, 2);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> pair of map) &#123;</span><br><span class="line">  console.log(pair);</span><br><span class="line">&#125;</span><br><span class="line">// [<span class="string">'a'</span>, 1]</span><br><span class="line">// [<span class="string">'b'</span>, 2]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> [key, value] of map) &#123;</span><br><span class="line">  console.log(key + <span class="string">' : '</span> + value);</span><br><span class="line">&#125;</span><br><span class="line">// a : 1</span><br><span class="line">// b : 2</span><br></pre></td></tr></table></figure><h4 id="计算生成的数据结构"><a href="#计算生成的数据结构" class="headerlink" title="计算生成的数据结构"></a>计算生成的数据结构</h4><p>有些数据结构是在现有数据结构的基础上，计算生成的。比如，ES6 的数组、Set、Map 都部署了以下三个方法，调用后都返回遍历器对象。</p><p>1.entries() 返回一个遍历器对象，用来遍历[键名, 键值]组成的数组。对于数组，键名就是索引值；对于 Set，键名与键值相同。Map 结构的 iterator 接口，默认就是调用 entries 方法。<br>2.keys() 返回一个遍历器对象，用来遍历所有的键名。<br>3.values() 返回一个遍历器对象，用来遍历所有的键值。<br>这三个方法调用后生成的遍历器对象，所遍历的都是计算生成的数据结构。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> pair of arr.entries()) &#123;</span><br><span class="line">  console.log(pair);</span><br><span class="line">&#125;</span><br><span class="line">// [0, <span class="string">'a'</span>]</span><br><span class="line">// [1, <span class="string">'b'</span>]</span><br><span class="line">// [2, <span class="string">'c'</span>]</span><br></pre></td></tr></table></figure><h4 id="类似数组的对象"><a href="#类似数组的对象" class="headerlink" title="类似数组的对象"></a>类似数组的对象</h4><p>类似数组的对象包括好几类。下面是 for…of 循环用于字符串、DOM NodeList 对象、arguments 对象的例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 字符串</span><br><span class="line"><span class="built_in">let</span> str = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> s of str) &#123;</span><br><span class="line">  console.log(s); // h e l l o</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// DOM NodeList对象</span><br><span class="line"><span class="built_in">let</span> paras = document.querySelectorAll(<span class="string">"p"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> p of paras) &#123;</span><br><span class="line">  p.classList.add(<span class="string">"test"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// arguments对象</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">printArgs</span></span>() &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">let</span> x of arguments) &#123;</span><br><span class="line">    console.log(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">printArgs(<span class="string">'a'</span>, <span class="string">'b'</span>);</span><br><span class="line">// <span class="string">'a'</span></span><br><span class="line">// <span class="string">'b'</span></span><br></pre></td></tr></table></figure><p>对于字符串来说，for…of 循环还有一个特点，就是会正确识别 32 位 UTF-16 字符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> x of <span class="string">'a\uD83D\uDC0A'</span>) &#123;</span><br><span class="line">  console.log(x);</span><br><span class="line">&#125;</span><br><span class="line">// <span class="string">'a'</span></span><br><span class="line">// <span class="string">'\uD83D\uDC0A'</span></span><br></pre></td></tr></table></figure><p>并不是所有类似数组的对象都具有 iterator 接口，一个简便的解决方法，就是使用 Array.from 方法将其转为数组。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arrayLike = &#123; length: 2, 0: <span class="string">'a'</span>, 1: <span class="string">'b'</span> &#125;;</span><br><span class="line"></span><br><span class="line">// 报错</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> x of arrayLike) &#123;</span><br><span class="line">  console.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 正确</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> x of Array.from(arrayLike)) &#123;</span><br><span class="line">  console.log(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>对于普通的对象，for…of 结构不能直接使用，会报错，必须部署了 iterator 接口后才能使用。但是，这样情况下，for…in 循环依然可以用来遍历键名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var es6 = &#123;</span><br><span class="line">  edition: 6,</span><br><span class="line">  committee: <span class="string">"TC39"</span>,</span><br><span class="line">  standard: <span class="string">"ECMA-262"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> e <span class="keyword">in</span> es6) &#123;</span><br><span class="line">  console.log(e);</span><br><span class="line">&#125;</span><br><span class="line">// edition</span><br><span class="line">// committee</span><br><span class="line">// standard</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> e of es6) &#123;</span><br><span class="line">  console.log(e);</span><br><span class="line">&#125;</span><br><span class="line">// TypeError: es6 is not iterable</span><br></pre></td></tr></table></figure><p>上面代码表示，对于普通的对象，for…in 循环可以遍历键名，for…of 循环会报错。</p><p>一种解决方法是，使用 Object.keys 方法将对象的键名生成一个数组，然后遍历这个数组。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (var key of Object.keys(someObject)) &#123;</span><br><span class="line">  console.log(key + <span class="string">": "</span> + someObject[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在对象上部署 iterator 接口的代码，参见本章前面部分。一个方便的方法是将数组的 Symbol.iterator 属性，直接赋值给其他对象的 Symbol.iterator 属性。比如，想要让 for…of 环遍历 jQuery 对象，只要加上下面这一行就可以了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jQuery.prototype[Symbol.iterator] =</span><br><span class="line">  Array.prototype[Symbol.iterator];</span><br></pre></td></tr></table></figure><p>另一个方法是使用 Generator 函数将对象重新包装一下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* entries(obj) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">let</span> key of Object.keys(obj)) &#123;</span><br><span class="line">    yield [key, obj[key]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> [key, value] of entries(obj)) &#123;</span><br><span class="line">  console.log(key, <span class="string">"-&gt;"</span>, value);</span><br><span class="line">&#125;</span><br><span class="line">// a -&gt; 1</span><br><span class="line">// b -&gt; 2</span><br><span class="line">// c -&gt; 3</span><br></pre></td></tr></table></figure><h4 id="与其他遍历语法的比较"><a href="#与其他遍历语法的比较" class="headerlink" title="与其他遍历语法的比较"></a>与其他遍历语法的比较</h4><p>以数组为例，JavaScript 提供多种遍历语法。最原始的写法就是 for 循环。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (var index = 0; index &lt; myArray.length; index++) &#123;</span><br><span class="line">  console.log(myArray[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法比较麻烦，因此数组提供内置的 forEach 方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myArray.forEach(<span class="keyword">function</span> (value) &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这种写法的问题在于，无法中途跳出 forEach 循环，break 命令或 return 命令都不能奏效。</p><p>for…in 循环可以遍历数组的键名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (var index <span class="keyword">in</span> myArray) &#123;</span><br><span class="line">  console.log(myArray[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for…in 循环有几个缺点。</p><p>1.数组的键名是数字，但是 for…in 循环是以字符串作为键名“0”、“1”、“2”等等。<br>2.for…in 循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。 3.某些情况下，for…in 循环会以任意顺序遍历键名。<br>总之，for…in 循环主要是为遍历对象而设计的，不适用于遍历数组。</p><p>for…of 循环相比上面几种做法，有一些显著的优点。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> value of myArray) &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有着同 for…in 一样的简洁语法，但是没有 for…in 那些缺点。<br>不同用于 forEach 方法，它可以与 break、continue 和 return 配合使用。<br>提供了遍历所有数据结构的统一操作接口。<br>下面是一个使用 break 语句，跳出 for…of 循环的例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (var n of fibonacci) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; 1000)</span><br><span class="line">    <span class="built_in">break</span>;</span><br><span class="line">  console.log(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子，会输出斐波纳契数列小于等于 1000 的项。如果当前项大于 1000，就会使用 break 语句跳出 for…of 循环。</p>]]></content>
      
      
      <categories>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6_Proxy_Reflect</title>
      <link href="/2019/03/05/es6-Proxy-Reflect/"/>
      <url>/2019/03/05/es6-Proxy-Reflect/</url>
      
        <content type="html"><![CDATA[<h3 id="Proxy-和-Reflect"><a href="#Proxy-和-Reflect" class="headerlink" title="Proxy 和 Reflect"></a>Proxy 和 Reflect</h3><h4 id="Proxy-概述"><a href="#Proxy-概述" class="headerlink" title="Proxy 概述"></a>Proxy 概述</h4><p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。</p><p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var obj = new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  get: <span class="keyword">function</span> (target, key, receiver) &#123;</span><br><span class="line">    console.log(`getting <span class="variable">$&#123;key&#125;</span>!`);</span><br><span class="line">    <span class="built_in">return</span> Reflect.get(target, key, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">set</span>: <span class="keyword">function</span> (target, key, value, receiver) &#123;</span><br><span class="line">    console.log(`setting <span class="variable">$&#123;key&#125;</span>!`);</span><br><span class="line">    <span class="built_in">return</span> Reflect.set(target, key, value, receiver);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码对一个空对象架设了一层拦截，重定义了属性的读取（get）和设置（set）行为。这里暂时先不解释具体的语法，只看运行结果。对设置了拦截行为的对象 obj，去读写它的属性，就会得到下面的结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">obj.count = 1</span><br><span class="line">//  setting count!</span><br><span class="line">++obj.count</span><br><span class="line">//  getting count!</span><br><span class="line">//  setting count!</span><br><span class="line">//  2</span><br></pre></td></tr></table></figure><p>上面代码说明，Proxy 实际上重载（overload）了点运算符，即用自己的定义覆盖了语言的原始定义。</p><p>ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。</p><p>var proxy = new Proxy(target, handler);<br>Proxy 对象的所有用法，都是上面这种形式，不同的只是 handler 参数的写法。其中，new Proxy()表示生成一个 Proxy 实例，target 参数表示所要拦截的目标对象，handler 参数也是一个对象，用来定制拦截行为。</p><p>下面是另一个拦截读取属性行为的例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var proxy = new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  get: <span class="keyword">function</span>(target, property) &#123;</span><br><span class="line">    <span class="built_in">return</span> 35;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.time // 35</span><br><span class="line">proxy.name // 35</span><br><span class="line">proxy.title // 35</span><br></pre></td></tr></table></figure><p>上面代码中，作为构造函数，Proxy 接受两个参数。第一个参数是所要代理的目标对象（上例是一个空对象），即如果没有 Proxy 的介入，操作原来要访问的就是这个对象；第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。比如，上面代码中，配置对象有一个 get 方法，用来拦截对目标对象属性的访问请求。get 方法的两个参数分别是目标对象和所要访问的属性。可以看到，由于拦截函数总是返回 35，所以访问任何属性都得到 35。</p><p>注意，要使得 Proxy 起作用，必须针对 Proxy 实例（上例是 proxy 对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。</p><p>如果 handler 没有设置任何拦截，那就等同于直接通向原对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var target = &#123;&#125;;</span><br><span class="line">var handler = &#123;&#125;;</span><br><span class="line">var proxy = new Proxy(target, handler);</span><br><span class="line">proxy.a = <span class="string">'b'</span>;</span><br><span class="line">target.a // <span class="string">"b"</span></span><br></pre></td></tr></table></figure><p>上面代码中，handler 是一个空对象，没有任何拦截效果，访问 handler 就等同于访问 target。</p><p>一个技巧是将 Proxy 对象，设置到 object.proxy 属性，从而可以在 object 对象上调用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var object = &#123; proxy: new Proxy(target, handler) &#125;;</span><br></pre></td></tr></table></figure><p>Proxy 实例也可以作为其他对象的原型对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var proxy = new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  get: <span class="keyword">function</span>(target, property) &#123;</span><br><span class="line">    <span class="built_in">return</span> 35;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> obj = Object.create(proxy);</span><br><span class="line">obj.time // 35</span><br></pre></td></tr></table></figure><p>上面代码中，proxy 对象是 obj 对象的原型，obj 对象本身并没有 time 属性，所以根据原型链，会在 proxy 对象上读取该属性，导致被拦截。</p><p>同一个拦截器函数，可以设置拦截多个操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var handler = &#123;</span><br><span class="line">  get: <span class="keyword">function</span>(target, name) &#123;</span><br><span class="line">    <span class="keyword">if</span> (name === <span class="string">'prototype'</span>) &#123;</span><br><span class="line">      <span class="built_in">return</span> Object.prototype;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">'Hello, '</span> + name;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  apply: <span class="keyword">function</span>(target, thisBinding, args) &#123;</span><br><span class="line">    <span class="built_in">return</span> args[0];</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  construct: <span class="keyword">function</span>(target, args) &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;value: args[1]&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var fproxy = new Proxy(<span class="keyword">function</span>(x, y) &#123;</span><br><span class="line">  <span class="built_in">return</span> x + y;</span><br><span class="line">&#125;, handler);</span><br><span class="line"></span><br><span class="line">fproxy(1, 2) // 1</span><br><span class="line">new fproxy(1,2) // &#123;value: 2&#125;</span><br><span class="line">fproxy.prototype === Object.prototype // <span class="literal">true</span></span><br><span class="line">fproxy.foo // <span class="string">"Hello, foo"</span></span><br></pre></td></tr></table></figure><p>下面是 Proxy 支持的拦截操作一览。</p><p>对于可以设置、但没有设置拦截的操作，则直接落在目标对象上，按照原先的方式产生结果。</p><h5 id="get-target-propKey-receiver"><a href="#get-target-propKey-receiver" class="headerlink" title="get(target, propKey, receiver)"></a>get(target, propKey, receiver)</h5><p>拦截对象属性的读取，比如 proxy.foo 和 proxy[‘foo’]。</p><p>最后一个参数 receiver 是一个对象，可选，参见下面 Reflect.get 的部分。</p><h5 id="set-target-propKey-value-receiver"><a href="#set-target-propKey-value-receiver" class="headerlink" title="set(target, propKey, value, receiver)"></a>set(target, propKey, value, receiver)</h5><p>拦截对象属性的设置，比如 proxy.foo = v 或 proxy[‘foo’] = v，返回一个布尔值。</p><h5 id="has-target-propKey"><a href="#has-target-propKey" class="headerlink" title="has(target, propKey)"></a>has(target, propKey)</h5><p>拦截 propKey in proxy 的操作，以及对象的 hasOwnProperty 方法，返回一个布尔值。</p><h5 id="deleteProperty-target-propKey"><a href="#deleteProperty-target-propKey" class="headerlink" title="deleteProperty(target, propKey)"></a>deleteProperty(target, propKey)</h5><p>拦截 delete proxy[propKey]的操作，返回一个布尔值。</p><h5 id="ownKeys-target"><a href="#ownKeys-target" class="headerlink" title="ownKeys(target)"></a>ownKeys(target)</h5><p>拦截 Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)，返回一个数组。该方法返回对象所有自身的属性，而 Object.keys()仅返回对象可遍历的属性。</p><h5 id="getOwnPropertyDescriptor-target-propKey"><a href="#getOwnPropertyDescriptor-target-propKey" class="headerlink" title="getOwnPropertyDescriptor(target, propKey)"></a>getOwnPropertyDescriptor(target, propKey)</h5><p>拦截 Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。</p><h5 id="defineProperty-target-propKey-propDesc"><a href="#defineProperty-target-propKey-propDesc" class="headerlink" title="defineProperty(target, propKey, propDesc)"></a>defineProperty(target, propKey, propDesc)</h5><p>拦截 Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。</p><h5 id="preventExtensions-target"><a href="#preventExtensions-target" class="headerlink" title="preventExtensions(target)"></a>preventExtensions(target)</h5><p>拦截 Object.preventExtensions(proxy)，返回一个布尔值。</p><h5 id="getPrototypeOf-target"><a href="#getPrototypeOf-target" class="headerlink" title="getPrototypeOf(target)"></a>getPrototypeOf(target)</h5><p>拦截 Object.getPrototypeOf(proxy)，返回一个对象。</p><h5 id="isExtensible-target"><a href="#isExtensible-target" class="headerlink" title="isExtensible(target)"></a>isExtensible(target)</h5><p>拦截 Object.isExtensible(proxy)，返回一个布尔值。</p><h5 id="setPrototypeOf-target-proto"><a href="#setPrototypeOf-target-proto" class="headerlink" title="setPrototypeOf(target, proto)"></a>setPrototypeOf(target, proto)</h5><p>拦截 Object.setPrototypeOf(proxy, proto)，返回一个布尔值。</p><p>如果目标对象是函数，那么还有两种额外操作可以拦截。</p><h5 id="apply-target-object-args"><a href="#apply-target-object-args" class="headerlink" title="apply(target, object, args)"></a>apply(target, object, args)</h5><p>拦截 Proxy 实例作为函数调用的操作，比如 proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。</p><h5 id="construct-target-args"><a href="#construct-target-args" class="headerlink" title="construct(target, args)"></a>construct(target, args)</h5><p>拦截 Proxy 实例作为构造函数调用的操作，比如 new proxy(…args)。</p><h4 id="Proxy-实例的方法"><a href="#Proxy-实例的方法" class="headerlink" title="Proxy 实例的方法"></a>Proxy 实例的方法</h4><p>下面是上面这些拦截方法的详细介绍。</p><h5 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h5><p>get 方法用于拦截某个属性的读取操作。上文已经有一个例子，下面是另一个拦截读取操作的例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">  name: <span class="string">"张三"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var proxy = new Proxy(person, &#123;</span><br><span class="line">  get: <span class="keyword">function</span>(target, property) &#123;</span><br><span class="line">    <span class="keyword">if</span> (property <span class="keyword">in</span> target) &#123;</span><br><span class="line">      <span class="built_in">return</span> target[property];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      throw new ReferenceError(<span class="string">"Property \""</span> + property + <span class="string">"\" does not exist."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.name // <span class="string">"张三"</span></span><br><span class="line">proxy.age // 抛出一个错误</span><br></pre></td></tr></table></figure><p>上面代码表示，如果访问目标对象不存在的属性，会抛出一个错误。如果没有这个拦截函数，访问不存在的属性，只会返回 undefined。</p><p>get 方法可以继承。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> proto = new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  get(target, propertyKey, receiver) &#123;</span><br><span class="line">    console.log(<span class="string">'GET '</span>+propertyKey);</span><br><span class="line">    <span class="built_in">return</span> target[propertyKey];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> obj = Object.create(proto);</span><br><span class="line">obj.xxx // <span class="string">"GET xxx"</span></span><br></pre></td></tr></table></figure><p>上面代码中，拦截操作定义在 Prototype 对象上面，所以如果读取 obj 对象继承的属性时，拦截会生效。</p><p>下面的例子使用 get 拦截，实现数组读取负数的索引。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> createArray(...elements) &#123;</span><br><span class="line">  <span class="built_in">let</span> handler = &#123;</span><br><span class="line">    get(target, propKey, receiver) &#123;</span><br><span class="line">      <span class="built_in">let</span> index = Number(propKey);</span><br><span class="line">      <span class="keyword">if</span> (index &lt; 0) &#123;</span><br><span class="line">        propKey = String(target.length + index);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">return</span> Reflect.get(target, propKey, receiver);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">let</span> target = [];</span><br><span class="line">  target.push(...elements);</span><br><span class="line">  <span class="built_in">return</span> new Proxy(target, handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> arr = createArray(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>);</span><br><span class="line">arr[-1] // c</span><br></pre></td></tr></table></figure><p>上面代码中，数组的位置参数是-1，就会输出数组的倒数最后一个成员。</p><p>利用 Proxy，可以将读取属性的操作（get），转变为执行某个函数，从而实现属性的链式操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var pipe = (<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  <span class="built_in">return</span> <span class="keyword">function</span> (value) &#123;</span><br><span class="line">    var funcStack = [];</span><br><span class="line">    var oproxy = new Proxy(&#123;&#125; , &#123;</span><br><span class="line">      get : <span class="keyword">function</span> (pipeObject, fnName) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fnName === <span class="string">'get'</span>) &#123;</span><br><span class="line">          <span class="built_in">return</span> funcStack.reduce(<span class="keyword">function</span> (val, fn) &#123;</span><br><span class="line">            <span class="built_in">return</span> fn(val);</span><br><span class="line">          &#125;,value);</span><br><span class="line">        &#125;</span><br><span class="line">        funcStack.push(window[fnName]);</span><br><span class="line">        <span class="built_in">return</span> oproxy;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> oproxy;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">var double = n =&gt; n * 2;</span><br><span class="line">var pow    = n =&gt; n * n;</span><br><span class="line">var reverseInt = n =&gt; n.toString().split(<span class="string">""</span>).reverse().join(<span class="string">""</span>) | 0;</span><br><span class="line"></span><br><span class="line">pipe(3).double.pow.reverseInt.get; // 63</span><br></pre></td></tr></table></figure><p>上面代码设置 Proxy 以后，达到了将函数名链式使用的效果。</p><p>下面的例子则是利用 get 拦截，实现一个生成各种 DOM 节点的通用函数 dom。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">const dom = new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  get(target, property) &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="keyword">function</span>(attrs = &#123;&#125;, ...children) &#123;</span><br><span class="line">      const el = document.createElement(property);</span><br><span class="line">      <span class="keyword">for</span> (<span class="built_in">let</span> prop of Object.keys(attrs)) &#123;</span><br><span class="line">        el.setAttribute(prop, attrs[prop]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="built_in">let</span> child of children) &#123;</span><br><span class="line">        <span class="keyword">if</span> (typeof child === <span class="string">'string'</span>) &#123;</span><br><span class="line">          child = document.createTextNode(child);</span><br><span class="line">        &#125;</span><br><span class="line">        el.appendChild(child);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">return</span> el;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const el = dom.div(&#123;&#125;,</span><br><span class="line">  <span class="string">'Hello, my name is '</span>,</span><br><span class="line">  dom.a(&#123;href: <span class="string">'//example.com'</span>&#125;, <span class="string">'Mark'</span>),</span><br><span class="line">  <span class="string">'. I like:'</span>,</span><br><span class="line">  dom.ul(&#123;&#125;,</span><br><span class="line">    dom.li(&#123;&#125;, <span class="string">'The web'</span>),</span><br><span class="line">    dom.li(&#123;&#125;, <span class="string">'Food'</span>),</span><br><span class="line">    dom.li(&#123;&#125;, <span class="string">'…actually that\'</span>s it<span class="string">')</span></span><br><span class="line"><span class="string">  )</span></span><br><span class="line"><span class="string">);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">document.body.appendChild(el);</span></span><br></pre></td></tr></table></figure><h5 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h5><p>set 方法用来拦截某个属性的赋值操作。</p><p>假定 Person 对象有一个 age 属性，该属性应该是一个不大于 200 的整数，那么可以使用 Proxy 保证 age 的属性值符合要求。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> validator = &#123;</span><br><span class="line">  <span class="built_in">set</span>: <span class="keyword">function</span>(obj, prop, value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">'age'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!Number.isInteger(value)) &#123;</span><br><span class="line">        throw new TypeError(<span class="string">'The age is not an integer'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (value &gt; 200) &#123;</span><br><span class="line">        throw new RangeError(<span class="string">'The age seems invalid'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 对于age以外的属性，直接保存</span><br><span class="line">    obj[prop] = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> person = new Proxy(&#123;&#125;, validator);</span><br><span class="line"></span><br><span class="line">person.age = 100;</span><br><span class="line"></span><br><span class="line">person.age // 100</span><br><span class="line">person.age = <span class="string">'young'</span> // 报错</span><br><span class="line">person.age = 300 // 报错</span><br></pre></td></tr></table></figure><p>上面代码中，由于设置了存值函数 set，任何不符合要求的 age 属性赋值，都会抛出一个错误。利用 set 方法，还可以数据绑定，即每当对象发生变化时，会自动更新 DOM。</p><p>有时，我们会在对象上面设置内部属性，属性名的第一个字符使用下划线开头，表示这些属性不应该被外部使用。结合 get 和 set 方法，就可以做到防止这些内部属性被外部读写。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var handler = &#123;</span><br><span class="line">  get (target, key) &#123;</span><br><span class="line">    invariant(key, <span class="string">'get'</span>);</span><br><span class="line">    <span class="built_in">return</span> target[key];</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">set</span> (target, key, value) &#123;</span><br><span class="line">    invariant(key, <span class="string">'set'</span>);</span><br><span class="line">    target[key] = value;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> invariant (key, action) &#123;</span><br><span class="line">  <span class="keyword">if</span> (key[0] === <span class="string">'_'</span>) &#123;</span><br><span class="line">    throw new Error(`Invalid attempt to <span class="variable">$&#123;action&#125;</span> private <span class="string">"<span class="variable">$&#123;key&#125;</span>"</span> property`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var target = &#123;&#125;;</span><br><span class="line">var proxy = new Proxy(target, handler);</span><br><span class="line">proxy._prop</span><br><span class="line">// Error: Invalid attempt to get private <span class="string">"_prop"</span> property</span><br><span class="line">proxy._prop = <span class="string">'c'</span></span><br><span class="line">// Error: Invalid attempt to <span class="built_in">set</span> private <span class="string">"_prop"</span> property</span><br></pre></td></tr></table></figure><p>上面代码中，只要读写的属性名的第一个字符是下划线，一律抛错，从而达到禁止读写内部属性的目的。</p><h5 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h5><p>apply 方法拦截函数的调用、call 和 apply 操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var handler = &#123;</span><br><span class="line">  apply (target, ctx, args) &#123;</span><br><span class="line">    <span class="built_in">return</span> Reflect.apply(...arguments);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>apply 方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（this）和目标对象的参数数组。</p><p>下面是一个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var target = <span class="function"><span class="title">function</span></span> () &#123; <span class="built_in">return</span> <span class="string">'I am the target'</span>; &#125;;</span><br><span class="line">var handler = &#123;</span><br><span class="line">  apply: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">'I am the proxy'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var p = new Proxy(target, handler);</span><br><span class="line"></span><br><span class="line">p()</span><br><span class="line">// <span class="string">"I am the proxy"</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量 p 是 Proxy 的实例，当它作为函数调用时（p()），就会被 apply 方法拦截，返回一个字符串。</p><p>下面是另外一个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var twice = &#123;</span><br><span class="line">  apply (target, ctx, args) &#123;</span><br><span class="line">    <span class="built_in">return</span> Reflect.apply(...arguments) * 2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> sum (left, right) &#123;</span><br><span class="line">  <span class="built_in">return</span> left + right;</span><br><span class="line">&#125;;</span><br><span class="line">var proxy = new Proxy(sum, twice);</span><br><span class="line">proxy(1, 2) // 6</span><br><span class="line">proxy.call(null, 5, 6) // 22</span><br><span class="line">proxy.apply(null, [7, 8]) // 30</span><br></pre></td></tr></table></figure><p>上面代码中，每当执行 proxy 函数（直接调用或 call 和 apply 调用），就会被 apply 方法拦截。</p><p>另外，直接调用 Reflect.apply 方法，也会被拦截。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Reflect.apply(proxy, null, [9, 10]) // 38</span><br></pre></td></tr></table></figure><h5 id="has"><a href="#has" class="headerlink" title="has()"></a>has()</h5><p>has 方法用来拦截 HasProperty 操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是 in 运算符。</p><p>下面的例子使用 has 方法隐藏某些属性，不被 in 运算符发现。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var handler = &#123;</span><br><span class="line">  has (target, key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key[0] === <span class="string">'_'</span>) &#123;</span><br><span class="line">      <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> key <span class="keyword">in</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var target = &#123; _prop: <span class="string">'foo'</span>, prop: <span class="string">'foo'</span> &#125;;</span><br><span class="line">var proxy = new Proxy(target, handler);</span><br><span class="line"><span class="string">'_prop'</span> <span class="keyword">in</span> proxy // <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>上面代码中，如果原对象的属性名的第一个字符是下划线，proxy.has 就会返回 false，从而不会被 in 运算符发现。</p><p>如果原对象不可配置或者禁止扩展，这时 has 拦截会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; a: 10 &#125;;</span><br><span class="line">Object.preventExtensions(obj);</span><br><span class="line">var p = new Proxy(obj, &#123;</span><br><span class="line">  has: <span class="keyword">function</span>(target, prop) &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="string">'a'</span> <span class="keyword">in</span> p // TypeError is thrown</span><br></pre></td></tr></table></figure><p>上面代码中，obj 对象禁止扩展，结果使用 has 拦截就会报错。</p><p>值得注意的是，has 方法拦截的是 HasProperty 操作，而不是 HasOwnProperty 操作，即 has 方法不判断一个属性是对象自身的属性，还是继承的属性。</p><p>另外，虽然 for…in 循环也用到了 in 运算符，但是 has 拦截对 for…in 循环不生效。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> stu1 = &#123;name: <span class="string">'张三'</span>, score: 59&#125;;</span><br><span class="line"><span class="built_in">let</span> stu2 = &#123;name: <span class="string">'李四'</span>, score: 99&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> handler = &#123;</span><br><span class="line">  has(target, prop) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">'score'</span> &amp;&amp; target[prop] &lt; 60) &#123;</span><br><span class="line">      console.log(`<span class="variable">$&#123;target.name&#125;</span> 不及格`);</span><br><span class="line">      <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> prop <span class="keyword">in</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> oproxy1 = new Proxy(stu1, handler);</span><br><span class="line"><span class="built_in">let</span> oproxy2 = new Proxy(stu2, handler);</span><br><span class="line"></span><br><span class="line"><span class="string">'score'</span> <span class="keyword">in</span> oproxy1</span><br><span class="line">// 张三 不及格</span><br><span class="line">// <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="string">'score'</span> <span class="keyword">in</span> oproxy2</span><br><span class="line">// <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> a <span class="keyword">in</span> oproxy1) &#123;</span><br><span class="line">  console.log(oproxy1[a]);</span><br><span class="line">&#125;</span><br><span class="line">// 张三</span><br><span class="line">// 59</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> b <span class="keyword">in</span> oproxy2) &#123;</span><br><span class="line">  console.log(oproxy2[b]);</span><br><span class="line">&#125;</span><br><span class="line">// 李四</span><br><span class="line">// 99</span><br></pre></td></tr></table></figure><p>上面代码中，has 拦截只对 in 循环生效，对 for…in 循环不生效，导致不符合要求的属性没有被排除在 for…in 循环之外。</p><h5 id="construct"><a href="#construct" class="headerlink" title="construct()"></a>construct()</h5><p>construct 方法用于拦截 new 命令，下面是拦截对象的写法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var handler = &#123;</span><br><span class="line">  construct (target, args, newTarget) &#123;</span><br><span class="line">    <span class="built_in">return</span> new target(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>construct 方法可以接受两个参数。</p><pre>target: 目标对象args：构建函数的参数对象</pre><p>下面是一个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var p = new Proxy(<span class="function"><span class="title">function</span></span>() &#123;&#125;, &#123;</span><br><span class="line">  construct: <span class="keyword">function</span>(target, args) &#123;</span><br><span class="line">    console.log(<span class="string">'called: '</span> + args.join(<span class="string">', '</span>));</span><br><span class="line">    <span class="built_in">return</span> &#123; value: args[0] * 10 &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">new p(1).value</span><br><span class="line">// <span class="string">"called: 1"</span></span><br><span class="line">// 10</span><br></pre></td></tr></table></figure><p>construct 方法返回的必须是一个对象，否则会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var p = new Proxy(<span class="function"><span class="title">function</span></span>() &#123;&#125;, &#123;</span><br><span class="line">  construct: <span class="keyword">function</span>(target, argumentsList) &#123;</span><br><span class="line">    <span class="built_in">return</span> 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">new p() // 报错</span><br></pre></td></tr></table></figure><h5 id="deleteProperty"><a href="#deleteProperty" class="headerlink" title="deleteProperty()"></a>deleteProperty()</h5><p>deleteProperty 方法用于拦截 delete 操作，如果这个方法抛出错误或者返回 false，当前属性就无法被 delete 命令删除。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var handler = &#123;</span><br><span class="line">  deleteProperty (target, key) &#123;</span><br><span class="line">    invariant(key, <span class="string">'delete'</span>);</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> invariant (key, action) &#123;</span><br><span class="line">  <span class="keyword">if</span> (key[0] === <span class="string">'_'</span>) &#123;</span><br><span class="line">    throw new Error(`Invalid attempt to <span class="variable">$&#123;action&#125;</span> private <span class="string">"<span class="variable">$&#123;key&#125;</span>"</span> property`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var target = &#123; _prop: <span class="string">'foo'</span> &#125;;</span><br><span class="line">var proxy = new Proxy(target, handler);</span><br><span class="line">delete proxy._prop</span><br><span class="line">// Error: Invalid attempt to delete private <span class="string">"_prop"</span> property</span><br></pre></td></tr></table></figure><p>上面代码中，deleteProperty 方法拦截了 delete 操作符，删除第一个字符为下划线的属性会报错。</p><h5 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty()"></a>defineProperty()</h5><p>defineProperty 方法拦截了 Object.defineProperty 操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var handler = &#123;</span><br><span class="line">  defineProperty (target, key, descriptor) &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var target = &#123;&#125;;</span><br><span class="line">var proxy = new Proxy(target, handler);</span><br><span class="line">proxy.foo = <span class="string">'bar'</span></span><br><span class="line">// TypeError: proxy defineProperty handler returned <span class="literal">false</span> <span class="keyword">for</span> property <span class="string">'"foo"'</span></span><br></pre></td></tr></table></figure><p>上面代码中，defineProperty 方法返回 false，导致添加新属性会抛出错误。</p><h5 id="getOwnPropertyDescriptor"><a href="#getOwnPropertyDescriptor" class="headerlink" title="getOwnPropertyDescriptor()"></a>getOwnPropertyDescriptor()</h5><p>getOwnPropertyDescriptor 方法拦截 Object.getOwnPropertyDescriptor，返回一个属性描述对象或者 undefined。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var handler = &#123;</span><br><span class="line">  getOwnPropertyDescriptor (target, key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key[0] === <span class="string">'_'</span>) &#123;</span><br><span class="line">      <span class="built_in">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> Object.getOwnPropertyDescriptor(target, key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var target = &#123; _foo: <span class="string">'bar'</span>, baz: <span class="string">'tar'</span> &#125;;</span><br><span class="line">var proxy = new Proxy(target, handler);</span><br><span class="line">Object.getOwnPropertyDescriptor(proxy, <span class="string">'wat'</span>)</span><br><span class="line">// undefined</span><br><span class="line">Object.getOwnPropertyDescriptor(proxy, <span class="string">'_foo'</span>)</span><br><span class="line">// undefined</span><br><span class="line">Object.getOwnPropertyDescriptor(proxy, <span class="string">'baz'</span>)</span><br><span class="line">// &#123; value: <span class="string">'tar'</span>, writable: <span class="literal">true</span>, enumerable: <span class="literal">true</span>, configurable: <span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure><p>上面代码中，handler.getOwnPropertyDescriptor 方法对于第一个字符为下划线的属性名会返回 undefined。</p><h5 id="getPrototypeOf"><a href="#getPrototypeOf" class="headerlink" title="getPrototypeOf()"></a>getPrototypeOf()</h5><p>getPrototypeOf 方法主要用来拦截 Object.getPrototypeOf()运算符，以及其他一些操作。</p><pre>Object.prototype.__proto__Object.prototype.isPrototypeOf()Object.getPrototypeOf()Reflect.getPrototypeOf()instanceof运算符</pre><p>下面是一个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var proto = &#123;&#125;;</span><br><span class="line">var p = new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  getPrototypeOf(target) &#123;</span><br><span class="line">    <span class="built_in">return</span> proto;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Object.getPrototypeOf(p) === proto // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>上面代码中，getPrototypeOf 方法拦截 Object.getPrototypeOf()，返回 proto 对象。</p><h5 id="isExtensible"><a href="#isExtensible" class="headerlink" title="isExtensible()"></a>isExtensible()</h5><p>isExtensible 方法拦截 Object.isExtensible 操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var p = new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  isExtensible: <span class="keyword">function</span>(target) &#123;</span><br><span class="line">    console.log(<span class="string">"called"</span>);</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Object.isExtensible(p)</span><br><span class="line">// <span class="string">"called"</span></span><br><span class="line">// <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>上面代码设置了 isExtensible 方法，在调用 Object.isExtensible 时会输出 called。</p><p>这个方法有一个强限制，如果不能满足下面的条件，就会抛出错误。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.isExtensible(proxy) === Object.isExtensible(target)</span><br></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var p = new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  isExtensible: <span class="keyword">function</span>(target) &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Object.isExtensible(p) // 报错</span><br></pre></td></tr></table></figure><h5 id="ownKeys"><a href="#ownKeys" class="headerlink" title="ownKeys()"></a>ownKeys()</h5><p>ownKeys 方法用来拦截 Object.keys()操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> target = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> handler = &#123;</span><br><span class="line">  ownKeys(target) &#123;</span><br><span class="line">    <span class="built_in">return</span> [<span class="string">'hello'</span>, <span class="string">'world'</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> proxy = new Proxy(target, handler);</span><br><span class="line"></span><br><span class="line">Object.keys(proxy)</span><br><span class="line">// [ <span class="string">'hello'</span>, <span class="string">'world'</span> ]</span><br></pre></td></tr></table></figure><p>上面代码拦截了对于 target 对象的 Object.keys()操作，返回预先设定的数组。</p><p>下面的例子是拦截第一个字符为下划线的属性名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> target = &#123;</span><br><span class="line">  _bar: <span class="string">'foo'</span>,</span><br><span class="line">  _prop: <span class="string">'bar'</span>,</span><br><span class="line">  prop: <span class="string">'baz'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> handler = &#123;</span><br><span class="line">  ownKeys (target) &#123;</span><br><span class="line">    <span class="built_in">return</span> Reflect.ownKeys(target).filter(key =&gt; key[0] !== <span class="string">'_'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> proxy = new Proxy(target, handler);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> key of Object.keys(proxy)) &#123;</span><br><span class="line">  console.log(target[key]);</span><br><span class="line">&#125;</span><br><span class="line">// <span class="string">"baz"</span></span><br></pre></td></tr></table></figure><h5 id="preventExtensions"><a href="#preventExtensions" class="headerlink" title="preventExtensions()"></a>preventExtensions()</h5><p>preventExtensions 方法拦截 Object.preventExtensions()。该方法必须返回一个布尔值。</p><p>这个方法有一个限制，只有当 Object.isExtensible(proxy)为 false（即不可扩展）时，proxy.preventExtensions 才能返回 true，否则会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var p = new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  preventExtensions: <span class="keyword">function</span>(target) &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Object.preventExtensions(p) // 报错</span><br></pre></td></tr></table></figure><p>上面代码中，proxy.preventExtensions 方法返回 true，但这时 Object.isExtensible(proxy)会返回 true，因此报错。</p><p>为了防止出现这个问题，通常要在 proxy.preventExtensions 方法里面，调用一次 Object.preventExtensions。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var p = new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  preventExtensions: <span class="keyword">function</span>(target) &#123;</span><br><span class="line">    console.log(<span class="string">"called"</span>);</span><br><span class="line">    Object.preventExtensions(target);</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Object.preventExtensions(p)</span><br><span class="line">// <span class="string">"called"</span></span><br><span class="line">// <span class="literal">true</span></span><br></pre></td></tr></table></figure><h5 id="setPrototypeOf"><a href="#setPrototypeOf" class="headerlink" title="setPrototypeOf()"></a>setPrototypeOf()</h5><p>setPrototypeOf 方法主要用来拦截 Object.setPrototypeOf 方法。</p><p>下面是一个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var handler = &#123;</span><br><span class="line">  setPrototypeOf (target, proto) &#123;</span><br><span class="line">    throw new Error(<span class="string">'Changing the prototype is forbidden'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var proto = &#123;&#125;;</span><br><span class="line">var target = <span class="function"><span class="title">function</span></span> () &#123;&#125;;</span><br><span class="line">var proxy = new Proxy(target, handler);</span><br><span class="line">proxy.setPrototypeOf(proxy, proto);</span><br><span class="line">// Error: Changing the prototype is forbidden</span><br></pre></td></tr></table></figure><p>上面代码中，只要修改 target 的原型对象，就会报错。</p><h5 id="Proxy-revocable"><a href="#Proxy-revocable" class="headerlink" title="Proxy.revocable()"></a>Proxy.revocable()</h5><p>Proxy.revocable 方法返回一个可取消的 Proxy 实例。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> target = &#123;&#125;;</span><br><span class="line"><span class="built_in">let</span> handler = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> &#123;proxy, revoke&#125; = Proxy.revocable(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.foo = 123;</span><br><span class="line">proxy.foo // 123</span><br><span class="line"></span><br><span class="line">revoke();</span><br><span class="line">proxy.foo // TypeError: Revoked</span><br></pre></td></tr></table></figure><p>Proxy.revocable 方法返回一个对象，该对象的 proxy 属性是 Proxy 实例，revoke 属性是一个函数，可以取消 Proxy 实例。上面代码中，当执行 revoke 函数之后，再访问 Proxy 实例，就会抛出一个错误。</p><h4 id="this-问题"><a href="#this-问题" class="headerlink" title="this 问题"></a>this 问题</h4><p>虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的 this 关键字会指向 Proxy 代理。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const target = &#123;</span><br><span class="line">  m: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(this === proxy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const handler = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">const proxy = new Proxy(target, handler);</span><br><span class="line"></span><br><span class="line">target.m() // <span class="literal">false</span></span><br><span class="line">proxy.m()  // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>上面代码中，一旦 proxy 代理 target.m，后者内部的 this 就是指向 proxy，而不是 target。</p><p>下面是一个例子，由于 this 指向的变化，导致 Proxy 无法代理目标对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const _name = new WeakMap();</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    _name.set(this, name);</span><br><span class="line">  &#125;</span><br><span class="line">  get <span class="function"><span class="title">name</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> _name.get(this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const jane = new Person(<span class="string">'Jane'</span>);</span><br><span class="line">jane.name // <span class="string">'Jane'</span></span><br><span class="line"></span><br><span class="line">const proxy = new Proxy(jane, &#123;&#125;);</span><br><span class="line">proxy.name // undefined</span><br></pre></td></tr></table></figure><p>上面代码中，目标对象 jane 的 name 属性，实际保存在外部 WeakMap 对象_name 上面，通过 this 键区分。由于通过 proxy.name 访问时，this 指向 proxy，导致无法取到值，所以返回 undefined。</p><p>此外，有些原生对象的内部属性，只有通过正确的 this 才能拿到，所以 Proxy 也无法代理这些原生对象的属性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const target = new Date();</span><br><span class="line">const handler = &#123;&#125;;</span><br><span class="line">const proxy = new Proxy(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.getDate();</span><br><span class="line">// TypeError: this is not a Date object.</span><br></pre></td></tr></table></figure><p>上面代码中，getDate 方法只能在 Date 对象实例上面拿到，如果 this 不是 Date 对象实例就会报错。这时，this 绑定原始对象，就可以解决这个问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const target = new Date(<span class="string">'2015-01-01'</span>);</span><br><span class="line">const handler = &#123;</span><br><span class="line">  get(target, prop) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">'getDate'</span>) &#123;</span><br><span class="line">      <span class="built_in">return</span> target.getDate.bind(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> Reflect.get(target, prop);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const proxy = new Proxy(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.getDate() // 1</span><br></pre></td></tr></table></figure><h4 id="Reflect-概述"><a href="#Reflect-概述" class="headerlink" title="Reflect 概述"></a>Reflect 概述</h4><p>Reflect 对象与 Proxy 对象一样，也是 ES6 为了操作对象而提供的新 API。Reflect 对象的设计目的有这样几个。</p><p>（1） 将 Object 对象的一些明显属于语言内部的方法（比如 Object.defineProperty），放到 Reflect 对象上。现阶段，某些方法同时在 Object 和 Reflect 对象上部署，未来的新方法将只部署在 Reflect 对象上。</p><p>（2） 修改某些 Object 方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而 Reflect.defineProperty(obj, name, desc)则会返回 false。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 老写法</span><br><span class="line">try &#123;</span><br><span class="line">  Object.defineProperty(target, property, attributes);</span><br><span class="line">  // success</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">  // failure</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 新写法</span><br><span class="line"><span class="keyword">if</span> (Reflect.defineProperty(target, property, attributes)) &#123;</span><br><span class="line">  // success</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  // failure</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3） 让 Object 操作都变成函数行为。某些 Object 操作是命令式，比如 name in obj 和 delete obj[name]，而 Reflect.has(obj, name)和 Reflect.deleteProperty(obj, name)让它们变成了函数行为。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 老写法</span><br><span class="line"><span class="string">'assign'</span> <span class="keyword">in</span> Object // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">// 新写法</span><br><span class="line">Reflect.has(Object, <span class="string">'assign'</span>) // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>（4）Reflect 对象的方法与 Proxy 对象的方法一一对应，只要是 Proxy 对象的方法，就能在 Reflect 对象上找到对应的方法。这就让 Proxy 对象可以方便地调用对应的 Reflect 方法，完成默认行为，作为修改行为的基础。也就是说，不管 Proxy 怎么修改默认行为，你总可以在 Reflect 上获取默认行为。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Proxy(target, &#123;</span><br><span class="line">  <span class="built_in">set</span>: <span class="keyword">function</span>(target, name, value, receiver) &#123;</span><br><span class="line">    var success = Reflect.set(target,name, value, receiver);</span><br><span class="line">    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">      <span class="built_in">log</span>(<span class="string">'property '</span> + name + <span class="string">' on '</span> + target + <span class="string">' set to '</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> success;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，Proxy 方法拦截 target 对象的属性赋值行为。它采用 Reflect.set 方法将值赋值给对象的属性，然后再部署额外的功能。</p><p>下面是另一个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var loggedObj = new Proxy(obj, &#123;</span><br><span class="line">  get(target, name) &#123;</span><br><span class="line">    console.log(<span class="string">'get'</span>, target, name);</span><br><span class="line">    <span class="built_in">return</span> Reflect.get(target, name);</span><br><span class="line">  &#125;,</span><br><span class="line">  deleteProperty(target, name) &#123;</span><br><span class="line">    console.log(<span class="string">'delete'</span> + name);</span><br><span class="line">    <span class="built_in">return</span> Reflect.deleteProperty(target, name);</span><br><span class="line">  &#125;,</span><br><span class="line">  has(target, name) &#123;</span><br><span class="line">    console.log(<span class="string">'has'</span> + name);</span><br><span class="line">    <span class="built_in">return</span> Reflect.has(target, name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，每一个 Proxy 对象的拦截操作（get、delete、has），内部都调用对应的 Reflect 方法，保证原生行为能够正常执行。添加的工作，就是将每一个操作输出一行日志。</p><p>有了 Reflect 对象以后，很多操作会更易读。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 老写法</span><br><span class="line">Function.prototype.apply.call(Math.floor, undefined, [1.75]) // 1</span><br><span class="line"></span><br><span class="line">// 新写法</span><br><span class="line">Reflect.apply(Math.floor, undefined, [1.75]) // 1</span><br></pre></td></tr></table></figure><h4 id="Reflect-对象的方法"><a href="#Reflect-对象的方法" class="headerlink" title="Reflect 对象的方法"></a>Reflect 对象的方法</h4><p>Reflect 对象的方法清单如下，共 13 个。</p><pre>Reflect.apply(target,thisArg,args)Reflect.construct(target,args)Reflect.get(target,name,receiver)Reflect.set(target,name,value,receiver)Reflect.defineProperty(target,name,desc)Reflect.deleteProperty(target,name)Reflect.has(target,name)Reflect.ownKeys(target)Reflect.isExtensible(target)Reflect.preventExtensions(target)Reflect.getOwnPropertyDescriptor(target, name)Reflect.getPrototypeOf(target)Reflect.setPrototypeOf(target, prototype)</pre><p>上面这些方法的作用，大部分与 Object 对象的同名方法的作用都是相同的，而且它与 Proxy 对象的方法是一一对应的。下面是对其中几个方法的解释。</p><h5 id="Reflect-get-target-name-receiver"><a href="#Reflect-get-target-name-receiver" class="headerlink" title="Reflect.get(target, name, receiver)"></a>Reflect.get(target, name, receiver)</h5><p>查找并返回 target 对象的 name 属性，如果没有该属性，则返回 undefined。</p><p>如果 name 属性部署了读取函数，则读取函数的 this 绑定 receiver。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  get <span class="function"><span class="title">foo</span></span>() &#123; <span class="built_in">return</span> this.bar(); &#125;,</span><br><span class="line">  bar: <span class="function"><span class="title">function</span></span>() &#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 下面语句会让 this.bar()</span><br><span class="line">// 变成调用 wrapper.bar()</span><br><span class="line">Reflect.get(obj, <span class="string">"foo"</span>, wrapper);</span><br></pre></td></tr></table></figure><h5 id="Reflect-set-target-name-value-receiver"><a href="#Reflect-set-target-name-value-receiver" class="headerlink" title="Reflect.set(target, name, value, receiver)"></a>Reflect.set(target, name, value, receiver)</h5><p>设置 target 对象的 name 属性等于 value。如果 name 属性设置了赋值函数，则赋值函数的 this 绑定 receiver。</p><h5 id="Reflect-has-obj-name"><a href="#Reflect-has-obj-name" class="headerlink" title="Reflect.has(obj, name)"></a>Reflect.has(obj, name)</h5><p>等同于 name in obj。</p><h5 id="Reflect-deleteProperty-obj-name"><a href="#Reflect-deleteProperty-obj-name" class="headerlink" title="Reflect.deleteProperty(obj, name)"></a>Reflect.deleteProperty(obj, name)</h5><p>等同于 delete obj[name]。</p><h5 id="Reflect-construct-target-args"><a href="#Reflect-construct-target-args" class="headerlink" title="Reflect.construct(target, args)"></a>Reflect.construct(target, args)</h5><p>等同于 new target(…args)，这提供了一种不使用 new，来调用构造函数的方法。</p><h5 id="Reflect-getPrototypeOf-obj"><a href="#Reflect-getPrototypeOf-obj" class="headerlink" title="Reflect.getPrototypeOf(obj)"></a>Reflect.getPrototypeOf(obj)</h5><p>读取对象的<strong>proto</strong>属性，对应 Object.getPrototypeOf(obj)。</p><h5 id="Reflect-setPrototypeOf-obj-newProto"><a href="#Reflect-setPrototypeOf-obj-newProto" class="headerlink" title="Reflect.setPrototypeOf(obj, newProto)"></a>Reflect.setPrototypeOf(obj, newProto)</h5><p>设置对象的<strong>proto</strong>属性，对应 Object.setPrototypeOf(obj, newProto)。</p><h5 id="Reflect-apply-fun-thisArg-args"><a href="#Reflect-apply-fun-thisArg-args" class="headerlink" title="Reflect.apply(fun,thisArg,args)"></a>Reflect.apply(fun,thisArg,args)</h5><p>等同于 Function.prototype.apply.call(fun,thisArg,args)。一般来说，如果要绑定一个函数的 this 对象，可以这样写 fn.apply(obj, args)，但是如果函数定义了自己的 apply 方法，就只能写成 Function.prototype.apply.call(fn, obj, args)，采用 Reflect 对象可以简化这种操作。</p><p>另外，需要注意的是，Reflect.set()、Reflect.defineProperty()、Reflect.freeze()、Reflect.seal()和 Reflect.preventExtensions()返回一个布尔值，表示操作是否成功。它们对应的 Object 方法，失败时都会抛出错误。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 失败时抛出错误</span><br><span class="line">Object.defineProperty(obj, name, desc);</span><br><span class="line">// 失败时返回<span class="literal">false</span></span><br><span class="line">Reflect.defineProperty(obj, name, desc);</span><br></pre></td></tr></table></figure><p>上面代码中，Reflect.defineProperty 方法的作用与 Object.defineProperty 是一样的，都是为对象定义一个属性。但是，Reflect.defineProperty 方法失败时，不会抛出错误，只会返回 false。</p><h4 id="实例：使用-Proxy-实现观察者模式"><a href="#实例：使用-Proxy-实现观察者模式" class="headerlink" title="实例：使用 Proxy 实现观察者模式"></a>实例：使用 Proxy 实现观察者模式</h4><p>观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const person = observable(&#123;</span><br><span class="line">  name: <span class="string">'张三'</span>,</span><br><span class="line">  age: 20</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">print</span></span>() &#123;</span><br><span class="line">  console.log(`<span class="variable">$&#123;person.name&#125;</span>, <span class="variable">$&#123;person.age&#125;</span>`)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">observe(<span class="built_in">print</span>);</span><br><span class="line">person.name = <span class="string">'李四'</span>;</span><br><span class="line">// 输出</span><br><span class="line">// 李四, 20</span><br></pre></td></tr></table></figure><p>上面代码中，数据对象 person 是观察目标，函数 print 是观察者。一旦数据对象发生变化，print 就会自动执行。</p><p>下面，使用 Proxy 写一个观察者模式的最简单实现，即实现 observable 和 observe 这两个函数。思路是 observable 函数返回一个原始对象的 Proxy 代理，拦截赋值操作，触发充当观察者的各个函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const queuedObservers = new Set();</span><br><span class="line"></span><br><span class="line">const observe = fn =&gt; queuedObservers.add(fn);</span><br><span class="line">const observable = obj =&gt; new Proxy(obj, &#123;<span class="built_in">set</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="built_in">set</span>(target, key, value, receiver) &#123;</span><br><span class="line">  const result = Reflect.set(target, key, value, receiver);</span><br><span class="line">  queuedObservers.forEach(observer =&gt; observer());</span><br><span class="line">  <span class="built_in">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，先定义了一个 Set 集合，所有观察者函数都放进这个集合。然后，observable 函数返回原始对象的代理，拦截赋值操作。拦截函数 set 之中，会自动执行所有观察者。</p>]]></content>
      
      
      <categories>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6_Set_Map</title>
      <link href="/2019/02/27/es6-Set-Map/"/>
      <url>/2019/02/27/es6-Set-Map/</url>
      
        <content type="html"><![CDATA[<h3 id="ES6-set-和-map-数据结构"><a href="#ES6-set-和-map-数据结构" class="headerlink" title="ES6 set 和 map 数据结构"></a>ES6 set 和 map 数据结构</h3><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><h5 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h5><p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p><p>Set 本身是一个构造函数，用来生成 Set 数据结构。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var s = new Set();</span><br><span class="line"></span><br><span class="line">[2, 3, 5, 4, 5, 2, 2].map(x =&gt; s.add(x));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i of s) &#123;</span><br><span class="line">  console.log(i);</span><br><span class="line">&#125;</span><br><span class="line">// 2 3 5 4</span><br></pre></td></tr></table></figure><p>上面代码通过 add 方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。</p><p>Set 函数可以接受一个数组（或类似数组的对象）作为参数，用来初始化。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 例一</span><br><span class="line">var <span class="built_in">set</span> = new Set([1, 2, 3, 4, 4]);</span><br><span class="line">[...<span class="built_in">set</span>]</span><br><span class="line">// [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">// 例二</span><br><span class="line">var items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);</span><br><span class="line">items.size // 5</span><br><span class="line"></span><br><span class="line">// 例三</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">divs</span></span> () &#123;</span><br><span class="line">  <span class="built_in">return</span> [...document.querySelectorAll(<span class="string">'div'</span>)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var <span class="built_in">set</span> = new Set(divs());</span><br><span class="line">set.size // 56</span><br><span class="line"></span><br><span class="line">// 类似于</span><br><span class="line">divs().forEach(div =&gt; set.add(div));</span><br><span class="line">set.size // 56</span><br></pre></td></tr></table></figure><p>上面代码中，例一和例二都是 Set 函数接受数组作为参数，例三是接受类似数组的对象作为参数。</p><p>上面代码中，也展示了一种去除数组重复成员的方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 去除数组的重复成员</span><br><span class="line">[...new Set(array)]</span><br></pre></td></tr></table></figure><p>向 Set 加入值的时候，不会发生类型转换，所以 5 和”5”是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value equality”，它类似于精确相等运算符（===），主要的区别是 NaN 等于自身，而精确相等运算符认为 NaN 不等于自身。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> <span class="built_in">set</span> = new Set();</span><br><span class="line"><span class="built_in">let</span> a = NaN;</span><br><span class="line"><span class="built_in">let</span> b = NaN;</span><br><span class="line">set.add(a);</span><br><span class="line">set.add(b);</span><br><span class="line"><span class="built_in">set</span> // Set &#123;NaN&#125;</span><br></pre></td></tr></table></figure><p>上面代码向 Set 实例添加了两个 NaN，但是只能加入一个。这表明，在 Set 内部，两个 NaN 是相等。</p><p>另外，两个对象总是不相等的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> <span class="built_in">set</span> = new Set();</span><br><span class="line"></span><br><span class="line">set.add(&#123;&#125;);</span><br><span class="line">set.size // 1</span><br><span class="line"></span><br><span class="line">set.add(&#123;&#125;);</span><br><span class="line">set.size // 2</span><br></pre></td></tr></table></figure><p>上面代码表示，由于两个空对象不相等，所以它们被视为两个值。</p><h5 id="Set-实例的属性和方法"><a href="#Set-实例的属性和方法" class="headerlink" title="Set 实例的属性和方法"></a>Set 实例的属性和方法</h5><p>Set 结构的实例有以下属性。</p><p>1.Set.prototype.constructor：构造函数，默认就是 Set 函数。<br>2.Set.prototype.size：返回 Set 实例的成员总数。<br>Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。</p><p>1.add(value)：添加某个值，返回 Set 结构本身。<br>2.delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。<br>3.has(value)：返回一个布尔值，表示该值是否为 Set 的成员。<br>4.clear()：清除所有成员，没有返回值。<br>上面这些属性和方法的实例如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">s.add(1).add(2).add(2);</span><br><span class="line">// 注意2被加入了两次</span><br><span class="line"></span><br><span class="line">s.size // 2</span><br><span class="line"></span><br><span class="line">s.has(1) // <span class="literal">true</span></span><br><span class="line">s.has(2) // <span class="literal">true</span></span><br><span class="line">s.has(3) // <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">s.delete(2);</span><br><span class="line">s.has(2) // <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>下面是一个对比，看看在判断是否包括一个键上面，Object 结构和 Set 结构的写法不同。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 对象的写法</span><br><span class="line">var properties = &#123;</span><br><span class="line">  <span class="string">'width'</span>: 1,</span><br><span class="line">  <span class="string">'height'</span>: 1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (properties[someName]) &#123;</span><br><span class="line">  // <span class="keyword">do</span> something</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Set的写法</span><br><span class="line">var properties = new Set();</span><br><span class="line"></span><br><span class="line">properties.add(<span class="string">'width'</span>);</span><br><span class="line">properties.add(<span class="string">'height'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (properties.has(someName)) &#123;</span><br><span class="line">  // <span class="keyword">do</span> something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Array.from 方法可以将 Set 结构转为数组。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var items = new Set([1, 2, 3, 4, 5]);</span><br><span class="line">var array = Array.from(items);</span><br></pre></td></tr></table></figure><p>这就提供了去除数组重复成员的另一种方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> dedupe(array) &#123;</span><br><span class="line">  <span class="built_in">return</span> Array.from(new Set(array));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dedupe([1, 1, 2, 3]) // [1, 2, 3]</span><br></pre></td></tr></table></figure><h5 id="遍历操作"><a href="#遍历操作" class="headerlink" title="遍历操作"></a>遍历操作</h5><p>Set 结构的实例有四个遍历方法，可以用于遍历成员。</p><p>1.keys()：返回键名的遍历器<br>2.values()：返回键值的遍历器<br>3.entries()：返回键值对的遍历器<br>4.forEach()：使用回调函数遍历每个成员<br>需要特别指出的是，Set 的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用。</p><h6 id="keys-，values-，entries"><a href="#keys-，values-，entries" class="headerlink" title="keys()，values()，entries()"></a>keys()，values()，entries()</h6><p>key 方法、value 方法、entries 方法返回的都是遍历器对象（详见《Iterator 对象》一章）。由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以 key 方法和 value 方法的行为完全一致。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> <span class="built_in">set</span> = new Set([<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> item of set.keys()) &#123;</span><br><span class="line">  console.log(item);</span><br><span class="line">&#125;</span><br><span class="line">// red</span><br><span class="line">// green</span><br><span class="line">// blue</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> item of set.values()) &#123;</span><br><span class="line">  console.log(item);</span><br><span class="line">&#125;</span><br><span class="line">// red</span><br><span class="line">// green</span><br><span class="line">// blue</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> item of set.entries()) &#123;</span><br><span class="line">  console.log(item);</span><br><span class="line">&#125;</span><br><span class="line">// [<span class="string">"red"</span>, <span class="string">"red"</span>]</span><br><span class="line">// [<span class="string">"green"</span>, <span class="string">"green"</span>]</span><br><span class="line">// [<span class="string">"blue"</span>, <span class="string">"blue"</span>]</span><br></pre></td></tr></table></figure><p>上面代码中，entries 方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。</p><p>Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的 values 方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set.prototype[Symbol.iterator] === Set.prototype.values</span><br><span class="line">// <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>这意味着，可以省略 values 方法，直接用 for…of 循环遍历 Set。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> <span class="built_in">set</span> = new Set([<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> x of <span class="built_in">set</span>) &#123;</span><br><span class="line">  console.log(x);</span><br><span class="line">&#125;</span><br><span class="line">// red</span><br><span class="line">// green</span><br><span class="line">// blue</span><br></pre></td></tr></table></figure><h6 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h6><p>Set 结构的实例的 forEach 方法，用于对每个成员执行某种操作，没有返回值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> <span class="built_in">set</span> = new Set([1, 2, 3]);</span><br><span class="line">set.forEach((value, key) =&gt; console.log(value * 2) )</span><br><span class="line">// 2</span><br><span class="line">// 4</span><br><span class="line">// 6</span><br></pre></td></tr></table></figure><p>上面代码说明，forEach 方法的参数就是一个处理函数。该函数的参数依次为键值、键名、集合本身（上例省略了该参数）。另外，forEach 方法还可以有第二个参数，表示绑定的 this 对象。</p><h6 id="遍历的应用"><a href="#遍历的应用" class="headerlink" title="遍历的应用"></a>遍历的应用</h6><p>扩展运算符（…）内部使用 for…of 循环，所以也可以用于 Set 结构。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> <span class="built_in">set</span> = new Set([<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]);</span><br><span class="line"><span class="built_in">let</span> arr = [...<span class="built_in">set</span>];</span><br><span class="line">// [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br></pre></td></tr></table></figure><p>扩展运算符和 Set 结构相结合，就可以去除数组的重复成员。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arr = [3, 5, 2, 2, 5, 5];</span><br><span class="line"><span class="built_in">let</span> unique = [...new Set(arr)];</span><br><span class="line">// [3, 5, 2]</span><br></pre></td></tr></table></figure><p>而且，数组的 map 和 filter 方法也可以用于 Set 了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> <span class="built_in">set</span> = new Set([1, 2, 3]);</span><br><span class="line"><span class="built_in">set</span> = new Set([...<span class="built_in">set</span>].map(x =&gt; x * 2));</span><br><span class="line">// 返回Set结构：&#123;2, 4, 6&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> <span class="built_in">set</span> = new Set([1, 2, 3, 4, 5]);</span><br><span class="line"><span class="built_in">set</span> = new Set([...<span class="built_in">set</span>].filter(x =&gt; (x % 2) == 0));</span><br><span class="line">// 返回Set结构：&#123;2, 4&#125;</span><br></pre></td></tr></table></figure><p>因此使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> a = new Set([1, 2, 3]);</span><br><span class="line"><span class="built_in">let</span> b = new Set([4, 3, 2]);</span><br><span class="line"></span><br><span class="line">// 并集</span><br><span class="line"><span class="built_in">let</span> union = new Set([...a, ...b]);</span><br><span class="line">// Set &#123;1, 2, 3, 4&#125;</span><br><span class="line"></span><br><span class="line">// 交集</span><br><span class="line"><span class="built_in">let</span> intersect = new Set([...a].filter(x =&gt; b.has(x)));</span><br><span class="line">// <span class="built_in">set</span> &#123;2, 3&#125;</span><br><span class="line"></span><br><span class="line">// 差集</span><br><span class="line"><span class="built_in">let</span> difference = new Set([...a].filter(x =&gt; !b.has(x)));</span><br><span class="line">// Set &#123;1&#125;</span><br></pre></td></tr></table></figure><p>如果想在遍历操作中，同步改变原来的 Set 结构，目前没有直接的方法，但有两种变通方法。一种是利用原 Set 结构映射出一个新的结构，然后赋值给原来的 Set 结构；另一种是利用 Array.from 方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 方法一</span><br><span class="line"><span class="built_in">let</span> <span class="built_in">set</span> = new Set([1, 2, 3]);</span><br><span class="line"><span class="built_in">set</span> = new Set([...<span class="built_in">set</span>].map(val =&gt; val * 2));</span><br><span class="line">// <span class="built_in">set</span>的值是2, 4, 6</span><br><span class="line"></span><br><span class="line">// 方法二</span><br><span class="line"><span class="built_in">let</span> <span class="built_in">set</span> = new Set([1, 2, 3]);</span><br><span class="line"><span class="built_in">set</span> = new Set(Array.from(<span class="built_in">set</span>, val =&gt; val * 2));</span><br><span class="line">// <span class="built_in">set</span>的值是2, 4, 6</span><br></pre></td></tr></table></figure><p>上面代码提供了两种方法，直接在遍历操作中改变原来的 Set 结构。</p><h5 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h5><p>WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。</p><p>首先，WeakSet 的成员只能是对象，而不能是其他类型的值。</p><p>其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。这个特点意味着，无法引用 WeakSet 的成员，因此 WeakSet 是不可遍历的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var ws = new WeakSet();</span><br><span class="line">ws.add(1)</span><br><span class="line">// TypeError: Invalid value used <span class="keyword">in</span> weak <span class="built_in">set</span></span><br><span class="line">ws.add(Symbol())</span><br><span class="line">// TypeError: invalid value used <span class="keyword">in</span> weak <span class="built_in">set</span></span><br></pre></td></tr></table></figure><p>上面代码试图向 WeakSet 添加一个数值和 Symbol 值，结果报错，因为 WeakSet 只能放置对象。</p><p>WeakSet 是一个构造函数，可以使用 new 命令，创建 WeakSet 数据结构。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var ws = new WeakSet();</span><br></pre></td></tr></table></figure><p>作为构造函数，WeakSet 可以接受一个数组或类似数组的对象作为参数。（实际上，任何具有 iterable 接口的对象，都可以作为 WeakSet 的参数。）该数组的所有成员，都会自动成为 WeakSet 实例对象的成员。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = [[1,2], [3,4]];</span><br><span class="line">var ws = new WeakSet(a);</span><br></pre></td></tr></table></figure><p>上面代码中，a 是一个数组，它有两个成员，也都是数组。将 a 作为 WeakSet 构造函数的参数，a 的成员会自动成为 WeakSet 的成员。</p><p>注意，是 a 数组的成员成为 WeakSet 的成员，而不是 a 数组本身。这意味着，数组的成员只能是对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var b = [3, 4];</span><br><span class="line">var ws = new WeakSet(b);</span><br><span class="line">// Uncaught TypeError: Invalid value used <span class="keyword">in</span> weak <span class="built_in">set</span>(…)</span><br></pre></td></tr></table></figure><p>上面代码中，数组 b 的成员不是对象，加入 WeaKSet 就会报错。</p><p>WeakSet 结构有以下三个方法。</p><p>1.WeakSet.prototype.add(value)：向 WeakSet 实例添加一个新成员。<br>2.WeakSet.prototype.delete(value)：清除 WeakSet 实例的指定成员。<br>3.WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。<br>下面是一个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var ws = new WeakSet();</span><br><span class="line">var obj = &#123;&#125;;</span><br><span class="line">var foo = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">ws.add(window);</span><br><span class="line">ws.add(obj);</span><br><span class="line"></span><br><span class="line">ws.has(window); // <span class="literal">true</span></span><br><span class="line">ws.has(foo);    // <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">ws.delete(window);</span><br><span class="line">ws.has(window);    // <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>WeakSet 没有 size 属性，没有办法遍历它的成员。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ws.size // undefined</span><br><span class="line">ws.forEach // undefined</span><br><span class="line"></span><br><span class="line">ws.forEach(<span class="keyword">function</span>(item)&#123; console.log(<span class="string">'WeakSet has '</span> + item)&#125;)</span><br><span class="line">// TypeError: undefined is not a <span class="keyword">function</span></span><br></pre></td></tr></table></figure><p>上面代码试图获取 size 和 forEach 属性，结果都不能成功。</p><p>WeakSet 不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。</p><p>下面是 WeakSet 的另一个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const foos = new WeakSet()</span><br><span class="line">class Foo &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    foos.add(this)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">method</span></span> () &#123;</span><br><span class="line">    <span class="keyword">if</span> (!foos.has(this)) &#123;</span><br><span class="line">      throw new TypeError(<span class="string">'Foo.prototype.method 只能在Foo的实例上调用！'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码保证了 Foo 的实例方法，只能在 Foo 的实例上调用。这里使用 WeakSet 的好处是，foos 对实例的引用，不会被计入内存回收机制，所以删除实例的时候，不用考虑 foos，也不会出现内存泄漏。</p><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><h5 id="Map-结构的目的和基本用法"><a href="#Map-结构的目的和基本用法" class="headerlink" title="Map 结构的目的和基本用法"></a>Map 结构的目的和基本用法</h5><p>JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var data = &#123;&#125;;</span><br><span class="line">var element = document.getElementById(<span class="string">'myDiv'</span>);</span><br><span class="line"></span><br><span class="line">data[element] = <span class="string">'metadata'</span>;</span><br><span class="line">data[<span class="string">'[object HTMLDivElement]'</span>] // <span class="string">"metadata"</span></span><br></pre></td></tr></table></figure><p>上面代码原意是将一个 DOM 节点作为对象 data 的键，但是由于对象只接受字符串作为键名，所以 element 被自动转为字符串[object HTMLDivElement]。</p><p>为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var m = new Map();</span><br><span class="line">var o = &#123;p: <span class="string">'Hello World'</span>&#125;;</span><br><span class="line"></span><br><span class="line">m.set(o, <span class="string">'content'</span>)</span><br><span class="line">m.get(o) // <span class="string">"content"</span></span><br><span class="line"></span><br><span class="line">m.has(o) // <span class="literal">true</span></span><br><span class="line">m.delete(o) // <span class="literal">true</span></span><br><span class="line">m.has(o) // <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>上面代码使用 set 方法，将对象 o 当作 m 的一个键，然后又使用 get 方法读取这个键，接着使用 delete 方法删除了这个键。</p><p>作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var map = new Map([</span><br><span class="line">  [<span class="string">'name'</span>, <span class="string">'张三'</span>],</span><br><span class="line">  [<span class="string">'title'</span>, <span class="string">'Author'</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">map.size // 2</span><br><span class="line">map.has(<span class="string">'name'</span>) // <span class="literal">true</span></span><br><span class="line">map.get(<span class="string">'name'</span>) // <span class="string">"张三"</span></span><br><span class="line">map.has(<span class="string">'title'</span>) // <span class="literal">true</span></span><br><span class="line">map.get(<span class="string">'title'</span>) // <span class="string">"Author"</span></span><br></pre></td></tr></table></figure><p>上面代码在新建 Map 实例时，就指定了两个键 name 和 title。</p><p>Map 构造函数接受数组作为参数，实际上执行的是下面的算法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var items = [</span><br><span class="line">  [<span class="string">'name'</span>, <span class="string">'张三'</span>],</span><br><span class="line">  [<span class="string">'title'</span>, <span class="string">'Author'</span>]</span><br><span class="line">];</span><br><span class="line">var map = new Map();</span><br><span class="line">items.forEach(([key, value]) =&gt; map.set(key, value));</span><br></pre></td></tr></table></figure><p>下面的例子中，字符串 true 和布尔值 true 是两个不同的键。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var m = new Map([</span><br><span class="line">  [<span class="literal">true</span>, <span class="string">'foo'</span>],</span><br><span class="line">  [<span class="string">'true'</span>, <span class="string">'bar'</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">m.get(<span class="literal">true</span>) // <span class="string">'foo'</span></span><br><span class="line">m.get(<span class="string">'true'</span>) // <span class="string">'bar'</span></span><br></pre></td></tr></table></figure><p>如果对同一个键多次赋值，后面的值将覆盖前面的值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> map = new Map();</span><br><span class="line"></span><br><span class="line">map</span><br><span class="line">.<span class="built_in">set</span>(1, <span class="string">'aaa'</span>)</span><br><span class="line">.<span class="built_in">set</span>(1, <span class="string">'bbb'</span>);</span><br><span class="line"></span><br><span class="line">map.get(1) // <span class="string">"bbb"</span></span><br></pre></td></tr></table></figure><p>上面代码对键 1 连续赋值两次，后一次的值覆盖前一次的值。</p><p>如果读取一个未知的键，则返回 undefined。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new Map().get(<span class="string">'asfddfsasadf'</span>)</span><br><span class="line">// undefined</span><br></pre></td></tr></table></figure><p>注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var map = new Map();</span><br><span class="line"></span><br><span class="line">map.set([<span class="string">'a'</span>], 555);</span><br><span class="line">map.get([<span class="string">'a'</span>]) // undefined</span><br></pre></td></tr></table></figure><p>上面代码的 set 和 get 方法，表面是针对同一个键，但实际上这是两个值，内存地址是不一样的，因此 get 方法无法读取该键，返回 undefined。</p><p>同理，同样的值的两个实例，在 Map 结构中被视为两个键。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var map = new Map();</span><br><span class="line"></span><br><span class="line">var k1 = [<span class="string">'a'</span>];</span><br><span class="line">var k2 = [<span class="string">'a'</span>];</span><br><span class="line"></span><br><span class="line">map</span><br><span class="line">.<span class="built_in">set</span>(k1, 111)</span><br><span class="line">.<span class="built_in">set</span>(k2, 222);</span><br><span class="line"></span><br><span class="line">map.get(k1) // 111</span><br><span class="line">map.get(k2) // 222</span><br></pre></td></tr></table></figure><p>上面代码中，变量 k1 和 k2 的值是一样的，但是它们在 Map 结构中被视为两个键。</p><p>由上可知，Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。</p><p>如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，包括 0 和-0。另外，虽然 NaN 不严格相等于自身，但 Map 将其视为同一个键。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> map = new Map();</span><br><span class="line"></span><br><span class="line">map.set(NaN, 123);</span><br><span class="line">map.get(NaN) // 123</span><br><span class="line"></span><br><span class="line">map.set(-0, 123);</span><br><span class="line">map.get(+0) // 123</span><br></pre></td></tr></table></figure><h5 id="实例的属性和操作方法"><a href="#实例的属性和操作方法" class="headerlink" title="实例的属性和操作方法"></a>实例的属性和操作方法</h5><p>Map 结构的实例有以下属性和操作方法。</p><h6 id="size-属性"><a href="#size-属性" class="headerlink" title="size 属性"></a>size 属性</h6><p>size 属性返回 Map 结构的成员总数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> map = new Map();</span><br><span class="line">map.set(<span class="string">'foo'</span>, <span class="literal">true</span>);</span><br><span class="line">map.set(<span class="string">'bar'</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">map.size // 2</span><br></pre></td></tr></table></figure><h6 id="set-key-value"><a href="#set-key-value" class="headerlink" title="set(key, value)"></a>set(key, value)</h6><p>set 方法设置 key 所对应的键值，然后返回整个 Map 结构。如果 key 已经有值，则键值会被更新，否则就新生成该键。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var m = new Map();</span><br><span class="line"></span><br><span class="line">m.set(<span class="string">"edition"</span>, 6)        // 键是字符串</span><br><span class="line">m.set(262, <span class="string">"standard"</span>)     // 键是数值</span><br><span class="line">m.set(undefined, <span class="string">"nah"</span>)    // 键是undefined</span><br></pre></td></tr></table></figure><p>set 方法返回的是 Map 本身，因此可以采用链式写法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> map = new Map()</span><br><span class="line">  .<span class="built_in">set</span>(1, <span class="string">'a'</span>)</span><br><span class="line">  .<span class="built_in">set</span>(2, <span class="string">'b'</span>)</span><br><span class="line">  .<span class="built_in">set</span>(3, <span class="string">'c'</span>);</span><br></pre></td></tr></table></figure><h6 id="get-key"><a href="#get-key" class="headerlink" title="get(key)"></a>get(key)</h6><p>get 方法读取 key 对应的键值，如果找不到 key，返回 undefined。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var m = new Map();</span><br><span class="line"></span><br><span class="line">var hello = <span class="function"><span class="title">function</span></span>() &#123;console.log(<span class="string">"hello"</span>);&#125;</span><br><span class="line">m.set(hello, <span class="string">"Hello ES6!"</span>) // 键是函数</span><br><span class="line"></span><br><span class="line">m.get(hello)  // Hello ES6!</span><br></pre></td></tr></table></figure><h6 id="has-key"><a href="#has-key" class="headerlink" title="has(key)"></a>has(key)</h6><p>has 方法返回一个布尔值，表示某个键是否在 Map 数据结构中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var m = new Map();</span><br><span class="line"></span><br><span class="line">m.set(<span class="string">"edition"</span>, 6);</span><br><span class="line">m.set(262, <span class="string">"standard"</span>);</span><br><span class="line">m.set(undefined, <span class="string">"nah"</span>);</span><br><span class="line"></span><br><span class="line">m.has(<span class="string">"edition"</span>)     // <span class="literal">true</span></span><br><span class="line">m.has(<span class="string">"years"</span>)       // <span class="literal">false</span></span><br><span class="line">m.has(262)           // <span class="literal">true</span></span><br><span class="line">m.has(undefined)     // <span class="literal">true</span></span><br></pre></td></tr></table></figure><h6 id="delete-key"><a href="#delete-key" class="headerlink" title="delete(key)"></a>delete(key)</h6><p>delete 方法删除某个键，返回 true。如果删除失败，返回 false。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var m = new Map();</span><br><span class="line">m.set(undefined, <span class="string">"nah"</span>);</span><br><span class="line">m.has(undefined)     // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">m.delete(undefined)</span><br><span class="line">m.has(undefined)       // <span class="literal">false</span></span><br></pre></td></tr></table></figure><h6 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h6><p>clear 方法清除所有成员，没有返回值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> map = new Map();</span><br><span class="line">map.set(<span class="string">'foo'</span>, <span class="literal">true</span>);</span><br><span class="line">map.set(<span class="string">'bar'</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">map.size // 2</span><br><span class="line">map.clear()</span><br><span class="line">map.size // 0</span><br></pre></td></tr></table></figure><h5 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h5><p>Map 原生提供三个遍历器生成函数和一个遍历方法。</p><p>1.keys()：返回键名的遍历器。<br>2.values()：返回键值的遍历器。<br>3.entries()：返回所有成员的遍历器。<br>4.forEach()：遍历 Map 的所有成员。<br>需要特别注意的是，Map 的遍历顺序就是插入顺序。</p><p>下面是使用实例。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> map = new Map([</span><br><span class="line">  [<span class="string">'F'</span>, <span class="string">'no'</span>],</span><br><span class="line">  [<span class="string">'T'</span>,  <span class="string">'yes'</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> key of map.keys()) &#123;</span><br><span class="line">  console.log(key);</span><br><span class="line">&#125;</span><br><span class="line">// <span class="string">"F"</span></span><br><span class="line">// <span class="string">"T"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> value of map.values()) &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;</span><br><span class="line">// <span class="string">"no"</span></span><br><span class="line">// <span class="string">"yes"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> item of map.entries()) &#123;</span><br><span class="line">  console.log(item[0], item[1]);</span><br><span class="line">&#125;</span><br><span class="line">// <span class="string">"F"</span> <span class="string">"no"</span></span><br><span class="line">// <span class="string">"T"</span> <span class="string">"yes"</span></span><br><span class="line"></span><br><span class="line">// 或者</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> [key, value] of map.entries()) &#123;</span><br><span class="line">  console.log(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 等同于使用map.entries()</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> [key, value] of map) &#123;</span><br><span class="line">  console.log(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码最后的那个例子，表示 Map 结构的默认遍历器接口（Symbol.iterator 属性），就是 entries 方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map[Symbol.iterator] === map.entries</span><br><span class="line">// <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>Map 结构转为数组结构，比较快速的方法是结合使用扩展运算符（…）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> map = new Map([</span><br><span class="line">  [1, <span class="string">'one'</span>],</span><br><span class="line">  [2, <span class="string">'two'</span>],</span><br><span class="line">  [3, <span class="string">'three'</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">[...map.keys()]</span><br><span class="line">// [1, 2, 3]</span><br><span class="line"></span><br><span class="line">[...map.values()]</span><br><span class="line">// [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>]</span><br><span class="line"></span><br><span class="line">[...map.entries()]</span><br><span class="line">// [[1,<span class="string">'one'</span>], [2, <span class="string">'two'</span>], [3, <span class="string">'three'</span>]]</span><br><span class="line"></span><br><span class="line">[...map]</span><br><span class="line">// [[1,<span class="string">'one'</span>], [2, <span class="string">'two'</span>], [3, <span class="string">'three'</span>]]</span><br></pre></td></tr></table></figure><p>结合数组的 map 方法、filter 方法，可以实现 Map 的遍历和过滤（Map 本身没有 map 和 filter 方法）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> map0 = new Map()</span><br><span class="line">  .<span class="built_in">set</span>(1, <span class="string">'a'</span>)</span><br><span class="line">  .<span class="built_in">set</span>(2, <span class="string">'b'</span>)</span><br><span class="line">  .<span class="built_in">set</span>(3, <span class="string">'c'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> map1 = new Map(</span><br><span class="line">  [...map0].filter(([k, v]) =&gt; k &lt; 3)</span><br><span class="line">);</span><br><span class="line">// 产生Map结构 &#123;1 =&gt; <span class="string">'a'</span>, 2 =&gt; <span class="string">'b'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> map2 = new Map(</span><br><span class="line">  [...map0].map(([k, v]) =&gt; [k * 2, <span class="string">'_'</span> + v])</span><br><span class="line">    );</span><br><span class="line">// 产生Map结构 &#123;2 =&gt; <span class="string">'_a'</span>, 4 =&gt; <span class="string">'_b'</span>, 6 =&gt; <span class="string">'_c'</span>&#125;</span><br></pre></td></tr></table></figure><p>此外，Map 还有一个 forEach 方法，与数组的 forEach 方法类似，也可以实现遍历。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map.forEach(<span class="keyword">function</span>(value, key, map) &#123;</span><br><span class="line">  console.log(<span class="string">"Key: %s, Value: %s"</span>, key, value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>forEach 方法还可以接受第二个参数，用来绑定 this。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var reporter = &#123;</span><br><span class="line">  report: <span class="keyword">function</span>(key, value) &#123;</span><br><span class="line">    console.log(<span class="string">"Key: %s, Value: %s"</span>, key, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">map.forEach(<span class="keyword">function</span>(value, key, map) &#123;</span><br><span class="line">  this.report(key, value);</span><br><span class="line">&#125;, reporter);</span><br></pre></td></tr></table></figure><p>上面代码中，forEach 方法的回调函数的 this，就指向 reporter。</p><h5 id="与其他数据结构的互相转换"><a href="#与其他数据结构的互相转换" class="headerlink" title="与其他数据结构的互相转换"></a>与其他数据结构的互相转换</h5><h6 id="Map-转为数组"><a href="#Map-转为数组" class="headerlink" title="Map 转为数组"></a>Map 转为数组</h6><p>前面已经提过，Map 转为数组最方便的方法，就是使用扩展运算符（…）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> myMap = new Map().<span class="built_in">set</span>(<span class="literal">true</span>, 7).<span class="built_in">set</span>(&#123;foo: 3&#125;, [<span class="string">'abc'</span>]);</span><br><span class="line">[...myMap]</span><br><span class="line">// [ [ <span class="literal">true</span>, 7 ], [ &#123; foo: 3 &#125;, [ <span class="string">'abc'</span> ] ] ]</span><br></pre></td></tr></table></figure><h6 id="数组转为-Map"><a href="#数组转为-Map" class="headerlink" title="数组转为 Map"></a>数组转为 Map</h6><p>将数组转入 Map 构造函数，就可以转为 Map。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new Map([[<span class="literal">true</span>, 7], [&#123;foo: 3&#125;, [<span class="string">'abc'</span>]]])</span><br><span class="line">// Map &#123;<span class="literal">true</span> =&gt; 7, Object &#123;foo: 3&#125; =&gt; [<span class="string">'abc'</span>]&#125;</span><br></pre></td></tr></table></figure><h6 id="Map-转为对象"><a href="#Map-转为对象" class="headerlink" title="Map 转为对象"></a>Map 转为对象</h6><p>如果所有 Map 的键都是字符串，它可以转为对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> strMapToObj(strMap) &#123;</span><br><span class="line">  <span class="built_in">let</span> obj = Object.create(null);</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">let</span> [k,v] of strMap) &#123;</span><br><span class="line">    obj[k] = v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> myMap = new Map().<span class="built_in">set</span>(<span class="string">'yes'</span>, <span class="literal">true</span>).<span class="built_in">set</span>(<span class="string">'no'</span>, <span class="literal">false</span>);</span><br><span class="line">strMapToObj(myMap)</span><br><span class="line">// &#123; yes: <span class="literal">true</span>, no: <span class="literal">false</span> &#125;</span><br></pre></td></tr></table></figure><h6 id="对象转为-Map"><a href="#对象转为-Map" class="headerlink" title="对象转为 Map"></a>对象转为 Map</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> objToStrMap(obj) &#123;</span><br><span class="line">  <span class="built_in">let</span> strMap = new Map();</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">let</span> k of Object.keys(obj)) &#123;</span><br><span class="line">    strMap.set(k, obj[k]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> strMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">objToStrMap(&#123;yes: <span class="literal">true</span>, no: <span class="literal">false</span>&#125;)</span><br><span class="line">// [ [ <span class="string">'yes'</span>, <span class="literal">true</span> ], [ <span class="string">'no'</span>, <span class="literal">false</span> ] ]</span><br></pre></td></tr></table></figure><h6 id="Map-转为-JSON"><a href="#Map-转为-JSON" class="headerlink" title="Map 转为 JSON"></a>Map 转为 JSON</h6><p>Map 转为 JSON 要区分两种情况。一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> strMapToJson(strMap) &#123;</span><br><span class="line">  <span class="built_in">return</span> JSON.stringify(strMapToObj(strMap));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> myMap = new Map().<span class="built_in">set</span>(<span class="string">'yes'</span>, <span class="literal">true</span>).<span class="built_in">set</span>(<span class="string">'no'</span>, <span class="literal">false</span>);</span><br><span class="line">strMapToJson(myMap)</span><br><span class="line">// <span class="string">'&#123;"yes":true,"no":false&#125;'</span></span><br></pre></td></tr></table></figure><p>另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> mapToArrayJson(map) &#123;</span><br><span class="line">  <span class="built_in">return</span> JSON.stringify([...map]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> myMap = new Map().<span class="built_in">set</span>(<span class="literal">true</span>, 7).<span class="built_in">set</span>(&#123;foo: 3&#125;, [<span class="string">'abc'</span>]);</span><br><span class="line">mapToArrayJson(myMap)</span><br><span class="line">// <span class="string">'[[true,7],[&#123;"foo":3&#125;,["abc"]]]'</span></span><br></pre></td></tr></table></figure><h6 id="JSON-转为-Map"><a href="#JSON-转为-Map" class="headerlink" title="JSON 转为 Map"></a>JSON 转为 Map</h6><p>JSON 转为 Map，正常情况下，所有键名都是字符串。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> jsonToStrMap(jsonStr) &#123;</span><br><span class="line">  <span class="built_in">return</span> objToStrMap(JSON.parse(jsonStr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jsonToStrMap(<span class="string">'&#123;"yes":true,"no":false&#125;'</span>)</span><br><span class="line">// Map &#123;<span class="string">'yes'</span> =&gt; <span class="literal">true</span>, <span class="string">'no'</span> =&gt; <span class="literal">false</span>&#125;</span><br></pre></td></tr></table></figure><p>但是，有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是数组转为 JSON 的逆操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> jsonToMap(jsonStr) &#123;</span><br><span class="line">  <span class="built_in">return</span> new Map(JSON.parse(jsonStr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jsonToMap(<span class="string">'[[true,7],[&#123;"foo":3&#125;,["abc"]]]'</span>)</span><br><span class="line">// Map &#123;<span class="literal">true</span> =&gt; 7, Object &#123;foo: 3&#125; =&gt; [<span class="string">'abc'</span>]&#125;</span><br></pre></td></tr></table></figure><h5 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h5><p>WeakMap 结构与 Map 结构基本类似，唯一的区别是它只接受对象作为键名（null 除外），不接受其他类型的值作为键名，而且键名所指向的对象，不计入垃圾回收机制。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var map = new WeakMap()</span><br><span class="line">map.set(1, 2)</span><br><span class="line">// TypeError: 1 is not an object!</span><br><span class="line">map.set(Symbol(), 2)</span><br><span class="line">// TypeError: Invalid value used as weak map key</span><br></pre></td></tr></table></figure><p>上面代码中，如果将 1 和 Symbol 作为 WeakMap 的键名，都会报错。</p><p>WeakMap 的设计目的在于，键名是对象的弱引用（垃圾回收机制不将该引用考虑在内），所以其所对应的对象可能会被自动回收。当对象被回收后，WeakMap 自动移除对应的键值对。典型应用是，一个对应 DOM 元素的 WeakMap 结构，当某个 DOM 元素被清除，其所对应的 WeakMap 记录就会自动被移除。基本上，WeakMap 的专用场合就是，它的键所对应的对象，可能会在将来消失。WeakMap 结构有助于防止内存泄漏。</p><p>下面是 WeakMap 结构的一个例子，可以看到用法上与 Map 几乎一样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var wm = new WeakMap();</span><br><span class="line">var element = document.querySelector(<span class="string">".element"</span>);</span><br><span class="line"></span><br><span class="line">wm.set(element, <span class="string">"Original"</span>);</span><br><span class="line">wm.get(element) // <span class="string">"Original"</span></span><br><span class="line"></span><br><span class="line">element.parentNode.removeChild(element);</span><br><span class="line">element = null;</span><br><span class="line">wm.get(element) // undefined</span><br></pre></td></tr></table></figure><p>上面代码中，变量 wm 是一个 WeakMap 实例，我们将一个 DOM 节点 element 作为键名，然后销毁这个节点，element 对应的键就自动消失了，再引用这个键名就返回 undefined。</p><p>WeakMap 与 Map 在 API 上的区别主要是两个，一是没有遍历操作（即没有 key()、values()和 entries()方法），也没有 size 属性；二是无法清空，即不支持 clear 方法。这与 WeakMap 的键不被计入引用、被垃圾回收机制忽略有关。因此，WeakMap 只有四个方法可用：get()、set()、has()、delete()。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var wm = new WeakMap();</span><br><span class="line"></span><br><span class="line">wm.size</span><br><span class="line">// undefined</span><br><span class="line"></span><br><span class="line">wm.forEach</span><br><span class="line">// undefined</span><br></pre></td></tr></table></figure><p>前文说过，WeakMap 应用的典型场合就是 DOM 节点作为键名。下面是一个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> myElement = document.getElementById(<span class="string">'logo'</span>);</span><br><span class="line"><span class="built_in">let</span> myWeakmap = new WeakMap();</span><br><span class="line"></span><br><span class="line">myWeakmap.set(myElement, &#123;timesClicked: 0&#125;);</span><br><span class="line"></span><br><span class="line">myElement.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  <span class="built_in">let</span> logoData = myWeakmap.get(myElement);</span><br><span class="line">  logoData.timesClicked++;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，myElement 是一个 DOM 节点，每当发生 click 事件，就更新一下状态。我们将这个状态作为键值放在 WeakMap 里，对应的键名就是 myElement。一旦这个 DOM 节点删除，该状态就会自动消失，不存在内存泄漏风险。</p><p>WeakMap 的另一个用处是部署私有属性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> _counter = new WeakMap();</span><br><span class="line"><span class="built_in">let</span> _action = new WeakMap();</span><br><span class="line"></span><br><span class="line">class Countdown &#123;</span><br><span class="line">  constructor(counter, action) &#123;</span><br><span class="line">    _counter.set(this, counter);</span><br><span class="line">    _action.set(this, action);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">dec</span></span>() &#123;</span><br><span class="line">    <span class="built_in">let</span> counter = _counter.get(this);</span><br><span class="line">    <span class="keyword">if</span> (counter &lt; 1) <span class="built_in">return</span>;</span><br><span class="line">    counter--;</span><br><span class="line">    _counter.set(this, counter);</span><br><span class="line">    <span class="keyword">if</span> (counter === 0) &#123;</span><br><span class="line">      _action.get(this)();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> c = new Countdown(2, () =&gt; console.log(<span class="string">'DONE'</span>));</span><br><span class="line"></span><br><span class="line">c.dec()</span><br><span class="line">c.dec()</span><br><span class="line">// DONE</span><br></pre></td></tr></table></figure><p>上面代码中，Countdown 类的两个内部属性_counter 和_action，是实例的弱引用，所以如果删除实例，它们也就随之消失，不会造成内存泄漏。</p>]]></content>
      
      
      <categories>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6_Symbol</title>
      <link href="/2019/02/15/es6-Symbol/"/>
      <url>/2019/02/15/es6-Symbol/</url>
      
        <content type="html"><![CDATA[<h3 id="ES6-symbol"><a href="#ES6-symbol" class="headerlink" title="ES6 symbol"></a>ES6 symbol</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入 Symbol 的原因。</p><p>ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：Undefined、Null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</p><p>Symbol 值通过 Symbol 函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> s = Symbol();</span><br><span class="line"></span><br><span class="line">typeof s</span><br><span class="line">// <span class="string">"symbol"</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量 s 就是一个独一无二的值。typeof 运算符的结果，表明变量 s 是 Symbol 数据类型，而不是字符串之类的其他类型。</p><p>注意，Symbol 函数前不能使用 new 命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。</p><p>Symbol 函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var s1 = Symbol(<span class="string">'foo'</span>);</span><br><span class="line">var s2 = Symbol(<span class="string">'bar'</span>);</span><br><span class="line"></span><br><span class="line">s1 // Symbol(foo)</span><br><span class="line">s2 // Symbol(bar)</span><br><span class="line"></span><br><span class="line">s1.toString() // <span class="string">"Symbol(foo)"</span></span><br><span class="line">s2.toString() // <span class="string">"Symbol(bar)"</span></span><br></pre></td></tr></table></figure><p>上面代码中，s1 和 s2 是两个 Symbol 值。如果不加参数，它们在控制台的输出都是 Symbol()，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。</p><p>如果 Symbol 的参数是一个对象，就会调用该对象的 toString 方法，将其转为字符串，然后才生成一个 Symbol 值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line">  <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">'abc'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const sym = Symbol(obj);</span><br><span class="line">sym // Symbol(abc)</span><br></pre></td></tr></table></figure><p>注意，Symbol 函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的 Symbol 函数的返回值是不相等的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 没有参数的情况</span><br><span class="line">var s1 = Symbol();</span><br><span class="line">var s2 = Symbol();</span><br><span class="line"></span><br><span class="line">s1 === s2 // <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">// 有参数的情况</span><br><span class="line">var s1 = Symbol(<span class="string">'foo'</span>);</span><br><span class="line">var s2 = Symbol(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line">s1 === s2 // <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>上面代码中，s1 和 s2 都是 Symbol 函数的返回值，而且参数相同，但是它们是不相等的。</p><p>Symbol 值不能与其他类型的值进行运算，会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var sym = Symbol(<span class="string">'My symbol'</span>);</span><br><span class="line"></span><br><span class="line"><span class="string">"your symbol is "</span> + sym</span><br><span class="line">// TypeError: can<span class="string">'t convert symbol to string</span></span><br><span class="line"><span class="string">`your symbol is $&#123;sym&#125;`</span></span><br><span class="line"><span class="string">// TypeError: can'</span>t convert symbol to string</span><br><span class="line">但是，Symbol值可以显式转为字符串。</span><br><span class="line"></span><br><span class="line">var sym = Symbol(<span class="string">'My symbol'</span>);</span><br><span class="line"></span><br><span class="line">String(sym) // <span class="string">'Symbol(My symbol)'</span></span><br><span class="line">sym.toString() // <span class="string">'Symbol(My symbol)'</span></span><br></pre></td></tr></table></figure><p>另外，Symbol 值也可以转为布尔值，但是不能转为数值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var sym = Symbol();</span><br><span class="line">Boolean(sym) // <span class="literal">true</span></span><br><span class="line">!sym  // <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sym) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Number(sym) // TypeError</span><br><span class="line">sym + 2 // TypeError</span><br></pre></td></tr></table></figure><h4 id="作为属性名的-Symbol"><a href="#作为属性名的-Symbol" class="headerlink" title="作为属性名的 Symbol"></a>作为属性名的 Symbol</h4><p>由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var mySymbol = Symbol();</span><br><span class="line"></span><br><span class="line">// 第一种写法</span><br><span class="line">var a = &#123;&#125;;</span><br><span class="line">a[mySymbol] = <span class="string">'Hello!'</span>;</span><br><span class="line"></span><br><span class="line">// 第二种写法</span><br><span class="line">var a = &#123;</span><br><span class="line">  [mySymbol]: <span class="string">'Hello!'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 第三种写法</span><br><span class="line">var a = &#123;&#125;;</span><br><span class="line">Object.defineProperty(a, mySymbol, &#123; value: <span class="string">'Hello!'</span> &#125;);</span><br><span class="line"></span><br><span class="line">// 以上写法都得到同样结果</span><br><span class="line">a[mySymbol] // <span class="string">"Hello!"</span></span><br></pre></td></tr></table></figure><p>上面代码通过方括号结构和 Object.defineProperty，将对象的属性名指定为一个 Symbol 值。</p><p>注意，Symbol 值作为对象属性名时，不能用点运算符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var mySymbol = Symbol();</span><br><span class="line">var a = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">a.mySymbol = <span class="string">'Hello!'</span>;</span><br><span class="line">a[mySymbol] // undefined</span><br><span class="line">a[<span class="string">'mySymbol'</span>] // <span class="string">"Hello!"</span></span><br></pre></td></tr></table></figure><p>上面代码中，因为点运算符后面总是字符串，所以不会读取 mySymbol 作为标识名所指代的那个值，导致 a 的属性名实际上是一个字符串，而不是一个 Symbol 值。</p><p>同理，在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> s = Symbol();</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> obj = &#123;</span><br><span class="line">  [s]: <span class="keyword">function</span> (arg) &#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj[s](123);</span><br></pre></td></tr></table></figure><p>上面代码中，如果 s 不放在方括号中，该属性的键名就是字符串 s，而不是 s 所代表的那个 Symbol 值。</p><p>采用增强的对象写法，上面代码的 obj 对象可以写得更简洁一些。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> obj = &#123;</span><br><span class="line">  [s](arg) &#123; ... &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Symbol 类型还可以用于定义一组常量，保证这组常量的值都是不相等的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">log.levels = &#123;</span><br><span class="line">  DEBUG: Symbol(<span class="string">'debug'</span>),</span><br><span class="line">  INFO: Symbol(<span class="string">'info'</span>),</span><br><span class="line">  WARN: Symbol(<span class="string">'warn'</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">log</span>(log.levels.DEBUG, <span class="string">'debug message'</span>);</span><br><span class="line"><span class="built_in">log</span>(log.levels.INFO, <span class="string">'info message'</span>);</span><br></pre></td></tr></table></figure><p>下面是另外一个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const COLOR_RED    = Symbol();</span><br><span class="line">const COLOR_GREEN  = Symbol();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> getComplement(color) &#123;</span><br><span class="line">  switch (color) &#123;</span><br><span class="line">    <span class="keyword">case</span> COLOR_RED:</span><br><span class="line">      <span class="built_in">return</span> COLOR_GREEN;</span><br><span class="line">    <span class="keyword">case</span> COLOR_GREEN:</span><br><span class="line">      <span class="built_in">return</span> COLOR_RED;</span><br><span class="line">    default:</span><br><span class="line">      throw new Error(<span class="string">'Undefined color'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常量使用 Symbol 值最大的好处，就是其他任何值都不可能有相同的值了，因此可以保证上面的 switch 语句会按设计的方式工作。</p><p>还有一点需要注意，Symbol 值作为属性名时，该属性还是公开属性，不是私有属性。</p><h4 id="实例：消除魔术字符串"><a href="#实例：消除魔术字符串" class="headerlink" title="实例：消除魔术字符串"></a>实例：消除魔术字符串</h4><p>魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。风格良好的代码，应该尽量消除魔术字符串，该由含义清晰的变量代替。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> getArea(shape, options) &#123;</span><br><span class="line">  var area = 0;</span><br><span class="line"></span><br><span class="line">  switch (shape) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'Triangle'</span>: // 魔术字符串</span><br><span class="line">      area = .5 * options.width * options.height;</span><br><span class="line">      <span class="built_in">break</span>;</span><br><span class="line">    /* ... more code ... */</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> area;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getArea(<span class="string">'Triangle'</span>, &#123; width: 100, height: 100 &#125;); // 魔术字符串</span><br></pre></td></tr></table></figure><p>上面代码中，字符串“Triangle”就是一个魔术字符串。它多次出现，与代码形成“强耦合”，不利于将来的修改和维护。</p><p>常用的消除魔术字符串的方法，就是把它写成一个变量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var shapeType = &#123;</span><br><span class="line">  triangle: <span class="string">'Triangle'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> getArea(shape, options) &#123;</span><br><span class="line">  var area = 0;</span><br><span class="line">  switch (shape) &#123;</span><br><span class="line">    <span class="keyword">case</span> shapeType.triangle:</span><br><span class="line">      area = .5 * options.width * options.height;</span><br><span class="line">      <span class="built_in">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> area;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getArea(shapeType.triangle, &#123; width: 100, height: 100 &#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，我们把“Triangle”写成 shapeType 对象的 triangle 属性，这样就消除了强耦合。</p><p>如果仔细分析，可以发现 shapeType.triangle 等于哪个值并不重要，只要确保不会跟其他 shapeType 属性的值冲突即可。因此，这里就很适合改用 Symbol 值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const shapeType = &#123;</span><br><span class="line">  triangle: Symbol()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，除了将 shapeType.triangle 的值设为一个 Symbol，其他地方都不用修改。</p><h4 id="属性名的遍历"><a href="#属性名的遍历" class="headerlink" title="属性名的遍历"></a>属性名的遍历</h4><p>Symbol 作为属性名，该属性不会出现在 for…in、for…of 循环中，也不会被 Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。但是，它也不是私有属性，有一个 Object.getOwnPropertySymbols 方法，可以获取指定对象的所有 Symbol 属性名。</p><p>Object.getOwnPropertySymbols 方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">var a = Symbol(<span class="string">'a'</span>);</span><br><span class="line">var b = Symbol(<span class="string">'b'</span>);</span><br><span class="line"></span><br><span class="line">obj[a] = <span class="string">'Hello'</span>;</span><br><span class="line">obj[b] = <span class="string">'World'</span>;</span><br><span class="line"></span><br><span class="line">var objectSymbols = Object.getOwnPropertySymbols(obj);</span><br><span class="line"></span><br><span class="line">objectSymbols</span><br><span class="line">// [Symbol(a), Symbol(b)]</span><br></pre></td></tr></table></figure><p>下面是另一个例子，Object.getOwnPropertySymbols 方法与 for…in 循环、Object.getOwnPropertyNames 方法进行对比的例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">var foo = Symbol(<span class="string">"foo"</span>);</span><br><span class="line"></span><br><span class="line">Object.defineProperty(obj, foo, &#123;</span><br><span class="line">  value: <span class="string">"foobar"</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (var i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  console.log(i); // 无输出</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object.getOwnPropertyNames(obj)</span><br><span class="line">// []</span><br><span class="line"></span><br><span class="line">Object.getOwnPropertySymbols(obj)</span><br><span class="line">// [Symbol(foo)]</span><br></pre></td></tr></table></figure><p>上面代码中，使用 Object.getOwnPropertyNames 方法得不到 Symbol 属性名，需要使用 Object.getOwnPropertySymbols 方法。</p><p>另一个新的 API，Reflect.ownKeys 方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> obj = &#123;</span><br><span class="line">  [Symbol(<span class="string">'my_key'</span>)]: 1,</span><br><span class="line">  enum: 2,</span><br><span class="line">  nonEnum: 3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Reflect.ownKeys(obj)</span><br><span class="line">// [Symbol(my_key), <span class="string">'enum'</span>, <span class="string">'nonEnum'</span>]</span><br></pre></td></tr></table></figure><p>由于以 Symbol 值作为名称的属性，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var size = Symbol(<span class="string">'size'</span>);</span><br><span class="line"></span><br><span class="line">class Collection &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    this[size] = 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  add(item) &#123;</span><br><span class="line">    this[this[size]] = item;</span><br><span class="line">    this[size]++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static sizeOf(instance) &#123;</span><br><span class="line">    <span class="built_in">return</span> instance[size];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var x = new Collection();</span><br><span class="line">Collection.sizeOf(x) // 0</span><br><span class="line"></span><br><span class="line">x.add(<span class="string">'foo'</span>);</span><br><span class="line">Collection.sizeOf(x) // 1</span><br><span class="line"></span><br><span class="line">Object.keys(x) // [<span class="string">'0'</span>]</span><br><span class="line">Object.getOwnPropertyNames(x) // [<span class="string">'0'</span>]</span><br><span class="line">Object.getOwnPropertySymbols(x) // [Symbol(size)]</span><br></pre></td></tr></table></figure><p>上面代码中，对象 x 的 size 属性是一个 Symbol 值，所以 Object.keys(x)、Object.getOwnPropertyNames(x)都无法获取它。这就造成了一种非私有的内部方法的效果。</p><h5 id="Symbol-for-，Symbol-keyFor"><a href="#Symbol-for-，Symbol-keyFor" class="headerlink" title="Symbol.for()，Symbol.keyFor()"></a>Symbol.for()，Symbol.keyFor()</h5><p>有时，我们希望重新使用同一个 Symbol 值，Symbol.for 方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var s1 = Symbol.for(<span class="string">'foo'</span>);</span><br><span class="line">var s2 = Symbol.for(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line">s1 === s2 // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>上面代码中，s1 和 s2 都是 Symbol 值，但是它们都是同样参数的 Symbol.for 方法生成的，所以实际上是同一个值。</p><p>Symbol.for()与 Symbol()这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。Symbol.for()不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的 key 是否已经存在，如果不存在才会新建一个值。比如，如果你调用 Symbol.for(“cat”)30 次，每次都会返回同一个 Symbol 值，但是调用 Symbol(“cat”)30 次，会返回 30 个不同的 Symbol 值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Symbol.for(<span class="string">"bar"</span>) === Symbol.for(<span class="string">"bar"</span>)</span><br><span class="line">// <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">Symbol(<span class="string">"bar"</span>) === Symbol(<span class="string">"bar"</span>)</span><br><span class="line">// <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>上面代码中，由于 Symbol()写法没有登记机制，所以每次调用都会返回一个不同的值。</p><p>Symbol.keyFor 方法返回一个已登记的 Symbol 类型值的 key。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var s1 = Symbol.for(<span class="string">"foo"</span>);</span><br><span class="line">Symbol.keyFor(s1) // <span class="string">"foo"</span></span><br><span class="line"></span><br><span class="line">var s2 = Symbol(<span class="string">"foo"</span>);</span><br><span class="line">Symbol.keyFor(s2) // undefined</span><br></pre></td></tr></table></figure><p>上面代码中，变量 s2 属于未登记的 Symbol 值，所以返回 undefined。</p><p>需要注意的是，Symbol.for 为 Symbol 值登记的名字，是全局环境的，可以在不同的 iframe 或 service worker 中取到同一个值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iframe = document.createElement(<span class="string">'iframe'</span>);</span><br><span class="line">iframe.src = String(window.location);</span><br><span class="line">document.body.appendChild(iframe);</span><br><span class="line"></span><br><span class="line">iframe.contentWindow.Symbol.for(<span class="string">'foo'</span>) === Symbol.for(<span class="string">'foo'</span>)</span><br><span class="line">// <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>上面代码中，iframe 窗口生成的 Symbol 值，可以在主页面得到。</p><h4 id="实例：模块的-Singleton-模式"><a href="#实例：模块的-Singleton-模式" class="headerlink" title="实例：模块的 Singleton 模式"></a>实例：模块的 Singleton 模式</h4><p>Singleton 模式指的是调用一个类，任何时候返回的都是同一个实例。</p><p>对于 Node 来说，模块文件可以看成是一个类。怎么保证每次执行这个模块文件，返回的都是同一个实例呢？</p><p>很容易想到，可以把实例放到顶层对象 global。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// mod.js</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">A</span></span>() &#123;</span><br><span class="line">  this.foo = <span class="string">'hello'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!global._foo) &#123;</span><br><span class="line">  global._foo = new A();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = global._foo;</span><br></pre></td></tr></table></figure><p>然后，加载上面的 mod.js。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = require(<span class="string">'./mod.js'</span>);</span><br><span class="line">console.log(a.foo);</span><br></pre></td></tr></table></figure><p>上面代码中，变量 a 任何时候加载的都是 A 的同一个实例。</p><p>但是，这里有一个问题，全局变量 global._foo 是可写的，任何文件都可以修改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = require(<span class="string">'./mod.js'</span>);</span><br><span class="line">global._foo = 123;</span><br></pre></td></tr></table></figure><p>上面的代码，会使得别的脚本加载 mod.js 都失真。</p><p>为了防止这种情况出现，我们就可以使用 Symbol。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// mod.js</span><br><span class="line">const FOO_KEY = Symbol.for(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">A</span></span>() &#123;</span><br><span class="line">  this.foo = <span class="string">'hello'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!global[FOO_KEY]) &#123;</span><br><span class="line">  global[FOO_KEY] = new A();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = global[FOO_KEY];</span><br></pre></td></tr></table></figure><p>上面代码中，可以保证 global[FOO_KEY]不会被无意间覆盖，但还是可以被改写。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = require(<span class="string">'./mod.js'</span>);</span><br><span class="line">global[Symbol.for(<span class="string">'foo'</span>)] = 123;</span><br></pre></td></tr></table></figure><p>如果键名使用 Symbol 方法生成，那么外部将无法引用这个值，当然也就无法改写。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// mod.js</span><br><span class="line">const FOO_KEY = Symbol(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line">// 后面代码相同 ……</span><br></pre></td></tr></table></figure><p>上面代码将导致其他脚本都无法引用 FOO_KEY。但这样也有一个问题，就是如果多次执行这个脚本，每次得到的 FOO_KEY 都是不一样的。虽然 Node 会将脚本的执行结果缓存，一般情况下，不会多次执行同一个脚本，但是用户可以手动清除缓存，所以也不是完全可靠。</p><h4 id="内置的-Symbol-值"><a href="#内置的-Symbol-值" class="headerlink" title="内置的 Symbol 值"></a>内置的 Symbol 值</h4><p>除了定义自己使用的 Symbol 值以外，ES6 还提供了 11 个内置的 Symbol 值，指向语言内部使用的方法。</p><h5 id="Symbol-hasInstance"><a href="#Symbol-hasInstance" class="headerlink" title="Symbol.hasInstance"></a>Symbol.hasInstance</h5><p>对象的 Symbol.hasInstance 属性，指向一个内部方法。当其他对象使用 instanceof 运算符，判断是否为该对象的实例时，会调用这个方法。比如，foo instanceof Foo 在语言内部，实际调用的是 Foo<a href="foo">Symbol.hasInstance</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">  [Symbol.hasInstance](foo) &#123;</span><br><span class="line">    <span class="built_in">return</span> foo instanceof Array;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[1, 2, 3] instanceof new MyClass() // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>上面代码中，MyClass 是一个类，new MyClass()会返回一个实例。该实例的 Symbol.hasInstance 方法，会在进行 instanceof 运算时自动调用，判断左侧的运算子是否为 Array 的实例。</p><p>下面是另一个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Even &#123;</span><br><span class="line">  static [Symbol.hasInstance](obj) &#123;</span><br><span class="line">    <span class="built_in">return</span> Number(obj) % 2 === 0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">1 instanceof Even // <span class="literal">false</span></span><br><span class="line">2 instanceof Even // <span class="literal">true</span></span><br><span class="line">12345 instanceof Even // <span class="literal">false</span></span><br></pre></td></tr></table></figure><h5 id="Symbol-isConcatSpreadable"><a href="#Symbol-isConcatSpreadable" class="headerlink" title="Symbol.isConcatSpreadable"></a>Symbol.isConcatSpreadable</h5><p>对象的 Symbol.isConcatSpreadable 属性等于一个布尔值，表示该对象使用 Array.prototype.concat()时，是否可以展开。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arr1 = [<span class="string">'c'</span>, <span class="string">'d'</span>];</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>].concat(arr1, <span class="string">'e'</span>) // [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>]</span><br><span class="line">arr1[Symbol.isConcatSpreadable] // undefined</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> arr2 = [<span class="string">'c'</span>, <span class="string">'d'</span>];</span><br><span class="line">arr2[Symbol.isConcatSpreadable] = <span class="literal">false</span>;</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>].concat(arr2, <span class="string">'e'</span>) // [<span class="string">'a'</span>, <span class="string">'b'</span>, [<span class="string">'c'</span>,<span class="string">'d'</span>], <span class="string">'e'</span>]</span><br></pre></td></tr></table></figure><p>上面代码说明，数组的默认行为是可以展开。Symbol.isConcatSpreadable 属性等于 true 或 undefined，都有这个效果。</p><p>类似数组的对象也可以展开，但它的 Symbol.isConcatSpreadable 属性默认为 false，必须手动打开。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> obj = &#123;length: 2, 0: <span class="string">'c'</span>, 1: <span class="string">'d'</span>&#125;;</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>].concat(obj, <span class="string">'e'</span>) // [<span class="string">'a'</span>, <span class="string">'b'</span>, obj, <span class="string">'e'</span>]</span><br><span class="line"></span><br><span class="line">obj[Symbol.isConcatSpreadable] = <span class="literal">true</span>;</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>].concat(obj, <span class="string">'e'</span>) // [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>]</span><br></pre></td></tr></table></figure><p>对于一个类来说，Symbol.isConcatSpreadable 属性必须写成实例的属性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class A1 extends Array &#123;</span><br><span class="line">  constructor(args) &#123;</span><br><span class="line">    super(args);</span><br><span class="line">    this[Symbol.isConcatSpreadable] = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class A2 extends Array &#123;</span><br><span class="line">  constructor(args) &#123;</span><br><span class="line">    super(args);</span><br><span class="line">    this[Symbol.isConcatSpreadable] = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> a1 = new A1();</span><br><span class="line">a1[0] = 3;</span><br><span class="line">a1[1] = 4;</span><br><span class="line"><span class="built_in">let</span> a2 = new A2();</span><br><span class="line">a2[0] = 5;</span><br><span class="line">a2[1] = 6;</span><br><span class="line">[1, 2].concat(a1).concat(a2)</span><br><span class="line">// [1, 2, 3, 4, [5, 6]]</span><br></pre></td></tr></table></figure><p>上面代码中，类 A1 是可展开的，类 A2 是不可展开的，所以使用 concat 时有不一样的结果。</p><h5 id="Symbol-species"><a href="#Symbol-species" class="headerlink" title="Symbol.species"></a>Symbol.species</h5><p>对象的 Symbol.species 属性，指向一个方法。该对象作为构造函数创造实例时，会调用这个方法。即如果 this.constructor[Symbol.species]存在，就会使用这个属性作为构造函数，来创造新的实例对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Symbol.species属性默认的读取器如下。</span><br><span class="line"></span><br><span class="line">static get [Symbol.species]() &#123;</span><br><span class="line">  <span class="built_in">return</span> this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Symbol-match"><a href="#Symbol-match" class="headerlink" title="Symbol.match"></a>Symbol.match</h5><p>对象的 Symbol.match 属性，指向一个函数。当执行 str.match(myObject)时，如果该属性存在，会调用它，返回该方法的返回值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String.prototype.match(regexp)</span><br><span class="line">// 等同于</span><br><span class="line">regexp[Symbol.match](this)</span><br><span class="line"></span><br><span class="line">class MyMatcher &#123;</span><br><span class="line">  [Symbol.match](string) &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">'hello world'</span>.indexOf(string);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">'e'</span>.match(new MyMatcher()) // 1</span><br></pre></td></tr></table></figure><h5 id="Symbol-replace"><a href="#Symbol-replace" class="headerlink" title="Symbol.replace"></a>Symbol.replace</h5><p>对象的 Symbol.replace 属性，指向一个方法，当该对象被 String.prototype.replace 方法调用时，会返回该方法的返回值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String.prototype.replace(searchValue, replaceValue)</span><br><span class="line">// 等同于</span><br><span class="line">searchValue[Symbol.replace](this, replaceValue)</span><br></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const x = &#123;&#125;;</span><br><span class="line">x[Symbol.replace] = (...s) =&gt; console.log(s);</span><br><span class="line"></span><br><span class="line"><span class="string">'Hello'</span>.replace(x, <span class="string">'World'</span>) // [<span class="string">"Hello"</span>, <span class="string">"World"</span>]</span><br></pre></td></tr></table></figure><p>Symbol.replace 方法会收到两个参数，第一个参数是 replace 方法正在作用的对象，上面例子是 Hello，第二个参数是替换后的值，上面例子是 World。</p><h5 id="Symbol-search"><a href="#Symbol-search" class="headerlink" title="Symbol.search"></a>Symbol.search</h5><p>对象的 Symbol.search 属性，指向一个方法，当该对象被 String.prototype.search 方法调用时，会返回该方法的返回值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String.prototype.search(regexp)</span><br><span class="line">// 等同于</span><br><span class="line">regexp[Symbol.search](this)</span><br><span class="line"></span><br><span class="line">class MySearch &#123;</span><br><span class="line">  constructor(value) &#123;</span><br><span class="line">    this.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">  [Symbol.search](string) &#123;</span><br><span class="line">    <span class="built_in">return</span> string.indexOf(this.value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">'foobar'</span>.search(new MySearch(<span class="string">'foo'</span>)) // 0</span><br></pre></td></tr></table></figure><h5 id="Symbol-split"><a href="#Symbol-split" class="headerlink" title="Symbol.split"></a>Symbol.split</h5><p>对象的 Symbol.split 属性，指向一个方法，当该对象被 String.prototype.split 方法调用时，会返回该方法的返回值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String.prototype.split(separator, <span class="built_in">limit</span>)</span><br><span class="line">// 等同于</span><br><span class="line">separator[Symbol.split](this, <span class="built_in">limit</span>)</span><br></pre></td></tr></table></figure><h5 id="Symbol-iterator"><a href="#Symbol-iterator" class="headerlink" title="Symbol.iterator"></a>Symbol.iterator</h5><p>对象的 Symbol.iterator 属性，指向该对象的默认遍历器方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var myIterable = &#123;&#125;;</span><br><span class="line">myIterable[Symbol.iterator] = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  yield 2;</span><br><span class="line">  yield 3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[...myIterable] // [1, 2, 3]</span><br></pre></td></tr></table></figure><p>对象进行 for…of 循环时，会调用 Symbol.iterator 方法，返回该对象的默认遍历器，详细介绍参见《Iterator 和 for…of 循环》一章。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Collection &#123;</span><br><span class="line">  *[Symbol.iterator]() &#123;</span><br><span class="line">    <span class="built_in">let</span> i = 0;</span><br><span class="line">    <span class="keyword">while</span>(this[i] !== undefined) &#123;</span><br><span class="line">      yield this[i];</span><br><span class="line">      ++i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> myCollection = new Collection();</span><br><span class="line">myCollection[0] = 1;</span><br><span class="line">myCollection[1] = 2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">let</span> value of myCollection) &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br></pre></td></tr></table></figure><h5 id="Symbol-toPrimitive"><a href="#Symbol-toPrimitive" class="headerlink" title="Symbol.toPrimitive"></a>Symbol.toPrimitive</h5><p>对象的 Symbol.toPrimitive 属性，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。</p><p>Symbol.toPrimitive 被调用时，会接受一个字符串参数，表示当前运算的模式，一共有三种模式。</p><p>1.Number：该场合需要转成数值<br>2.String：该场合需要转成字符串<br>3.Default：该场合可以转成数值，也可以转成字符串</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> obj = &#123;</span><br><span class="line">  [Symbol.toPrimitive](hint) &#123;</span><br><span class="line">    switch (hint) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'number'</span>:</span><br><span class="line">        <span class="built_in">return</span> 123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'string'</span>:</span><br><span class="line">        <span class="built_in">return</span> <span class="string">'str'</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'default'</span>:</span><br><span class="line">        <span class="built_in">return</span> <span class="string">'default'</span>;</span><br><span class="line">      default:</span><br><span class="line">        throw new Error();</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">2 * obj // 246</span><br><span class="line">3 + obj // <span class="string">'3default'</span></span><br><span class="line">obj == <span class="string">'default'</span> // <span class="literal">true</span></span><br><span class="line">String(obj) // <span class="string">'str'</span></span><br></pre></td></tr></table></figure><h5 id="Symbol-toStringTag"><a href="#Symbol-toStringTag" class="headerlink" title="Symbol.toStringTag"></a>Symbol.toStringTag</h5><p>对象的 Symbol.toStringTag 属性，指向一个方法。在该对象上面调用 Object.prototype.toString 方法时，如果这个属性存在，它的返回值会出现在 toString 方法返回的字符串之中，表示对象的类型。也就是说，这个属性可以用来定制[object Object]或[object Array]中 object 后面的那个字符串。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 例一</span><br><span class="line">(&#123;[Symbol.toStringTag]: <span class="string">'Foo'</span>&#125;.toString())</span><br><span class="line">// <span class="string">"[object Foo]"</span></span><br><span class="line"></span><br><span class="line">// 例二</span><br><span class="line">class Collection &#123;</span><br><span class="line">  get [Symbol.toStringTag]() &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">'xxx'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var x = new Collection();</span><br><span class="line">Object.prototype.toString.call(x) // <span class="string">"[object xxx]"</span></span><br></pre></td></tr></table></figure><p>ES6 新增内置对象的 Symbol.toStringTag 属性值如下。</p><p>1.JSON[Symbol.toStringTag]：’JSON’<br>2.Math[Symbol.toStringTag]：’Math’<br>3.Module 对象 M[Symbol.toStringTag]：’Module’<br>4.ArrayBuffer.prototype[Symbol.toStringTag]：’ArrayBuffer’<br>5.DataView.prototype[Symbol.toStringTag]：’DataView’<br>6.Map.prototype[Symbol.toStringTag]：’Map’<br>7.Promise.prototype[Symbol.toStringTag]：’Promise’<br>8.Set.prototype[Symbol.toStringTag]：’Set’<br>9.%TypedArray%.prototype[Symbol.toStringTag]：’Uint8Array’等<br>10.WeakMap.prototype[Symbol.toStringTag]：’WeakMap’<br>11.WeakSet.prototype[Symbol.toStringTag]：’WeakSet’<br>12.%MapIteratorPrototype%[Symbol.toStringTag]：’Map Iterator’<br>13.%SetIteratorPrototype%[Symbol.toStringTag]：’Set Iterator’<br>14.%StringIteratorPrototype%[Symbol.toStringTag]：’String Iterator’<br>15.Symbol.prototype[Symbol.toStringTag]：’Symbol’<br>16.Generator.prototype[Symbol.toStringTag]：’Generator’<br>17.GeneratorFunction.prototype[Symbol.toStringTag]：’GeneratorFunction’</p><h5 id="Symbol-unscopables"><a href="#Symbol-unscopables" class="headerlink" title="Symbol.unscopables"></a>Symbol.unscopables</h5><p>对象的 Symbol.unscopables 属性，指向一个对象。该对象指定了使用 with 关键字时，哪些属性会被 with 环境排除。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype[Symbol.unscopables]</span><br><span class="line">// &#123;</span><br><span class="line">//   copyWithin: <span class="literal">true</span>,</span><br><span class="line">//   entries: <span class="literal">true</span>,</span><br><span class="line">//   fill: <span class="literal">true</span>,</span><br><span class="line">//   find: <span class="literal">true</span>,</span><br><span class="line">//   findIndex: <span class="literal">true</span>,</span><br><span class="line">//   keys: <span class="literal">true</span></span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">Object.keys(Array.prototype[Symbol.unscopables])</span><br><span class="line">// [<span class="string">'copyWithin'</span>, <span class="string">'entries'</span>, <span class="string">'fill'</span>, <span class="string">'find'</span>, <span class="string">'findIndex'</span>, <span class="string">'keys'</span>]</span><br></pre></td></tr></table></figure><p>上面代码说明，数组有 6 个属性，会被 with 命令排除。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 没有unscopables时</span><br><span class="line">class MyClass &#123;</span><br><span class="line">  <span class="function"><span class="title">foo</span></span>() &#123; <span class="built_in">return</span> 1; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var foo = <span class="function"><span class="title">function</span></span> () &#123; <span class="built_in">return</span> 2; &#125;;</span><br><span class="line"></span><br><span class="line">with (MyClass.prototype) &#123;</span><br><span class="line">  foo(); // 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 有unscopables时</span><br><span class="line">class MyClass &#123;</span><br><span class="line">  <span class="function"><span class="title">foo</span></span>() &#123; <span class="built_in">return</span> 1; &#125;</span><br><span class="line">  get [Symbol.unscopables]() &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123; foo: <span class="literal">true</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var foo = <span class="function"><span class="title">function</span></span> () &#123; <span class="built_in">return</span> 2; &#125;;</span><br><span class="line"></span><br><span class="line">with (MyClass.prototype) &#123;</span><br><span class="line">  foo(); // 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6_Object</title>
      <link href="/2019/02/10/es6-Object/"/>
      <url>/2019/02/10/es6-Object/</url>
      
        <content type="html"><![CDATA[<h3 id="ES6-对象的扩展"><a href="#ES6-对象的扩展" class="headerlink" title="ES6 对象的扩展"></a>ES6 对象的扩展</h3><h4 id="属性的简洁表示法"><a href="#属性的简洁表示法" class="headerlink" title="属性的简洁表示法"></a>属性的简洁表示法</h4><p>ES6 允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var foo = <span class="string">'bar'</span>;</span><br><span class="line">var baz = &#123;foo&#125;;</span><br><span class="line">baz // &#123;foo: <span class="string">"bar"</span>&#125;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">var baz = &#123;foo: foo&#125;;</span><br></pre></td></tr></table></figure><p>上面代码表明，ES6 允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。下面是另一个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> f(x, y) &#123;</span><br><span class="line">  <span class="built_in">return</span> &#123;x, y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> f(x, y) &#123;</span><br><span class="line">  <span class="built_in">return</span> &#123;x: x, y: y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(1, 2) // Object &#123;x: 1, y: 2&#125;</span><br></pre></td></tr></table></figure><p>除了属性简写，方法也可以简写。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">  <span class="function"><span class="title">method</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">"Hello!"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line"></span><br><span class="line">var o = &#123;</span><br><span class="line">  method: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">"Hello!"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面是一个实际的例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var birth = <span class="string">'2000/01/01'</span>;</span><br><span class="line"></span><br><span class="line">var Person = &#123;</span><br><span class="line"></span><br><span class="line">  name: <span class="string">'张三'</span>,</span><br><span class="line"></span><br><span class="line">  //等同于birth: birth</span><br><span class="line">  birth,</span><br><span class="line"></span><br><span class="line">  // 等同于hello: <span class="keyword">function</span> ()...</span><br><span class="line">  <span class="function"><span class="title">hello</span></span>() &#123; console.log(<span class="string">'我的名字是'</span>, this.name); &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种写法用于函数的返回值，将会非常方便。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">getPoint</span></span>() &#123;</span><br><span class="line">  var x = 1;</span><br><span class="line">  var y = 10;</span><br><span class="line">  <span class="built_in">return</span> &#123;x, y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getPoint()</span><br><span class="line">// &#123;x:1, y:10&#125;</span><br></pre></td></tr></table></figure><p>CommonJS 模块输出变量，就非常合适使用简洁写法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var ms = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> getItem (key) &#123;</span><br><span class="line">  <span class="built_in">return</span> key <span class="keyword">in</span> ms ? ms[key] : null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> setItem (key, value) &#123;</span><br><span class="line">  ms[key] = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">clear</span></span> () &#123;</span><br><span class="line">  ms = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = &#123; getItem, setItem, clear &#125;;</span><br><span class="line">// 等同于</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  getItem: getItem,</span><br><span class="line">  setItem: setItem,</span><br><span class="line">  clear: clear</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>属性的赋值器（setter）和取值器（getter），事实上也是采用这种写法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var cart = &#123;</span><br><span class="line">  _wheels: 4,</span><br><span class="line"></span><br><span class="line">  get <span class="function"><span class="title">wheels</span></span> () &#123;</span><br><span class="line">    <span class="built_in">return</span> this._wheels;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="built_in">set</span> wheels (value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; this._wheels) &#123;</span><br><span class="line">      throw new Error(<span class="string">'数值太小了！'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    this._wheels = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，简洁写法的属性名总是字符串，这会导致一些看上去比较奇怪的结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  <span class="function"><span class="title">class</span></span> () &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">  <span class="string">'class'</span>: <span class="function"><span class="title">function</span></span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，class 是字符串，所以不会因为它属于关键字，而导致语法解析报错。</p><p>如果某个方法的值是一个 Generator 函数，前面需要加上星号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  * <span class="function"><span class="title">m</span></span>()&#123;</span><br><span class="line">    yield <span class="string">'hello world'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="属性名表达式"><a href="#属性名表达式" class="headerlink" title="属性名表达式"></a>属性名表达式</h4><p>JavaScript 语言定义对象的属性，有两种方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 方法一</span><br><span class="line">obj.foo = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">// 方法二</span><br><span class="line">obj[<span class="string">'a'</span> + <span class="string">'bc'</span>] = 123;</span><br></pre></td></tr></table></figure><p>上面代码的方法一是直接用标识符作为属性名，方法二是用表达式作为属性名，这时要将表达式放在方括号之内。</p><p>但是，如果使用字面量方式定义对象（使用大括号），在 ES5 中只能使用方法一（标识符）定义属性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  foo: <span class="literal">true</span>,</span><br><span class="line">  abc: 123</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>ES6 允许字面量定义对象时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> propKey = <span class="string">'foo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> obj = &#123;</span><br><span class="line">  [propKey]: <span class="literal">true</span>,</span><br><span class="line">  [<span class="string">'a'</span> + <span class="string">'bc'</span>]: 123</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面是另一个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var lastWord = <span class="string">'last word'</span>;</span><br><span class="line"></span><br><span class="line">var a = &#123;</span><br><span class="line">  <span class="string">'first word'</span>: <span class="string">'hello'</span>,</span><br><span class="line">  [lastWord]: <span class="string">'world'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a[<span class="string">'first word'</span>] // <span class="string">"hello"</span></span><br><span class="line">a[lastWord] // <span class="string">"world"</span></span><br><span class="line">a[<span class="string">'last word'</span>] // <span class="string">"world"</span></span><br></pre></td></tr></table></figure><p>表达式还可以用于定义方法名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> obj = &#123;</span><br><span class="line">  [<span class="string">'h'</span> + <span class="string">'ello'</span>]() &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">'hi'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.hello() // hi</span><br></pre></td></tr></table></figure><p>注意，属性名表达式与简洁表示法，不能同时使用，会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line">var foo = <span class="string">'bar'</span>;</span><br><span class="line">var bar = <span class="string">'abc'</span>;</span><br><span class="line">var baz = &#123; [foo] &#125;;</span><br><span class="line"></span><br><span class="line">// 正确</span><br><span class="line">var foo = <span class="string">'bar'</span>;</span><br><span class="line">var baz = &#123; [foo]: <span class="string">'abc'</span>&#125;;</span><br></pre></td></tr></table></figure><p>注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]，这一点要特别小心。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const keyA = &#123;a: 1&#125;;</span><br><span class="line">const keyB = &#123;b: 2&#125;;</span><br><span class="line"></span><br><span class="line">const myObject = &#123;</span><br><span class="line">  [keyA]: <span class="string">'valueA'</span>,</span><br><span class="line">  [keyB]: <span class="string">'valueB'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myObject // Object &#123;[object Object]: <span class="string">"valueB"</span>&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，[keyA]和[keyB]得到的都是[object Object]，所以[keyB]会把[keyA]覆盖掉，而 myObject 最后只有一个[object Object]属性。</p><h4 id="方法的-name-属性"><a href="#方法的-name-属性" class="headerlink" title="方法的 name 属性"></a>方法的 name 属性</h4><p>函数的 name 属性，返回函数名。对象方法也是函数，因此也有 name 属性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">  <span class="function"><span class="title">sayName</span></span>() &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;,</span><br><span class="line">  get <span class="function"><span class="title">firstName</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">"Nicholas"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.sayName.name   // <span class="string">"sayName"</span></span><br><span class="line">person.firstName.name // <span class="string">"get firstName"</span></span><br></pre></td></tr></table></figure><p>上面代码中，方法的 name 属性返回函数名（即方法名）。如果使用了取值函数，则会在方法名前加上 get。如果是存值函数，方法名的前面会加上 set。</p><p>有两种特殊情况：bind 方法创造的函数，name 属性返回“bound”加上原函数的名字；Function 构造函数创造的函数，name 属性返回“anonymous”。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(new Function()).name // <span class="string">"anonymous"</span></span><br><span class="line"></span><br><span class="line">var doSomething = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;;</span><br><span class="line">doSomething.bind().name // <span class="string">"bound doSomething"</span></span><br></pre></td></tr></table></figure><p>如果对象的方法是一个 Symbol 值，那么 name 属性返回的是这个 Symbol 值的描述。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const key1 = Symbol(<span class="string">'description'</span>);</span><br><span class="line">const key2 = Symbol();</span><br><span class="line"><span class="built_in">let</span> obj = &#123;</span><br><span class="line">  [key1]() &#123;&#125;,</span><br><span class="line">  [key2]() &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">obj[key1].name // <span class="string">"[description]"</span></span><br><span class="line">obj[key2].name // <span class="string">""</span></span><br></pre></td></tr></table></figure><p>上面代码中，key1 对应的 Symbol 值有描述，key2 没有。</p><h4 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h4><p>ES5 比较两个值是否相等，只有两个运算符：相等运算符（==）和严格相等运算符（===）。它们都有缺点，前者会自动转换数据类型，后者的 NaN 不等于自身，以及+0 等于-0。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。</p><p>ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。Object.is 就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object.is(<span class="string">'foo'</span>, <span class="string">'foo'</span>)</span><br><span class="line">// <span class="literal">true</span></span><br><span class="line">Object.is(&#123;&#125;, &#123;&#125;)</span><br><span class="line">// <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>不同之处只有两个：一是+0 不等于-0，二是 NaN 等于自身。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+0 === -0 //<span class="literal">true</span></span><br><span class="line">NaN === NaN // <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">Object.is(+0, -0) // <span class="literal">false</span></span><br><span class="line">Object.is(NaN, NaN) // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>ES5 可以通过下面的代码，部署 Object.is。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty(Object, <span class="string">'is'</span>, &#123;</span><br><span class="line">  value: <span class="keyword">function</span>(x, y) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x === y) &#123;</span><br><span class="line">      // 针对+0 不等于 -0的情况</span><br><span class="line">      <span class="built_in">return</span> x !== 0 || 1 / x === 1 / y;</span><br><span class="line">    &#125;</span><br><span class="line">    // 针对NaN的情况</span><br><span class="line">    <span class="built_in">return</span> x !== x &amp;&amp; y !== y;</span><br><span class="line">  &#125;,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">  writable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h4><h5 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h5><p>Object.assign 方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var target = &#123; a: 1 &#125;;</span><br><span class="line"></span><br><span class="line">var source1 = &#123; b: 2 &#125;;</span><br><span class="line">var source2 = &#123; c: 3 &#125;;</span><br><span class="line"></span><br><span class="line">Object.assign(target, source1, source2);</span><br><span class="line">target // &#123;a:1, b:2, c:3&#125;</span><br></pre></td></tr></table></figure><p>Object.assign 方法的第一个参数是目标对象，后面的参数都是源对象。</p><p>注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var target = &#123; a: 1, b: 1 &#125;;</span><br><span class="line"></span><br><span class="line">var source1 = &#123; b: 2, c: 2 &#125;;</span><br><span class="line">var source2 = &#123; c: 3 &#125;;</span><br><span class="line"></span><br><span class="line">Object.assign(target, source1, source2);</span><br><span class="line">target // &#123;a:1, b:2, c:3&#125;</span><br></pre></td></tr></table></figure><p>如果只有一个参数，Object.assign 会直接返回该参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;a: 1&#125;;</span><br><span class="line">Object.assign(obj) === obj // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>如果该参数不是对象，则会先转成对象，然后返回。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeof Object.assign(2) // <span class="string">"object"</span></span><br></pre></td></tr></table></figure><p>由于 undefined 和 null 无法转成对象，所以如果它们作为参数，就会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.assign(undefined) // 报错</span><br><span class="line">Object.assign(null) // 报错</span><br></pre></td></tr></table></figure><p>如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果 undefined 和 null 不在首参数，就不会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> obj = &#123;a: 1&#125;;</span><br><span class="line">Object.assign(obj, undefined) === obj // <span class="literal">true</span></span><br><span class="line">Object.assign(obj, null) === obj // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var v1 = <span class="string">'abc'</span>;</span><br><span class="line">var v2 = <span class="literal">true</span>;</span><br><span class="line">var v3 = 10;</span><br><span class="line"></span><br><span class="line">var obj = Object.assign(&#123;&#125;, v1, v2, v3);</span><br><span class="line">console.log(obj); // &#123; <span class="string">"0"</span>: <span class="string">"a"</span>, <span class="string">"1"</span>: <span class="string">"b"</span>, <span class="string">"2"</span>: <span class="string">"c"</span> &#125;</span><br></pre></td></tr></table></figure><p>上面代码中，v1、v2、v3 分别是字符串、布尔值和数值，结果只有字符串合入目标对象（以字符数组的形式），数值和布尔值都会被忽略。这是因为只有字符串的包装对象，会产生可枚举属性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object(<span class="literal">true</span>) // &#123;[[PrimitiveValue]]: <span class="literal">true</span>&#125;</span><br><span class="line">Object(10)  //  &#123;[[PrimitiveValue]]: 10&#125;</span><br><span class="line">Object(<span class="string">'abc'</span>) // &#123;0: <span class="string">"a"</span>, 1: <span class="string">"b"</span>, 2: <span class="string">"c"</span>, length: 3, [[PrimitiveValue]]: <span class="string">"abc"</span>&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，布尔值、数值、字符串分别转成对应的包装对象，可以看到它们的原始值都在包装对象的内部属性[[PrimitiveValue]]上面，这个属性是不会被 Object.assign 拷贝的。只有字符串的包装对象，会产生可枚举的实义属性，那些属性则会被拷贝。</p><p>Object.assign 拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Object.assign(&#123;b: <span class="string">'c'</span>&#125;,</span><br><span class="line">  Object.defineProperty(&#123;&#125;, <span class="string">'invisible'</span>, &#123;</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    value: <span class="string">'hello'</span></span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br><span class="line">// &#123; b: <span class="string">'c'</span> &#125;</span><br></pre></td></tr></table></figure><p>上面代码中，Object.assign 要拷贝的对象只有一个不可枚举属性 invisible，这个属性并没有被拷贝进去。</p><p>属性名为 Symbol 值的属性，也会被 Object.assign 拷贝。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.assign(&#123; a: <span class="string">'b'</span> &#125;, &#123; [Symbol(<span class="string">'c'</span>)]: <span class="string">'d'</span> &#125;)</span><br><span class="line">// &#123; a: <span class="string">'b'</span>, Symbol(c): <span class="string">'d'</span> &#125;</span><br></pre></td></tr></table></figure><h5 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h5><p>Object.assign 方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = &#123;a: &#123;b: 1&#125;&#125;;</span><br><span class="line">var obj2 = Object.assign(&#123;&#125;, obj1);</span><br><span class="line"></span><br><span class="line">obj1.a.b = 2;</span><br><span class="line">obj2.a.b // 2</span><br></pre></td></tr></table></figure><p>上面代码中，源对象 obj1 的 a 属性的值是一个对象，Object.assign 拷贝得到的是这个对象的引用。这个对象的任何变化，都会反映到目标对象上面。</p><p>对于这种嵌套的对象，一旦遇到同名属性，Object.assign 的处理方法是替换，而不是添加。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var target = &#123; a: &#123; b: <span class="string">'c'</span>, d: <span class="string">'e'</span> &#125; &#125;</span><br><span class="line">var <span class="built_in">source</span> = &#123; a: &#123; b: <span class="string">'hello'</span> &#125; &#125;</span><br><span class="line">Object.assign(target, <span class="built_in">source</span>)</span><br><span class="line">// &#123; a: &#123; b: <span class="string">'hello'</span> &#125; &#125;</span><br></pre></td></tr></table></figure><p>上面代码中，target 对象的 a 属性被 source 对象的 a 属性整个替换掉了，而不会得到{ a: { b: ‘hello’, d: ‘e’ } }的结果。这通常不是开发者想要的，需要特别小心。</p><p>有一些函数库提供 Object.assign 的定制版本（比如 Lodash 的_.defaultsDeep 方法），可以解决浅拷贝的问题，得到深拷贝的合并。</p><p>注意，Object.assign 可以用来处理数组，但是会把数组视为对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.assign([1, 2, 3], [4, 5])</span><br><span class="line">// [4, 5, 3]</span><br></pre></td></tr></table></figure><p>上面代码中，Object.assign 把数组视为属性名为 0、1、2 的对象，因此目标数组的 0 号属性 4 覆盖了原数组的 0 号属性 1。</p><h5 id="常见用途"><a href="#常见用途" class="headerlink" title="常见用途"></a>常见用途</h5><p>Object.assign 方法有很多用处。</p><h6 id="为对象添加属性"><a href="#为对象添加属性" class="headerlink" title="为对象添加属性"></a>为对象添加属性</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  constructor(x, y) &#123;</span><br><span class="line">    Object.assign(this, &#123;x, y&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面方法通过 Object.assign 方法，将 x 属性和 y 属性添加到 Point 类的对象实例。</p><h6 id="为对象添加方法"><a href="#为对象添加方法" class="headerlink" title="为对象添加方法"></a>为对象添加方法</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Object.assign(SomeClass.prototype, &#123;</span><br><span class="line">  someMethod(arg1, arg2) &#123;</span><br><span class="line">    ···</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">anotherMethod</span></span>() &#123;</span><br><span class="line">    ···</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 等同于下面的写法</span><br><span class="line">SomeClass.prototype.someMethod = <span class="keyword">function</span> (arg1, arg2) &#123;</span><br><span class="line">  ···</span><br><span class="line">&#125;;</span><br><span class="line">SomeClass.prototype.anotherMethod = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  ···</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码使用了对象属性的简洁表示法，直接将两个函数放在大括号中，再使用 assign 方法添加到 SomeClass.prototype 之中。</p><h6 id="克隆对象"><a href="#克隆对象" class="headerlink" title="克隆对象"></a>克隆对象</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="built_in">clone</span>(origin) &#123;</span><br><span class="line">  <span class="built_in">return</span> Object.assign(&#123;&#125;, origin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆。</p><p>不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="built_in">clone</span>(origin) &#123;</span><br><span class="line">  <span class="built_in">let</span> originProto = Object.getPrototypeOf(origin);</span><br><span class="line">  <span class="built_in">return</span> Object.assign(Object.create(originProto), origin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="合并多个对象"><a href="#合并多个对象" class="headerlink" title="合并多个对象"></a>合并多个对象</h6><p>将多个对象合并到某个对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const merge =</span><br><span class="line">  (target, ...sources) =&gt; Object.assign(target, ...sources);</span><br></pre></td></tr></table></figure><p>如果希望合并后返回一个新对象，可以改写上面函数，对一个空对象合并。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const merge =</span><br><span class="line">  (...sources) =&gt; Object.assign(&#123;&#125;, ...sources);</span><br></pre></td></tr></table></figure><h6 id="为属性指定默认值"><a href="#为属性指定默认值" class="headerlink" title="为属性指定默认值"></a>为属性指定默认值</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const DEFAULTS = &#123;</span><br><span class="line">  logLevel: 0,</span><br><span class="line">  outputFormat: <span class="string">'html'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> processContent(options) &#123;</span><br><span class="line">  options = Object.assign(&#123;&#125;, DEFAULTS, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，DEFAULTS 对象是默认值，options 对象是用户提供的参数。Object.assign 方法将 DEFAULTS 和 options 合并成一个新对象，如果两者有同名属性，则 option 的属性值会覆盖 DEFAULTS 的属性值。</p><p>注意，由于存在深拷贝的问题，DEFAULTS 对象和 options 对象的所有属性的值，都只能是简单类型，而不能指向另一个对象。否则，将导致 DEFAULTS 对象的该属性不起作用。</p><h5 id="属性的可枚举性"><a href="#属性的可枚举性" class="headerlink" title="属性的可枚举性"></a>属性的可枚举性</h5><p>对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。Object.getOwnPropertyDescriptor 方法可以获取该属性的描述对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> obj = &#123; foo: 123 &#125;;</span><br><span class="line">Object.getOwnPropertyDescriptor(obj, <span class="string">'foo'</span>)</span><br><span class="line">//  &#123;</span><br><span class="line">//    value: 123,</span><br><span class="line">//    writable: <span class="literal">true</span>,</span><br><span class="line">//    enumerable: <span class="literal">true</span>,</span><br><span class="line">//    configurable: <span class="literal">true</span></span><br><span class="line">//  &#125;</span><br></pre></td></tr></table></figure><p>描述对象的 enumerable 属性，称为”可枚举性“，如果该属性为 false，就表示某些操作会忽略当前属性。</p><p>ES5 有三个操作会忽略 enumerable 为 false 的属性。</p><p>1.for…in 循环：只遍历对象自身的和继承的可枚举的属性<br>2.Object.keys()：返回对象自身的所有可枚举的属性的键名<br>3.JSON.stringify()：只串行化对象自身的可枚举的属性<br>ES6 新增了一个操作 Object.assign()，会忽略 enumerable 为 false 的属性，只拷贝对象自身的可枚举的属性。</p><p>这四个操作之中，只有 for…in 会返回继承的属性。实际上，引入 enumerable 的最初目的，就是让某些属性可以规避掉 for…in 操作。比如，对象原型的 toString 方法，以及数组的 length 属性，就通过这种手段，不会被 for…in 遍历到。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object.getOwnPropertyDescriptor(Object.prototype, <span class="string">'toString'</span>).enumerable</span><br><span class="line">// <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">Object.getOwnPropertyDescriptor([], <span class="string">'length'</span>).enumerable</span><br><span class="line">// <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>上面代码中，toString 和 length 属性的 enumerable 都是 false，因此 for…in 不会遍历到这两个继承自原型的属性。</p><p>另外，ES6 规定，所有 Class 的原型的方法都是不可枚举的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.getOwnPropertyDescriptor(class &#123;<span class="function"><span class="title">foo</span></span>() &#123;&#125;&#125;.prototype, <span class="string">'foo'</span>).enumerable</span><br><span class="line">// <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>总的来说，操作中引入继承的属性会让问题复杂化，大多数时候，我们只关心对象自身的属性。所以，尽量不要用 for…in 循环，而用 Object.keys()代替。</p><h5 id="属性的遍历"><a href="#属性的遍历" class="headerlink" title="属性的遍历"></a>属性的遍历</h5><p>ES6 一共有 5 种方法可以遍历对象的属性。</p><h6 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h6><p>for…in 循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。</p><h6 id="Object-keys-obj"><a href="#Object-keys-obj" class="headerlink" title="Object.keys(obj)"></a>Object.keys(obj)</h6><p>Object.keys 返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）。</p><h6 id="Object-getOwnPropertyNames-obj"><a href="#Object-getOwnPropertyNames-obj" class="headerlink" title="Object.getOwnPropertyNames(obj)"></a>Object.getOwnPropertyNames(obj)</h6><p>Object.getOwnPropertyNames 返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）。</p><h6 id="Object-getOwnPropertySymbols-obj"><a href="#Object-getOwnPropertySymbols-obj" class="headerlink" title="Object.getOwnPropertySymbols(obj)"></a>Object.getOwnPropertySymbols(obj)</h6><p>Object.getOwnPropertySymbols 返回一个数组，包含对象自身的所有 Symbol 属性。</p><h6 id="Reflect-ownKeys-obj"><a href="#Reflect-ownKeys-obj" class="headerlink" title="Reflect.ownKeys(obj)"></a>Reflect.ownKeys(obj)</h6><p>Reflect.ownKeys 返回一个数组，包含对象自身的所有属性，不管是属性名是 Symbol 或字符串，也不管是否可枚举。</p><p>以上的 5 种方法遍历对象的属性，都遵守同样的属性遍历的次序规则。</p><p>首先遍历所有属性名为数值的属性，按照数字排序。<br>其次遍历所有属性名为字符串的属性，按照生成时间排序。<br>最后遍历所有属性名为 Symbol 值的属性，按照生成时间排序。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Reflect.ownKeys(&#123; [Symbol()]:0, b:0, 10:0, 2:0, a:0 &#125;)</span><br><span class="line">// [<span class="string">'2'</span>, <span class="string">'10'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>, Symbol()]</span><br></pre></td></tr></table></figure><p>上面代码中，Reflect.ownKeys 方法返回一个数组，包含了参数对象的所有属性。这个数组的属性次序是这样的，首先是数值属性 2 和 10，其次是字符串属性 b 和 a，最后是 Symbol 属性。</p><h5 id="proto属性，Object-setPrototypeOf-，Object-getPrototypeOf"><a href="#proto属性，Object-setPrototypeOf-，Object-getPrototypeOf" class="headerlink" title="proto属性，Object.setPrototypeOf()，Object.getPrototypeOf()"></a><strong>proto</strong>属性，Object.setPrototypeOf()，Object.getPrototypeOf()</h5><h6 id="proto属性"><a href="#proto属性" class="headerlink" title="proto属性"></a><strong>proto</strong>属性</h6><p><strong>proto</strong>属性（前后各两个下划线），用来读取或设置当前对象的 prototype 对象。目前，所有浏览器（包括 IE11）都部署了这个属性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// es6的写法</span><br><span class="line">var obj = &#123;</span><br><span class="line">  method: <span class="function"><span class="title">function</span></span>() &#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.__proto__ = someOtherObj;</span><br><span class="line"></span><br><span class="line">// es5的写法</span><br><span class="line">var obj = Object.create(someOtherObj);</span><br><span class="line">obj.method = <span class="function"><span class="title">function</span></span>() &#123; ... &#125;;</span><br></pre></td></tr></table></figure><p>该属性没有写入 ES6 的正文，而是写入了附录，原因是<strong>proto</strong>前后的双下划线，说明它本质上是一个内部属性，而不是一个正式的对外的 API，只是由于浏览器广泛支持，才被加入了 ES6。标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的 Object.setPrototypeOf()（写操作）、Object.getPrototypeOf()（读操作）、Object.create()（生成操作）代替。</p><p>在实现上，<strong>proto</strong>调用的是 Object.prototype.<strong>proto</strong>，具体实现如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty(Object.prototype, <span class="string">'__proto__'</span>, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span></span>() &#123;</span><br><span class="line">    <span class="built_in">let</span> _thisObj = Object(this);</span><br><span class="line">    <span class="built_in">return</span> Object.getPrototypeOf(_thisObj);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">set</span>(proto) &#123;</span><br><span class="line">    <span class="keyword">if</span> (this === undefined || this === null) &#123;</span><br><span class="line">      throw new TypeError();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isObject(this)) &#123;</span><br><span class="line">      <span class="built_in">return</span> undefined;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isObject(proto)) &#123;</span><br><span class="line">      <span class="built_in">return</span> undefined;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">let</span> status = Reflect.setPrototypeOf(this, proto);</span><br><span class="line">    <span class="keyword">if</span> (!status) &#123;</span><br><span class="line">      throw new TypeError();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">function</span> isObject(value) &#123;</span><br><span class="line">  <span class="built_in">return</span> Object(value) === value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个对象本身部署了<strong>proto</strong>属性，则该属性的值就是对象的原型。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.getPrototypeOf(&#123; __proto__: null &#125;)</span><br><span class="line">// null</span><br></pre></td></tr></table></figure><h6 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h6><p>Object.setPrototypeOf 方法的作用与<strong>proto</strong>相同，用来设置一个对象的 prototype 对象。它是 ES6 正式推荐的设置原型对象的方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 格式</span><br><span class="line">Object.setPrototypeOf(object, prototype)</span><br><span class="line"></span><br><span class="line">// 用法</span><br><span class="line">var o = Object.setPrototypeOf(&#123;&#125;, null);</span><br></pre></td></tr></table></figure><p>该方法等同于下面的函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> (obj, proto) &#123;</span><br><span class="line">  obj.__proto__ = proto;</span><br><span class="line">  <span class="built_in">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> proto = &#123;&#125;;</span><br><span class="line"><span class="built_in">let</span> obj = &#123; x: 10 &#125;;</span><br><span class="line">Object.setPrototypeOf(obj, proto);</span><br><span class="line"></span><br><span class="line">proto.y = 20;</span><br><span class="line">proto.z = 40;</span><br><span class="line"></span><br><span class="line">obj.x // 10</span><br><span class="line">obj.y // 20</span><br><span class="line">obj.z // 40</span><br></pre></td></tr></table></figure><p>上面代码将 proto 对象设为 obj 对象的原型，所以从 obj 对象可以读取 proto 对象的属性。</p><h6 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h6><p>该方法与 setPrototypeOf 方法配套，用于读取一个对象的 prototype 对象。</p><p>Object.getPrototypeOf(obj);<br>下面是一个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Rectangle</span></span>() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var rec = new Rectangle();</span><br><span class="line"></span><br><span class="line">Object.getPrototypeOf(rec) === Rectangle.prototype</span><br><span class="line">// <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">Object.setPrototypeOf(rec, Object.prototype);</span><br><span class="line">Object.getPrototypeOf(rec) === Rectangle.prototype</span><br><span class="line">// <span class="literal">false</span></span><br></pre></td></tr></table></figure><h4 id="Object-values-，Object-entries"><a href="#Object-values-，Object-entries" class="headerlink" title="Object.values()，Object.entries()"></a>Object.values()，Object.entries()</h4><h5 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h5><p>ES5 引入了 Object.keys 方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; foo: <span class="string">"bar"</span>, baz: 42 &#125;;</span><br><span class="line">Object.keys(obj)</span><br><span class="line">// [<span class="string">"foo"</span>, <span class="string">"baz"</span>]</span><br></pre></td></tr></table></figure><p>目前，ES7 有一个提案，引入了跟 Object.keys 配套的 Object.values 和 Object.entries。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> &#123;keys, values, entries&#125; = Object;</span><br><span class="line"><span class="built_in">let</span> obj = &#123; a: 1, b: 2, c: 3 &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> key of keys(obj)) &#123;</span><br><span class="line">  console.log(key); // <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> value of values(obj)) &#123;</span><br><span class="line">  console.log(value); // 1, 2, 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> [key, value] of entries(obj)) &#123;</span><br><span class="line">  console.log([key, value]); // [<span class="string">'a'</span>, 1], [<span class="string">'b'</span>, 2], [<span class="string">'c'</span>, 3]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values()"></a>Object.values()</h5><p>Object.values 方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; foo: <span class="string">"bar"</span>, baz: 42 &#125;;</span><br><span class="line">Object.values(obj)</span><br><span class="line">// [<span class="string">"bar"</span>, 42]</span><br></pre></td></tr></table></figure><p>返回数组的成员顺序，与本章的《属性的遍历》部分介绍的排列规则一致。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; 100: <span class="string">'a'</span>, 2: <span class="string">'b'</span>, 7: <span class="string">'c'</span> &#125;;</span><br><span class="line">Object.values(obj)</span><br><span class="line">// [<span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"a"</span>]</span><br></pre></td></tr></table></figure><p>上面代码中，属性名为数值的属性，是按照数值大小，从小到大遍历的，因此返回的顺序是 b、c、a。</p><p>Object.values 只返回对象自身的可遍历属性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj = Object.create(&#123;&#125;, &#123;p: &#123;value: 42&#125;&#125;);</span><br><span class="line">Object.values(obj) // []</span><br></pre></td></tr></table></figure><p>上面代码中，Object.create 方法的第二个参数添加的对象属性（属性 p），如果不显式声明，默认是不可遍历的。Object.values 不会返回这个属性。</p><p>Object.values 会过滤属性名为 Symbol 值的属性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.values(&#123; [Symbol()]: 123, foo: <span class="string">'abc'</span> &#125;);</span><br><span class="line">// [<span class="string">'abc'</span>]</span><br></pre></td></tr></table></figure><p>如果 Object.values 方法的参数是一个字符串，会返回各个字符组成的一个数组。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.values(<span class="string">'foo'</span>)</span><br><span class="line">// [<span class="string">'f'</span>, <span class="string">'o'</span>, <span class="string">'o'</span>]</span><br></pre></td></tr></table></figure><p>上面代码中，字符串会先转成一个类似数组的对象。字符串的每个字符，就是该对象的一个属性。因此，Object.values 返回每个属性的键值，就是各个字符组成的一个数组。</p><p>如果参数不是对象，Object.values 会先将其转为对象。由于数值和布尔值的包装对象，都不会为实例添加非继承的属性。所以，Object.values 会返回空数组。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.values(42) // []</span><br><span class="line">Object.values(<span class="literal">true</span>) // []</span><br></pre></td></tr></table></figure><h5 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries"></a>Object.entries</h5><p>Object.entries 方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; foo: <span class="string">'bar'</span>, baz: 42 &#125;;</span><br><span class="line">Object.entries(obj)</span><br><span class="line">// [ [<span class="string">"foo"</span>, <span class="string">"bar"</span>], [<span class="string">"baz"</span>, 42] ]</span><br></pre></td></tr></table></figure><p>除了返回值不一样，该方法的行为与 Object.values 基本一致。</p><p>如果原对象的属性名是一个 Symbol 值，该属性会被省略。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.entries(&#123; [Symbol()]: 123, foo: <span class="string">'abc'</span> &#125;);</span><br><span class="line">// [ [ <span class="string">'foo'</span>, <span class="string">'abc'</span> ] ]</span><br></pre></td></tr></table></figure><p>上面代码中，原对象有两个属性，Object.entries 只输出属性名非 Symbol 值的属性。将来可能会有 Reflect.ownEntries()方法，返回对象自身的所有属性。</p><p>Object.entries 的基本用途是遍历对象的属性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> obj = &#123; one: 1, two: 2 &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> [k, v] of Object.entries(obj)) &#123;</span><br><span class="line">  console.log(`<span class="variable">$&#123;JSON.stringify(k)&#125;</span>: <span class="variable">$&#123;JSON.stringify(v)&#125;</span>`);</span><br><span class="line">&#125;</span><br><span class="line">// <span class="string">"one"</span>: 1</span><br><span class="line">// <span class="string">"two"</span>: 2</span><br></pre></td></tr></table></figure><p>Object.entries 方法的一个用处是，将对象转为真正的 Map 结构。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; foo: <span class="string">'bar'</span>, baz: 42 &#125;;</span><br><span class="line">var map = new Map(Object.entries(obj));</span><br><span class="line">map // Map &#123; foo: <span class="string">"bar"</span>, baz: 42 &#125;</span><br></pre></td></tr></table></figure><p>自己实现 Object.entries 方法，非常简单。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Generator函数的版本</span><br><span class="line"><span class="keyword">function</span>* entries(obj) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">let</span> key of Object.keys(obj)) &#123;</span><br><span class="line">    yield [key, obj[key]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 非Generator函数的版本</span><br><span class="line"><span class="keyword">function</span> entries(obj) &#123;</span><br><span class="line">  <span class="built_in">let</span> arr = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">let</span> key of Object.keys(obj)) &#123;</span><br><span class="line">    arr.push([key, obj[key]]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对象的扩展运算符"><a href="#对象的扩展运算符" class="headerlink" title="对象的扩展运算符"></a>对象的扩展运算符</h4><p>目前，ES7 有一个提案，将 Rest 运算符（解构赋值）/扩展运算符（…）引入对象。Babel 转码器已经支持这项功能。</p><h5 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h5><p>对象的解构赋值用于从一个对象取值，相当于将所有可遍历的、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;;</span><br><span class="line">x // 1</span><br><span class="line">y // 2</span><br><span class="line">z // &#123; a: 3, b: 4 &#125;</span><br></pre></td></tr></table></figure><p>上面代码中，变量 z 是解构赋值所在的对象。它获取等号右边的所有尚未读取的键（a 和 b），将它们连同值一起拷贝过来。</p><p>由于解构赋值要求等号右边是一个对象，所以如果等号右边是 undefined 或 null，就会报错，因为它们无法转为对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> &#123; x, y, ...z &#125; = null; // 运行时错误</span><br><span class="line"><span class="built_in">let</span> &#123; x, y, ...z &#125; = undefined; // 运行时错误</span><br></pre></td></tr></table></figure><p>解构赋值必须是最后一个参数，否则会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> &#123; ...x, y, z &#125; = obj; // 句法错误</span><br><span class="line"><span class="built_in">let</span> &#123; x, ...y, ...z &#125; = obj; // 句法错误</span><br></pre></td></tr></table></figure><p>上面代码中，解构赋值不是最后一个参数，所以会报错。</p><p>注意，解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> obj = &#123; a: &#123; b: 1 &#125; &#125;;</span><br><span class="line"><span class="built_in">let</span> &#123; ...x &#125; = obj;</span><br><span class="line">obj.a.b = 2;</span><br><span class="line">x.a.b // 2</span><br></pre></td></tr></table></figure><p>上面代码中，x 是解构赋值所在的对象，拷贝了对象 obj 的 a 属性。a 属性引用了一个对象，修改这个对象的值，会影响到解构赋值对它的引用。</p><p>另外，解构赋值不会拷贝继承自原型对象的属性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> o1 = &#123; a: 1 &#125;;</span><br><span class="line"><span class="built_in">let</span> o2 = &#123; b: 2 &#125;;</span><br><span class="line">o2.__proto__ = o1;</span><br><span class="line"><span class="built_in">let</span> o3 = &#123; ...o2 &#125;;</span><br><span class="line">o3 // &#123; b: 2 &#125;</span><br></pre></td></tr></table></figure><p>上面代码中，对象 o3 是 o2 的拷贝，但是只复制了 o2 自身的属性，没有复制它的原型对象 o1 的属性。</p><p>下面是另一个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var o = Object.create(&#123; x: 1, y: 2 &#125;);</span><br><span class="line">o.z = 3;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> &#123; x, ...&#123; y, z &#125; &#125; = o;</span><br><span class="line">x // 1</span><br><span class="line">y // undefined</span><br><span class="line">z // 3</span><br></pre></td></tr></table></figure><p>上面代码中，变量 x 是单纯的解构赋值，所以可以读取继承的属性；解构赋值产生的变量 y 和 z，只能读取对象自身的属性，所以只有变量 z 可以赋值成功。</p><p>解构赋值的一个用处，是扩展某个函数的参数，引入其他操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> baseFunction(&#123; a, b &#125;) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> wrapperFunction(&#123; x, y, ...restConfig &#125;) &#123;</span><br><span class="line">  // 使用x和y参数进行操作</span><br><span class="line">  // 其余参数传给原始函数</span><br><span class="line">  <span class="built_in">return</span> baseFunction(restConfig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，原始函数 baseFunction 接受 a 和 b 作为参数，函数 wrapperFunction 在 baseFunction 的基础上进行了扩展，能够接受多余的参数，并且保留原始函数的行为。</p><h5 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h5><p>扩展运算符（…）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> z = &#123; a: 3, b: 4 &#125;;</span><br><span class="line"><span class="built_in">let</span> n = &#123; ...z &#125;;</span><br><span class="line">n // &#123; a: 3, b: 4 &#125;</span><br></pre></td></tr></table></figure><p>这等同于使用 Object.assign 方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> aClone = &#123; ...a &#125;;</span><br><span class="line">// 等同于</span><br><span class="line"><span class="built_in">let</span> aClone = Object.assign(&#123;&#125;, a);</span><br></pre></td></tr></table></figure><p>扩展运算符可以用于合并两个对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> ab = &#123; ...a, ...b &#125;;</span><br><span class="line">// 等同于</span><br><span class="line"><span class="built_in">let</span> ab = Object.assign(&#123;&#125;, a, b);</span><br></pre></td></tr></table></figure><p>如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> aWithOverrides = &#123; ...a, x: 1, y: 2 &#125;;</span><br><span class="line">// 等同于</span><br><span class="line"><span class="built_in">let</span> aWithOverrides = &#123; ...a, ...&#123; x: 1, y: 2 &#125; &#125;;</span><br><span class="line">// 等同于</span><br><span class="line"><span class="built_in">let</span> x = 1, y = 2, aWithOverrides = &#123; ...a, x, y &#125;;</span><br><span class="line">// 等同于</span><br><span class="line"><span class="built_in">let</span> aWithOverrides = Object.assign(&#123;&#125;, a, &#123; x: 1, y: 2 &#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，a 对象的 x 属性和 y 属性，拷贝到新对象后会被覆盖掉。</p><p>这用来修改现有对象部分的部分属性就很方便了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> newVersion = &#123;</span><br><span class="line">  ...previousVersion,</span><br><span class="line">  name: <span class="string">'New Name'</span> // Override the name property</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，newVersion 对象自定义了 name 属性，其他属性全部复制自 previousVersion 对象。</p><p>如果把自定义属性放在扩展运算符前面，就变成了设置新对象的默认属性值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> aWithDefaults = &#123; x: 1, y: 2, ...a &#125;;</span><br><span class="line">// 等同于</span><br><span class="line"><span class="built_in">let</span> aWithDefaults = Object.assign(&#123;&#125;, &#123; x: 1, y: 2 &#125;, a);</span><br><span class="line">// 等同于</span><br><span class="line"><span class="built_in">let</span> aWithDefaults = Object.assign(&#123; x: 1, y: 2 &#125;, a);</span><br></pre></td></tr></table></figure><p>扩展运算符的参数对象之中，如果有取值函数 get，这个函数是会执行的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 并不会抛出错误，因为x属性只是被定义，但没执行</span><br><span class="line"><span class="built_in">let</span> aWithXGetter = &#123;</span><br><span class="line">  ...a,</span><br><span class="line">  get <span class="function"><span class="title">x</span></span>() &#123;</span><br><span class="line">    throws new Error(<span class="string">'not thrown yet'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 会抛出错误，因为x属性被执行了</span><br><span class="line"><span class="built_in">let</span> runtimeError = &#123;</span><br><span class="line">  ...a,</span><br><span class="line">  ...&#123;</span><br><span class="line">    get <span class="function"><span class="title">x</span></span>() &#123;</span><br><span class="line">      throws new Error(<span class="string">'thrown now'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果扩展运算符的参数是 null 或 undefined，这个两个值会被忽略，不会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> emptyObject = &#123; ...null, ...undefined &#125;; // 不报错</span><br></pre></td></tr></table></figure><h4 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h4><p>ES5 有一个 Object.getOwnPropertyDescriptor 方法，返回某个对象属性的描述对象（descriptor）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; p: <span class="string">'a'</span> &#125;;</span><br><span class="line"></span><br><span class="line">Object.getOwnPropertyDescriptor(obj, <span class="string">'p'</span>)</span><br><span class="line">// Object &#123; value: <span class="string">"a"</span>,</span><br><span class="line">//   writable: <span class="literal">true</span>,</span><br><span class="line">//   enumerable: <span class="literal">true</span>,</span><br><span class="line">//   configurable: <span class="literal">true</span></span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure><p>ES7 有一个提案，提出了 Object.getOwnPropertyDescriptors 方法，返回指定对象所有自身属性（非继承属性）的描述对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line">  foo: 123,</span><br><span class="line">  get <span class="function"><span class="title">bar</span></span>() &#123; <span class="built_in">return</span> <span class="string">'abc'</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.getOwnPropertyDescriptors(obj)</span><br><span class="line">// &#123; foo:</span><br><span class="line">//    &#123; value: 123,</span><br><span class="line">//      writable: <span class="literal">true</span>,</span><br><span class="line">//      enumerable: <span class="literal">true</span>,</span><br><span class="line">//      configurable: <span class="literal">true</span> &#125;,</span><br><span class="line">//   bar:</span><br><span class="line">//    &#123; get: [Function: bar],</span><br><span class="line">//      <span class="built_in">set</span>: undefined,</span><br><span class="line">//      enumerable: <span class="literal">true</span>,</span><br><span class="line">//      configurable: <span class="literal">true</span> &#125; &#125;</span><br></pre></td></tr></table></figure><p>Object.getOwnPropertyDescriptors 方法返回一个对象，所有原对象的属性名都是该对象的属性名，对应的属性值就是该属性的描述对象。</p><p>该方法的实现非常容易。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> getOwnPropertyDescriptors(obj) &#123;</span><br><span class="line">  const result = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">let</span> key of Reflect.ownKeys(obj)) &#123;</span><br><span class="line">    result[key] = Object.getOwnPropertyDescriptor(obj, key);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法的提出目的，主要是为了解决 Object.assign()无法正确拷贝 get 属性和 set 属性的问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const <span class="built_in">source</span> = &#123;</span><br><span class="line">  <span class="built_in">set</span> foo(value) &#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const target1 = &#123;&#125;;</span><br><span class="line">Object.assign(target1, <span class="built_in">source</span>);</span><br><span class="line"></span><br><span class="line">Object.getOwnPropertyDescriptor(target1, <span class="string">'foo'</span>)</span><br><span class="line">// &#123; value: undefined,</span><br><span class="line">//   writable: <span class="literal">true</span>,</span><br><span class="line">//   enumerable: <span class="literal">true</span>,</span><br><span class="line">//   configurable: <span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure><p>上面代码中，source 对象的 foo 属性的值是一个赋值函数，Object.assign 方法将这个属性拷贝给 target1 对象，结果该属性的值变成了 undefined。这是因为 Object.assign 方法总是拷贝一个属性的值，而不会拷贝它背后的赋值方法或取值方法。</p><p>这时，Object.getOwnPropertyDescriptors 方法配合 Object.defineProperties 方法，就可以实现正确拷贝。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const <span class="built_in">source</span> = &#123;</span><br><span class="line">  <span class="built_in">set</span> foo(value) &#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const target2 = &#123;&#125;;</span><br><span class="line">Object.defineProperties(target2, Object.getOwnPropertyDescriptors(<span class="built_in">source</span>));</span><br><span class="line">Object.getOwnPropertyDescriptor(target2, <span class="string">'foo'</span>)</span><br><span class="line">// &#123; get: undefined,</span><br><span class="line">//   <span class="built_in">set</span>: [Function: foo],</span><br><span class="line">//   enumerable: <span class="literal">true</span>,</span><br><span class="line">//   configurable: <span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure><p>上面代码中，将两个对象合并的逻辑提炼出来，就是下面这样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const shallowMerge = (target, <span class="built_in">source</span>) =&gt; Object.defineProperties(</span><br><span class="line">  target,</span><br><span class="line">  Object.getOwnPropertyDescriptors(<span class="built_in">source</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>Object.getOwnPropertyDescriptors 方法的另一个用处，是配合 Object.create 方法，将对象属性克隆到一个新对象。这属于浅拷贝。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const <span class="built_in">clone</span> = Object.create(Object.getPrototypeOf(obj),</span><br><span class="line">  Object.getOwnPropertyDescriptors(obj));</span><br><span class="line"></span><br><span class="line">// 或者</span><br><span class="line"></span><br><span class="line">const shallowClone = (obj) =&gt; Object.create(</span><br><span class="line">  Object.getPrototypeOf(obj),</span><br><span class="line">  Object.getOwnPropertyDescriptors(obj)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面代码会克隆对象 obj。</p><p>另外，Object.getOwnPropertyDescriptors 方法可以实现，一个对象继承另一个对象。以前，继承另一个对象，常常写成下面这样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line">  __proto__: prot,</span><br><span class="line">  foo: 123,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>ES6 规定<strong>proto</strong>只有浏览器要部署，其他环境不用部署。如果去除<strong>proto</strong>，上面代码就要改成下面这样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const obj = Object.create(prot);</span><br><span class="line">obj.foo = 123;</span><br><span class="line"></span><br><span class="line">// 或者</span><br><span class="line"></span><br><span class="line">const obj = Object.assign(</span><br><span class="line">  Object.create(prot),</span><br><span class="line">  &#123;</span><br><span class="line">    foo: 123,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>有了 Object.getOwnPropertyDescriptors，我们就有了另一种写法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const obj = Object.create(</span><br><span class="line">  prot,</span><br><span class="line">  Object.getOwnPropertyDescriptors(&#123;</span><br><span class="line">    foo: 123,</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>Object.getOwnPropertyDescriptors 也可以用来实现 Mixin（混入）模式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> mix = (object) =&gt; (&#123;</span><br><span class="line">  with: (...mixins) =&gt; mixins.reduce(</span><br><span class="line">    (c, mixin) =&gt; Object.create(</span><br><span class="line">      c, Object.getOwnPropertyDescriptors(mixin)</span><br><span class="line">    ), object)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// multiple mixins example</span><br><span class="line"><span class="built_in">let</span> a = &#123;a: <span class="string">'a'</span>&#125;;</span><br><span class="line"><span class="built_in">let</span> b = &#123;b: <span class="string">'b'</span>&#125;;</span><br><span class="line"><span class="built_in">let</span> c = &#123;c: <span class="string">'c'</span>&#125;;</span><br><span class="line"><span class="built_in">let</span> d = mix(c).with(a, b);</span><br></pre></td></tr></table></figure><p>上面代码中，对象 a 和 b 被混入了对象 c。</p><p>出于完整性的考虑，Object.getOwnPropertyDescriptors 进入标准以后，还会有 Reflect.getOwnPropertyDescriptors 方法。</p>]]></content>
      
      
      <categories>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6_Function</title>
      <link href="/2019/02/01/es6-Function/"/>
      <url>/2019/02/01/es6-Function/</url>
      
        <content type="html"><![CDATA[<h3 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h3><h4 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h4><h5 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h5><p>在 ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="built_in">log</span>(x, y) &#123;</span><br><span class="line">  y = y || <span class="string">'World'</span>;</span><br><span class="line">  console.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">log</span>(<span class="string">'Hello'</span>) // Hello World</span><br><span class="line"><span class="built_in">log</span>(<span class="string">'Hello'</span>, <span class="string">'China'</span>) // Hello China</span><br><span class="line"><span class="built_in">log</span>(<span class="string">'Hello'</span>, <span class="string">''</span>) // Hello World</span><br></pre></td></tr></table></figure><p>上面代码检查函数 log 的参数 y 有没有赋值，如果没有，则指定默认值为 World。这种写法的缺点在于，如果参数 y 赋值了，但是对应的布尔值为 false，则该赋值不起作用。就像上面代码的最后一行，参数 y 等于空字符，结果被改为默认值。</p><p>为了避免这个问题，通常需要先判断一下参数 y 是否被赋值，如果没有，再等于默认值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (typeof y === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">  y = <span class="string">'World'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="built_in">log</span>(x, y = <span class="string">'World'</span>) &#123;</span><br><span class="line">  console.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">log</span>(<span class="string">'Hello'</span>) // Hello World</span><br><span class="line"><span class="built_in">log</span>(<span class="string">'Hello'</span>, <span class="string">'China'</span>) // Hello China</span><br><span class="line"><span class="built_in">log</span>(<span class="string">'Hello'</span>, <span class="string">''</span>) // Hello</span><br></pre></td></tr></table></figure><p>可以看到，ES6 的写法比 ES5 简洁许多，而且非常自然。下面是另一个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Point(x = 0, y = 0) &#123;</span><br><span class="line">  this.x = x;</span><br><span class="line">  this.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p = new Point();</span><br><span class="line">p // &#123; x: 0, y: 0 &#125;</span><br></pre></td></tr></table></figure><p>除了简洁，ES6 的写法还有两个好处：首先，阅读代码的人，可以立刻意识到哪些参数是可以省略的，不用查看函数体或文档；其次，有利于将来的代码优化，即使未来的版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行。</p><p>参数变量是默认声明的，所以不能用 let 或 const 再次声明。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> foo(x = 5) &#123;</span><br><span class="line">  <span class="built_in">let</span> x = 1; // error</span><br><span class="line">  const x = 2; // error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，参数变量 x 是默认声明的，在函数体中，不能用 let 或 const 再次声明，否则会报错。</p><h5 id="与解构赋值默认值结合使用"><a href="#与解构赋值默认值结合使用" class="headerlink" title="与解构赋值默认值结合使用"></a>与解构赋值默认值结合使用</h5><p>参数默认值可以与解构赋值的默认值，结合起来使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> foo(&#123;x, y = 5&#125;) &#123;</span><br><span class="line">  console.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(&#123;&#125;) // undefined, 5</span><br><span class="line">foo(&#123;x: 1&#125;) // 1, 5</span><br><span class="line">foo(&#123;x: 1, y: 2&#125;) // 1, 2</span><br><span class="line">foo() // TypeError: Cannot <span class="built_in">read</span> property <span class="string">'x'</span> of undefined</span><br></pre></td></tr></table></figure><p>上面代码使用了对象的解构赋值默认值，而没有使用函数参数的默认值。只有当函数 foo 的参数是一个对象时，变量 x 和 y 才会通过解构赋值而生成。如果函数 foo 调用时参数不是对象，变量 x 和 y 就不会生成，从而报错。如果参数对象没有 y 属性，y 的默认值 5 才会生效。</p><p>下面是另一个对象的解构赋值默认值的例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> fetch(url, &#123; body = <span class="string">''</span>, method = <span class="string">'GET'</span>, headers = &#123;&#125; &#125;) &#123;</span><br><span class="line">  console.log(method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fetch(<span class="string">'http://example.com'</span>, &#123;&#125;)</span><br><span class="line">// <span class="string">"GET"</span></span><br><span class="line"></span><br><span class="line">fetch(<span class="string">'http://example.com'</span>)</span><br><span class="line">// 报错</span><br></pre></td></tr></table></figure><p>上面代码中，如果函数 fetch 的第二个参数是一个对象，就可以为它的三个属性设置默认值。</p><p>上面的写法不能省略第二个参数，如果结合函数参数的默认值，就可以省略第二个参数。这时，就出现了双重默认值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> fetch(url, &#123; method = <span class="string">'GET'</span> &#125; = &#123;&#125;) &#123;</span><br><span class="line">  console.log(method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fetch(<span class="string">'http://example.com'</span>)</span><br><span class="line">// <span class="string">"GET"</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数 fetch 没有第二个参数时，函数参数的默认值就会生效，然后才是解构赋值的默认值生效，变量 method 才会取到默认值 GET。</p><p>再请问下面两种写法有什么差别？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 写法一</span><br><span class="line"><span class="keyword">function</span> m1(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123;</span><br><span class="line">  <span class="built_in">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 写法二</span><br><span class="line"><span class="keyword">function</span> m2(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123;</span><br><span class="line">  <span class="built_in">return</span> [x, y];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两种写法都对函数的参数设定了默认值，区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 函数没有参数的情况</span><br><span class="line">m1() // [0, 0]</span><br><span class="line">m2() // [0, 0]</span><br><span class="line"></span><br><span class="line">// x和y都有值的情况</span><br><span class="line">m1(&#123;x: 3, y: 8&#125;) // [3, 8]</span><br><span class="line">m2(&#123;x: 3, y: 8&#125;) // [3, 8]</span><br><span class="line"></span><br><span class="line">// x有值，y无值的情况</span><br><span class="line">m1(&#123;x: 3&#125;) // [3, 0]</span><br><span class="line">m2(&#123;x: 3&#125;) // [3, undefined]</span><br><span class="line"></span><br><span class="line">// x和y都无值的情况</span><br><span class="line">m1(&#123;&#125;) // [0, 0];</span><br><span class="line">m2(&#123;&#125;) // [undefined, undefined]</span><br><span class="line"></span><br><span class="line">m1(&#123;z: 3&#125;) // [0, 0]</span><br><span class="line">m2(&#123;z: 3&#125;) // [undefined, undefined]</span><br></pre></td></tr></table></figure><h5 id="参数默认值的位置"><a href="#参数默认值的位置" class="headerlink" title="参数默认值的位置"></a>参数默认值的位置</h5><p>通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 例一</span><br><span class="line"><span class="keyword">function</span> f(x = 1, y) &#123;</span><br><span class="line">  <span class="built_in">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() // [1, undefined]</span><br><span class="line">f(2) // [2, undefined])</span><br><span class="line">f(, 1) // 报错</span><br><span class="line">f(undefined, 1) // [1, 1]</span><br><span class="line"></span><br><span class="line">// 例二</span><br><span class="line"><span class="keyword">function</span> f(x, y = 5, z) &#123;</span><br><span class="line">  <span class="built_in">return</span> [x, y, z];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() // [undefined, 5, undefined]</span><br><span class="line">f(1) // [1, 5, undefined]</span><br><span class="line">f(1, ,2) // 报错</span><br><span class="line">f(1, undefined, 2) // [1, 5, 2]</span><br></pre></td></tr></table></figure><p>上面代码中，有默认值的参数都不是尾参数。这时，无法只省略该参数，而不省略它后面的参数，除非显式输入 undefined。</p><p>如果传入 undefined，将触发该参数等于默认值，null 则没有这个效果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> foo(x = 5, y = 6) &#123;</span><br><span class="line">  console.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(undefined, null)</span><br><span class="line">// 5 null</span><br></pre></td></tr></table></figure><p>上面代码中，x 参数对应 undefined，结果触发了默认值，y 参数等于 null，就没有触发默认值。</p><h5 id="函数的-length-属性"><a href="#函数的-length-属性" class="headerlink" title="函数的 length 属性"></a>函数的 length 属性</h5><p>指定了默认值以后，函数的 length 属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length 属性将失真。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (a) &#123;&#125;).length // 1</span><br><span class="line">(<span class="keyword">function</span> (a = 5) &#123;&#125;).length // 0</span><br><span class="line">(<span class="keyword">function</span> (a, b, c = 5) &#123;&#125;).length // 2</span><br></pre></td></tr></table></figure><p>上面代码中，length 属性的返回值，等于函数的参数个数减去指定了默认值的参数个数。比如，上面最后一个函数，定义了 3 个参数，其中有一个参数 c 指定了默认值，因此 length 属性等于 3 减去 1，最后得到 2。</p><p>这是因为 length 属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，rest 参数也不会计入 length 属性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(...args) &#123;&#125;).length // 0</span><br></pre></td></tr></table></figure><p>如果设置了默认值的参数不是尾参数，那么 length 属性也不再计入后面的参数了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (a = 0, b, c) &#123;&#125;).length // 0</span><br><span class="line">(<span class="keyword">function</span> (a, b = 1, c) &#123;&#125;).length // 1</span><br></pre></td></tr></table></figure><h5 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h5><p>一个需要注意的地方是，如果参数默认值是一个变量，则该变量所处的作用域，与其他变量的作用域规则是一样的，即先是当前函数的作用域，然后才是全局作用域。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var x = 1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> f(x, y = x) &#123;</span><br><span class="line">  console.log(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(2) // 2</span><br></pre></td></tr></table></figure><p>上面代码中，参数 y 的默认值等于 x。调用时，由于函数作用域内部的变量 x 已经生成，所以 y 等于参数 x，而不是全局变量 x。</p><p>如果调用时，函数作用域内部的变量 x 没有生成，结果就会不一样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> x = 1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> f(y = x) &#123;</span><br><span class="line">  <span class="built_in">let</span> x = 2;</span><br><span class="line">  console.log(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() // 1</span><br></pre></td></tr></table></figure><p>上面代码中，函数调用时，y 的默认值变量 x 尚未在函数内部生成，所以 x 指向全局变量。</p><p>如果此时，全局变量 x 不存在，就会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> f(y = x) &#123;</span><br><span class="line">  <span class="built_in">let</span> x = 2;</span><br><span class="line">  console.log(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() // ReferenceError: x is not defined</span><br></pre></td></tr></table></figure><p>下面这样写，也会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var x = 1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> foo(x = x) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() // ReferenceError: x is not defined</span><br></pre></td></tr></table></figure><p>上面代码中，函数 foo 的参数 x 的默认值也是 x。这时，默认值 x 的作用域是函数作用域，而不是全局作用域。由于在函数作用域中，存在变量 x，但是默认值在 x 赋值之前先执行了，所以这时属于暂时性死区（参见《let 和 const 命令》一章），任何对 x 的操作都会报错。</p><p>如果参数的默认值是一个函数，该函数的作用域是其声明时所在的作用域。请看下面的例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> foo = <span class="string">'outer'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> bar(func = x =&gt; foo) &#123;</span><br><span class="line">  <span class="built_in">let</span> foo = <span class="string">'inner'</span>;</span><br><span class="line">  console.log(func()); // outer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar();</span><br></pre></td></tr></table></figure><p>上面代码中，函数 bar 的参数 func 的默认值是一个匿名函数，返回值为变量 foo。这个匿名函数声明时，bar 函数的作用域还没有形成，所以匿名函数里面的 foo 指向外层作用域的 foo，输出 outer。</p><p>如果写成下面这样，就会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> bar(func = () =&gt; foo) &#123;</span><br><span class="line">  <span class="built_in">let</span> foo = <span class="string">'inner'</span>;</span><br><span class="line">  console.log(func());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar() // ReferenceError: foo is not defined</span><br></pre></td></tr></table></figure><p>上面代码中，匿名函数里面的 foo 指向函数外层，但是函数外层并没有声明 foo，所以就报错了。</p><p>下面是一个更复杂的例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var x = 1;</span><br><span class="line"><span class="keyword">function</span> foo(x, y = <span class="function"><span class="title">function</span></span>() &#123; x = 2; &#125;) &#123;</span><br><span class="line">  var x = 3;</span><br><span class="line">  y();</span><br><span class="line">  console.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() // 3</span><br></pre></td></tr></table></figure><p>上面代码中，函数 foo 的参数 y 的默认值是一个匿名函数。函数 foo 调用时，它的参数 x 的值为 undefined，所以 y 函数内部的 x 一开始是 undefined，后来被重新赋值 2。但是，函数 foo 内部重新声明了一个 x，值为 3，这两个 x 是不一样的，互相不产生影响，因此最后输出 3。</p><p>如果将 var x = 3 的 var 去除，两个 x 就是一样的，最后输出的就是 2。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var x = 1;</span><br><span class="line"><span class="keyword">function</span> foo(x, y = <span class="function"><span class="title">function</span></span>() &#123; x = 2; &#125;) &#123;</span><br><span class="line">  x = 3;</span><br><span class="line">  y();</span><br><span class="line">  console.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() // 2</span><br></pre></td></tr></table></figure><h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><p>利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">throwIfMissing</span></span>() &#123;</span><br><span class="line">  throw new Error(<span class="string">'Missing parameter'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> foo(mustBeProvided = throwIfMissing()) &#123;</span><br><span class="line">  <span class="built_in">return</span> mustBeProvided;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line">// Error: Missing parameter</span><br></pre></td></tr></table></figure><p>上面代码的 foo 函数，如果调用的时候没有参数，就会调用默认值 throwIfMissing 函数，从而抛出一个错误。</p><p>从上面代码还可以看到，参数 mustBeProvided 的默认值等于 throwIfMissing 函数的运行结果（即函数名之后有一对圆括号），这表明参数的默认值不是在定义时执行，而是在运行时执行（即如果参数已经赋值，默认值中的函数就不会运行），这与 python 语言不一样。</p><p>另外，可以将参数默认值设为 undefined，表明这个参数是可以省略的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> foo(optional = undefined) &#123; ··· &#125;</span><br></pre></td></tr></table></figure><h5 id="rest-参数"><a href="#rest-参数" class="headerlink" title="rest 参数"></a>rest 参数</h5><p>ES6 引入 rest 参数（形式为“…变量名”），用于获取函数的多余参数，这样就不需要使用 arguments 对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> add(...values) &#123;</span><br><span class="line">  <span class="built_in">let</span> sum = 0;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (var val of values) &#123;</span><br><span class="line">    sum += val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(2, 5, 3) // 10</span><br></pre></td></tr></table></figure><p>上面代码的 add 函数是一个求和函数，利用 rest 参数，可以向该函数传入任意数目的参数。</p><p>下面是一个 rest 参数代替 arguments 变量的例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// arguments变量的写法</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">sortNumbers</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> Array.prototype.slice.call(arguments).sort();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// rest参数的写法</span><br><span class="line">const sortNumbers = (...numbers) =&gt; numbers.sort();</span><br></pre></td></tr></table></figure><p>上面代码的两种写法，比较后可以发现，rest 参数的写法更自然也更简洁。</p><p>rest 参数中的变量代表一个数组，所以数组特有的方法都可以用于这个变量。下面是一个利用 rest 参数改写数组 push 方法的例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> push(array, ...items) &#123;</span><br><span class="line">  items.forEach(<span class="keyword">function</span>(item) &#123;</span><br><span class="line">    array.push(item);</span><br><span class="line">    console.log(item);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = [];</span><br><span class="line">push(a, 1, 2, 3)</span><br></pre></td></tr></table></figure><p>注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line"><span class="keyword">function</span> f(a, ...b, c) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的 length 属性，不包括 rest 参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(a) &#123;&#125;).length  // 1</span><br><span class="line">(<span class="keyword">function</span>(...a) &#123;&#125;).length  // 0</span><br><span class="line">(<span class="keyword">function</span>(a, ...b) &#123;&#125;).length  // 1</span><br></pre></td></tr></table></figure><h4 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h4><h5 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h5><p>扩展运算符（spread）是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">console.log(...[1, 2, 3])</span><br><span class="line">// 1 2 3</span><br><span class="line"></span><br><span class="line">console.log(1, ...[2, 3, 4], 5)</span><br><span class="line">// 1 2 3 4 5</span><br><span class="line"></span><br><span class="line">[...document.querySelectorAll(<span class="string">'div'</span>)]</span><br><span class="line">// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]</span><br></pre></td></tr></table></figure><p>该运算符主要用于函数调用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> push(array, ...items) &#123;</span><br><span class="line">  array.push(...items);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> add(x, y) &#123;</span><br><span class="line">  <span class="built_in">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var numbers = [4, 38];</span><br><span class="line">add(...numbers) // 42</span><br></pre></td></tr></table></figure><p>上面代码中，array.push(…items)和 add(…numbers)这两行，都是函数的调用，它们的都使用了扩展运算符。该运算符将一个数组，变为参数序列。</p><p>扩展运算符与正常的函数参数可以结合使用，非常灵活。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> f(v, w, x, y, z) &#123; &#125;</span><br><span class="line">var args = [0, 1];</span><br><span class="line">f(-1, ...args, 2, ...[3]);</span><br></pre></td></tr></table></figure><h5 id="替代数组的-apply-方法"><a href="#替代数组的-apply-方法" class="headerlink" title="替代数组的 apply 方法"></a>替代数组的 apply 方法</h5><p>由于扩展运算符可以展开数组，所以不再需要 apply 方法，将数组转为函数的参数了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// ES5的写法</span><br><span class="line"><span class="keyword">function</span> f(x, y, z) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line">var args = [0, 1, 2];</span><br><span class="line">f.apply(null, args);</span><br><span class="line"></span><br><span class="line">// ES6的写法</span><br><span class="line"><span class="keyword">function</span> f(x, y, z) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line">var args = [0, 1, 2];</span><br><span class="line">f(...args);</span><br></pre></td></tr></table></figure><p>下面是扩展运算符取代 apply 方法的一个实际的例子，应用 Math.max 方法，简化求出一个数组最大元素的写法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// ES5的写法</span><br><span class="line">Math.max.apply(null, [14, 3, 77])</span><br><span class="line"></span><br><span class="line">// ES6的写法</span><br><span class="line">Math.max(...[14, 3, 77])</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">Math.max(14, 3, 77);</span><br></pre></td></tr></table></figure><p>上面代码表示，由于 JavaScript 不提供求数组最大元素的函数，所以只能套用 Math.max 函数，将数组转为一个参数序列，然后求最大值。有了扩展运算符以后，就可以直接用 Math.max 了。</p><p>另一个例子是通过 push 函数，将一个数组添加到另一个数组的尾部。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// ES5的写法</span><br><span class="line">var arr1 = [0, 1, 2];</span><br><span class="line">var arr2 = [3, 4, 5];</span><br><span class="line">Array.prototype.push.apply(arr1, arr2);</span><br><span class="line"></span><br><span class="line">// ES6的写法</span><br><span class="line">var arr1 = [0, 1, 2];</span><br><span class="line">var arr2 = [3, 4, 5];</span><br><span class="line">arr1.push(...arr2);</span><br></pre></td></tr></table></figure><p>上面代码的 ES5 写法中，push 方法的参数不能是数组，所以只好通过 apply 方法变通使用 push 方法。有了扩展运算符，就可以直接将数组传入 push 方法。</p><p>下面是另外一个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// ES5</span><br><span class="line">new (Date.bind.apply(Date, [null, 2015, 1, 1]))</span><br><span class="line">// ES6</span><br><span class="line">new Date(...[2015, 1, 1]);</span><br></pre></td></tr></table></figure><h5 id="扩展运算符的应用"><a href="#扩展运算符的应用" class="headerlink" title="扩展运算符的应用"></a>扩展运算符的应用</h5><h6 id="合并数组"><a href="#合并数组" class="headerlink" title="合并数组"></a>合并数组</h6><p>扩展运算符提供了数组合并的新写法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// ES5</span><br><span class="line">[1, 2].concat(more)</span><br><span class="line">// ES6</span><br><span class="line">[1, 2, ...more]</span><br><span class="line"></span><br><span class="line">var arr1 = [<span class="string">'a'</span>, <span class="string">'b'</span>];</span><br><span class="line">var arr2 = [<span class="string">'c'</span>];</span><br><span class="line">var arr3 = [<span class="string">'d'</span>, <span class="string">'e'</span>];</span><br><span class="line"></span><br><span class="line">// ES5的合并数组</span><br><span class="line">arr1.concat(arr2, arr3);</span><br><span class="line">// [ <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span> ]</span><br><span class="line"></span><br><span class="line">// ES6的合并数组</span><br><span class="line">[...arr1, ...arr2, ...arr3]</span><br><span class="line">// [ <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span> ]</span><br></pre></td></tr></table></figure><h6 id="与解构赋值结合"><a href="#与解构赋值结合" class="headerlink" title="与解构赋值结合"></a>与解构赋值结合</h6><p>扩展运算符可以与解构赋值结合起来，用于生成数组。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// ES5</span><br><span class="line">a = list[0], rest = list.slice(1)</span><br><span class="line">// ES6</span><br><span class="line">[a, ...rest] = list</span><br></pre></td></tr></table></figure><p>下面是另外一些例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const [first, ...rest] = [1, 2, 3, 4, 5];</span><br><span class="line">first // 1</span><br><span class="line">rest  // [2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">const [first, ...rest] = [];</span><br><span class="line">first // undefined</span><br><span class="line">rest  // []:</span><br><span class="line"></span><br><span class="line">const [first, ...rest] = [<span class="string">"foo"</span>];</span><br><span class="line">first  // <span class="string">"foo"</span></span><br><span class="line">rest   // []</span><br></pre></td></tr></table></figure><p>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const [...butLast, last] = [1, 2, 3, 4, 5];</span><br><span class="line">// 报错</span><br><span class="line"></span><br><span class="line">const [first, ...middle, last] = [1, 2, 3, 4, 5];</span><br><span class="line">// 报错</span><br></pre></td></tr></table></figure><h6 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h6><p>JavaScript 的函数只能返回一个值，如果需要返回多个值，只能返回数组或对象。扩展运算符提供了解决这个问题的一种变通方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var dateFields = readDateFields(database);</span><br><span class="line">var d = new Date(...dateFields);</span><br></pre></td></tr></table></figure><p>上面代码从数据库取出一行数据，通过扩展运算符，直接将其传入构造函数 Date。</p><h6 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h6><p>扩展运算符还可以将字符串转为真正的数组。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...<span class="string">'hello'</span>]</span><br><span class="line">// [ <span class="string">"h"</span>, <span class="string">"e"</span>, <span class="string">"l"</span>, <span class="string">"l"</span>, <span class="string">"o"</span> ]</span><br></pre></td></tr></table></figure><p>上面的写法，有一个重要的好处，那就是能够正确识别 32 位的 Unicode 字符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'x\uD83D\uDE80y'</span>.length // 4</span><br><span class="line">[...<span class="string">'x\uD83D\uDE80y'</span>].length // 3</span><br></pre></td></tr></table></figure><p>上面代码的第一种写法，JavaScript 会将 32 位 Unicode 字符，识别为 2 个字符，采用扩展运算符就没有这个问题。因此，正确返回字符串长度的函数，可以像下面这样写。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> length(str) &#123;</span><br><span class="line">  <span class="built_in">return</span> [...str].length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">length(<span class="string">'x\uD83D\uDE80y'</span>) // 3</span><br></pre></td></tr></table></figure><p>凡是涉及到操作 32 位 Unicode 字符的函数，都有这个问题。因此，最好都用扩展运算符改写。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> str = <span class="string">'x\uD83D\uDE80y'</span>;</span><br><span class="line"></span><br><span class="line">str.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</span><br><span class="line">// <span class="string">'y\uDE80\uD83Dx'</span></span><br><span class="line"></span><br><span class="line">[...str].reverse().join(<span class="string">''</span>)</span><br><span class="line">// <span class="string">'y\uD83D\uDE80x'</span></span><br></pre></td></tr></table></figure><p>上面代码中，如果不用扩展运算符，字符串的 reverse 操作就不正确。</p><h6 id="实现了-Iterator-接口的对象"><a href="#实现了-Iterator-接口的对象" class="headerlink" title="实现了 Iterator 接口的对象"></a>实现了 Iterator 接口的对象</h6><p>任何 Iterator 接口的对象，都可以用扩展运算符转为真正的数组。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var nodeList = document.querySelectorAll(<span class="string">'div'</span>);</span><br><span class="line">var array = [...nodeList];</span><br></pre></td></tr></table></figure><p>上面代码中，querySelectorAll 方法返回的是一个 nodeList 对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于 NodeList 对象实现了 Iterator 接口。</p><p>对于那些没有部署 Iterator 接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arrayLike = &#123;</span><br><span class="line">  <span class="string">'0'</span>: <span class="string">'a'</span>,</span><br><span class="line">  <span class="string">'1'</span>: <span class="string">'b'</span>,</span><br><span class="line">  <span class="string">'2'</span>: <span class="string">'c'</span>,</span><br><span class="line">  length: 3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// TypeError: Cannot spread non-iterable object.</span><br><span class="line"><span class="built_in">let</span> arr = [...arrayLike];</span><br></pre></td></tr></table></figure><p>上面代码中，arrayLike 是一个类似数组的对象，但是没有部署 Iterator 接口，扩展运算符就会报错。这时，可以改为使用 Array.from 方法将 arrayLike 转为真正的数组。</p><h6 id="Map-和-Set-结构，Generator-函数"><a href="#Map-和-Set-结构，Generator-函数" class="headerlink" title="Map 和 Set 结构，Generator 函数"></a>Map 和 Set 结构，Generator 函数</h6><p>扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符，比如 Map 结构。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> map = new Map([</span><br><span class="line">  [1, <span class="string">'one'</span>],</span><br><span class="line">  [2, <span class="string">'two'</span>],</span><br><span class="line">  [3, <span class="string">'three'</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> arr = [...map.keys()]; // [1, 2, 3]</span><br></pre></td></tr></table></figure><p>Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var go = <span class="keyword">function</span>*()&#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  yield 2;</span><br><span class="line">  yield 3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[...go()] // [1, 2, 3]</span><br></pre></td></tr></table></figure><p>上面代码中，变量 go 是一个 Generator 函数，执行后返回的是一个遍历器对象，对这个遍历器对象执行扩展运算符，就会将内部遍历得到的值，转为一个数组。</p><p>如果对没有 iterator 接口的对象，使用扩展运算符，将会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;a: 1, b: 2&#125;;</span><br><span class="line"><span class="built_in">let</span> arr = [...obj]; // TypeError: Cannot spread non-iterable object</span><br></pre></td></tr></table></figure><h5 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h5><p>从 ES5 开始，函数内部可以设定为严格模式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> doSomething(a, b) &#123;</span><br><span class="line">  <span class="string">'use strict'</span>;</span><br><span class="line">  // code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>《ECMAScript 2016 标准》做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line"><span class="keyword">function</span> doSomething(a, b = a) &#123;</span><br><span class="line">  <span class="string">'use strict'</span>;</span><br><span class="line">  // code</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 报错</span><br><span class="line">const doSomething = <span class="keyword">function</span> (&#123;a, b&#125;) &#123;</span><br><span class="line">  <span class="string">'use strict'</span>;</span><br><span class="line">  // code</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 报错</span><br><span class="line">const doSomething = (...a) =&gt; &#123;</span><br><span class="line">  <span class="string">'use strict'</span>;</span><br><span class="line">  // code</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const obj = &#123;</span><br><span class="line">  // 报错</span><br><span class="line">  doSomething(&#123;a, b&#125;) &#123;</span><br><span class="line">    <span class="string">'use strict'</span>;</span><br><span class="line">    // code</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样规定的原因是，函数内部的严格模式，同时适用于函数体代码和函数参数代码。但是，函数执行的时候，先执行函数参数代码，然后再执行函数体代码。这样就有一个不合理的地方，只有从函数体代码之中，才能知道参数代码是否应该以严格模式执行，但是参数代码却应该先于函数体代码执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line"><span class="keyword">function</span> doSomething(value = 070) &#123;</span><br><span class="line">  <span class="string">'use strict'</span>;</span><br><span class="line">  <span class="built_in">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，参数 value 的默认值是八进制数 070，但是严格模式下不能用前缀 0 表示八进制，所以应该报错。但是实际上，JavaScript 引擎会先成功执行 value = 070，然后进入函数体内部，发现需要用严格模式执行，这时才会报错。</p><p>虽然可以先解析函数体代码，再执行参数代码，但是这样无疑就增加了复杂性。因此，标准索性禁止了这种用法，只要参数使用了默认值、解构赋值、或者扩展运算符，就不能显式指定严格模式。</p><p>两种方法可以规避这种限制。第一种是设定全局性的严格模式，这是合法的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> doSomething(a, b = a) &#123;</span><br><span class="line">  // code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种是把函数包在一个无参数的立即执行函数里面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const doSomething = (<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  <span class="string">'use strict'</span>;</span><br><span class="line">  <span class="built_in">return</span> <span class="keyword">function</span>(value = 42) &#123;</span><br><span class="line">    <span class="built_in">return</span> value;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><h5 id="name-属性"><a href="#name-属性" class="headerlink" title="name 属性"></a>name 属性</h5><p>函数的 name 属性，返回该函数的函数名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;&#125;</span><br><span class="line">foo.name // <span class="string">"foo"</span></span><br></pre></td></tr></table></figure><p>这个属性早就被浏览器广泛支持，但是直到 ES6，才将其写入了标准。</p><p>需要注意的是，ES6 对这个属性的行为做出了一些修改。如果将一个匿名函数赋值给一个变量，ES5 的 name 属性，会返回空字符串，而 ES6 的 name 属性会返回实际的函数名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var func1 = <span class="function"><span class="title">function</span></span> () &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// ES5</span><br><span class="line">func1.name // <span class="string">""</span></span><br><span class="line"></span><br><span class="line">// ES6</span><br><span class="line">func1.name // <span class="string">"func1"</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量 func1 等于一个匿名函数，ES5 和 ES6 的 name 属性返回的值不一样。</p><p>如果将一个具名函数赋值给一个变量，则 ES5 和 ES6 的 name 属性都返回这个具名函数原本的名字。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const bar = <span class="keyword">function</span> <span class="function"><span class="title">baz</span></span>() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// ES5</span><br><span class="line">bar.name // <span class="string">"baz"</span></span><br><span class="line"></span><br><span class="line">// ES6</span><br><span class="line">bar.name // <span class="string">"baz"</span></span><br></pre></td></tr></table></figure><p>Function 构造函数返回的函数实例，name 属性的值为“anonymous”。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(new Function).name // <span class="string">"anonymous"</span></span><br></pre></td></tr></table></figure><p>bind 返回的函数，name 属性值会加上“bound ”前缀。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;&#125;;</span><br><span class="line">foo.bind(&#123;&#125;).name // <span class="string">"bound foo"</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="title">function</span></span>()&#123;&#125;).<span class="built_in">bind</span>(&#123;&#125;).name // <span class="string">"bound "</span></span><br></pre></td></tr></table></figure><h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><h5 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h5><p>ES6 允许使用“箭头”（=&gt;）定义函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var f = v =&gt; v;</span><br></pre></td></tr></table></figure><p>上面的箭头函数等同于：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var f = <span class="keyword">function</span>(v) &#123;</span><br><span class="line">  <span class="built_in">return</span> v;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var f = () =&gt; 5;</span><br><span class="line">// 等同于</span><br><span class="line">var f = <span class="function"><span class="title">function</span></span> () &#123; <span class="built_in">return</span> 5 &#125;;</span><br><span class="line"></span><br><span class="line">var sum = (num1, num2) =&gt; num1 + num2;</span><br><span class="line">// 等同于</span><br><span class="line">var sum = <span class="keyword">function</span>(num1, num2) &#123;</span><br><span class="line">  <span class="built_in">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用 return 语句返回。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var sum = (num1, num2) =&gt; &#123; <span class="built_in">return</span> num1 + num2; &#125;</span><br></pre></td></tr></table></figure><p>由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var getTempItem = id =&gt; (&#123; id: id, name: <span class="string">"Temp"</span> &#125;);</span><br></pre></td></tr></table></figure><p>箭头函数可以与变量解构结合使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const full = (&#123; first, last &#125;) =&gt; first + <span class="string">' '</span> + last;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line"><span class="keyword">function</span> full(person) &#123;</span><br><span class="line">  <span class="built_in">return</span> person.first + <span class="string">' '</span> + person.last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>箭头函数使得表达更加简洁。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const isEven = n =&gt; n % 2 == 0;</span><br><span class="line">const square = n =&gt; n * n;</span><br></pre></td></tr></table></figure><p>上面代码只用了两行，就定义了两个简单的工具函数。如果不用箭头函数，可能就要占用多行，而且还不如现在这样写醒目。</p><p>箭头函数的一个用处是简化回调函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 正常函数写法</span><br><span class="line">[1,2,3].map(<span class="keyword">function</span> (x) &#123;</span><br><span class="line">  <span class="built_in">return</span> x * x;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 箭头函数写法</span><br><span class="line">[1,2,3].map(x =&gt; x * x);</span><br><span class="line">另一个例子是</span><br><span class="line"></span><br><span class="line">// 正常函数写法</span><br><span class="line">var result = values.sort(<span class="keyword">function</span> (a, b) &#123;</span><br><span class="line">  <span class="built_in">return</span> a - b;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 箭头函数写法</span><br><span class="line">var result = values.sort((a, b) =&gt; a - b);</span><br></pre></td></tr></table></figure><p>下面是 rest 参数与箭头函数结合的例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const numbers = (...nums) =&gt; nums;</span><br><span class="line"></span><br><span class="line">numbers(1, 2, 3, 4, 5)</span><br><span class="line">// [1,2,3,4,5]</span><br><span class="line"></span><br><span class="line">const headAndTail = (head, ...tail) =&gt; [head, tail];</span><br><span class="line"></span><br><span class="line">headAndTail(1, 2, 3, 4, 5)</span><br><span class="line">// [1,[2,3,4,5]]</span><br></pre></td></tr></table></figure><h5 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h5><p>箭头函数有几个使用注意点。</p><p>（1）函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。</p><p>（2）不可以当作构造函数，也就是说，不可以使用 new 命令，否则会抛出一个错误。</p><p>（3）不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 Rest 参数代替。</p><p>（4）不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。</p><p>上面四点中，第一点尤其值得注意。this 对象的指向是可变的，但是在箭头函数中，它是固定的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(<span class="string">'id:'</span>, this.id);</span><br><span class="line">  &#125;, 100);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var id = 21;</span><br><span class="line"></span><br><span class="line">foo.call(&#123; id: 42 &#125;);</span><br><span class="line">// id: 42</span><br></pre></td></tr></table></figure><p>上面代码中，setTimeout 的参数是一个箭头函数，这个箭头函数的定义生效是在 foo 函数生成时，而它的真正执行要等到 100 毫秒后。如果是普通函数，执行时 this 应该指向全局对象 window，这时应该输出 21。但是，箭头函数导致 this 总是指向函数定义生效时所在的对象（本例是{id: 42}），所以输出的是 42。</p><p>箭头函数可以让 setTimeout 里面的 this，绑定定义时所在的作用域，而不是指向运行时所在的作用域。下面是另一个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Timer</span></span>() &#123;</span><br><span class="line">  this.s1 = 0;</span><br><span class="line">  this.s2 = 0;</span><br><span class="line">  // 箭头函数</span><br><span class="line">  setInterval(() =&gt; this.s1++, 1000);</span><br><span class="line">  // 普通函数</span><br><span class="line">  setInterval(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    this.s2++;</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var timer = new Timer();</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; console.log(<span class="string">'s1: '</span>, timer.s1), 3100);</span><br><span class="line">setTimeout(() =&gt; console.log(<span class="string">'s2: '</span>, timer.s2), 3100);</span><br><span class="line">// s1: 3</span><br><span class="line">// s2: 0</span><br></pre></td></tr></table></figure><p>上面代码中，Timer 函数内部设置了两个定时器，分别使用了箭头函数和普通函数。前者的 this 绑定定义时所在的作用域（即 Timer 函数），后者的 this 指向运行时所在的作用域（即全局对象）。所以，3100 毫秒之后，timer.s1 被更新了 3 次，而 timer.s2 一次都没更新。</p><p>箭头函数可以让 this 指向固定化，这种特性很有利于封装回调函数。下面是一个例子，DOM 事件的回调函数封装在一个对象里面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var handler = &#123;</span><br><span class="line">  id: <span class="string">'123456'</span>,</span><br><span class="line"></span><br><span class="line">  init: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    document.addEventListener(<span class="string">'click'</span>,</span><br><span class="line">      event =&gt; this.doSomething(event.type), <span class="literal">false</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  doSomething: <span class="keyword">function</span>(<span class="built_in">type</span>) &#123;</span><br><span class="line">    console.log(<span class="string">'Handling '</span> + <span class="built_in">type</span>  + <span class="string">' for '</span> + this.id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码的 init 方法中，使用了箭头函数，这导致这个箭头函数里面的 this，总是指向 handler 对象。否则，回调函数运行时，this.doSomething 这一行会报错，因为此时 this 指向 document 对象。</p><p>this 指向的固定化，并不是因为箭头函数内部有绑定 this 的机制，实际原因是箭头函数根本没有自己的 this，导致内部的 this 就是外层代码块的 this。正是因为它没有 this，所以也就不能用作构造函数。</p><p>所以，箭头函数转成 ES5 的代码如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// ES6</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(<span class="string">'id:'</span>, this.id);</span><br><span class="line">  &#125;, 100);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ES5</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">  var _this = this;</span><br><span class="line"></span><br><span class="line">  setTimeout(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(<span class="string">'id:'</span>, _this.id);</span><br><span class="line">  &#125;, 100);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，转换后的 ES5 版本清楚地说明了，箭头函数里面根本没有自己的 this，而是引用外层的 this。</p><p>请问下面的代码之中有几个 this？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> () =&gt; &#123;</span><br><span class="line">    <span class="built_in">return</span> () =&gt; &#123;</span><br><span class="line">      <span class="built_in">return</span> () =&gt; &#123;</span><br><span class="line">        console.log(<span class="string">'id:'</span>, this.id);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var f = foo.call(&#123;id: 1&#125;);</span><br><span class="line"></span><br><span class="line">var t1 = f.call(&#123;id: 2&#125;)()(); // id: 1</span><br><span class="line">var t2 = f().call(&#123;id: 3&#125;)(); // id: 1</span><br><span class="line">var t3 = f()().call(&#123;id: 4&#125;); // id: 1</span><br></pre></td></tr></table></figure><p>上面代码之中，只有一个 this，就是函数 foo 的 this，所以 t1、t2、t3 都输出同样的结果。因为所有的内层函数都是箭头函数，都没有自己的 this，它们的 this 其实都是最外层 foo 函数的 this。</p><p>除了 this，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：arguments、super、new.target。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(<span class="string">'args:'</span>, arguments);</span><br><span class="line">  &#125;, 100);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(2, 4, 6, 8)</span><br><span class="line">// args: [2, 4, 6, 8]</span><br></pre></td></tr></table></figure><p>上面代码中，箭头函数内部的变量 arguments，其实是函数 foo 的 arguments 变量。</p><p>另外，由于箭头函数没有自己的 this，所以当然也就不能用 call()、apply()、bind()这些方法去改变 this 的指向。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> [</span><br><span class="line">    (() =&gt; this.x).<span class="built_in">bind</span>(&#123; x: <span class="string">'inner'</span> &#125;)()</span><br><span class="line">  ];</span><br><span class="line">&#125;).call(&#123; x: <span class="string">'outer'</span> &#125;);</span><br><span class="line">// [<span class="string">'outer'</span>]</span><br></pre></td></tr></table></figure><p>上面代码中，箭头函数没有自己的 this，所以 bind 方法无效，内部的 this 指向外部的 this。</p><p>长期以来，JavaScript 语言的 this 对象一直是一个令人头痛的问题，在对象方法中使用 this，必须非常小心。箭头函数”绑定”this，很大程度上解决了这个困扰。</p><h5 id="嵌套的箭头函数"><a href="#嵌套的箭头函数" class="headerlink" title="嵌套的箭头函数"></a>嵌套的箭头函数</h5><p>箭头函数内部，还可以再使用箭头函数。下面是一个 ES5 语法的多重嵌套函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> insert(value) &#123;</span><br><span class="line">  <span class="built_in">return</span> &#123;into: <span class="keyword">function</span> (array) &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;after: <span class="keyword">function</span> (afterValue) &#123;</span><br><span class="line">      array.splice(array.indexOf(afterValue) + 1, 0, value);</span><br><span class="line">      <span class="built_in">return</span> array;</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">  &#125;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">insert(2).into([1, 3]).after(1); //[1, 2, 3]</span><br></pre></td></tr></table></figure><p>上面这个函数，可以使用箭头函数改写。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> insert = (value) =&gt; (&#123;into: (array) =&gt; (&#123;after: (afterValue) =&gt; &#123;</span><br><span class="line">  array.splice(array.indexOf(afterValue) + 1, 0, value);</span><br><span class="line">  <span class="built_in">return</span> array;</span><br><span class="line">&#125;&#125;)&#125;);</span><br><span class="line"></span><br><span class="line">insert(2).into([1, 3]).after(1); //[1, 2, 3]</span><br></pre></td></tr></table></figure><p>下面是一个部署管道机制（pipeline）的例子，即前一个函数的输出是后一个函数的输入。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const pipeline = (...funcs) =&gt;</span><br><span class="line">  val =&gt; funcs.reduce((a, b) =&gt; b(a), val);</span><br><span class="line"></span><br><span class="line">const plus1 = a =&gt; a + 1;</span><br><span class="line">const mult2 = a =&gt; a * 2;</span><br><span class="line">const addThenMult = pipeline(plus1, mult2);</span><br><span class="line"></span><br><span class="line">addThenMult(5)</span><br><span class="line">// 12</span><br></pre></td></tr></table></figure><p>如果觉得上面的写法可读性比较差，也可以采用下面的写法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const plus1 = a =&gt; a + 1;</span><br><span class="line">const mult2 = a =&gt; a * 2;</span><br><span class="line"></span><br><span class="line">mult2(plus1(5))</span><br><span class="line">// 12</span><br></pre></td></tr></table></figure><p>箭头函数还有一个功能，就是可以很方便地改写 λ 演算。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// λ演算的写法</span><br><span class="line">fix = λf.(λx.f(λv.x(x)(v)))(λx.f(λv.x(x)(v)))</span><br><span class="line"></span><br><span class="line">// ES6的写法</span><br><span class="line">var fix = f =&gt; (x =&gt; f(v =&gt; x(x)(v)))</span><br><span class="line">               (x =&gt; f(v =&gt; x(x)(v)));</span><br></pre></td></tr></table></figure><p>上面两种写法，几乎是一一对应的。由于 λ 演算对于计算机科学非常重要，这使得我们可以用 ES6 作为替代工具，探索计算机科学。</p><h5 id="绑定-this"><a href="#绑定-this" class="headerlink" title="绑定 this"></a>绑定 this</h5><p>箭头函数可以绑定 this 对象，大大减少了显式绑定 this 对象的写法（call、apply、bind）。但是，箭头函数并不适用于所有场合，所以 ES7 提出了“函数绑定”（function bind）运算符，用来取代 call、apply、bind 调用。虽然该语法还是 ES7 的一个提案，但是 Babel 转码器已经支持。</p><p>函数绑定运算符是并排的两个双冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即 this 对象），绑定到右边的函数上面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">foo::bar;</span><br><span class="line">// 等同于</span><br><span class="line">bar.bind(foo);</span><br><span class="line"></span><br><span class="line">foo::bar(...arguments);</span><br><span class="line">// 等同于</span><br><span class="line">bar.apply(foo, arguments);</span><br><span class="line"></span><br><span class="line">const hasOwnProperty = Object.prototype.hasOwnProperty;</span><br><span class="line"><span class="keyword">function</span> hasOwn(obj, key) &#123;</span><br><span class="line">  <span class="built_in">return</span> obj::hasOwnProperty(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var method = obj::obj.foo;</span><br><span class="line">// 等同于</span><br><span class="line">var method = ::obj.foo;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> <span class="built_in">log</span> = ::console.log;</span><br><span class="line">// 等同于</span><br><span class="line">var <span class="built_in">log</span> = console.log.bind(console);</span><br></pre></td></tr></table></figure><p>由于双冒号运算符返回的还是原对象，因此可以采用链式写法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 例一</span><br><span class="line">import &#123; map, takeWhile, forEach &#125; from <span class="string">"iterlib"</span>;</span><br><span class="line"></span><br><span class="line">getPlayers()</span><br><span class="line">::map(x =&gt; x.character())</span><br><span class="line">::takeWhile(x =&gt; x.strength &gt; 100)</span><br><span class="line">::forEach(x =&gt; console.log(x));</span><br><span class="line"></span><br><span class="line">// 例二</span><br><span class="line"><span class="built_in">let</span> &#123; find, html &#125; = jake;</span><br><span class="line"></span><br><span class="line">document.querySelectorAll(<span class="string">"div.myClass"</span>)</span><br><span class="line">::find(<span class="string">"p"</span>)</span><br><span class="line">::html(<span class="string">"hahaha"</span>);</span><br></pre></td></tr></table></figure><h4 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h4><h5 id="什么是尾调用？"><a href="#什么是尾调用？" class="headerlink" title="什么是尾调用？"></a>什么是尾调用？</h5><p>尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> f(x)&#123;</span><br><span class="line">  <span class="built_in">return</span> g(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，函数 f 的最后一步是调用函数 g，这就叫尾调用。</p><p>以下三种情况，都不属于尾调用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 情况一</span><br><span class="line"><span class="keyword">function</span> f(x)&#123;</span><br><span class="line">  <span class="built_in">let</span> y = g(x);</span><br><span class="line">  <span class="built_in">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 情况二</span><br><span class="line"><span class="keyword">function</span> f(x)&#123;</span><br><span class="line">  <span class="built_in">return</span> g(x) + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 情况三</span><br><span class="line"><span class="keyword">function</span> f(x)&#123;</span><br><span class="line">  g(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，情况一是调用函数 g 之后，还有赋值操作，所以不属于尾调用，即使语义完全一样。情况二也属于调用后还有操作，即使写在一行内。情况三等同于下面的代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> f(x)&#123;</span><br><span class="line">  g(x);</span><br><span class="line">  <span class="built_in">return</span> undefined;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尾调用不一定出现在函数尾部，只要是最后一步操作即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> f(x) &#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; 0) &#123;</span><br><span class="line">    <span class="built_in">return</span> m(x)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> n(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，函数 m 和 n 都属于尾调用，因为它们都是函数 f 的最后一步操作。</p><h5 id="尾调用优化-1"><a href="#尾调用优化-1" class="headerlink" title="尾调用优化"></a>尾调用优化</h5><p>尾调用之所以与其他调用不同，就在于它的特殊的调用位置。</p><p>我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数 A 的内部调用函数 B，那么在 A 的调用帧上方，还会形成一个 B 的调用帧。等到 B 运行结束，将结果返回到 A，B 的调用帧才会消失。如果函数 B 内部还调用函数 C，那就还有一个 C 的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。</p><p>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  <span class="built_in">let</span> m = 1;</span><br><span class="line">  <span class="built_in">let</span> n = 2;</span><br><span class="line">  <span class="built_in">return</span> g(m + n);</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> g(3);</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">g(3);</span><br></pre></td></tr></table></figure><p>上面代码中，如果函数 g 不是尾调用，函数 f 就需要保存内部变量 m 和 n 的值、g 的调用位置等信息。但由于调用 g 之后，函数 f 就结束了，所以执行到最后一步，完全可以删除 f(x) 的调用帧，只保留 g(3) 的调用帧。</p><p>这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。</p><p>注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> addOne(a)&#123;</span><br><span class="line">  var one = 1;</span><br><span class="line">  <span class="keyword">function</span> inner(b)&#123;</span><br><span class="line">    <span class="built_in">return</span> b + one;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> inner(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数不会进行尾调用优化，因为内层函数 inner 用到了外层函数 addOne 的内部变量 one。</p><h5 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h5><p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</p><p>递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> factorial(n) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n === 1) <span class="built_in">return</span> 1;</span><br><span class="line">  <span class="built_in">return</span> n * factorial(n - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(5) // 120</span><br></pre></td></tr></table></figure><p>上面代码是一个阶乘函数，计算 n 的阶乘，最多需要保存 n 个调用记录，复杂度 O(n) 。</p><p>如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> factorial(n, total) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n === 1) <span class="built_in">return</span> total;</span><br><span class="line">  <span class="built_in">return</span> factorial(n - 1, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(5, 1) // 120</span><br></pre></td></tr></table></figure><p>还有一个比较著名的例子，就是计算 fibonacci 数列，也能充分说明尾递归优化的重要性</p><p>如果是非尾递归的 fibonacci 递归方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Fibonacci (n) &#123;</span><br><span class="line">  <span class="keyword">if</span> ( n &lt;= 1 ) &#123;<span class="built_in">return</span> 1&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> Fibonacci(n - 1) + Fibonacci(n - 2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Fibonacci(10); // 89</span><br><span class="line">// Fibonacci(100)</span><br><span class="line">// Fibonacci(500)</span><br><span class="line">// 堆栈溢出了</span><br></pre></td></tr></table></figure><p>如果我们使用尾递归优化过的 fibonacci 递归算法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Fibonacci2 (n , ac1 = 1 , ac2 = 1) &#123;</span><br><span class="line">  <span class="keyword">if</span>( n &lt;= 1 ) &#123;<span class="built_in">return</span> ac2&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> Fibonacci2 (n - 1, ac2, ac1 + ac2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Fibonacci2(100) // 573147844013817200000</span><br><span class="line">Fibonacci2(1000) // 7.0330367711422765e+208</span><br><span class="line">Fibonacci2(10000) // Infinity</span><br></pre></td></tr></table></figure><p>由此可见，“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6 也是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署“尾调用优化”。这就是说，在 ES6 中，只要使用尾递归，就不会发生栈溢出，相对节省内存。</p><h5 id="递归函数的改写"><a href="#递归函数的改写" class="headerlink" title="递归函数的改写"></a>递归函数的改写</h5><p>尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。比如上面的例子，阶乘函数 factorial 需要用到一个中间变量 total ，那就把这个中间变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，为什么计算 5 的阶乘，需要传入两个参数 5 和 1？</p><p>两个方法可以解决这个问题。方法一是在尾递归函数之外，再提供一个正常形式的函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> tailFactorial(n, total) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n === 1) <span class="built_in">return</span> total;</span><br><span class="line">  <span class="built_in">return</span> tailFactorial(n - 1, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> factorial(n) &#123;</span><br><span class="line">  <span class="built_in">return</span> tailFactorial(n, 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(5) // 120</span><br></pre></td></tr></table></figure><p>上面代码通过一个正常形式的阶乘函数 factorial ，调用尾递归函数 tailFactorial ，看起来就正常多了。</p><p>函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> currying(fn, n) &#123;</span><br><span class="line">  <span class="built_in">return</span> <span class="keyword">function</span> (m) &#123;</span><br><span class="line">    <span class="built_in">return</span> fn.call(this, m, n);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> tailFactorial(n, total) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n === 1) <span class="built_in">return</span> total;</span><br><span class="line">  <span class="built_in">return</span> tailFactorial(n - 1, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const factorial = currying(tailFactorial, 1);</span><br><span class="line"></span><br><span class="line">factorial(5) // 120</span><br></pre></td></tr></table></figure><p>上面代码通过柯里化，将尾递归函数 tailFactorial 变为只接受 1 个参数的 factorial 。</p><p>第二种方法就简单多了，就是采用 ES6 的函数默认值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> factorial(n, total = 1) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n === 1) <span class="built_in">return</span> total;</span><br><span class="line">  <span class="built_in">return</span> factorial(n - 1, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(5) // 120</span><br></pre></td></tr></table></figure><p>上面代码中，参数 total 有默认值 1，所以调用时不用提供这个值。</p><p>总结一下，递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。对于其他支持“尾调用优化”的语言（比如 Lua，ES6），只需要知道循环可以用递归代替，而一旦使用递归，就最好使用尾递归。</p><h5 id="严格模式-1"><a href="#严格模式-1" class="headerlink" title="严格模式"></a>严格模式</h5><p>ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。</p><p>这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。</p><p>1.func.arguments：返回调用时函数的参数。<br>2.func.caller：返回调用当前函数的那个函数。<br>尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">restricted</span></span>() &#123;</span><br><span class="line">  <span class="string">"use strict"</span>;</span><br><span class="line">  restricted.caller;    // 报错</span><br><span class="line">  restricted.arguments; // 报错</span><br><span class="line">&#125;</span><br><span class="line">restricted();</span><br></pre></td></tr></table></figure><h5 id="尾递归优化的实现"><a href="#尾递归优化的实现" class="headerlink" title="尾递归优化的实现"></a>尾递归优化的实现</h5><p>尾递归优化只在严格模式下生效，那么正常模式下，或者那些不支持该功能的环境中，有没有办法也使用尾递归优化呢？回答是可以的，就是自己实现尾递归优化。</p><p>它的原理非常简单。尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是采用“循环”换掉“递归”。</p><p>下面是一个正常的递归函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> sum(x, y) &#123;</span><br><span class="line">  <span class="keyword">if</span> (y &gt; 0) &#123;</span><br><span class="line">    <span class="built_in">return</span> sum(x + 1, y - 1);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(1, 100000)</span><br><span class="line">// Uncaught RangeError: Maximum call stack size exceeded(…)</span><br></pre></td></tr></table></figure><p>上面代码中，sum 是一个递归函数，参数 x 是需要累加的值，参数 y 控制递归次数。一旦指定 sum 递归 100000 次，就会报错，提示超出调用栈的最大次数。</p><p>蹦床函数（trampoline）可以将递归执行转为循环执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> trampoline(f) &#123;</span><br><span class="line">  <span class="keyword">while</span> (f &amp;&amp; f instanceof Function) &#123;</span><br><span class="line">    f = f();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是蹦床函数的一个实现，它接受一个函数 f 作为参数。只要 f 执行后返回一个函数，就继续执行。注意，这里是返回一个函数，然后执行该函数，而不是函数里面调用函数，这样就避免了递归执行，从而就消除了调用栈过大的问题。</p><p>然后，要做的就是将原来的递归函数，改写为每一步返回另一个函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> sum(x, y) &#123;</span><br><span class="line">  <span class="keyword">if</span> (y &gt; 0) &#123;</span><br><span class="line">    <span class="built_in">return</span> sum.bind(null, x + 1, y - 1);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，sum 函数的每次执行，都会返回自身的另一个版本。</p><p>现在，使用蹦床函数执行 sum，就不会发生调用栈溢出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">trampoline(sum(1, 100000))</span><br><span class="line">// 100001</span><br></pre></td></tr></table></figure><p>蹦床函数并不是真正的尾递归优化，下面的实现才是。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> tco(f) &#123;</span><br><span class="line">  var value;</span><br><span class="line">  var active = <span class="literal">false</span>;</span><br><span class="line">  var accumulated = [];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> <span class="keyword">function</span> <span class="function"><span class="title">accumulator</span></span>() &#123;</span><br><span class="line">    accumulated.push(arguments);</span><br><span class="line">    <span class="keyword">if</span> (!active) &#123;</span><br><span class="line">      active = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">while</span> (accumulated.length) &#123;</span><br><span class="line">        value = f.apply(this, accumulated.shift());</span><br><span class="line">      &#125;</span><br><span class="line">      active = <span class="literal">false</span>;</span><br><span class="line">      <span class="built_in">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var sum = tco(<span class="keyword">function</span>(x, y) &#123;</span><br><span class="line">  <span class="keyword">if</span> (y &gt; 0) &#123;</span><br><span class="line">    <span class="built_in">return</span> sum(x + 1, y - 1)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">return</span> x</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">sum(1, 100000)</span><br><span class="line">// 100001</span><br></pre></td></tr></table></figure><p>上面代码中，tco 函数是尾递归优化的实现，它的奥妙就在于状态变量 active。默认情况下，这个变量是不激活的。一旦进入尾递归优化的过程，这个变量就激活了。然后，每一轮递归 sum 返回的都是 undefined，所以就避免了递归执行；而 accumulated 数组存放每一轮 sum 执行的参数，总是有值的，这就保证了 accumulator 函数内部的 while 循环总是会执行。这样就很巧妙地将“递归”改成了“循环”，而后一轮的参数会取代前一轮的参数，保证了调用栈只有一层。</p><h5 id="函数参数的尾逗号"><a href="#函数参数的尾逗号" class="headerlink" title="函数参数的尾逗号"></a>函数参数的尾逗号</h5><p>ECMAScript 2017 将允许函数的最后一个参数有尾逗号（trailing comma）。</p><p>此前，函数定义和调用时，都不允许最后一个参数后面出现逗号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> clownsEverywhere(</span><br><span class="line">  param1,</span><br><span class="line">  param2</span><br><span class="line">) &#123; /* ... */ &#125;</span><br><span class="line"></span><br><span class="line">clownsEverywhere(</span><br><span class="line">  <span class="string">'foo'</span>,</span><br><span class="line">  <span class="string">'bar'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面代码中，如果在 param2 或 bar 后面加一个逗号，就会报错。</p><p>这样的话，如果以后修改代码，想为函数 clownsEverywhere 添加第三个参数，就势必要在第二个参数后面添加一个逗号。这对版本管理系统来说，就会显示，添加逗号的那一行也发生了变动。这看上去有点冗余，因此新的语法允许定义和调用时，尾部直接有一个逗号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> clownsEverywhere(</span><br><span class="line">  param1,</span><br><span class="line">  param2,</span><br><span class="line">) &#123; /* ... */ &#125;</span><br><span class="line"></span><br><span class="line">clownsEverywhere(</span><br><span class="line">  <span class="string">'foo'</span>,</span><br><span class="line">  <span class="string">'bar'</span>,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6_Array</title>
      <link href="/2019/01/20/es6-Array/"/>
      <url>/2019/01/20/es6-Array/</url>
      
        <content type="html"><![CDATA[<h3 id="ES6-数组的扩展"><a href="#ES6-数组的扩展" class="headerlink" title="ES6 数组的扩展"></a>ES6 数组的扩展</h3><h4 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h4><p>Array.from 方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。</p><p>下面是一个类似数组的对象，Array.from 将它转为真正的数组。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arrayLike = &#123;</span><br><span class="line">    <span class="string">'0'</span>: <span class="string">'a'</span>,</span><br><span class="line">    <span class="string">'1'</span>: <span class="string">'b'</span>,</span><br><span class="line">    <span class="string">'2'</span>: <span class="string">'c'</span>,</span><br><span class="line">    length: 3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// ES5的写法</span><br><span class="line">var arr1 = [].slice.call(arrayLike); // [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"></span><br><span class="line">// ES6的写法</span><br><span class="line"><span class="built_in">let</span> arr2 = Array.from(arrayLike); // [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br></pre></td></tr></table></figure><p>实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的 arguments 对象。Array.from 都可以将它们转为真正的数组。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// NodeList对象</span><br><span class="line"><span class="built_in">let</span> ps = document.querySelectorAll(<span class="string">'p'</span>);</span><br><span class="line">Array.from(ps).forEach(<span class="keyword">function</span> (p) &#123;</span><br><span class="line">  console.log(p);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// arguments对象</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">  var args = Array.from(arguments);</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，querySelectorAll 方法返回的是一个类似数组的对象，只有将这个对象转为真正的数组，才能使用 forEach 方法。</p><p>只要是部署了 Iterator 接口的数据结构，Array.from 都能将其转为数组。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Array.from(<span class="string">'hello'</span>)</span><br><span class="line">// [<span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> namesSet = new Set([<span class="string">'a'</span>, <span class="string">'b'</span>])</span><br><span class="line">Array.from(namesSet) // [<span class="string">'a'</span>, <span class="string">'b'</span>]</span><br></pre></td></tr></table></figure><p>上面代码中，字符串和 Set 结构都具有 Iterator 接口，因此可以被 Array.from 转为真正的数组。</p><p>如果参数是一个真正的数组，Array.from 会返回一个一模一样的新数组。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array.from([1, 2, 3])</span><br><span class="line">// [1, 2, 3]</span><br></pre></td></tr></table></figure><p>值得提醒的是，扩展运算符（…）也可以将某些数据结构转为数组。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// arguments对象</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">  var args = [...arguments];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// NodeList对象</span><br><span class="line">[...document.querySelectorAll(<span class="string">'div'</span>)]</span><br></pre></td></tr></table></figure><p>扩展运算符背后调用的是遍历器接口（Symbol.iterator），如果一个对象没有部署这个接口，就无法转换。Array.from 方法则是还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有 length 属性。因此，任何有 length 属性的对象，都可以通过 Array.from 方法转为数组，而此时扩展运算符就无法转换。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array.from(&#123; length: 3 &#125;);</span><br><span class="line">// [ undefined, undefined, undefined ]</span><br></pre></td></tr></table></figure><p>上面代码中，Array.from 返回了一个具有三个成员的数组，每个位置的值都是 undefined。扩展运算符转换不了这个对象。</p><p>对于还没有部署该方法的浏览器，可以用 Array.prototype.slice 方法替代。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const toArray = (() =&gt;</span><br><span class="line">  Array.from ? Array.from : obj =&gt; [].slice.call(obj)</span><br><span class="line">)();</span><br></pre></td></tr></table></figure><p>Array.from 还可以接受第二个参数，作用类似于数组的 map 方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Array.from(arrayLike, x =&gt; x * x);</span><br><span class="line">// 等同于</span><br><span class="line">Array.from(arrayLike).map(x =&gt; x * x);</span><br><span class="line"></span><br><span class="line">Array.from([1, 2, 3], (x) =&gt; x * x)</span><br><span class="line">// [1, 4, 9]</span><br></pre></td></tr></table></figure><p>下面的例子是取出一组 DOM 节点的文本内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> spans = document.querySelectorAll(<span class="string">'span.name'</span>);</span><br><span class="line"></span><br><span class="line">// map()</span><br><span class="line"><span class="built_in">let</span> names1 = Array.prototype.map.call(spans, s =&gt; s.textContent);</span><br><span class="line"></span><br><span class="line">// Array.from()</span><br><span class="line"><span class="built_in">let</span> names2 = Array.from(spans, s =&gt; s.textContent)</span><br></pre></td></tr></table></figure><p>下面的例子将数组中布尔值为 false 的成员转为 0。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array.from([1, , 2, , 3], (n) =&gt; n || 0)</span><br><span class="line">// [1, 0, 2, 0, 3]</span><br></pre></td></tr></table></figure><p>另一个例子是返回各种数据的类型。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">typesOf</span></span> () &#123;</span><br><span class="line">  <span class="built_in">return</span> Array.from(arguments, value =&gt; typeof value)</span><br><span class="line">&#125;</span><br><span class="line">typesOf(null, [], NaN)</span><br><span class="line">// [<span class="string">'object'</span>, <span class="string">'object'</span>, <span class="string">'number'</span>]</span><br></pre></td></tr></table></figure><p>如果 map 函数里面用到了 this 关键字，还可以传入 Array.from 的第三个参数，用来绑定 this。</p><p>Array.from()可以将各种值转为真正的数组，并且还提供 map 功能。这实际上意味着，只要有一个原始的数据结构，你就可以先对它的值进行处理，然后转成规范的数组结构，进而就可以使用数量众多的数组方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array.from(&#123; length: 2 &#125;, () =&gt; <span class="string">'jack'</span>)</span><br><span class="line">// [<span class="string">'jack'</span>, <span class="string">'jack'</span>]</span><br></pre></td></tr></table></figure><p>上面代码中，Array.from 的第一个参数指定了第二个参数运行的次数。这种特性可以让该方法的用法变得非常灵活。</p><p>Array.from()的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种 Unicode 字符，可以避免 JavaScript 将大于\uFFFF 的 Unicode 字符，算作两个字符的 bug。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> countSymbols(string) &#123;</span><br><span class="line">  <span class="built_in">return</span> Array.from(string).length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h4><p>Array.of 方法用于将一组值，转换为数组。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Array.of(3, 11, 8) // [3,11,8]</span><br><span class="line">Array.of(3) // [3]</span><br><span class="line">Array.of(3).length // 1</span><br></pre></td></tr></table></figure><p>这个方法的主要目的，是弥补数组构造函数 Array()的不足。因为参数个数的不同，会导致 Array()的行为有差异。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Array() // []</span><br><span class="line">Array(3) // [, , ,]</span><br><span class="line">Array(3, 11, 8) // [3, 11, 8]</span><br></pre></td></tr></table></figure><p>上面代码中，Array 方法没有参数、一个参数、三个参数时，返回结果都不一样。只有当参数个数不少于 2 个时，Array()才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。</p><p>Array.of 基本上可以用来替代 Array()或 new Array()，并且不存在由于参数不同而导致的重载。它的行为非常统一。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Array.of() // []</span><br><span class="line">Array.of(undefined) // [undefined]</span><br><span class="line">Array.of(1) // [1]</span><br><span class="line">Array.of(1, 2) // [1, 2]</span><br></pre></td></tr></table></figure><p>Array.of 总是返回参数值组成的数组。如果没有参数，就返回一个空数组。</p><p>Array.of 方法可以用下面的代码模拟实现。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">ArrayOf</span></span>()&#123;</span><br><span class="line">  <span class="built_in">return</span> [].slice.call(arguments);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组实例的-copyWithin"><a href="#数组实例的-copyWithin" class="headerlink" title="数组实例的 copyWithin()"></a>数组实例的 copyWithin()</h4><p>数组实例的 copyWithin 方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。</p><p>Array.prototype.copyWithin(target, start = 0, end = this.length)<br>它接受三个参数。</p><p>1.target（必需）：从该位置开始替换数据。<br>2.start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示倒数。<br>3.end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。<br>这三个参数都应该是数值，如果不是，会自动转为数值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4, 5].copyWithin(0, 3)</span><br><span class="line">// [4, 5, 3, 4, 5]</span><br></pre></td></tr></table></figure><p>上面代码表示将从 3 号位直到数组结束的成员（4 和 5），复制到从 0 号位开始的位置，结果覆盖了原来的 1 和 2。</p><p>下面是更多例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 将3号位复制到0号位</span><br><span class="line">[1, 2, 3, 4, 5].copyWithin(0, 3, 4)</span><br><span class="line">// [4, 2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">// -2相当于3号位，-1相当于4号位</span><br><span class="line">[1, 2, 3, 4, 5].copyWithin(0, -2, -1)</span><br><span class="line">// [4, 2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">// 将3号位复制到0号位</span><br><span class="line">[].copyWithin.call(&#123;length: 5, 3: 1&#125;, 0, 3)</span><br><span class="line">// &#123;0: 1, 3: 1, length: 5&#125;</span><br><span class="line"></span><br><span class="line">// 将2号位到数组结束，复制到0号位</span><br><span class="line">var i32a = new Int32Array([1, 2, 3, 4, 5]);</span><br><span class="line">i32a.copyWithin(0, 2);</span><br><span class="line">// Int32Array [3, 4, 5, 4, 5]</span><br><span class="line"></span><br><span class="line">// 对于没有部署TypedArray的copyWithin方法的平台</span><br><span class="line">// 需要采用下面的写法</span><br><span class="line">[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4);</span><br><span class="line">// Int32Array [4, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure><h4 id="数组实例的-find-和-findIndex"><a href="#数组实例的-find-和-findIndex" class="headerlink" title="数组实例的 find()和 findIndex()"></a>数组实例的 find()和 findIndex()</h4><p>数组实例的 find 方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为 true 的成员，然后返回该成员。如果没有符合条件的成员，则返回 undefined。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 4, -5, 10].find((n) =&gt; n &lt; 0)</span><br><span class="line">// -5</span><br></pre></td></tr></table></figure><p>上面代码找出数组中第一个小于 0 的成员。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[1, 5, 10, 15].find(<span class="keyword">function</span>(value, index, arr) &#123;</span><br><span class="line">  <span class="built_in">return</span> value &gt; 9;</span><br><span class="line">&#125;) // 10</span><br></pre></td></tr></table></figure><p>上面代码中，find 方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。</p><p>数组实例的 findIndex 方法的用法与 find 方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[1, 5, 10, 15].findIndex(<span class="keyword">function</span>(value, index, arr) &#123;</span><br><span class="line">  <span class="built_in">return</span> value &gt; 9;</span><br><span class="line">&#125;) // 2</span><br></pre></td></tr></table></figure><p>这两个方法都可以接受第二个参数，用来绑定回调函数的 this 对象。</p><p>另外，这两个方法都可以发现 NaN，弥补了数组的 IndexOf 方法的不足。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[NaN].indexOf(NaN)</span><br><span class="line">// -1</span><br><span class="line"></span><br><span class="line">[NaN].findIndex(y =&gt; Object.is(NaN, y))</span><br><span class="line">// 0</span><br></pre></td></tr></table></figure><p>上面代码中，indexOf 方法无法识别数组的 NaN 成员，但是 findIndex 方法可以借助 Object.is 方法做到。</p><h4 id="数组实例的-fill"><a href="#数组实例的-fill" class="headerlink" title="数组实例的 fill()"></a>数组实例的 fill()</h4><p>fill 方法使用给定值，填充一个数组。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].fill(7)</span><br><span class="line">// [7, 7, 7]</span><br><span class="line"></span><br><span class="line">new Array(3).fill(7)</span><br><span class="line">// [7, 7, 7]</span><br></pre></td></tr></table></figure><p>上面代码表明，fill 方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。</p><p>fill 方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].fill(7, 1, 2)</span><br><span class="line">// [<span class="string">'a'</span>, 7, <span class="string">'c'</span>]</span><br></pre></td></tr></table></figure><p>上面代码表示，fill 方法从 1 号位开始，向原数组填充 7，到 2 号位之前结束。</p><h4 id="数组实例的-entries-，keys-和-values"><a href="#数组实例的-entries-，keys-和-values" class="headerlink" title="数组实例的 entries()，keys()和 values()"></a>数组实例的 entries()，keys()和 values()</h4><p>ES6 提供三个新的方法——entries()，keys()和 values()——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用 for…of 循环进行遍历，唯一的区别是 keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> index of [<span class="string">'a'</span>, <span class="string">'b'</span>].keys()) &#123;</span><br><span class="line">  console.log(index);</span><br><span class="line">&#125;</span><br><span class="line">// 0</span><br><span class="line">// 1</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> elem of [<span class="string">'a'</span>, <span class="string">'b'</span>].values()) &#123;</span><br><span class="line">  console.log(elem);</span><br><span class="line">&#125;</span><br><span class="line">// <span class="string">'a'</span></span><br><span class="line">// <span class="string">'b'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> [index, elem] of [<span class="string">'a'</span>, <span class="string">'b'</span>].entries()) &#123;</span><br><span class="line">  console.log(index, elem);</span><br><span class="line">&#125;</span><br><span class="line">// 0 <span class="string">"a"</span></span><br><span class="line">// 1 <span class="string">"b"</span></span><br></pre></td></tr></table></figure><p>如果不使用 for…of 循环，可以手动调用遍历器对象的 next 方法，进行遍历。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> letter = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="built_in">let</span> entries = letter.entries();</span><br><span class="line">console.log(entries.next().value); // [0, <span class="string">'a'</span>]</span><br><span class="line">console.log(entries.next().value); // [1, <span class="string">'b'</span>]</span><br><span class="line">console.log(entries.next().value); // [2, <span class="string">'c'</span>]</span><br></pre></td></tr></table></figure><h4 id="数组实例的-includes"><a href="#数组实例的-includes" class="headerlink" title="数组实例的 includes()"></a>数组实例的 includes()</h4><p>Array.prototype.includes 方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的 includes 方法类似。该方法属于 ES7，但 Babel 转码器已经支持。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3].includes(2);     // <span class="literal">true</span></span><br><span class="line">[1, 2, 3].includes(4);     // <span class="literal">false</span></span><br><span class="line">[1, 2, NaN].includes(NaN); // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>该方法的第二个参数表示搜索的起始位置，默认为 0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为 3），则会重置为从 0 开始。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3].includes(3, 3);  // <span class="literal">false</span></span><br><span class="line">[1, 2, 3].includes(3, -1); // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>没有该方法之前，我们通常使用数组的 indexOf 方法，检查是否包含某个值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (arr.indexOf(el) !== -1) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>indexOf 方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相当运算符（===）进行判断，这会导致对 NaN 的误判。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[NaN].indexOf(NaN)</span><br><span class="line">// -1</span><br><span class="line">includes使用的是不一样的判断算法，就没有这个问题。</span><br><span class="line"></span><br><span class="line">[NaN].includes(NaN)</span><br><span class="line">// <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>下面代码用来检查当前环境是否支持该方法，如果不支持，部署一个简易的替代版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const contains = (() =&gt;</span><br><span class="line">  Array.prototype.includes</span><br><span class="line">    ? (arr, value) =&gt; arr.includes(value)</span><br><span class="line">    : (arr, value) =&gt; arr.some(el =&gt; el === value)</span><br><span class="line">)();</span><br><span class="line">contains([<span class="string">"foo"</span>, <span class="string">"bar"</span>], <span class="string">"baz"</span>); // =&gt; <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>另外，Map 和 Set 数据结构有一个 has 方法，需要注意与 includes 区分。</p><p>1.Map 结构的 has 方法，是用来查找键名的，比如 Map.prototype.has(key)、WeakMap.prototype.has(key)、Reflect.has(target, propertyKey)。<br>2.Set 结构的 has 方法，是用来查找值的，比如 Set.prototype.has(value)、WeakSet.prototype.has(value)。</p><h4 id="数组的空位"><a href="#数组的空位" class="headerlink" title="数组的空位"></a>数组的空位</h4><p>数组的空位指，数组的某一个位置没有任何值。比如，Array 构造函数返回的数组都是空位。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array(3) // [, , ,]</span><br></pre></td></tr></table></figure><p>上面代码中，Array(3)返回一个具有 3 个空位的数组。</p><p>注意，空位不是 undefined，一个位置的值等于 undefined，依然是有值的。空位是没有任何值，in 运算符可以说明这一点。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 <span class="keyword">in</span> [undefined, undefined, undefined] // <span class="literal">true</span></span><br><span class="line">0 <span class="keyword">in</span> [, , ,] // <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>上面代码说明，第一个数组的 0 号位置是有值的，第二个数组的 0 号位置没有值。</p><p>ES5 对空位的处理，已经很不一致了，大多数情况下会忽略空位。</p><p>forEach(), filter(), every() 和 some()都会跳过空位。<br>map()会跳过空位，但会保留这个值<br>join()和 toString()会将空位视为 undefined，而 undefined 和 null 会被处理成空字符串。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// forEach方法</span><br><span class="line">[,<span class="string">'a'</span>].forEach((x,i) =&gt; console.log(i)); // 1</span><br><span class="line"></span><br><span class="line">// filter方法</span><br><span class="line">[<span class="string">'a'</span>,,<span class="string">'b'</span>].filter(x =&gt; <span class="literal">true</span>) // [<span class="string">'a'</span>,<span class="string">'b'</span>]</span><br><span class="line"></span><br><span class="line">// every方法</span><br><span class="line">[,<span class="string">'a'</span>].every(x =&gt; x===<span class="string">'a'</span>) // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">// some方法</span><br><span class="line">[,<span class="string">'a'</span>].some(x =&gt; x !== <span class="string">'a'</span>) // <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">// map方法</span><br><span class="line">[,<span class="string">'a'</span>].map(x =&gt; 1) // [,1]</span><br><span class="line"></span><br><span class="line">// join方法</span><br><span class="line">[,<span class="string">'a'</span>,undefined,null].join(<span class="string">'#'</span>) // <span class="string">"#a##"</span></span><br><span class="line"></span><br><span class="line">// toString方法</span><br><span class="line">[,<span class="string">'a'</span>,undefined,null].toString() // <span class="string">",a,,"</span></span><br></pre></td></tr></table></figure><p>ES6 则是明确将空位转为 undefined。</p><p>Array.from 方法会将数组的空位，转为 undefined，也就是说，这个方法不会忽略空位。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array.from([<span class="string">'a'</span>,,<span class="string">'b'</span>])</span><br><span class="line">// [ <span class="string">"a"</span>, undefined, <span class="string">"b"</span> ]</span><br></pre></td></tr></table></figure><p>扩展运算符（…）也会将空位转为 undefined。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...[<span class="string">'a'</span>,,<span class="string">'b'</span>]]</span><br><span class="line">// [ <span class="string">"a"</span>, undefined, <span class="string">"b"</span> ]</span><br></pre></td></tr></table></figure><p>copyWithin()会连空位一起拷贝。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[,<span class="string">'a'</span>,<span class="string">'b'</span>,,].copyWithin(2,0) // [,<span class="string">"a"</span>,,<span class="string">"a"</span>]</span><br></pre></td></tr></table></figure><p>fill()会将空位视为正常的数组位置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Array(3).fill(<span class="string">'a'</span>) // [<span class="string">"a"</span>,<span class="string">"a"</span>,<span class="string">"a"</span>]</span><br></pre></td></tr></table></figure><p>for…of 循环也会遍历空位。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arr = [, ,];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i of arr) &#123;</span><br><span class="line">  console.log(1);</span><br><span class="line">&#125;</span><br><span class="line">// 1</span><br><span class="line">// 1</span><br></pre></td></tr></table></figure><p>上面代码中，数组 arr 有两个空位，for…of 并没有忽略它们。如果改成 map 方法遍历，空位是会跳过的。</p><p>entries()、keys()、values()、find()和 findIndex()会将空位处理成 undefined。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// entries()</span><br><span class="line">[...[,<span class="string">'a'</span>].entries()] // [[0,undefined], [1,<span class="string">"a"</span>]]</span><br><span class="line"></span><br><span class="line">// keys()</span><br><span class="line">[...[,<span class="string">'a'</span>].keys()] // [0,1]</span><br><span class="line"></span><br><span class="line">// values()</span><br><span class="line">[...[,<span class="string">'a'</span>].values()] // [undefined,<span class="string">"a"</span>]</span><br><span class="line"></span><br><span class="line">// find()</span><br><span class="line">[,<span class="string">'a'</span>].find(x =&gt; <span class="literal">true</span>) // undefined</span><br><span class="line"></span><br><span class="line">// findIndex()</span><br><span class="line">[,<span class="string">'a'</span>].findIndex(x =&gt; <span class="literal">true</span>) // 0</span><br></pre></td></tr></table></figure><p>由于空位的处理规则非常不统一，所以建议避免出现空位。</p>]]></content>
      
      
      <categories>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6_Number</title>
      <link href="/2019/01/15/es6-Number/"/>
      <url>/2019/01/15/es6-Number/</url>
      
        <content type="html"><![CDATA[<h3 id="ES6-数值的扩展"><a href="#ES6-数值的扩展" class="headerlink" title="ES6 数值的扩展"></a>ES6 数值的扩展</h3><h4 id="二进制和八进制表示法"><a href="#二进制和八进制表示法" class="headerlink" title="二进制和八进制表示法"></a>二进制和八进制表示法</h4><p>ES6 提供了二进制和八进制数值的新的写法，分别用前缀 0b（或 0B）和 0o（或 0O）表示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0b111110111 === 503 // <span class="literal">true</span></span><br><span class="line">0o767 === 503 // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>从 ES5 开始，在严格模式之中，八进制就不再允许使用前缀 0 表示，ES6 进一步明确，要使用前缀 0o 表示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 非严格模式</span><br><span class="line">(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">  console.log(0o11 === 011);</span><br><span class="line">&#125;)() // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">// 严格模式</span><br><span class="line">(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">  <span class="string">'use strict'</span>;</span><br><span class="line">  console.log(0o11 === 011);</span><br><span class="line">&#125;)() // Uncaught SyntaxError: Octal literals are not allowed <span class="keyword">in</span> strict mode.</span><br></pre></td></tr></table></figure><p>如果要将 0b 和 0o 前缀的字符串数值转为十进制，要使用 Number 方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Number(<span class="string">'0b111'</span>)  // 7</span><br><span class="line">Number(<span class="string">'0o10'</span>)  // 8</span><br></pre></td></tr></table></figure><h4 id="Number-isFinite-Number-isNaN"><a href="#Number-isFinite-Number-isNaN" class="headerlink" title="Number.isFinite(), Number.isNaN()"></a>Number.isFinite(), Number.isNaN()</h4><p>ES6 在 Number 对象上，新提供了 Number.isFinite()和 Number.isNaN()两个方法。</p><p>Number.isFinite()用来检查一个数值是否为有限的（finite）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Number.isFinite(15); // <span class="literal">true</span></span><br><span class="line">Number.isFinite(0.8); // <span class="literal">true</span></span><br><span class="line">Number.isFinite(NaN); // <span class="literal">false</span></span><br><span class="line">Number.isFinite(Infinity); // <span class="literal">false</span></span><br><span class="line">Number.isFinite(-Infinity); // <span class="literal">false</span></span><br><span class="line">Number.isFinite(<span class="string">'foo'</span>); // <span class="literal">false</span></span><br><span class="line">Number.isFinite(<span class="string">'15'</span>); // <span class="literal">false</span></span><br><span class="line">Number.isFinite(<span class="literal">true</span>); // <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>ES5 可以通过下面的代码，部署 Number.isFinite 方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (global) &#123;</span><br><span class="line">  var global_isFinite = global.isFinite;</span><br><span class="line"></span><br><span class="line">  Object.defineProperty(Number, <span class="string">'isFinite'</span>, &#123;</span><br><span class="line">    value: <span class="keyword">function</span> isFinite(value) &#123;</span><br><span class="line">      <span class="built_in">return</span> typeof value === <span class="string">'number'</span> &amp;&amp; global_isFinite(value);</span><br><span class="line">    &#125;,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    writable: <span class="literal">true</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)(this);</span><br></pre></td></tr></table></figure><p>Number.isNaN()用来检查一个值是否为 NaN。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Number.isNaN(NaN) // <span class="literal">true</span></span><br><span class="line">Number.isNaN(15) // <span class="literal">false</span></span><br><span class="line">Number.isNaN(<span class="string">'15'</span>) // <span class="literal">false</span></span><br><span class="line">Number.isNaN(<span class="literal">true</span>) // <span class="literal">false</span></span><br><span class="line">Number.isNaN(9/NaN) // <span class="literal">true</span></span><br><span class="line">Number.isNaN(<span class="string">'true'</span>/0) // <span class="literal">true</span></span><br><span class="line">Number.isNaN(<span class="string">'true'</span>/<span class="string">'true'</span>) // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>ES5 通过下面的代码，部署 Number.isNaN()。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (global) &#123;</span><br><span class="line">  var global_isNaN = global.isNaN;</span><br><span class="line"></span><br><span class="line">  Object.defineProperty(Number, <span class="string">'isNaN'</span>, &#123;</span><br><span class="line">    value: <span class="keyword">function</span> isNaN(value) &#123;</span><br><span class="line">      <span class="built_in">return</span> typeof value === <span class="string">'number'</span> &amp;&amp; global_isNaN(value);</span><br><span class="line">    &#125;,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    writable: <span class="literal">true</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)(this);</span><br></pre></td></tr></table></figure><p>它们与传统的全局方法 isFinite()和 isNaN()的区别在于，传统方法先调用 Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，非数值一律返回 false。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">isFinite(25) // <span class="literal">true</span></span><br><span class="line">isFinite(<span class="string">"25"</span>) // <span class="literal">true</span></span><br><span class="line">Number.isFinite(25) // <span class="literal">true</span></span><br><span class="line">Number.isFinite(<span class="string">"25"</span>) // <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">isNaN(NaN) // <span class="literal">true</span></span><br><span class="line">isNaN(<span class="string">"NaN"</span>) // <span class="literal">true</span></span><br><span class="line">Number.isNaN(NaN) // <span class="literal">true</span></span><br><span class="line">Number.isNaN(<span class="string">"NaN"</span>) // <span class="literal">false</span></span><br></pre></td></tr></table></figure><h4 id="Number-parseInt-Number-parseFloat"><a href="#Number-parseInt-Number-parseFloat" class="headerlink" title="Number.parseInt(), Number.parseFloat()"></a>Number.parseInt(), Number.parseFloat()</h4><p>ES6 将全局方法 parseInt()和 parseFloat()，移植到 Number 对象上面，行为完全保持不变。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// ES5的写法</span><br><span class="line">parseInt(<span class="string">'12.34'</span>) // 12</span><br><span class="line">parseFloat(<span class="string">'123.45#'</span>) // 123.45</span><br><span class="line"></span><br><span class="line">// ES6的写法</span><br><span class="line">Number.parseInt(<span class="string">'12.34'</span>) // 12</span><br><span class="line">Number.parseFloat(<span class="string">'123.45#'</span>) // 123.45</span><br></pre></td></tr></table></figure><p>这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Number.parseInt === parseInt // <span class="literal">true</span></span><br><span class="line">Number.parseFloat === parseFloat // <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="Number-isInteger"><a href="#Number-isInteger" class="headerlink" title="Number.isInteger()"></a>Number.isInteger()</h4><p>Number.isInteger()用来判断一个值是否为整数。需要注意的是，在 JavaScript 内部，整数和浮点数是同样的储存方法，所以 3 和 3.0 被视为同一个值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Number.isInteger(25) // <span class="literal">true</span></span><br><span class="line">Number.isInteger(25.0) // <span class="literal">true</span></span><br><span class="line">Number.isInteger(25.1) // <span class="literal">false</span></span><br><span class="line">Number.isInteger(<span class="string">"15"</span>) // <span class="literal">false</span></span><br><span class="line">Number.isInteger(<span class="literal">true</span>) // <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>ES5 可以通过下面的代码，部署 Number.isInteger()。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (global) &#123;</span><br><span class="line">  var floor = Math.floor,</span><br><span class="line">    isFinite = global.isFinite;</span><br><span class="line"></span><br><span class="line">  Object.defineProperty(Number, <span class="string">'isInteger'</span>, &#123;</span><br><span class="line">    value: <span class="keyword">function</span> isInteger(value) &#123;</span><br><span class="line">      <span class="built_in">return</span> typeof value === <span class="string">'number'</span> &amp;&amp; isFinite(value) &amp;&amp;</span><br><span class="line">        value &gt; -9007199254740992 &amp;&amp; value &lt; 9007199254740992 &amp;&amp;</span><br><span class="line">        floor(value) === value;</span><br><span class="line">    &#125;,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    writable: <span class="literal">true</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)(this);</span><br></pre></td></tr></table></figure><h4 id="Number-EPSILON"><a href="#Number-EPSILON" class="headerlink" title="Number.EPSILON"></a>Number.EPSILON</h4><p>ES6 在 Number 对象上面，新增一个极小的常量 Number.EPSILON。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Number.EPSILON</span><br><span class="line">// 2.220446049250313e-16</span><br><span class="line">Number.EPSILON.toFixed(20)</span><br><span class="line">// <span class="string">'0.00000000000000022204'</span></span><br></pre></td></tr></table></figure><p>引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。我们知道浮点数计算是不精确的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0.1 + 0.2</span><br><span class="line">// 0.30000000000000004</span><br><span class="line"></span><br><span class="line">0.1 + 0.2 - 0.3</span><br><span class="line">// 5.551115123125783e-17</span><br><span class="line"></span><br><span class="line">5.551115123125783e-17.toFixed(20)</span><br><span class="line">// <span class="string">'0.00000000000000005551'</span></span><br></pre></td></tr></table></figure><p>但是如果这个误差能够小于 Number.EPSILON，我们就可以认为得到了正确结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5.551115123125783e-17 &lt; Number.EPSILON</span><br><span class="line">// <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>因此，Number.EPSILON 的实质是一个可以接受的误差范围。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> withinErrorMargin (left, right) &#123;</span><br><span class="line">  <span class="built_in">return</span> Math.abs(left - right) &lt; Number.EPSILON;</span><br><span class="line">&#125;</span><br><span class="line">withinErrorMargin(0.1 + 0.2, 0.3)</span><br><span class="line">// <span class="literal">true</span></span><br><span class="line">withinErrorMargin(0.2 + 0.2, 0.3)</span><br><span class="line">// <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>上面的代码为浮点数运算，部署了一个误差检查函数。</p><h4 id="安全整数和-Number-isSafeInteger"><a href="#安全整数和-Number-isSafeInteger" class="headerlink" title="安全整数和 Number.isSafeInteger()"></a>安全整数和 Number.isSafeInteger()</h4><p>JavaScript 能够准确表示的整数范围在-2^53 到 2^53 之间（不含两个端点），超过这个范围，无法精确表示这个值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Math.pow(2, 53) // 9007199254740992</span><br><span class="line"></span><br><span class="line">9007199254740992  // 9007199254740992</span><br><span class="line">9007199254740993  // 9007199254740992</span><br><span class="line"></span><br><span class="line">Math.pow(2, 53) === Math.pow(2, 53) + 1</span><br><span class="line">// <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>上面代码中，超出 2 的 53 次方之后，一个数就不精确了。</p><p>ES6 引入了 Number.MAX_SAFE_INTEGER 和 Number.MIN_SAFE_INTEGER 这两个常量，用来表示这个范围的上下限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Number.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1</span><br><span class="line">// <span class="literal">true</span></span><br><span class="line">Number.MAX_SAFE_INTEGER === 9007199254740991</span><br><span class="line">// <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">Number.MIN_SAFE_INTEGER === -Number.MAX_SAFE_INTEGER</span><br><span class="line">// <span class="literal">true</span></span><br><span class="line">Number.MIN_SAFE_INTEGER === -9007199254740991</span><br><span class="line">// <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>上面代码中，可以看到 JavaScript 能够精确表示的极限。</p><p>Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Number.isSafeInteger(<span class="string">'a'</span>) // <span class="literal">false</span></span><br><span class="line">Number.isSafeInteger(null) // <span class="literal">false</span></span><br><span class="line">Number.isSafeInteger(NaN) // <span class="literal">false</span></span><br><span class="line">Number.isSafeInteger(Infinity) // <span class="literal">false</span></span><br><span class="line">Number.isSafeInteger(-Infinity) // <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">Number.isSafeInteger(3) // <span class="literal">true</span></span><br><span class="line">Number.isSafeInteger(1.2) // <span class="literal">false</span></span><br><span class="line">Number.isSafeInteger(9007199254740990) // <span class="literal">true</span></span><br><span class="line">Number.isSafeInteger(9007199254740992) // <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">Number.isSafeInteger(Number.MIN_SAFE_INTEGER - 1) // <span class="literal">false</span></span><br><span class="line">Number.isSafeInteger(Number.MIN_SAFE_INTEGER) // <span class="literal">true</span></span><br><span class="line">Number.isSafeInteger(Number.MAX_SAFE_INTEGER) // <span class="literal">true</span></span><br><span class="line">Number.isSafeInteger(Number.MAX_SAFE_INTEGER + 1) // <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>这个函数的实现很简单，就是跟安全整数的两个边界值比较一下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Number.isSafeInteger = <span class="keyword">function</span> (n) &#123;</span><br><span class="line">  <span class="built_in">return</span> (typeof n === <span class="string">'number'</span> &amp;&amp;</span><br><span class="line">    Math.round(n) === n &amp;&amp;</span><br><span class="line">    Number.MIN_SAFE_INTEGER &lt;= n &amp;&amp;</span><br><span class="line">    n &lt;= Number.MAX_SAFE_INTEGER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际使用这个函数时，需要注意。验证运算结果是否落在安全整数的范围内，不要只验证运算结果，而要同时验证参与运算的每个值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Number.isSafeInteger(9007199254740993)</span><br><span class="line">// <span class="literal">false</span></span><br><span class="line">Number.isSafeInteger(990)</span><br><span class="line">// <span class="literal">true</span></span><br><span class="line">Number.isSafeInteger(9007199254740993 - 990)</span><br><span class="line">// <span class="literal">true</span></span><br><span class="line">9007199254740993 - 990</span><br><span class="line">// 返回结果 9007199254740002</span><br><span class="line">// 正确答案应该是 9007199254740003</span><br></pre></td></tr></table></figure><p>上面代码中，9007199254740993 不是一个安全整数，但是 Number.isSafeInteger 会返回结果，显示计算结果是安全的。这是因为，这个数超出了精度范围，导致在计算机内部，以 9007199254740992 的形式储存。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">9007199254740993 === 9007199254740992</span><br><span class="line">// <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>所以，如果只验证运算结果是否为安全整数，很可能得到错误结果。下面的函数可以同时验证两个运算数和运算结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> trusty (left, right, result) &#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    Number.isSafeInteger(left) &amp;&amp;</span><br><span class="line">    Number.isSafeInteger(right) &amp;&amp;</span><br><span class="line">    Number.isSafeInteger(result)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="built_in">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  throw new RangeError(<span class="string">'Operation cannot be trusted!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trusty(9007199254740993, 990, 9007199254740993 - 990)</span><br><span class="line">// RangeError: Operation cannot be trusted!</span><br><span class="line"></span><br><span class="line">trusty(1, 2, 3)</span><br><span class="line">// 3</span><br></pre></td></tr></table></figure><h4 id="Math-对象的扩展"><a href="#Math-对象的扩展" class="headerlink" title="Math 对象的扩展"></a>Math 对象的扩展</h4><p>ES6 在 Math 对象上新增了 17 个与数学相关的方法。所有这些方法都是静态方法，只能在 Math 对象上调用。</p><h5 id="Math-trunc"><a href="#Math-trunc" class="headerlink" title="Math.trunc()"></a>Math.trunc()</h5><p>Math.trunc 方法用于去除一个数的小数部分，返回整数部分。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Math.trunc(4.1) // 4</span><br><span class="line">Math.trunc(4.9) // 4</span><br><span class="line">Math.trunc(-4.1) // -4</span><br><span class="line">Math.trunc(-4.9) // -4</span><br><span class="line">Math.trunc(-0.1234) // -0</span><br></pre></td></tr></table></figure><p>对于非数值，Math.trunc 内部使用 Number 方法将其先转为数值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.trunc(<span class="string">'123.456'</span>)</span><br><span class="line">// 123</span><br></pre></td></tr></table></figure><p>对于空值和无法截取整数的值，返回 NaN。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Math.trunc(NaN);      // NaN</span><br><span class="line">Math.trunc(<span class="string">'foo'</span>);    // NaN</span><br><span class="line">Math.trunc();         // NaN</span><br></pre></td></tr></table></figure><p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Math.trunc = Math.trunc || <span class="keyword">function</span>(x) &#123;</span><br><span class="line">  <span class="built_in">return</span> x &lt; 0 ? Math.ceil(x) : Math.floor(x);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="Math-sign"><a href="#Math-sign" class="headerlink" title="Math.sign()"></a>Math.sign()</h5><p>Math.sign 方法用来判断一个数到底是正数、负数、还是零。</p><p>它会返回五种值。</p><pre>参数为正数，返回+1；参数为负数，返回-1；参数为 0，返回 0；参数为-0，返回-0;其他值，返回 NaN。</pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Math.sign(-5) // -1</span><br><span class="line">Math.sign(5) // +1</span><br><span class="line">Math.sign(0) // +0</span><br><span class="line">Math.sign(-0) // -0</span><br><span class="line">Math.sign(NaN) // NaN</span><br><span class="line">Math.sign(<span class="string">'foo'</span>); // NaN</span><br><span class="line">Math.sign();      // NaN</span><br></pre></td></tr></table></figure><p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Math.sign = Math.sign || <span class="keyword">function</span>(x) &#123;</span><br><span class="line">  x = +x; // convert to a number</span><br><span class="line">  <span class="keyword">if</span> (x === 0 || isNaN(x)) &#123;</span><br><span class="line">    <span class="built_in">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> x &gt; 0 ? 1 : -1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="Math-cbrt"><a href="#Math-cbrt" class="headerlink" title="Math.cbrt()"></a>Math.cbrt()</h5><p>Math.cbrt 方法用于计算一个数的立方根。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Math.cbrt(-1) // -1</span><br><span class="line">Math.cbrt(0)  // 0</span><br><span class="line">Math.cbrt(1)  // 1</span><br><span class="line">Math.cbrt(2)  // 1.2599210498948734</span><br></pre></td></tr></table></figure><p>对于非数值，Math.cbrt 方法内部也是先使用 Number 方法将其转为数值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.cbrt(<span class="string">'8'</span>) // 2</span><br><span class="line">Math.cbrt(<span class="string">'hello'</span>) // NaN</span><br></pre></td></tr></table></figure><p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Math.cbrt = Math.cbrt || <span class="keyword">function</span>(x) &#123;</span><br><span class="line">  var y = Math.pow(Math.abs(x), 1/3);</span><br><span class="line">  <span class="built_in">return</span> x &lt; 0 ? -y : y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="Math-clz32"><a href="#Math-clz32" class="headerlink" title="Math.clz32()"></a>Math.clz32()</h5><p>JavaScript 的整数使用 32 位二进制形式表示，Math.clz32 方法返回一个数的 32 位无符号整数形式有多少个前导 0。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Math.clz32(0) // 32</span><br><span class="line">Math.clz32(1) // 31</span><br><span class="line">Math.clz32(1000) // 22</span><br><span class="line">Math.clz32(0b01000000000000000000000000000000) // 1</span><br><span class="line">Math.clz32(0b00100000000000000000000000000000) // 2</span><br></pre></td></tr></table></figure><p>上面代码中，0 的二进制形式全为 0，所以有 32 个前导 0；1 的二进制形式是 0b1，只占 1 位，所以 32 位之中有 31 个前导 0；1000 的二进制形式是 0b1111101000，一共有 10 位，所以 32 位之中有 22 个前导 0。</p><p>clz32 这个函数名就来自”count leading zero bits in 32-bit binary representations of a number“（计算 32 位整数的前导 0）的缩写。</p><p>左移运算符（&lt;&lt;）与 Math.clz32 方法直接相关。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Math.clz32(0) // 32</span><br><span class="line">Math.clz32(1) // 31</span><br><span class="line">Math.clz32(1 &lt;&lt; 1) // 30</span><br><span class="line">Math.clz32(1 &lt;&lt; 2) // 29</span><br><span class="line">Math.clz32(1 &lt;&lt; 29) // 2</span><br></pre></td></tr></table></figure><p>对于小数，Math.clz32 方法只考虑整数部分。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.clz32(3.2) // 30</span><br><span class="line">Math.clz32(3.9) // 30</span><br></pre></td></tr></table></figure><p>对于空值或其他类型的值，Math.clz32 方法会将它们先转为数值，然后再计算。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Math.clz32() // 32</span><br><span class="line">Math.clz32(NaN) // 32</span><br><span class="line">Math.clz32(Infinity) // 32</span><br><span class="line">Math.clz32(null) // 32</span><br><span class="line">Math.clz32(<span class="string">'foo'</span>) // 32</span><br><span class="line">Math.clz32([]) // 32</span><br><span class="line">Math.clz32(&#123;&#125;) // 32</span><br><span class="line">Math.clz32(<span class="literal">true</span>) // 31</span><br></pre></td></tr></table></figure><h5 id="Math-imul"><a href="#Math-imul" class="headerlink" title="Math.imul()"></a>Math.imul()</h5><p>Math.imul 方法返回两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Math.imul(2, 4)   // 8</span><br><span class="line">Math.imul(-1, 8)  // -8</span><br><span class="line">Math.imul(-2, -2) // 4</span><br></pre></td></tr></table></figure><p>如果只考虑最后 32 位，大多数情况下，Math.imul(a, b)与 a _ b 的结果是相同的，即该方法等同于(a _ b)|0 的效果（超过 32 位的部分溢出）。之所以需要部署这个方法，是因为 JavaScript 有精度限制，超过 2 的 53 次方的值无法精确表示。这就是说，对于那些很大的数的乘法，低位数值往往都是不精确的，Math.imul 方法可以返回正确的低位数值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(0x7fffffff * 0x7fffffff)|0 // 0</span><br></pre></td></tr></table></figure><p>上面这个乘法算式，返回结果为 0。但是由于这两个二进制数的最低位都是 1，所以这个结果肯定是不正确的，因为根据二进制乘法，计算结果的二进制最低位应该也是 1。这个错误就是因为它们的乘积超过了 2 的 53 次方，JavaScript 无法保存额外的精度，就把低位的值都变成了 0。Math.imul 方法可以返回正确的值 1。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.imul(0x7fffffff, 0x7fffffff) // 1</span><br></pre></td></tr></table></figure><h5 id="Math-fround"><a href="#Math-fround" class="headerlink" title="Math.fround()"></a>Math.fround()</h5><p>Math.fround 方法返回一个数的单精度浮点数形式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Math.fround(0)     // 0</span><br><span class="line">Math.fround(1)     // 1</span><br><span class="line">Math.fround(1.337) // 1.3370000123977661</span><br><span class="line">Math.fround(1.5)   // 1.5</span><br><span class="line">Math.fround(NaN)   // NaN</span><br></pre></td></tr></table></figure><p>对于整数来说，Math.fround 方法返回结果不会有任何不同，区别主要是那些无法用 64 个二进制位精确表示的小数。这时，Math.fround 方法会返回最接近这个小数的单精度浮点数。</p><p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Math.fround = Math.fround || <span class="keyword">function</span>(x) &#123;</span><br><span class="line">  <span class="built_in">return</span> new Float32Array([x])[0];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="Math-hypot"><a href="#Math-hypot" class="headerlink" title="Math.hypot()"></a>Math.hypot()</h5><p>Math.hypot 方法返回所有参数的平方和的平方根。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Math.hypot(3, 4);        // 5</span><br><span class="line">Math.hypot(3, 4, 5);     // 7.0710678118654755</span><br><span class="line">Math.hypot();            // 0</span><br><span class="line">Math.hypot(NaN);         // NaN</span><br><span class="line">Math.hypot(3, 4, <span class="string">'foo'</span>); // NaN</span><br><span class="line">Math.hypot(3, 4, <span class="string">'5'</span>);   // 7.0710678118654755</span><br><span class="line">Math.hypot(-3);          // 3</span><br></pre></td></tr></table></figure><p>上面代码中，3 的平方加上 4 的平方，等于 5 的平方。</p><p>如果参数不是数值，Math.hypot 方法会将其转为数值。只要有一个参数无法转为数值，就会返回 NaN。</p><h4 id="对数方法"><a href="#对数方法" class="headerlink" title="对数方法"></a>对数方法</h4><p>ES6 新增了 4 个对数相关方法。</p><p>（1） Math.expm1()</p><p>Math.expm1(x)返回 ex - 1，即 Math.exp(x) - 1。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Math.expm1(-1) // -0.6321205588285577</span><br><span class="line">Math.expm1(0)  // 0</span><br><span class="line">Math.expm1(1)  // 1.718281828459045</span><br></pre></td></tr></table></figure><p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Math.expm1 = Math.expm1 || <span class="keyword">function</span>(x) &#123;</span><br><span class="line">  <span class="built_in">return</span> Math.exp(x) - 1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>（2）Math.log1p()</p><p>Math.log1p(x)方法返回 1 + x 的自然对数，即 Math.log(1 + x)。如果 x 小于-1，返回 NaN。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Math.log1p(1)  // 0.6931471805599453</span><br><span class="line">Math.log1p(0)  // 0</span><br><span class="line">Math.log1p(-1) // -Infinity</span><br><span class="line">Math.log1p(-2) // NaN</span><br></pre></td></tr></table></figure><p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Math.log1p = Math.log1p || <span class="keyword">function</span>(x) &#123;</span><br><span class="line">  <span class="built_in">return</span> Math.log(1 + x);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>（3）Math.log10()</p><p>Math.log10(x)返回以 10 为底的 x 的对数。如果 x 小于 0，则返回 NaN。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Math.log10(2)      // 0.3010299956639812</span><br><span class="line">Math.log10(1)      // 0</span><br><span class="line">Math.log10(0)      // -Infinity</span><br><span class="line">Math.log10(-2)     // NaN</span><br><span class="line">Math.log10(100000) // 5</span><br></pre></td></tr></table></figure><p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Math.log10 = Math.log10 || <span class="keyword">function</span>(x) &#123;</span><br><span class="line">  <span class="built_in">return</span> Math.log(x) / Math.LN10;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>（4）Math.log2()</p><p>Math.log2(x)返回以 2 为底的 x 的对数。如果 x 小于 0，则返回 NaN。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Math.log2(3)       // 1.584962500721156</span><br><span class="line">Math.log2(2)       // 1</span><br><span class="line">Math.log2(1)       // 0</span><br><span class="line">Math.log2(0)       // -Infinity</span><br><span class="line">Math.log2(-2)      // NaN</span><br><span class="line">Math.log2(1024)    // 10</span><br><span class="line">Math.log2(1 &lt;&lt; 29) // 29</span><br></pre></td></tr></table></figure><p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Math.log2 = Math.log2 || <span class="keyword">function</span>(x) &#123;</span><br><span class="line">  <span class="built_in">return</span> Math.log(x) / Math.LN2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="三角函数方法"><a href="#三角函数方法" class="headerlink" title="三角函数方法"></a>三角函数方法</h4><p>ES6 新增了 6 个三角函数方法。</p><p>1.Math.sinh(x) 返回 x 的双曲正弦（hyperbolic sine）<br>2.Math.cosh(x) 返回 x 的双曲余弦（hyperbolic cosine）<br>3.Math.tanh(x) 返回 x 的双曲正切（hyperbolic tangent）<br>4.Math.asinh(x) 返回 x 的反双曲正弦（inverse hyperbolic sine）<br>5.Math.acosh(x) 返回 x 的反双曲余弦（inverse hyperbolic cosine）<br>6.Math.atanh(x) 返回 x 的反双曲正切（inverse hyperbolic tangent）</p><h4 id="指数运算符"><a href="#指数运算符" class="headerlink" title="指数运算符"></a>指数运算符</h4><p>ES7 新增了一个指数运算符（**），目前 Babel 转码器已经支持。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 ** 2 // 4</span><br><span class="line">2 ** 3 // 8</span><br></pre></td></tr></table></figure><p>指数运算符可以与等号结合，形成一个新的赋值运算符（**=）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> a = 2;</span><br><span class="line">a **= 2;</span><br><span class="line">// 等同于 a = a * a;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> b = 3;</span><br><span class="line">b **= 3;</span><br><span class="line">// 等同于 b = b * b * b;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6_RegExp</title>
      <link href="/2019/01/10/es6-RegExp/"/>
      <url>/2019/01/10/es6-RegExp/</url>
      
        <content type="html"><![CDATA[<h3 id="ES6-正则的扩展"><a href="#ES6-正则的扩展" class="headerlink" title="ES6 正则的扩展"></a>ES6 正则的扩展</h3><h4 id="RegExp-构造函数"><a href="#RegExp-构造函数" class="headerlink" title="RegExp 构造函数"></a>RegExp 构造函数</h4><p>在 ES5 中，RegExp 构造函数的参数有两种情况。</p><p>第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var regex = new RegExp(<span class="string">'xyz'</span>, <span class="string">'i'</span>);</span><br><span class="line">// 等价于</span><br><span class="line">var regex = /xyz/i;</span><br></pre></td></tr></table></figure><p>第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var regex = new RegExp(/xyz/i);</span><br><span class="line">// 等价于</span><br><span class="line">var regex = /xyz/i;</span><br></pre></td></tr></table></figure><p>但是，ES5 不允许此时使用第二个参数，添加修饰符，否则会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var regex = new RegExp(/xyz/, <span class="string">'i'</span>);</span><br><span class="line">// Uncaught TypeError: Cannot supply flags when constructing one RegExp from another</span><br></pre></td></tr></table></figure><p>ES6 改变了这种行为。如果 RegExp 构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new RegExp(/abc/ig, <span class="string">'i'</span>).flags</span><br><span class="line">// <span class="string">"i"</span></span><br></pre></td></tr></table></figure><p>上面代码中，原有正则对象的修饰符是 ig，它会被第二个参数 i 覆盖。</p><h4 id="字符串的正则方法"><a href="#字符串的正则方法" class="headerlink" title="字符串的正则方法"></a>字符串的正则方法</h4><p>字符串对象共有 4 个方法，可以使用正则表达式：match()、replace()、search()和 split()。</p><p>ES6 将这 4 个方法，在语言内部全部调用 RegExp 的实例方法，从而做到所有与正则相关的方法，全都定义在 RegExp 对象上。</p><p>1.String.prototype.match 调用 RegExp.prototype[Symbol.match]<br>2.String.prototype.replace 调用 RegExp.prototype[Symbol.replace]<br>3.String.prototype.search 调用 RegExp.prototype[Symbol.search]<br>4.String.prototype.split 调用 RegExp.prototype[Symbol.split]</p><h4 id="u-修饰符"><a href="#u-修饰符" class="headerlink" title="u 修饰符"></a>u 修饰符</h4><p>ES6 对正则表达式添加了 u 修饰符，含义为“Unicode 模式”，用来正确处理大于\uFFFF 的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/^\uD83D/u.test(<span class="string">'\uD83D\uDC2A'</span>)</span><br><span class="line">// <span class="literal">false</span></span><br><span class="line">/^\uD83D/.<span class="built_in">test</span>(<span class="string">'\uD83D\uDC2A'</span>)</span><br><span class="line">// <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>上面代码中，\uD83D\uDC2A 是一个四个字节的 UTF-16 编码，代表一个字符。但是，ES5 不支持四个字节的 UTF-16 编码，会将其识别为两个字符，导致第二行代码结果为 true。加了 u 修饰符以后，ES6 就会识别其为一个字符，所以第一行代码结果为 false。</p><p>一旦加上 u 修饰符号，就会修改下面这些正则表达式的行为。</p><p>（1）点字符</p><p>点（.）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于 0xFFFF 的 Unicode 字符，点字符不能识别，必须加上 u 修饰符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var s = <span class="string">'𠮷'</span>;</span><br><span class="line">/^.$/.<span class="built_in">test</span>(s) // <span class="literal">false</span></span><br><span class="line">/^.$/u.test(s) // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>上面代码表示，如果不添加 u 修饰符，正则表达式就会认为字符串为两个字符，从而匹配失败。</p><p>（2）Unicode 字符表示法</p><p>ES6 新增了使用大括号表示 Unicode 字符，这种表示法在正则表达式中必须加上 u 修饰符，才能识别。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/\u&#123;61&#125;/.<span class="built_in">test</span>(<span class="string">'a'</span>) // <span class="literal">false</span></span><br><span class="line">/\u&#123;61&#125;/u.test(<span class="string">'a'</span>) // <span class="literal">true</span></span><br><span class="line">/\u&#123;20BB7&#125;/u.test(<span class="string">'𠮷'</span>) // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>上面代码表示，如果不加 u 修饰符，正则表达式无法识别\u{61}这种表示法，只会认为这匹配 61 个连续的 u。</p><p>（3）量词</p><p>使用 u 修饰符后，所有量词都会正确识别码点大于 0xFFFF 的 Unicode 字符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/a&#123;2&#125;/.<span class="built_in">test</span>(<span class="string">'aa'</span>) // <span class="literal">true</span></span><br><span class="line">/a&#123;2&#125;/u.test(<span class="string">'aa'</span>) // <span class="literal">true</span></span><br><span class="line">/𠮷&#123;2&#125;/.<span class="built_in">test</span>(<span class="string">'𠮷𠮷'</span>) // <span class="literal">false</span></span><br><span class="line">/𠮷&#123;2&#125;/u.test(<span class="string">'𠮷𠮷'</span>) // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>另外，只有在使用 u 修饰符的情况下，Unicode 表达式当中的大括号才会被正确解读，否则会被解读为量词。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/^\u&#123;3&#125;$/.<span class="built_in">test</span>(<span class="string">'uuu'</span>) // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>上面代码中，由于正则表达式没有 u 修饰符，所以大括号被解读为量词。加上 u 修饰符，就会被解读为 Unicode 表达式。</p><p>（4）预定义模式</p><p>u 修饰符也影响到预定义模式，能否正确识别码点大于 0xFFFF 的 Unicode 字符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/^\S$/.<span class="built_in">test</span>(<span class="string">'𠮷'</span>) // <span class="literal">false</span></span><br><span class="line">/^\S$/u.test(<span class="string">'𠮷'</span>) // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>上面代码的\S 是预定义模式，匹配所有不是空格的字符。只有加了 u 修饰符，它才能正确匹配码点大于 0xFFFF 的 Unicode 字符。</p><p>利用这一点，可以写出一个正确返回字符串长度的函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> codePointLength(text) &#123;</span><br><span class="line">  var result = text.match(/[\s\S]/gu);</span><br><span class="line">  <span class="built_in">return</span> result ? result.length : 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var s = <span class="string">'𠮷𠮷'</span>;</span><br><span class="line"></span><br><span class="line">s.length // 4</span><br><span class="line">codePointLength(s) // 2</span><br></pre></td></tr></table></figure><p>（5）i 修饰符</p><p>有些 Unicode 字符的编码不同，但是字型很相近，比如，\u004B 与\u212A 都是大写的 K。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/[a-z]/i.test(<span class="string">'\u212A'</span>) // <span class="literal">false</span></span><br><span class="line">/[a-z]/iu.test(<span class="string">'\u212A'</span>) // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>上面代码中，不加 u 修饰符，就无法识别非规范的 K 字符。</p><h4 id="y-修饰符"><a href="#y-修饰符" class="headerlink" title="y 修饰符"></a>y 修饰符</h4><p>除了 u 修饰符，ES6 还为正则表达式添加了 y 修饰符，叫做“粘连”（sticky）修饰符。</p><p>y 修饰符的作用与 g 修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g 修饰符只要剩余位置中存在匹配就可，而 y 修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var s = <span class="string">'aaa_aa_a'</span>;</span><br><span class="line">var r1 = /a+/g;</span><br><span class="line">var r2 = /a+/y;</span><br><span class="line"></span><br><span class="line">r1.exec(s) // [<span class="string">"aaa"</span>]</span><br><span class="line">r2.exec(s) // [<span class="string">"aaa"</span>]</span><br><span class="line"></span><br><span class="line">r1.exec(s) // [<span class="string">"aa"</span>]</span><br><span class="line">r2.exec(s) // null</span><br></pre></td></tr></table></figure><p>上面代码有两个正则表达式，一个使用 g 修饰符，另一个使用 y 修饰符。这两个正则表达式各执行了两次，第一次执行的时候，两者行为相同，剩余字符串都是_aa_a。由于 g 修饰没有位置要求，所以第二次执行会返回结果，而 y 修饰符要求匹配必须从头部开始，所以返回 null。</p><p>如果改一下正则表达式，保证每次都能头部匹配，y 修饰符就会返回结果了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var s = <span class="string">'aaa_aa_a'</span>;</span><br><span class="line">var r = /a+_/y;</span><br><span class="line"></span><br><span class="line">r.exec(s) // [<span class="string">"aaa_"</span>]</span><br><span class="line">r.exec(s) // [<span class="string">"aa_"</span>]</span><br></pre></td></tr></table></figure><p>上面代码每次匹配，都是从剩余字符串的头部开始。</p><p>使用 lastIndex 属性，可以更好地说明 y 修饰符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const REGEX = /a/g;</span><br><span class="line"></span><br><span class="line">// 指定从2号位置（y）开始匹配</span><br><span class="line">REGEX.lastIndex = 2;</span><br><span class="line"></span><br><span class="line">// 匹配成功</span><br><span class="line">const match = REGEX.exec(<span class="string">'xaya'</span>);</span><br><span class="line"></span><br><span class="line">// 在3号位置匹配成功</span><br><span class="line">match.index // 3</span><br><span class="line"></span><br><span class="line">// 下一次匹配从4号位开始</span><br><span class="line">REGEX.lastIndex // 4</span><br><span class="line"></span><br><span class="line">// 4号位开始匹配失败</span><br><span class="line">REGEX.exec(<span class="string">'xaxa'</span>) // null</span><br></pre></td></tr></table></figure><p>上面代码中，lastIndex 属性指定每次搜索的开始位置，g 修饰符从这个位置开始向后搜索，直到发现匹配为止。</p><p>y 修饰符同样遵守 lastIndex 属性，但是要求必须在 lastIndex 指定的位置发现匹配。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const REGEX = /a/y;</span><br><span class="line"></span><br><span class="line">// 指定从2号位置开始匹配</span><br><span class="line">REGEX.lastIndex = 2;</span><br><span class="line"></span><br><span class="line">// 不是粘连，匹配失败</span><br><span class="line">REGEX.exec(<span class="string">'xaya'</span>) // null</span><br><span class="line"></span><br><span class="line">// 指定从3号位置开始匹配</span><br><span class="line">REGEX.lastIndex = 3;</span><br><span class="line"></span><br><span class="line">// 3号位置是粘连，匹配成功</span><br><span class="line">const match = REGEX.exec(<span class="string">'xaxa'</span>);</span><br><span class="line">match.index // 3</span><br><span class="line">REGEX.lastIndex // 4</span><br></pre></td></tr></table></figure><p>进一步说，y 修饰符号隐含了头部匹配的标志^。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/b/y.exec(<span class="string">'aba'</span>)</span><br><span class="line">// null</span><br></pre></td></tr></table></figure><p>上面代码由于不能保证头部匹配，所以返回 null。y 修饰符的设计本意，就是让头部匹配的标志^在全局匹配中都有效。</p><p>在 split 方法中使用 y 修饰符，原字符串必须以分隔符开头。这也意味着，只要匹配成功，数组的第一个成员肯定是空字符串。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 没有找到匹配</span><br><span class="line"><span class="string">'x##'</span>.split(/<span class="comment">#/y)</span></span><br><span class="line">// [ <span class="string">'x##'</span> ]</span><br><span class="line"></span><br><span class="line">// 找到两个匹配</span><br><span class="line"><span class="string">'##x'</span>.split(/<span class="comment">#/y)</span></span><br><span class="line">// [ <span class="string">''</span>, <span class="string">''</span>, <span class="string">'x'</span> ]</span><br></pre></td></tr></table></figure><p>后续的分隔符只有紧跟前面的分隔符，才会被识别。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'#x#'</span>.split(/<span class="comment">#/y)</span></span><br><span class="line">// [ <span class="string">''</span>, <span class="string">'x#'</span> ]</span><br><span class="line"></span><br><span class="line"><span class="string">'##'</span>.split(/<span class="comment">#/y)</span></span><br><span class="line">// [ <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span> ]</span><br></pre></td></tr></table></figure><p>下面是字符串对象的 replace 方法的例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const REGEX = /a/gy;</span><br><span class="line"><span class="string">'aaxa'</span>.replace(REGEX, <span class="string">'-'</span>) // <span class="string">'--xa'</span></span><br></pre></td></tr></table></figure><p>上面代码中，最后一个 a 因为不是出现下一次匹配的头部，所以不会被替换。</p><p>单单一个 y 修饰符对 match 方法，只能返回第一个匹配，必须与 g 修饰符联用，才能返回所有匹配。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'a1a2a3'</span>.match(/a\d/y) // [<span class="string">"a1"</span>]</span><br><span class="line"><span class="string">'a1a2a3'</span>.match(/a\d/gy) // [<span class="string">"a1"</span>, <span class="string">"a2"</span>, <span class="string">"a3"</span>]</span><br></pre></td></tr></table></figure><p>y 修饰符的一个应用，是从字符串提取 token（词元），y 修饰符确保了匹配之间不会有漏掉的字符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const TOKEN_Y = /\s*(\+|[0-9]+)\s*/y;</span><br><span class="line">const TOKEN_G  = /\s*(\+|[0-9]+)\s*/g;</span><br><span class="line"></span><br><span class="line">tokenize(TOKEN_Y, <span class="string">'3 + 4'</span>)</span><br><span class="line">// [ <span class="string">'3'</span>, <span class="string">'+'</span>, <span class="string">'4'</span> ]</span><br><span class="line">tokenize(TOKEN_G, <span class="string">'3 + 4'</span>)</span><br><span class="line">// [ <span class="string">'3'</span>, <span class="string">'+'</span>, <span class="string">'4'</span> ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> tokenize(TOKEN_REGEX, str) &#123;</span><br><span class="line">  <span class="built_in">let</span> result = [];</span><br><span class="line">  <span class="built_in">let</span> match;</span><br><span class="line">  <span class="keyword">while</span> (match = TOKEN_REGEX.exec(str)) &#123;</span><br><span class="line">    result.push(match[1]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，如果字符串里面没有非法字符，y 修饰符与 g 修饰符的提取结果是一样的。但是，一旦出现非法字符，两者的行为就不一样了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tokenize(TOKEN_Y, <span class="string">'3x + 4'</span>)</span><br><span class="line">// [ <span class="string">'3'</span> ]</span><br><span class="line">tokenize(TOKEN_G, <span class="string">'3x + 4'</span>)</span><br><span class="line">// [ <span class="string">'3'</span>, <span class="string">'+'</span>, <span class="string">'4'</span> ]</span><br></pre></td></tr></table></figure><p>上面代码中，g 修饰符会忽略非法字符，而 y 修饰符不会，这样就很容易发现错误。</p><h4 id="sticky-属性"><a href="#sticky-属性" class="headerlink" title="sticky 属性"></a>sticky 属性</h4><p>与 y 修饰符相匹配，ES6 的正则对象多了 sticky 属性，表示是否设置了 y 修饰符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var r = /hello\d/y;</span><br><span class="line">r.sticky // <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="flags-属性"><a href="#flags-属性" class="headerlink" title="flags 属性"></a>flags 属性</h4><p>ES6 为正则表达式新增了 flags 属性，会返回正则表达式的修饰符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// ES5的<span class="built_in">source</span>属性</span><br><span class="line">// 返回正则表达式的正文</span><br><span class="line">/abc/ig.source</span><br><span class="line">// <span class="string">"abc"</span></span><br><span class="line"></span><br><span class="line">// ES6的flags属性</span><br><span class="line">// 返回正则表达式的修饰符</span><br><span class="line">/abc/ig.flags</span><br><span class="line">// <span class="string">'gi'</span></span><br></pre></td></tr></table></figure><h4 id="RegExp-escape"><a href="#RegExp-escape" class="headerlink" title="RegExp.escape()"></a>RegExp.escape()</h4><p>字符串必须转义，才能作为正则模式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> escapeRegExp(str) &#123;</span><br><span class="line">  <span class="built_in">return</span> str.replace(/[\-\[\]\/\&#123;\&#125;\(\)\*\+\?\.\\\^\$\|]/g, <span class="string">'\\$&amp;'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> str = <span class="string">'/path/to/resource.html?search=query'</span>;</span><br><span class="line">escapeRegExp(str)</span><br><span class="line">// <span class="string">"\/path\/to\/resource\.html\?search=query"</span></span><br></pre></td></tr></table></figure><p>上面代码中，str 是一个正常字符串，必须使用反斜杠对其中的特殊字符转义，才能用来作为一个正则匹配的模式。</p><p>已经有提议将这个需求标准化，作为 RegExp 对象的静态方法 RegExp.escape()，放入 ES7。2015 年 7 月 31 日，TC39 认为，这个方法有安全风险，又不愿这个方法变得过于复杂，没有同意将其列入 ES7，但这不失为一个真实的需求。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RegExp.escape(<span class="string">'The Quick Brown Fox'</span>);</span><br><span class="line">// <span class="string">"The Quick Brown Fox"</span></span><br><span class="line"></span><br><span class="line">RegExp.escape(<span class="string">'Buy it. use it. break it. fix it.'</span>);</span><br><span class="line">// <span class="string">"Buy it\. use it\. break it\. fix it\."</span></span><br><span class="line"></span><br><span class="line">RegExp.escape(<span class="string">'(*.*)'</span>);</span><br><span class="line">// <span class="string">"\(\*\.\*\)"</span></span><br></pre></td></tr></table></figure><p>字符串转义以后，可以使用 RegExp 构造函数生成正则模式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str = <span class="string">'hello. how are you?'</span>;</span><br><span class="line">var regex = new RegExp(RegExp.escape(str), <span class="string">'g'</span>);</span><br><span class="line">assert.equal(String(regex), <span class="string">'/hello\. how are you\?/g'</span>);</span><br></pre></td></tr></table></figure><p>目前，该方法可以用上文的 escapeRegExp 函数或者垫片模块 regexp.escape 实现。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var escape = require(<span class="string">'regexp.escape'</span>);</span><br><span class="line">escape(<span class="string">'hi. how are you?'</span>);</span><br><span class="line">// <span class="string">"hi\\. how are you\\?"</span></span><br></pre></td></tr></table></figure><h4 id="s-修饰符：dotAll-模式"><a href="#s-修饰符：dotAll-模式" class="headerlink" title="s 修饰符：dotAll 模式"></a>s 修饰符：dotAll 模式</h4><p>正则表达式中，点（.）是一个特殊字符，代表任意的单个字符，但是行终止符（line terminator character）除外。</p><p>以下四个字符属于”行终止符“。</p><pre>U+000A 换行符（\n）U+000D 回车符（\r）U+2028 行分隔符（line separator）U+2029 段分隔符（paragraph separator）</pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/foo.bar/.<span class="built_in">test</span>(<span class="string">'foo\nbar'</span>)</span><br><span class="line">// <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>上面代码中，因为.不匹配\n，所以正则表达式返回 false。</p><p>但是，很多时候我们希望匹配的是任意单个字符，这时有一种变通的写法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/foo[^]bar/.<span class="built_in">test</span>(<span class="string">'foo\nbar'</span>)</span><br><span class="line">// <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>这种解决方案毕竟不太符合直觉，所以现在有一个提案，引入/s 修饰符，使得.可以匹配任意单个字符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/foo.bar/s.test(<span class="string">'foo\nbar'</span>) // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>这被称为 dotAll 模式，即点（dot）代表一切字符。所以，正则表达式还引入了一个 dotAll 属性，返回一个布尔值，表示该正则表达式是否处在 dotAll 模式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const re = /foo.bar/s;</span><br><span class="line">// 另一种写法</span><br><span class="line">// const re = new RegExp(<span class="string">'foo.bar'</span>, <span class="string">'s'</span>);</span><br><span class="line"></span><br><span class="line">re.test(<span class="string">'foo\nbar'</span>) // <span class="literal">true</span></span><br><span class="line">re.dotAll // <span class="literal">true</span></span><br><span class="line">re.flags // <span class="string">'s'</span></span><br></pre></td></tr></table></figure><p>/s 修饰符和多行修饰符/m 不冲突，两者一起使用的情况下，.匹配所有字符，而^和\$匹配每一行的行首和行尾。</p><h4 id="后行断言"><a href="#后行断言" class="headerlink" title="后行断言"></a>后行断言</h4><p>JavaScript 语言的正则表达式，只支持先行断言（lookahead）和先行否定断言（negative lookahead），不支持后行断言（lookbehind）和后行否定断言（negative lookbehind）。</p><p>目前，有一个提案，在 ES7 加入后行断言。V8 引擎 4.9 版已经支持，Chrome 浏览器 49 版打开”experimental JavaScript features“开关（地址栏键入 about:flags），就可以使用这项功能。</p><p>”先行断言“指的是，x 只有在 y 前面才匹配，必须写成/x(?=y)/。比如，只匹配百分号之前的数字，要写成/\d+(?=%)/。”先行否定断言“指的是，x 只有不在 y 前面才匹配，必须写成/x(?!y)/。比如，只匹配不在百分号之前的数字，要写成/\d+(?!%)/。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/\d+(?=%)/.<span class="built_in">exec</span>(<span class="string">'100% of US presidents have been male'</span>)  // [<span class="string">"100"</span>]</span><br><span class="line">/\d+(?!%)/.<span class="built_in">exec</span>(<span class="string">'that’s all 44 of them'</span>)                 // [<span class="string">"44"</span>]</span><br></pre></td></tr></table></figure><p>上面两个字符串，如果互换正则表达式，就会匹配失败。另外，还可以看到，”先行断言“括号之中的部分（(?=%)），是不计入返回结果的。</p><p>“后行断言”正好与”先行断言”相反，x 只有在 y 后面才匹配，必须写成/(?&lt;=y)x/。比如，只匹配美元符号之后的数字，要写成/(?&lt;=\$)\d+/。”后行否定断言“则与”先行否定断言“相反，x 只有不在 y 后面才匹配，必须写成/(?&lt;!y)x/。比如，只匹配不在美元符号后面的数字，要写成/(?&lt;!\$)\d+/。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/(?&lt;=\$)\d+/.<span class="built_in">exec</span>(<span class="string">'Benjamin Franklin is on the $100 bill'</span>)  // [<span class="string">"100"</span>]</span><br><span class="line">/(?&lt;!\$)\d+/.<span class="built_in">exec</span>(<span class="string">'it’s is worth about €90'</span>)                // [<span class="string">"90"</span>]</span><br></pre></td></tr></table></figure><p>上面的例子中，”后行断言”的括号之中的部分（(?&lt;=\$)），也是不计入返回结果。</p><p>“后行断言”的实现，需要先匹配/(?&lt;=y)x/的 x，然后再回到左边，匹配 y 的部分。这种”先右后左”的执行顺序，与所有其他正则操作相反，导致了一些不符合预期的行为。</p><p>首先，”后行断言“的组匹配，与正常情况下结果是不一样的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/(?&lt;=(\d+)(\d+))$/.<span class="built_in">exec</span>(<span class="string">'1053'</span>) // [<span class="string">""</span>, <span class="string">"1"</span>, <span class="string">"053"</span>]</span><br><span class="line">/^(\d+)(\d+)$/.<span class="built_in">exec</span>(<span class="string">'1053'</span>) // [<span class="string">"1053"</span>, <span class="string">"105"</span>, <span class="string">"3"</span>]</span><br></pre></td></tr></table></figure><p>上面代码中，需要捕捉两个组匹配。没有”后行断言”时，第一个括号是贪婪模式，第二个括号只能捕获一个字符，所以结果是 105 和 3。而”后行断言”时，由于执行顺序是从右到左，第二个括号是贪婪模式，第一个括号只能捕获一个字符，所以结果是 1 和 053。</p><p>其次，”后行断言”的反斜杠引用，也与通常的顺序相反，必须放在对应的那个括号之前。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/(?&lt;=(o)d\1)r/.<span class="built_in">exec</span>(<span class="string">'hodor'</span>)  // null</span><br><span class="line">/(?&lt;=\1d(o))r/.<span class="built_in">exec</span>(<span class="string">'hodor'</span>)  // [<span class="string">"r"</span>, <span class="string">"o"</span>]</span><br></pre></td></tr></table></figure><p>上面代码中，如果后行断言的反斜杠引用（\1）放在括号的后面，就不会得到匹配结果，必须放在前面才可以。</p><h4 id="Unicode-属性类"><a href="#Unicode-属性类" class="headerlink" title="Unicode 属性类"></a>Unicode 属性类</h4><p>目前，有一个提案，引入了一种新的类的写法\p{…}和\P{…}，允许正则表达式匹配符合 Unicode 某种属性的所有字符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const regexGreekSymbol = /\p&#123;Script=Greek&#125;/u;</span><br><span class="line">regexGreekSymbol.test(<span class="string">'π'</span>) // u</span><br></pre></td></tr></table></figure><p>上面代码中，\p{Script=Greek}指定匹配一个希腊文字母，所以匹配 π 成功。</p><p>Unicode 属性类要指定属性名和属性值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\p&#123;UnicodePropertyName=UnicodePropertyValue&#125;</span><br></pre></td></tr></table></figure><p>对于某些属性，可以只写属性名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\p&#123;UnicodePropertyName&#125;</span><br></pre></td></tr></table></figure><p>\P{…}是\p{…}的反向匹配，即匹配不满足条件的字符。</p><p>注意，这两种类只对 Unicode 有效，所以使用的时候一定要加上 u 修饰符。如果不加 u 修饰符，正则表达式使用\p 和\P 会报错，ECMAScript 预留了这两个类。</p><p>由于 Unicode 的各种属性非常多，所以这种新的类的表达能力非常强。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const regex = /^\p&#123;Decimal_Number&#125;+$/u;</span><br><span class="line">regex.test(<span class="string">'𝟏𝟐𝟑𝟜𝟝𝟞𝟩𝟪𝟫𝟬𝟭𝟮𝟯𝟺𝟻𝟼'</span>) // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>上面代码中，属性类指定匹配所有十进制字符，可以看到各种字型的十进制字符都会匹配成功。</p><p>\p{Number}甚至能匹配罗马数字。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 匹配所有数字</span><br><span class="line">const regex = /^\p&#123;Number&#125;+$/u;</span><br><span class="line">regex.test(<span class="string">'²³¹¼½¾'</span>) // <span class="literal">true</span></span><br><span class="line">regex.test(<span class="string">'㉛㉜㉝'</span>) // <span class="literal">true</span></span><br><span class="line">regex.test(<span class="string">'ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫ'</span>) // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>下面是其他一些例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 匹配各种文字的所有字母，等同于Unicode版的\w</span><br><span class="line">[\p&#123;Alphabetic&#125;\p&#123;Mark&#125;\p&#123;Decimal_Number&#125;\p&#123;Connector_Punctuation&#125;\p&#123;Join_Control&#125;]</span><br><span class="line"></span><br><span class="line">// 匹配各种文字的所有非字母的字符，等同于Unicode版的\W</span><br><span class="line">[\p&#123;Alphabetic&#125;\p&#123;Mark&#125;\p&#123;Decimal_Number&#125;\p&#123;Connector_Punctuation&#125;\p&#123;Join_Control&#125;]</span><br><span class="line"></span><br><span class="line">// 匹配所有的箭头字符</span><br><span class="line">const regexArrows = /^\p&#123;Block=Arrows&#125;+$/u;</span><br><span class="line">regexArrows.test(<span class="string">'←↑→↓↔↕↖↗↘↙⇏⇐⇑⇒⇓⇔⇕⇖⇗⇘⇙⇧⇩'</span>) // <span class="literal">true</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6_Unicode</title>
      <link href="/2019/01/05/es6-Unicode/"/>
      <url>/2019/01/05/es6-Unicode/</url>
      
        <content type="html"><![CDATA[<h3 id="ES6-字符串的扩展"><a href="#ES6-字符串的扩展" class="headerlink" title="ES6 字符串的扩展"></a>ES6 字符串的扩展</h3><p>ES6 加强了对 Unicode 的支持，并且扩展了字符串对象。</p><h4 id="字符的-Unicode-表示法"><a href="#字符的-Unicode-表示法" class="headerlink" title="字符的 Unicode 表示法"></a>字符的 Unicode 表示法</h4><p>JavaScript 允许采用\uxxxx 形式表示一个字符，其中“xxxx”表示字符的码点。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"\u0061"</span></span><br><span class="line">// <span class="string">"a"</span></span><br></pre></td></tr></table></figure><p>但是，这种表示法只限于\u0000——\uFFFF 之间的字符。超出这个范围的字符，必须用两个双字节的形式表达。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"\uD842\uDFB7"</span></span><br><span class="line">// <span class="string">"𠮷"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"\u20BB7"</span></span><br><span class="line">// <span class="string">" 7"</span></span><br></pre></td></tr></table></figure><p>上面代码表示，如果直接在\u 后面跟上超过 0xFFFF 的数值（比如\u20BB7），JavaScript 会理解成\u20BB+7。由于\u20BB 是一个不可打印字符，所以只会显示一个空格，后面跟着一个 7。</p><p>ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"\u&#123;20BB7&#125;"</span></span><br><span class="line">// <span class="string">"𠮷"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"\u&#123;41&#125;\u&#123;42&#125;\u&#123;43&#125;"</span></span><br><span class="line">// <span class="string">"ABC"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> hello = 123;</span><br><span class="line">hell\u&#123;6F&#125; // 123</span><br><span class="line"></span><br><span class="line"><span class="string">'\u&#123;1F680&#125;'</span> === <span class="string">'\uD83D\uDE80'</span></span><br><span class="line">// <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>上面代码中，最后一个例子表明，大括号表示法与四字节的 UTF-16 编码是等价的。</p><p>有了这种表示法之后，JavaScript 共有 6 种方法可以表示一个字符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'\z'</span> === <span class="string">'z'</span>  // <span class="literal">true</span></span><br><span class="line"><span class="string">'\172'</span> === <span class="string">'z'</span> // <span class="literal">true</span></span><br><span class="line"><span class="string">'\x7A'</span> === <span class="string">'z'</span> // <span class="literal">true</span></span><br><span class="line"><span class="string">'\u007A'</span> === <span class="string">'z'</span> // <span class="literal">true</span></span><br><span class="line"><span class="string">'\u&#123;7A&#125;'</span> === <span class="string">'z'</span> // <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="codePointAt"><a href="#codePointAt" class="headerlink" title="codePointAt()"></a>codePointAt()</h4><p>JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为 2 个字节。对于那些需要 4 个字节储存的字符（Unicode 码点大于 0xFFFF 的字符），JavaScript 会认为它们是两个字符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var s = <span class="string">"𠮷"</span>;</span><br><span class="line"></span><br><span class="line">s.length // 2</span><br><span class="line">s.charAt(0) // <span class="string">''</span></span><br><span class="line">s.charAt(1) // <span class="string">''</span></span><br><span class="line">s.charCodeAt(0) // 55362</span><br><span class="line">s.charCodeAt(1) // 57271</span><br></pre></td></tr></table></figure><p>上面代码中，汉字“𠮷”（注意，这个字不是”吉祥“的”吉“）的码点是 0x20BB7，UTF-16 编码为 0xD842 0xDFB7（十进制为 55362 57271），需要 4 个字节储存。对于这种 4 个字节的字符，JavaScript 不能正确处理，字符串长度会误判为 2，而且 charAt 方法无法读取整个字符，charCodeAt 方法只能分别返回前两个字节和后两个字节的值。</p><p>ES6 提供了 codePointAt 方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var s = <span class="string">'𠮷a'</span>;</span><br><span class="line"></span><br><span class="line">s.codePointAt(0) // 134071</span><br><span class="line">s.codePointAt(1) // 57271</span><br><span class="line"></span><br><span class="line">s.codePointAt(2) // 97</span><br></pre></td></tr></table></figure><p>codePointAt 方法的参数，是字符在字符串中的位置（从 0 开始）。上面代码中，JavaScript 将“𠮷 a”视为三个字符，codePointAt 方法在第一个字符上，正确地识别了“𠮷”，返回了它的十进制码点 134071（即十六进制的 20BB7）。在第二个字符（即“𠮷”的后两个字节）和第三个字符“a”上，codePointAt 方法的结果与 charCodeAt 方法相同。</p><p>总之，codePointAt 方法会正确返回 32 位的 UTF-16 字符的码点。对于那些两个字节储存的常规字符，它的返回结果与 charCodeAt 方法相同。</p><p>codePointAt 方法返回的是码点的十进制值，如果想要十六进制的值，可以使用 toString 方法转换一下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var s = <span class="string">'𠮷a'</span>;</span><br><span class="line"></span><br><span class="line">s.codePointAt(0).toString(16) // <span class="string">"20bb7"</span></span><br><span class="line">s.codePointAt(2).toString(16) // <span class="string">"61"</span></span><br></pre></td></tr></table></figure><p>你可能注意到了，codePointAt 方法的参数，仍然是不正确的。比如，上面代码中，字符 a 在字符串 s 的正确位置序号应该是 1，但是必须向 codePointAt 方法传入 2。解决这个问题的一个办法是使用 for…of 循环，因为它会正确识别 32 位的 UTF-16 字符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var s = <span class="string">'𠮷a'</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> ch of s) &#123;</span><br><span class="line">  console.log(ch.codePointAt(0).toString(16));</span><br><span class="line">&#125;</span><br><span class="line">// 20bb7</span><br><span class="line">// 61</span><br></pre></td></tr></table></figure><p>codePointAt 方法是测试一个字符由两个字节还是由四个字节组成的最简单方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> is32Bit(c) &#123;</span><br><span class="line">  <span class="built_in">return</span> c.codePointAt(0) &gt; 0xFFFF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">is32Bit(<span class="string">"𠮷"</span>) // <span class="literal">true</span></span><br><span class="line">is32Bit(<span class="string">"a"</span>) // <span class="literal">false</span></span><br></pre></td></tr></table></figure><h4 id="String-fromCodePoint"><a href="#String-fromCodePoint" class="headerlink" title="String.fromCodePoint()"></a>String.fromCodePoint()</h4><p>ES5 提供 String.fromCharCode 方法，用于从码点返回对应字符，但是这个方法不能识别 32 位的 UTF-16 字符（Unicode 编号大于 0xFFFF）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String.fromCharCode(0x20BB7)</span><br><span class="line">// <span class="string">"ஷ"</span></span><br></pre></td></tr></table></figure><p>上面代码中，String.fromCharCode 不能识别大于 0xFFFF 的码点，所以 0x20BB7 就发生了溢出，最高位 2 被舍弃了，最后返回码点 U+0BB7 对应的字符，而不是码点 U+20BB7 对应的字符。</p><p>ES6 提供了 String.fromCodePoint 方法，可以识别 0xFFFF 的字符，弥补了 String.fromCharCode 方法的不足。在作用上，正好与 codePointAt 方法相反。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String.fromCodePoint(0x20BB7)</span><br><span class="line">// <span class="string">"𠮷"</span></span><br><span class="line">String.fromCodePoint(0x78, 0x1f680, 0x79) === <span class="string">'x\uD83D\uDE80y'</span></span><br><span class="line">// <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>上面代码中，如果 String.fromCodePoint 方法有多个参数，则它们会被合并成一个字符串返回。</p><p>注意，fromCodePoint 方法定义在 String 对象上，而 codePointAt 方法定义在字符串的实例对象上。</p><h4 id="字符串的遍历器接口"><a href="#字符串的遍历器接口" class="headerlink" title="字符串的遍历器接口"></a>字符串的遍历器接口</h4><p>ES6 为字符串添加了遍历器接口（详见《Iterator》一章），使得字符串可以被 for…of 循环遍历。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> codePoint of <span class="string">'foo'</span>) &#123;</span><br><span class="line">  console.log(codePoint)</span><br><span class="line">&#125;</span><br><span class="line">// <span class="string">"f"</span></span><br><span class="line">// <span class="string">"o"</span></span><br><span class="line">// <span class="string">"o"</span></span><br></pre></td></tr></table></figure><p>除了遍历字符串，这个遍历器最大的优点是可以识别大于 0xFFFF 的码点，传统的 for 循环无法识别这样的码点。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var text = String.fromCodePoint(0x20BB7);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; text.length; i++) &#123;</span><br><span class="line">  console.log(text[i]);</span><br><span class="line">&#125;</span><br><span class="line">// <span class="string">" "</span></span><br><span class="line">// <span class="string">" "</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i of text) &#123;</span><br><span class="line">  console.log(i);</span><br><span class="line">&#125;</span><br><span class="line">// <span class="string">"𠮷"</span></span><br></pre></td></tr></table></figure><p>上面代码中，字符串 text 只有一个字符，但是 for 循环会认为它包含两个字符（都不可打印），而 for…of 循环会正确识别出这一个字符。</p><h4 id="at"><a href="#at" class="headerlink" title="at()"></a>at()</h4><p>ES5 对字符串对象提供 charAt 方法，返回字符串给定位置的字符。该方法不能识别码点大于 0xFFFF 的字符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'abc'</span>.charAt(0) // <span class="string">"a"</span></span><br><span class="line"><span class="string">'𠮷'</span>.charAt(0) // <span class="string">"\uD842"</span></span><br></pre></td></tr></table></figure><p>上面代码中，charAt 方法返回的是 UTF-16 编码的第一个字节，实际上是无法显示的。</p><p>目前，有一个提案，提出字符串实例的 at 方法，可以识别 Unicode 编号大于 0xFFFF 的字符，返回正确的字符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'abc'</span>.at(0) // <span class="string">"a"</span></span><br><span class="line"><span class="string">'𠮷'</span>.at(0) // <span class="string">"𠮷"</span></span><br></pre></td></tr></table></figure><p>这个方法可以通过垫片库实现。</p><h4 id="normalize"><a href="#normalize" class="headerlink" title="normalize()"></a>normalize()</h4><p>许多欧洲语言有语调符号和重音符号。为了表示它们，Unicode 提供了两种方法。一种是直接提供带重音符号的字符，比如 Ǒ（\u01D1）。另一种是提供合成符号（combining character），即原字符与重音符号的合成，两个字符合成一个字符，比如 O（\u004F）和 ˇ（\u030C）合成 Ǒ（\u004F\u030C）。</p><p>这两种表示方法，在视觉和语义上都等价，但是 JavaScript 不能识别。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'\u01D1'</span>===<span class="string">'\u004F\u030C'</span> //<span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="string">'\u01D1'</span>.length // 1</span><br><span class="line"><span class="string">'\u004F\u030C'</span>.length // 2</span><br></pre></td></tr></table></figure><p>上面代码表示，JavaScript 将合成字符视为两个字符，导致两种表示方法不相等。</p><p>ES6 提供字符串实例的 normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'\u01D1'</span>.normalize() === <span class="string">'\u004F\u030C'</span>.normalize()</span><br><span class="line">// <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>normalize 方法可以接受一个参数来指定 normalize 的方式，参数的四个可选值如下。</p><p>1.NFC，默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。<br>2.NFD，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。<br>3.NFKC，表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，normalize 方法不能识别中文。）<br>4.NFKD，表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'\u004F\u030C'</span>.normalize(<span class="string">'NFC'</span>).length // 1</span><br><span class="line"><span class="string">'\u004F\u030C'</span>.normalize(<span class="string">'NFD'</span>).length // 2</span><br></pre></td></tr></table></figure><p>上面代码表示，NFC 参数返回字符的合成形式，NFD 参数返回字符的分解形式。</p><p>不过，normalize 方法目前不能识别三个或三个以上字符的合成。这种情况下，还是只能使用正则表达式，通过 Unicode 编号区间判断。</p><h4 id="includes-startsWith-endsWith"><a href="#includes-startsWith-endsWith" class="headerlink" title="includes(), startsWith(), endsWith()"></a>includes(), startsWith(), endsWith()</h4><p>传统上，JavaScript 只有 indexOf 方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。</p><p>1.includes()：返回布尔值，表示是否找到了参数字符串。<br>2.startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。<br>3.endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var s = <span class="string">'Hello world!'</span>;</span><br><span class="line"></span><br><span class="line">s.startsWith(<span class="string">'Hello'</span>) // <span class="literal">true</span></span><br><span class="line">s.endsWith(<span class="string">'!'</span>) // <span class="literal">true</span></span><br><span class="line">s.includes(<span class="string">'o'</span>) // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>这三个方法都支持第二个参数，表示开始搜索的位置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var s = <span class="string">'Hello world!'</span>;</span><br><span class="line"></span><br><span class="line">s.startsWith(<span class="string">'world'</span>, 6) // <span class="literal">true</span></span><br><span class="line">s.endsWith(<span class="string">'Hello'</span>, 5) // <span class="literal">true</span></span><br><span class="line">s.includes(<span class="string">'Hello'</span>, 6) // <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>上面代码表示，使用第二个参数 n 时，endsWith 的行为与其他两个方法有所不同。它针对前 n 个字符，而其他两个方法针对从第 n 个位置直到字符串结束。</p><h4 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h4><p>repeat 方法返回一个新字符串，表示将原字符串重复 n 次。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'x'</span>.repeat(3) // <span class="string">"xxx"</span></span><br><span class="line"><span class="string">'hello'</span>.repeat(2) // <span class="string">"hellohello"</span></span><br><span class="line"><span class="string">'na'</span>.repeat(0) // <span class="string">""</span></span><br></pre></td></tr></table></figure><p>参数如果是小数，会被取整。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'na'</span>.repeat(2.9) // <span class="string">"nana"</span></span><br></pre></td></tr></table></figure><p>如果 repeat 的参数是负数或者 Infinity，会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'na'</span>.repeat(Infinity)</span><br><span class="line">// RangeError</span><br><span class="line"><span class="string">'na'</span>.repeat(-1)</span><br><span class="line">// RangeError</span><br></pre></td></tr></table></figure><p>但是，如果参数是 0 到-1 之间的小数，则等同于 0，这是因为会先进行取整运算。0 到-1 之间的小数，取整以后等于-0，repeat 视同为 0。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'na'</span>.repeat(-0.9) // <span class="string">""</span></span><br></pre></td></tr></table></figure><p>参数 NaN 等同于 0。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'na'</span>.repeat(NaN) // <span class="string">""</span></span><br></pre></td></tr></table></figure><p>如果 repeat 的参数是字符串，则会先转换成数字。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'na'</span>.repeat(<span class="string">'na'</span>) // <span class="string">""</span></span><br><span class="line"><span class="string">'na'</span>.repeat(<span class="string">'3'</span>) // <span class="string">"nanana"</span></span><br></pre></td></tr></table></figure><h4 id="padStart-，padEnd"><a href="#padStart-，padEnd" class="headerlink" title="padStart()，padEnd()"></a>padStart()，padEnd()</h4><p>ES7 推出了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart 用于头部补全，padEnd 用于尾部补全。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'x'</span>.padStart(5, <span class="string">'ab'</span>) // <span class="string">'ababx'</span></span><br><span class="line"><span class="string">'x'</span>.padStart(4, <span class="string">'ab'</span>) // <span class="string">'abax'</span></span><br><span class="line"></span><br><span class="line"><span class="string">'x'</span>.padEnd(5, <span class="string">'ab'</span>) // <span class="string">'xabab'</span></span><br><span class="line"><span class="string">'x'</span>.padEnd(4, <span class="string">'ab'</span>) // <span class="string">'xaba'</span></span><br></pre></td></tr></table></figure><p>上面代码中，padStart 和 padEnd 一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。</p><p>如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'xxx'</span>.padStart(2, <span class="string">'ab'</span>) // <span class="string">'xxx'</span></span><br><span class="line"><span class="string">'xxx'</span>.padEnd(2, <span class="string">'ab'</span>) // <span class="string">'xxx'</span></span><br></pre></td></tr></table></figure><p>如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'abc'</span>.padStart(10, <span class="string">'0123456789'</span>)</span><br><span class="line">// <span class="string">'0123456abc'</span></span><br></pre></td></tr></table></figure><p>如果省略第二个参数，则会用空格补全长度。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'x'</span>.padStart(4) // <span class="string">'   x'</span></span><br><span class="line"><span class="string">'x'</span>.padEnd(4) // <span class="string">'x   '</span></span><br></pre></td></tr></table></figure><p>padStart 的常见用途是为数值补全指定位数。下面代码生成 10 位的数值字符串。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'1'</span>.padStart(10, <span class="string">'0'</span>) // <span class="string">"0000000001"</span></span><br><span class="line"><span class="string">'12'</span>.padStart(10, <span class="string">'0'</span>) // <span class="string">"0000000012"</span></span><br><span class="line"><span class="string">'123456'</span>.padStart(10, <span class="string">'0'</span>) // <span class="string">"0000123456"</span></span><br></pre></td></tr></table></figure><p>另一个用途是提示字符串格式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'12'</span>.padStart(10, <span class="string">'YYYY-MM-DD'</span>) // <span class="string">"YYYY-MM-12"</span></span><br><span class="line"><span class="string">'09-12'</span>.padStart(10, <span class="string">'YYYY-MM-DD'</span>) // <span class="string">"YYYY-09-12"</span></span><br></pre></td></tr></table></figure><h4 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h4><p>传统的 JavaScript 语言，输出模板通常是这样写的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#result'</span>).append(</span><br><span class="line">  <span class="string">'There are &lt;b&gt;'</span> + basket.count + <span class="string">'&lt;/b&gt; '</span> +</span><br><span class="line">  <span class="string">'items in your basket, '</span> +</span><br><span class="line">  <span class="string">'&lt;em&gt;'</span> + basket.onSale +</span><br><span class="line">  <span class="string">'&lt;/em&gt; are on sale!'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面这种写法相当繁琐不方便，ES6 引入了模板字符串解决这个问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#result'</span>).append(`</span><br><span class="line">  There are &lt;b&gt;<span class="variable">$&#123;basket.count&#125;</span>&lt;/b&gt; items</span><br><span class="line">   <span class="keyword">in</span> your basket, &lt;em&gt;<span class="variable">$&#123;basket.onSale&#125;</span>&lt;/em&gt;</span><br><span class="line">  are on sale!</span><br><span class="line">`);</span><br></pre></td></tr></table></figure><p>模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 普通字符串</span><br><span class="line">`In JavaScript <span class="string">'\n'</span> is a line-feed.`</span><br><span class="line"></span><br><span class="line">// 多行字符串</span><br><span class="line">`In JavaScript this is</span><br><span class="line"> not legal.`</span><br><span class="line"></span><br><span class="line">console.log(`string text line 1</span><br><span class="line">string text line 2`);</span><br><span class="line"></span><br><span class="line">// 字符串中嵌入变量</span><br><span class="line">var name = <span class="string">"Bob"</span>, time = <span class="string">"today"</span>;</span><br><span class="line">`Hello <span class="variable">$&#123;name&#125;</span>, how are you <span class="variable">$&#123;time&#125;</span>?`</span><br></pre></td></tr></table></figure><p>上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var greeting = `\`Yo\` World!`;</span><br></pre></td></tr></table></figure><p>如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#list'</span>).html(`</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;first&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;second&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">`);</span><br></pre></td></tr></table></figure><p>上面代码中，所有模板字符串的空格和换行，都是被保留的，比如<ul>标签前面会有一个换行。如果你不想要这个换行，可以使用 trim 方法消除它。</ul></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#list'</span>).html(`</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;first&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;second&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">`.trim());</span><br></pre></td></tr></table></figure><p>模板字符串中嵌入变量，需要将变量名写在\${}之中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> authorize(user, action) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!user.hasPrivilege(action)) &#123;</span><br><span class="line">    throw new Error(</span><br><span class="line">      // 传统写法为</span><br><span class="line">      // <span class="string">'User '</span></span><br><span class="line">      // + user.name</span><br><span class="line">      // + <span class="string">' is not authorized to do '</span></span><br><span class="line">      // + action</span><br><span class="line">      // + <span class="string">'.'</span></span><br><span class="line">      `User <span class="variable">$&#123;user.name&#125;</span> is not authorized to <span class="keyword">do</span> <span class="variable">$&#123;action&#125;</span>.`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var x = 1;</span><br><span class="line">var y = 2;</span><br><span class="line"></span><br><span class="line">`<span class="variable">$&#123;x&#125;</span> + <span class="variable">$&#123;y&#125;</span> = <span class="variable">$&#123;x + y&#125;</span>`</span><br><span class="line">// <span class="string">"1 + 2 = 3"</span></span><br><span class="line"></span><br><span class="line">`<span class="variable">$&#123;x&#125;</span> + <span class="variable">$&#123;y * 2&#125;</span> = <span class="variable">$&#123;x + y * 2&#125;</span>`</span><br><span class="line">// <span class="string">"1 + 4 = 5"</span></span><br><span class="line"></span><br><span class="line">var obj = &#123;x: 1, y: 2&#125;;</span><br><span class="line">`<span class="variable">$&#123;obj.x + obj.y&#125;</span>`</span><br><span class="line">// 3</span><br></pre></td></tr></table></figure><p>模板字符串之中还能调用函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fn</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> <span class="string">"Hello World"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">`foo <span class="variable">$&#123;fn()&#125;</span> bar`</span><br><span class="line">// foo Hello World bar</span><br></pre></td></tr></table></figure><p>如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的 toString 方法。</p><p>如果模板字符串中的变量没有声明，将报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 变量place没有声明</span><br><span class="line">var msg = `Hello, <span class="variable">$&#123;place&#125;</span>`;</span><br><span class="line">// 报错</span><br></pre></td></tr></table></figure><p>由于模板字符串的大括号内部，就是执行 JavaScript 代码，因此如果大括号内部是一个字符串，将会原样输出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">`Hello <span class="variable">$&#123;'World'&#125;</span>`</span><br><span class="line">// <span class="string">"Hello World"</span></span><br></pre></td></tr></table></figure><p>模板字符串甚至还能嵌套。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const tmpl = addrs =&gt; `</span><br><span class="line">  &lt;table&gt;</span><br><span class="line">  $&#123;addrs.map(addr =&gt; `</span><br><span class="line">    &lt;tr&gt;&lt;td&gt;<span class="variable">$&#123;addr.first&#125;</span>&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">    &lt;tr&gt;&lt;td&gt;<span class="variable">$&#123;addr.last&#125;</span>&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">  `).join(<span class="string">''</span>)&#125;</span><br><span class="line">  &lt;/table&gt;</span><br><span class="line">`;</span><br></pre></td></tr></table></figure><p>上面代码中，模板字符串的变量之中，又嵌入了另一个模板字符串，使用方法如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const data = [</span><br><span class="line">    &#123; first: <span class="string">'&lt;Jane&gt;'</span>, last: <span class="string">'Bond'</span> &#125;,</span><br><span class="line">    &#123; first: <span class="string">'Lars'</span>, last: <span class="string">'&lt;Croft&gt;'</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">console.log(tmpl(data));</span><br><span class="line">// &lt;table&gt;</span><br><span class="line">//</span><br><span class="line">//   &lt;tr&gt;&lt;td&gt;&lt;Jane&gt;&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">//   &lt;tr&gt;&lt;td&gt;Bond&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">//</span><br><span class="line">//   &lt;tr&gt;&lt;td&gt;Lars&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">//   &lt;tr&gt;&lt;td&gt;&lt;Croft&gt;&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">//</span><br><span class="line">// &lt;/table&gt;</span><br></pre></td></tr></table></figure><p>如果需要引用模板字符串本身，在需要时执行，可以像下面这样写。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 写法一</span><br><span class="line"><span class="built_in">let</span> str = <span class="string">'return '</span> + <span class="string">'`Hello $&#123;name&#125;!`'</span>;</span><br><span class="line"><span class="built_in">let</span> func = new Function(<span class="string">'name'</span>, str);</span><br><span class="line">func(<span class="string">'Jack'</span>) // <span class="string">"Hello Jack!"</span></span><br><span class="line"></span><br><span class="line">// 写法二</span><br><span class="line"><span class="built_in">let</span> str = <span class="string">'(name) =&gt; `Hello $&#123;name&#125;!`'</span>;</span><br><span class="line"><span class="built_in">let</span> func = eval.call(null, str);</span><br><span class="line">func(<span class="string">'Jack'</span>) // <span class="string">"Hello Jack!"</span></span><br></pre></td></tr></table></figure><h4 id="实例：模板编译"><a href="#实例：模板编译" class="headerlink" title="实例：模板编译"></a>实例：模板编译</h4><p>下面，我们来看一个通过模板字符串，生成正式模板的实例。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var template = `</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;% <span class="keyword">for</span>(var i=0; i &lt; data.supplies.length; i++) &#123; %&gt;</span><br><span class="line">    &lt;li&gt;&lt;%= data.supplies[i] %&gt;&lt;/li&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">`;</span><br></pre></td></tr></table></figure><p>上面代码在模板字符串之中，放置了一个常规模板。该模板使用&lt;%…%&gt;放置 JavaScript 代码，使用&lt;%= … %&gt;输出 JavaScript 表达式。</p><p>怎么编译这个模板字符串呢？</p><p>一种思路是将其转换为 JavaScript 表达式字符串。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span>(<span class="string">'&lt;ul&gt;'</span>);</span><br><span class="line"><span class="keyword">for</span>(var i=0; i &lt; data.supplies.length; i++) &#123;</span><br><span class="line">  <span class="built_in">echo</span>(<span class="string">'&lt;li&gt;'</span>);</span><br><span class="line">  <span class="built_in">echo</span>(data.supplies[i]);</span><br><span class="line">  <span class="built_in">echo</span>(<span class="string">'&lt;/li&gt;'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">echo</span>(<span class="string">'&lt;/ul&gt;'</span>);</span><br></pre></td></tr></table></figure><p>这个转换使用正则表达式就行了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var evalExpr = /&lt;%=(.+?)%&gt;/g;</span><br><span class="line">var expr = /&lt;%([\s\S]+?)%&gt;/g;</span><br><span class="line"></span><br><span class="line">template = template</span><br><span class="line">  .replace(evalExpr, <span class="string">'`); \n  echo( $1 ); \n  echo(`'</span>)</span><br><span class="line">  .replace(expr, <span class="string">'`); \n $1 \n  echo(`'</span>);</span><br><span class="line"></span><br><span class="line">template = <span class="string">'echo(`'</span> + template + <span class="string">'`);'</span>;</span><br></pre></td></tr></table></figure><p>然后，将 template 封装在一个函数里面返回，就可以了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var script =</span><br><span class="line">`(<span class="keyword">function</span> parse(data)&#123;</span><br><span class="line">  var output = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="built_in">echo</span>(html)&#123;</span><br><span class="line">    output += html;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable">$&#123; template &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> output;</span><br><span class="line">&#125;)`;</span><br><span class="line"></span><br><span class="line"><span class="built_in">return</span> script;</span><br></pre></td></tr></table></figure><p>将上面的内容拼装成一个模板编译函数 compile。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> compile(template)&#123;</span><br><span class="line">  var evalExpr = /&lt;%=(.+?)%&gt;/g;</span><br><span class="line">  var expr = /&lt;%([\s\S]+?)%&gt;/g;</span><br><span class="line"></span><br><span class="line">  template = template</span><br><span class="line">    .replace(evalExpr, <span class="string">'`); \n  echo( $1 ); \n  echo(`'</span>)</span><br><span class="line">    .replace(expr, <span class="string">'`); \n $1 \n  echo(`'</span>);</span><br><span class="line"></span><br><span class="line">  template = <span class="string">'echo(`'</span> + template + <span class="string">'`);'</span>;</span><br><span class="line"></span><br><span class="line">  var script =</span><br><span class="line">  `(<span class="keyword">function</span> parse(data)&#123;</span><br><span class="line">    var output = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="built_in">echo</span>(html)&#123;</span><br><span class="line">      output += html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">$&#123; template &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> output;</span><br><span class="line">  &#125;)`;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> script;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>compile 函数的用法如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var parse = <span class="built_in">eval</span>(compile(template));</span><br><span class="line">div.innerHTML = parse(&#123; supplies: [ <span class="string">"broom"</span>, <span class="string">"mop"</span>, <span class="string">"cleaner"</span> ] &#125;);</span><br><span class="line">//   &lt;ul&gt;</span><br><span class="line">//     &lt;li&gt;broom&lt;/li&gt;</span><br><span class="line">//     &lt;li&gt;mop&lt;/li&gt;</span><br><span class="line">//     &lt;li&gt;cleaner&lt;/li&gt;</span><br><span class="line">//   &lt;/ul&gt;</span><br></pre></td></tr></table></figure><h4 id="标签模板"><a href="#标签模板" class="headerlink" title="标签模板"></a>标签模板</h4><p>模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert`123`</span><br><span class="line">// 等同于</span><br><span class="line">alert(123)</span><br></pre></td></tr></table></figure><p>标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。</p><p>但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = 5;</span><br><span class="line">var b = 10;</span><br><span class="line"></span><br><span class="line">tag`Hello <span class="variable">$&#123; a + b &#125;</span> world <span class="variable">$&#123; a * b &#125;</span>`;</span><br><span class="line">// 等同于</span><br><span class="line">tag([<span class="string">'Hello '</span>, <span class="string">' world '</span>, <span class="string">''</span>], 15, 50);</span><br></pre></td></tr></table></figure><p>上面代码中，模板字符串前面有一个标识名 tag，它是一个函数。整个表达式的返回值，就是 tag 函数处理模板字符串后的返回值。</p><p>函数 tag 依次会接收到多个参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> tag(stringArr, value1, value2)&#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> tag(stringArr, ...values)&#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tag 函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。</p><p>tag 函数的其他参数，都是模板字符串各个变量被替换后的值。由于本例中，模板字符串含有两个变量，因此 tag 会接受到 value1 和 value2 两个参数。</p><p>tag 函数所有参数的实际值如下。</p><p>1.第一个参数：[‘Hello ‘, ‘ world ‘, ‘’] 2.第二个参数: 15 3.第三个参数：50<br>也就是说，tag 函数实际上以下面的形式调用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tag([<span class="string">'Hello '</span>, <span class="string">' world '</span>, <span class="string">''</span>], 15, 50)</span><br></pre></td></tr></table></figure><p>我们可以按照需要编写 tag 函数的代码。下面是 tag 函数的一种写法，以及运行结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var a = 5;</span><br><span class="line">var b = 10;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> tag(s, v1, v2) &#123;</span><br><span class="line">  console.log(s[0]);</span><br><span class="line">  console.log(s[1]);</span><br><span class="line">  console.log(s[2]);</span><br><span class="line">  console.log(v1);</span><br><span class="line">  console.log(v2);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> <span class="string">"OK"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tag`Hello <span class="variable">$&#123; a + b &#125;</span> world <span class="variable">$&#123; a * b&#125;</span>`;</span><br><span class="line">// <span class="string">"Hello "</span></span><br><span class="line">// <span class="string">" world "</span></span><br><span class="line">// <span class="string">""</span></span><br><span class="line">// 15</span><br><span class="line">// 50</span><br><span class="line">// <span class="string">"OK"</span></span><br></pre></td></tr></table></figure><p>下面是一个更复杂的例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var total = 30;</span><br><span class="line">var msg = passthru`The total is <span class="variable">$&#123;total&#125;</span> (<span class="variable">$&#123;total*1.05&#125;</span> with tax)`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> passthru(literals) &#123;</span><br><span class="line">  var result = <span class="string">''</span>;</span><br><span class="line">  var i = 0;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i &lt; literals.length) &#123;</span><br><span class="line">    result += literals[i++];</span><br><span class="line">    <span class="keyword">if</span> (i &lt; arguments.length) &#123;</span><br><span class="line">      result += arguments[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">msg // <span class="string">"The total is 30 (31.5 with tax)"</span></span><br></pre></td></tr></table></figure><p>上面这个例子展示了，如何将各个参数按照原来的位置拼合回去。</p><p>passthru 函数采用 rest 参数的写法如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> passthru(literals, ...values) &#123;</span><br><span class="line">  var output = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">for</span> (var index = 0; index &lt; values.length; index++) &#123;</span><br><span class="line">    output += literals[index] + values[index];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  output += literals[index]</span><br><span class="line">  <span class="built_in">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“标签模板”的一个重要应用，就是过滤 HTML 字符串，防止用户输入恶意内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var message =</span><br><span class="line">  SaferHTML`&lt;p&gt;<span class="variable">$&#123;sender&#125;</span> has sent you a message.&lt;/p&gt;`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> SaferHTML(templateData) &#123;</span><br><span class="line">  var s = templateData[0];</span><br><span class="line">  <span class="keyword">for</span> (var i = 1; i &lt; arguments.length; i++) &#123;</span><br><span class="line">    var arg = String(arguments[i]);</span><br><span class="line"></span><br><span class="line">    // Escape special characters <span class="keyword">in</span> the substitution.</span><br><span class="line">    s += arg.replace(/&amp;/g, <span class="string">"&amp;amp;"</span>)</span><br><span class="line">            .replace(/&lt;/g, <span class="string">"&amp;lt;"</span>)</span><br><span class="line">            .replace(/&gt;/g, <span class="string">"&amp;gt;"</span>);</span><br><span class="line"></span><br><span class="line">    // Don<span class="string">'t escape special characters in the template.</span></span><br><span class="line"><span class="string">    s += templateData[i];</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  return s;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，sender 变量往往是用户提供的，经过 SaferHTML 函数处理，里面的特殊字符都会被转义。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var sender = <span class="string">'&lt;script&gt;alert("abc")&lt;/script&gt;'</span>; // 恶意代码</span><br><span class="line">var message = SaferHTML`&lt;p&gt;<span class="variable">$&#123;sender&#125;</span> has sent you a message.&lt;/p&gt;`;</span><br><span class="line"></span><br><span class="line">message</span><br><span class="line">// &lt;p&gt;&amp;lt;script&amp;gt;alert(<span class="string">"abc"</span>)&amp;lt;/script&amp;gt; has sent you a message.&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>标签模板的另一个应用，就是多语言转换（国际化处理）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i18n`Welcome to <span class="variable">$&#123;siteName&#125;</span>, you are visitor number <span class="variable">$&#123;visitorNumber&#125;</span>!`</span><br><span class="line">// <span class="string">"欢迎访问xxx，您是第xxxx位访问者！"</span></span><br></pre></td></tr></table></figure><p>模板字符串本身并不能取代 Mustache 之类的模板库，因为没有条件判断和循环处理功能，但是通过标签函数，你可以自己添加这些功能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 下面的hashTemplate函数</span><br><span class="line">// 是一个自定义的模板处理函数</span><br><span class="line">var libraryHtml = hashTemplate`</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    <span class="comment">#for book in $&#123;myBooks&#125;</span></span><br><span class="line">      &lt;li&gt;&lt;i&gt;<span class="comment">#&#123;book.title&#125;&lt;/i&gt; by #&#123;book.author&#125;&lt;/li&gt;</span></span><br><span class="line">    <span class="comment">#end</span></span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">`;</span><br></pre></td></tr></table></figure><p>除此之外，你甚至可以使用标签模板，在 JavaScript 语言之中嵌入其他语言。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">jsx`</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input</span><br><span class="line">      ref=<span class="string">'input'</span></span><br><span class="line">      onChange=<span class="string">'$&#123;this.handleChange&#125;'</span></span><br><span class="line">      defaultValue=<span class="string">'$&#123;this.state.value&#125;'</span> /&gt;</span><br><span class="line">      <span class="variable">$&#123;this.state.value&#125;</span></span><br><span class="line">   &lt;/div&gt;</span><br><span class="line">`</span><br></pre></td></tr></table></figure><p>上面的代码通过 jsx 函数，将一个 DOM 字符串转为 React 对象。你可以在 Github 找到 jsx 函数的具体实现。</p><p>下面则是一个假想的例子，通过 java 函数，在 JavaScript 代码之中运行 Java 代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java`</span><br><span class="line">class HelloWorldApp &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    System.out.println(“Hello World!”); // Display the string.</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">`</span><br><span class="line">HelloWorldApp.main();</span><br></pre></td></tr></table></figure><p>模板处理函数的第一个参数（模板字符串数组），还有一个 raw 属性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log`123`</span><br><span class="line">// [<span class="string">"123"</span>, raw: Array[1]]</span><br></pre></td></tr></table></figure><p>上面代码中，console.log 接受的参数，实际上是一个数组。该数组有一个 raw 属性，保存的是转义后的原字符串。</p><p>请看下面的例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tag`First line\nSecond line`</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> tag(strings) &#123;</span><br><span class="line">  console.log(strings.raw[0]);</span><br><span class="line">  // <span class="string">"First line\\nSecond line"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，tag 函数的第一个参数 strings，有一个 raw 属性，也指向一个数组。该数组的成员与 strings 数组完全一致。比如，strings 数组是[“First line\nSecond line”]，那么 strings.raw 数组就是[“First line\nSecond line”]。两者唯一的区别，就是字符串里面的斜杠都被转义了。比如，strings.raw 数组会将\n 视为\和 n 两个字符，而不是换行符。这是为了方便取得转义之前的原始模板而设计的。</p><h4 id="String-raw"><a href="#String-raw" class="headerlink" title="String.raw()"></a>String.raw()</h4><p>ES6 还为原生的 String 对象，提供了一个 raw 方法。</p><p>String.raw 方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String.raw`Hi\n<span class="variable">$&#123;2+3&#125;</span>!`;</span><br><span class="line">// <span class="string">"Hi\\n5!"</span></span><br><span class="line"></span><br><span class="line">String.raw`Hi\u000A!`;</span><br><span class="line">// <span class="string">'Hi\\u000A!'</span></span><br></pre></td></tr></table></figure><p>如果原字符串的斜杠已经转义，那么 String.raw 不会做任何处理。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String.raw`Hi\\n`</span><br><span class="line">// <span class="string">"Hi\\n"</span></span><br></pre></td></tr></table></figure><p>String.raw 的代码基本如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String.raw = <span class="keyword">function</span> (strings, ...values) &#123;</span><br><span class="line">  var output = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">for</span> (var index = 0; index &lt; values.length; index++) &#123;</span><br><span class="line">    output += strings.raw[index] + values[index];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  output += strings.raw[index]</span><br><span class="line">  <span class="built_in">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>String.raw 方法可以作为处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。</p><p>String.raw 方法也可以作为正常的函数使用。这时，它的第一个参数，应该是一个具有 raw 属性的对象，且 raw 属性的值应该是一个数组。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String.raw(&#123; raw: <span class="string">'test'</span> &#125;, 0, 1, 2);</span><br><span class="line">// <span class="string">'t0e1s2t'</span></span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">String.raw(&#123; raw: [<span class="string">'t'</span>,<span class="string">'e'</span>,<span class="string">'s'</span>,<span class="string">'t'</span>] &#125;, 0, 1, 2);</span><br></pre></td></tr></table></figure><h4 id="模板字符串的限制"><a href="#模板字符串的限制" class="headerlink" title="模板字符串的限制"></a>模板字符串的限制</h4><p>前面提到标签模板里面，可以内嵌其他语言。但是，模板字符串默认会将字符串转义，因此导致了无法嵌入其他语言。</p><p>举例来说，在标签模板里面可以嵌入 Latex 语言。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> latex(strings) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> document = latex`</span><br><span class="line">\newcommand&#123;\fun&#125;&#123;\textbf&#123;Fun!&#125;&#125;  // 正常工作</span><br><span class="line">\newcommand&#123;\unicode&#125;&#123;\textbf&#123;Unicode!&#125;&#125; // 报错</span><br><span class="line">\newcommand&#123;\xerxes&#125;&#123;\textbf&#123;King!&#125;&#125; // 报错</span><br><span class="line"></span><br><span class="line">Breve over the h goes \u&#123;h&#125;ere // 报错</span><br><span class="line">`</span><br></pre></td></tr></table></figure><p>上面代码中，变量 document 内嵌的模板字符串，对于 Latex 语言来说完全是合法的，但是 JavaScript 引擎会报错。原因就在于字符串的转义。</p><p>模板字符串会将\u00FF 和\u{42}当作 Unicode 字符进行转义，所以\unicode 解析时报错；而\x56 会被当作十六进制字符串转义，所以\xerxes 会报错。</p><p>为了解决这个问题，现在有一个提案，放松对标签模板里面的字符串转义的限制。如果遇到不合法的字符串转义，就返回 undefined，而不是报错，并且从 raw 属性上面可以得到原始字符串。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> tag(strs) &#123;</span><br><span class="line">  strs[0] === undefined</span><br><span class="line">  strs.raw[0] === <span class="string">"\\unicode and \\u&#123;55&#125;"</span>;</span><br><span class="line">&#125;</span><br><span class="line">tag`\unicode and \u&#123;55&#125;`</span><br></pre></td></tr></table></figure><p>上面代码中，模板字符串原本是应该报错的，但是由于放松了对字符串转义的限制，所以不报错了，JavaScript 引擎将第一个字符设置为 undefined，但是 raw 属性依然可以得到原始字符串，因此 tag 函数还是可以对原字符串进行处理。</p><p>注意，这种对字符串转义的放松，只在标签模板解析字符串时生效，不是标签模板的场合，依然会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> bad = `bad escape sequence: \unicode`; // 报错</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6_Destructuring</title>
      <link href="/2018/12/31/es6-Destructuring/"/>
      <url>/2018/12/31/es6-Destructuring/</url>
      
        <content type="html"><![CDATA[<h3 id="ES6-变量的解构赋值"><a href="#ES6-变量的解构赋值" class="headerlink" title="ES6 变量的解构赋值"></a>ES6 变量的解构赋值</h3><h4 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h4><h5 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h5><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p><p>以前，为变量赋值，只能直接指定值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">var b = 2;</span><br><span class="line">var c = 3;</span><br><span class="line">ES6允许写成下面这样。</span><br><span class="line"></span><br><span class="line">var [a, b, c] = [1, 2, 3];</span><br></pre></td></tr></table></figure><p>上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。</p><p>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> [foo, [[bar], baz]] = [1, [[2], 3]];</span><br><span class="line">foo // 1</span><br><span class="line">bar // 2</span><br><span class="line">baz // 3</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> [ , , third] = [<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"baz"</span>];</span><br><span class="line">third // <span class="string">"baz"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> [x, , y] = [1, 2, 3];</span><br><span class="line">x // 1</span><br><span class="line">y // 3</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> [head, ...tail] = [1, 2, 3, 4];</span><br><span class="line">head // 1</span><br><span class="line">tail // [2, 3, 4]</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> [x, y, ...z] = [<span class="string">'a'</span>];</span><br><span class="line">x // <span class="string">"a"</span></span><br><span class="line">y // undefined</span><br><span class="line">z // []</span><br></pre></td></tr></table></figure><p>如果解构不成功，变量的值就等于 undefined。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var [foo] = [];</span><br><span class="line">var [bar, foo] = [1];</span><br></pre></td></tr></table></figure><p>以上两种情况都属于解构不成功，foo 的值都会等于 undefined。</p><p>另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> [x, y] = [1, 2, 3];</span><br><span class="line">x // 1</span><br><span class="line">y // 2</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> [a, [b], d] = [1, [2, 3], 4];</span><br><span class="line">a // 1</span><br><span class="line">b // 2</span><br><span class="line">d // 4</span><br></pre></td></tr></table></figure><p>上面两个例子，都属于不完全解构，但是可以成功。</p><p>如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line"><span class="built_in">let</span> [foo] = 1;</span><br><span class="line"><span class="built_in">let</span> [foo] = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">let</span> [foo] = NaN;</span><br><span class="line"><span class="built_in">let</span> [foo] = undefined;</span><br><span class="line"><span class="built_in">let</span> [foo] = null;</span><br><span class="line"><span class="built_in">let</span> [foo] = &#123;&#125;;</span><br></pre></td></tr></table></figure><p>上面的表达式都会报错，因为等号右边的值，要么转为对象以后不具备 Iterator 接口（前五个表达式），要么本身就不具备 Iterator 接口（最后一个表达式）。</p><p>解构赋值不仅适用于 var 命令，也适用于 let 和 const 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var [v1, v2, ..., vN ] = array;</span><br><span class="line"><span class="built_in">let</span> [v1, v2, ..., vN ] = array;</span><br><span class="line">const [v1, v2, ..., vN ] = array;</span><br></pre></td></tr></table></figure><p>对于 Set 结构，也可以使用数组的解构赋值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> [x, y, z] = new Set([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]);</span><br><span class="line">x // <span class="string">"a"</span></span><br></pre></td></tr></table></figure><p>事实上，只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">fibs</span></span>() &#123;</span><br><span class="line">  var a = 0;</span><br><span class="line">  var b = 1;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    yield a;</span><br><span class="line">    [a, b] = [b, a + b];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var [first, second, third, fourth, fifth, sixth] = fibs();</span><br><span class="line">sixth // 5</span><br></pre></td></tr></table></figure><p>上面代码中，fibs 是一个 Generator 函数，原生具有 Iterator 接口。解构赋值会依次从这个接口获取值。</p><h5 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h5><p>解构赋值允许指定默认值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var [foo = <span class="literal">true</span>] = [];</span><br><span class="line">foo // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>]; // x=<span class="string">'a'</span>, y=<span class="string">'b'</span></span><br><span class="line">[x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>, undefined]; // x=<span class="string">'a'</span>, y=<span class="string">'b'</span></span><br></pre></td></tr></table></figure><p>注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格等于 undefined，默认值是不会生效的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var [x = 1] = [undefined];</span><br><span class="line">x // 1</span><br><span class="line"></span><br><span class="line">var [x = 1] = [null];</span><br><span class="line">x // null</span><br></pre></td></tr></table></figure><p>上面代码中，如果一个数组成员是 null，默认值就不会生效，因为 null 不严格等于 undefined。</p><p>如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">'aaa'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> [x = f()] = [1];</span><br></pre></td></tr></table></figure><p>上面代码中，因为 x 能取到值，所以函数 f 根本不会执行。上面的代码其实等价于下面的代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> x;</span><br><span class="line"><span class="keyword">if</span> ([1][0] === undefined) &#123;</span><br><span class="line">  x = f();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  x = [1][0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认值可以引用解构赋值的其他变量，但该变量必须已经声明。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> [x = 1, y = x] = [];     // x=1; y=1</span><br><span class="line"><span class="built_in">let</span> [x = 1, y = x] = [2];    // x=2; y=2</span><br><span class="line"><span class="built_in">let</span> [x = 1, y = x] = [1, 2]; // x=1; y=2</span><br><span class="line"><span class="built_in">let</span> [x = y, y = 1] = [];     // ReferenceError</span><br></pre></td></tr></table></figure><p>上面最后一个表达式之所以会报错，是因为 x 用到默认值 y 时，y 还没有声明。</p><h4 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h4><p>解构不仅可以用于数组，还可以用于对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var &#123; foo, bar &#125; = &#123; foo: <span class="string">"aaa"</span>, bar: <span class="string">"bbb"</span> &#125;;</span><br><span class="line">foo // <span class="string">"aaa"</span></span><br><span class="line">bar // <span class="string">"bbb"</span></span><br></pre></td></tr></table></figure><p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var &#123; bar, foo &#125; = &#123; foo: <span class="string">"aaa"</span>, bar: <span class="string">"bbb"</span> &#125;;</span><br><span class="line">foo // <span class="string">"aaa"</span></span><br><span class="line">bar // <span class="string">"bbb"</span></span><br><span class="line"></span><br><span class="line">var &#123; baz &#125; = &#123; foo: <span class="string">"aaa"</span>, bar: <span class="string">"bbb"</span> &#125;;</span><br><span class="line">baz // undefined</span><br></pre></td></tr></table></figure><p>上面代码的第一个例子，等号左边的两个变量的次序，与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。第二个例子的变量没有对应的同名属性，导致取不到值，最后等于 undefined。</p><p>如果变量名与属性名不一致，必须写成下面这样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var &#123; foo: baz &#125; = &#123; foo: <span class="string">'aaa'</span>, bar: <span class="string">'bbb'</span> &#125;;</span><br><span class="line">baz // <span class="string">"aaa"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> obj = &#123; first: <span class="string">'hello'</span>, last: <span class="string">'world'</span> &#125;;</span><br><span class="line"><span class="built_in">let</span> &#123; first: f, last: l &#125; = obj;</span><br><span class="line">f // <span class="string">'hello'</span></span><br><span class="line">l // <span class="string">'world'</span></span><br></pre></td></tr></table></figure><p>这实际上说明，对象的解构赋值是下面形式的简写（参见《对象的扩展》一章）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var &#123; foo: foo, bar: bar &#125; = &#123; foo: <span class="string">"aaa"</span>, bar: <span class="string">"bbb"</span> &#125;;</span><br></pre></td></tr></table></figure><p>也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var &#123; foo: baz &#125; = &#123; foo: <span class="string">"aaa"</span>, bar: <span class="string">"bbb"</span> &#125;;</span><br><span class="line">baz // <span class="string">"aaa"</span></span><br><span class="line">foo // error: foo is not defined</span><br></pre></td></tr></table></figure><p>上面代码中，foo 是匹配的模式，baz 才是变量。真正被赋值的是变量 baz，而不是模式 foo。</p><p>注意，采用这种写法时，变量的声明和赋值是一体的。对于 let 和 const 来说，变量不能重新声明，所以一旦赋值的变量以前声明过，就会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> foo;</span><br><span class="line"><span class="built_in">let</span> &#123;foo&#125; = &#123;foo: 1&#125;; // SyntaxError: Duplicate declaration <span class="string">"foo"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> baz;</span><br><span class="line"><span class="built_in">let</span> &#123;bar: baz&#125; = &#123;bar: 1&#125;; // SyntaxError: Duplicate declaration <span class="string">"baz"</span></span><br></pre></td></tr></table></figure><p>上面代码中，解构赋值的变量都会重新声明，所以报错了。不过，因为 var 命令允许重新声明，所以这个错误只会在使用 let 和 const 命令时出现。如果没有第二个 let 命令，上面的代码就不会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> foo;</span><br><span class="line">(&#123;foo&#125; = &#123;foo: 1&#125;); // 成功</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> baz;</span><br><span class="line">(&#123;bar: baz&#125; = &#123;bar: 1&#125;); // 成功</span><br></pre></td></tr></table></figure><p>上面代码中，let 命令下面一行的圆括号是必须的，否则会报错。因为解析器会将起首的大括号，理解成一个代码块，而不是赋值语句。</p><p>和数组一样，解构也可以用于嵌套结构的对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  p: [</span><br><span class="line">    <span class="string">'Hello'</span>,</span><br><span class="line">    &#123; y: <span class="string">'World'</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var &#123; p: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">x // <span class="string">"Hello"</span></span><br><span class="line">y // <span class="string">"World"</span></span><br></pre></td></tr></table></figure><p>注意，这时 p 是模式，不是变量，因此不会被赋值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var node = &#123;</span><br><span class="line">  loc: &#123;</span><br><span class="line">    start: &#123;</span><br><span class="line">      line: 1,</span><br><span class="line">      column: 5</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var &#123; loc: &#123; start: &#123; line &#125;&#125; &#125; = node;</span><br><span class="line">line // 1</span><br><span class="line">loc  // error: loc is undefined</span><br><span class="line">start // error: start is undefined</span><br></pre></td></tr></table></figure><p>上面代码中，只有 line 是变量，loc 和 start 都是模式，不会被赋值。</p><p>下面是嵌套赋值的例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">let</span> arr = [];</span><br><span class="line"></span><br><span class="line">(&#123; foo: obj.prop, bar: arr[0] &#125; = &#123; foo: 123, bar: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line">obj // &#123;prop:123&#125;</span><br><span class="line">arr // [<span class="literal">true</span>]</span><br></pre></td></tr></table></figure><p>对象的解构也可以指定默认值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var &#123;x = 3&#125; = &#123;&#125;;</span><br><span class="line">x // 3</span><br><span class="line"></span><br><span class="line">var &#123;x, y = 5&#125; = &#123;x: 1&#125;;</span><br><span class="line">x // 1</span><br><span class="line">y // 5</span><br><span class="line"></span><br><span class="line">var &#123;x:y = 3&#125; = &#123;&#125;;</span><br><span class="line">y // 3</span><br><span class="line"></span><br><span class="line">var &#123;x:y = 3&#125; = &#123;x: 5&#125;;</span><br><span class="line">y // 5</span><br><span class="line"></span><br><span class="line">var &#123; message: msg = <span class="string">'Something went wrong'</span> &#125; = &#123;&#125;;</span><br><span class="line">msg // <span class="string">"Something went wrong"</span></span><br></pre></td></tr></table></figure><p>默认值生效的条件是，对象的属性值严格等于 undefined。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var &#123;x = 3&#125; = &#123;x: undefined&#125;;</span><br><span class="line">x // 3</span><br><span class="line"></span><br><span class="line">var &#123;x = 3&#125; = &#123;x: null&#125;;</span><br><span class="line">x // null</span><br></pre></td></tr></table></figure><p>上面代码中，如果 x 属性等于 null，就不严格相等于 undefined，导致默认值不会生效。</p><p>如果解构失败，变量的值等于 undefined。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var &#123;foo&#125; = &#123;bar: <span class="string">'baz'</span>&#125;;</span><br><span class="line">foo // undefined</span><br></pre></td></tr></table></figure><p>如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line">var &#123;foo: &#123;bar&#125;&#125; = &#123;baz: <span class="string">'baz'</span>&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，等号左边对象的 foo 属性，对应一个子对象。该子对象的 bar 属性，解构时会报错。原因很简单，因为 foo 这时等于 undefined，再取子属性就会报错，请看下面的代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var _tmp = &#123;baz: <span class="string">'baz'</span>&#125;;</span><br><span class="line">_tmp.foo.bar // 报错</span><br></pre></td></tr></table></figure><p>如果要将一个已经声明的变量用于解构赋值，必须非常小心。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 错误的写法</span><br><span class="line">var x;</span><br><span class="line">&#123;x&#125; = &#123;x: 1&#125;;</span><br><span class="line">// SyntaxError: syntax error</span><br></pre></td></tr></table></figure><p>上面代码的写法会报错，因为 JavaScript 引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 正确的写法</span><br><span class="line">(&#123;x&#125; = &#123;x: 1&#125;);</span><br></pre></td></tr></table></figure><p>上面代码将整个解构赋值语句，放在一个圆括号里面，就可以正确执行。关于圆括号与解构赋值的关系，参见下文。</p><p>解构赋值允许，等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(&#123;&#125; = [<span class="literal">true</span>, <span class="literal">false</span>]);</span><br><span class="line">(&#123;&#125; = <span class="string">'abc'</span>);</span><br><span class="line">(&#123;&#125; = []);</span><br></pre></td></tr></table></figure><p>上面的表达式虽然毫无意义，但是语法是合法的，可以执行。</p><p>对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> &#123; <span class="built_in">log</span>, sin, cos &#125; = Math;</span><br></pre></td></tr></table></figure><p>上面代码将 Math 对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。</p><p>由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3];</span><br><span class="line">var &#123;0 : first, [arr.length - 1] : last&#125; = arr;</span><br><span class="line">first // 1</span><br><span class="line">last // 3</span><br></pre></td></tr></table></figure><p>上面代码对数组进行对象解构。数组 arr 的 0 键对应的值是 1，[arr.length - 1]就是 2 键，对应的值是 3。方括号这种写法，属于“属性名表达式”，参见《对象的扩展》一章。</p><h4 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h4><p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const [a, b, c, d, e] = <span class="string">'hello'</span>;</span><br><span class="line">a // <span class="string">"h"</span></span><br><span class="line">b // <span class="string">"e"</span></span><br><span class="line">c // <span class="string">"l"</span></span><br><span class="line">d // <span class="string">"l"</span></span><br><span class="line">e // <span class="string">"o"</span></span><br></pre></td></tr></table></figure><p>类似数组的对象都有一个 length 属性，因此还可以对这个属性解构赋值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> &#123;length : len&#125; = <span class="string">'hello'</span>;</span><br><span class="line">len // 5</span><br></pre></td></tr></table></figure><h4 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h4><p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> &#123;toString: s&#125; = 123;</span><br><span class="line">s === Number.prototype.toString // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> &#123;toString: s&#125; = <span class="literal">true</span>;</span><br><span class="line">s === Boolean.prototype.toString // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>上面代码中，数值和布尔值的包装对象都有 toString 属性，因此变量 s 都能取到值。</p><p>解构赋值的规则是，只要等号右边的值不是对象，就先将其转为对象。由于 undefined 和 null 无法转为对象，所以对它们进行解构赋值，都会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> &#123; prop: x &#125; = undefined; // TypeError</span><br><span class="line"><span class="built_in">let</span> &#123; prop: y &#125; = null; // TypeError</span><br></pre></td></tr></table></figure><h4 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h4><p>函数的参数也可以使用解构赋值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> add([x, y])&#123;</span><br><span class="line">  <span class="built_in">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add([1, 2]); // 3</span><br></pre></td></tr></table></figure><p>上面代码中，函数 add 的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量 x 和 y。对于函数内部的代码来说，它们能感受到的参数就是 x 和 y。</p><p>下面是另一个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);</span><br><span class="line">// [ 3, 7 ]</span><br></pre></td></tr></table></figure><p>函数参数的解构也可以使用默认值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123;</span><br><span class="line">  <span class="built_in">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">move(&#123;x: 3, y: 8&#125;); // [3, 8]</span><br><span class="line">move(&#123;x: 3&#125;); // [3, 0]</span><br><span class="line">move(&#123;&#125;); // [0, 0]</span><br><span class="line">move(); // [0, 0]</span><br></pre></td></tr></table></figure><p>上面代码中，函数 move 的参数是一个对象，通过对这个对象进行解构，得到变量 x 和 y 的值。如果解构失败，x 和 y 等于默认值。</p><p>注意，下面的写法会得到不一样的结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> move(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123;</span><br><span class="line">  <span class="built_in">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">move(&#123;x: 3, y: 8&#125;); // [3, 8]</span><br><span class="line">move(&#123;x: 3&#125;); // [3, undefined]</span><br><span class="line">move(&#123;&#125;); // [undefined, undefined]</span><br><span class="line">move(); // [0, 0]</span><br></pre></td></tr></table></figure><p>上面代码是为函数 move 的参数指定默认值，而不是为变量 x 和 y 指定默认值，所以会得到与前一种写法不同的结果。</p><p>undefined 就会触发函数参数的默认值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, undefined, 3].map((x = <span class="string">'yes'</span>) =&gt; x);</span><br><span class="line">// [ 1, <span class="string">'yes'</span>, 3 ]</span><br></pre></td></tr></table></figure><h4 id="圆括号问题"><a href="#圆括号问题" class="headerlink" title="圆括号问题"></a>圆括号问题</h4><p>解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。</p><p>由此带来的问题是，如果模式中出现圆括号怎么处理。ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。</p><p>但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。</p><h5 id="不能使用圆括号的情况"><a href="#不能使用圆括号的情况" class="headerlink" title="不能使用圆括号的情况"></a>不能使用圆括号的情况</h5><p>以下三种解构赋值不得使用圆括号。</p><p>（1）变量声明语句中，不能带有圆括号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 全部报错</span><br><span class="line">var [(a)] = [1];</span><br><span class="line"></span><br><span class="line">var &#123;x: (c)&#125; = &#123;&#125;;</span><br><span class="line">var (&#123;x: c&#125;) = &#123;&#125;;</span><br><span class="line">var &#123;(x: c)&#125; = &#123;&#125;;</span><br><span class="line">var &#123;(x): c&#125; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">var &#123; o: (&#123; p: p &#125;) &#125; = &#123; o: &#123; p: 2 &#125; &#125;;</span><br></pre></td></tr></table></figure><p>上面三个语句都会报错，因为它们都是变量声明语句，模式不能使用圆括号。</p><p>（2）函数参数中，模式不能带有圆括号。</p><p>函数参数也属于变量声明，因此不能带有圆括号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line"><span class="keyword">function</span> f([(z)]) &#123; <span class="built_in">return</span> z; &#125;</span><br></pre></td></tr></table></figure><p>（3）赋值语句中，不能将整个模式，或嵌套模式中的一层，放在圆括号之中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 全部报错</span><br><span class="line">(&#123; p: a &#125;) = &#123; p: 42 &#125;;</span><br><span class="line">([a]) = [5];</span><br></pre></td></tr></table></figure><p>上面代码将整个模式放在圆括号之中，导致报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line">[(&#123; p: a &#125;), &#123; x: c &#125;] = [&#123;&#125;, &#123;&#125;];</span><br></pre></td></tr></table></figure><p>上面代码将嵌套模式的一层，放在圆括号之中，导致报错。</p><h5 id="可以使用圆括号的情况"><a href="#可以使用圆括号的情况" class="headerlink" title="可以使用圆括号的情况"></a>可以使用圆括号的情况</h5><p>可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[(b)] = [3]; // 正确</span><br><span class="line">(&#123; p: (d) &#125; = &#123;&#125;); // 正确</span><br><span class="line">[(parseInt.prop)] = [3]; // 正确</span><br></pre></td></tr></table></figure><p>上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是 p，而不是 d；第三行语句与第一行语句的性质一致。</p><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><p>变量的解构赋值用途很多。</p><p>（1）交换变量的值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x, y] = [y, x];</span><br></pre></td></tr></table></figure><p>上面代码交换变量 x 和 y 的值，这样的写法不仅简洁，而且易读，语义非常清晰。</p><p>（2）从函数返回多个值</p><p>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 返回一个数组</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">example</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> [1, 2, 3];</span><br><span class="line">&#125;</span><br><span class="line">var [a, b, c] = example();</span><br><span class="line"></span><br><span class="line">// 返回一个对象</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">example</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> &#123;</span><br><span class="line">    foo: 1,</span><br><span class="line">    bar: 2</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var &#123; foo, bar &#125; = example();</span><br></pre></td></tr></table></figure><p>（3）函数参数的定义</p><p>解构赋值可以方便地将一组参数与变量名对应起来。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 参数是一组有次序的值</span><br><span class="line"><span class="keyword">function</span> f([x, y, z]) &#123; ... &#125;</span><br><span class="line">f([1, 2, 3]);</span><br><span class="line"></span><br><span class="line">// 参数是一组无次序的值</span><br><span class="line"><span class="keyword">function</span> f(&#123;x, y, z&#125;) &#123; ... &#125;</span><br><span class="line">f(&#123;z: 3, y: 2, x: 1&#125;);</span><br></pre></td></tr></table></figure><p>（4）提取 JSON 数据</p><p>解构赋值对提取 JSON 对象中的数据，尤其有用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var jsonData = &#123;</span><br><span class="line">  id: 42,</span><br><span class="line">  status: <span class="string">"OK"</span>,</span><br><span class="line">  data: [867, 5309]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> &#123; id, status, data: number &#125; = jsonData;</span><br><span class="line"></span><br><span class="line">console.log(id, status, number);</span><br><span class="line">// 42, <span class="string">"OK"</span>, [867, 5309]</span><br></pre></td></tr></table></figure><p>上面代码可以快速提取 JSON 数据的值。</p><p>（5）函数参数的默认值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jQuery.ajax = <span class="keyword">function</span> (url, &#123;</span><br><span class="line">  async = <span class="literal">true</span>,</span><br><span class="line">  beforeSend = <span class="function"><span class="title">function</span></span> () &#123;&#125;,</span><br><span class="line">  cache = <span class="literal">true</span>,</span><br><span class="line">  complete = <span class="function"><span class="title">function</span></span> () &#123;&#125;,</span><br><span class="line">  crossDomain = <span class="literal">false</span>,</span><br><span class="line">  global = <span class="literal">true</span>,</span><br><span class="line">  // ... more config</span><br><span class="line">&#125;) &#123;</span><br><span class="line">  // ... <span class="keyword">do</span> stuff</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>指定参数的默认值，就避免了在函数体内部再写 var foo = config.foo || ‘default foo’;这样的语句。</p><p>（6）遍历 Map 结构</p><p>任何部署了 Iterator 接口的对象，都可以用 for…of 循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var map = new Map();</span><br><span class="line">map.set(<span class="string">'first'</span>, <span class="string">'hello'</span>);</span><br><span class="line">map.set(<span class="string">'second'</span>, <span class="string">'world'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> [key, value] of map) &#123;</span><br><span class="line">  console.log(key + <span class="string">" is "</span> + value);</span><br><span class="line">&#125;</span><br><span class="line">// first is hello</span><br><span class="line">// second is world</span><br></pre></td></tr></table></figure><p>如果只想获取键名，或者只想获取键值，可以写成下面这样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 获取键名</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> [key] of map) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取键值</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> [,value] of map) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（7）输入模块的指定方法</p><p>加载模块时，往往需要指定输入那些方法。解构赋值使得输入语句非常清晰。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const &#123; SourceMapConsumer, SourceNode &#125; = require(<span class="string">"source-map"</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6_let_const</title>
      <link href="/2018/12/15/es6_let_const/"/>
      <url>/2018/12/15/es6_let_const/</url>
      
        <content type="html"><![CDATA[<h3 id="let-与-const-变量"><a href="#let-与-const-变量" class="headerlink" title="let 与 const 变量"></a>let 与 const 变量</h3><h4 id="let"><a href="#let" class="headerlink" title="let"></a>let</h4><p>ES6 新增了 let 命令，用来声明变量。它的用法类似于 var，但是所声明的变量，只在 let 命令所在的代码块内有效。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="built_in">let</span> a = 10;</span><br><span class="line">  var b = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a // ReferenceError: a is not defined.</span><br><span class="line">b // 1</span><br></pre></td></tr></table></figure><p>上面代码在代码块之中，分别用 let 和 var 声明了两个变量。然后在代码块之外调用这两个变量，结果 let 声明的变量报错，var 声明的变量返回了正确的值。这表明，let 声明的变量只在它所在的代码块有效。</p><p>for 循环的计数器，就很合适使用 let 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; 10; i++) &#123;&#125;</span><br><span class="line"></span><br><span class="line">console.log(i);</span><br><span class="line">//ReferenceError: i is not defined</span><br></pre></td></tr></table></figure><p>上面代码中，计数器 i 只在 for 循环体内有效，在循环体外引用就会报错。</p><p>下面的代码如果使用 var，最后输出的是 10。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = [];</span><br><span class="line"><span class="keyword">for</span> (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[6](); // 10</span><br></pre></td></tr></table></figure><p>上面代码中，变量 i 是 var 声明的，在全局范围内都有效。所以每一次循环，新的 i 值都会覆盖旧值，导致最后输出的是最后一轮的 i 的值。</p><p>如果使用 let，声明的变量仅在块级作用域内有效，最后输出的是 6。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[6](); // 6</span><br></pre></td></tr></table></figure><p>上面代码中，变量 i 是 let 声明的，当前的 i 只在本轮循环有效，所以每一次循环的 i 其实都是一个新的变量，所以最后输出的是 6。</p><h5 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h5><p>let 不像 var 那样会发生“变量提升”现象。所以，变量一定要在声明后使用，否则报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(foo); // 输出undefined</span><br><span class="line">console.log(bar); // 报错ReferenceError</span><br><span class="line"></span><br><span class="line">var foo = 2;</span><br><span class="line"><span class="built_in">let</span> bar = 2;</span><br></pre></td></tr></table></figure><p>上面代码中，变量 foo 用 var 命令声明，会发生变量提升，即脚本开始运行时，变量 foo 已经存在了，但是没有值，所以会输出 undefined。变量 bar 用 let 命令声明，不会发生变量提升。这表示在声明它之前，变量 bar 是不存在的，这时如果用到它，就会抛出一个错误。</p><h5 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h5><p>只要块级作用域内存在 let 命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var tmp = 123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  tmp = <span class="string">'abc'</span>; // ReferenceError</span><br><span class="line">  <span class="built_in">let</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，存在全局变量 tmp，但是块级作用域内 let 又声明了一个局部变量 tmp，导致后者绑定这个块级作用域，所以在 let 声明变量前，对 tmp 赋值会报错。</p><p>ES6 明确规定，如果区块中存在 let 和 const 命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p><p>总之，在代码块内，使用 let 命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  // TDZ开始</span><br><span class="line">  tmp = <span class="string">'abc'</span>; // ReferenceError</span><br><span class="line">  console.log(tmp); // ReferenceError</span><br><span class="line"></span><br><span class="line">  <span class="built_in">let</span> tmp; // TDZ结束</span><br><span class="line">  console.log(tmp); // undefined</span><br><span class="line"></span><br><span class="line">  tmp = 123;</span><br><span class="line">  console.log(tmp); // 123</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，在 let 命令声明变量 tmp 之前，都属于变量 tmp 的“死区”。</p><p>“暂时性死区”也意味着 typeof 不再是一个百分之百安全的操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typeof x; // ReferenceError</span><br><span class="line"><span class="built_in">let</span> x;</span><br></pre></td></tr></table></figure><p>上面代码中，变量 x 使用 let 命令声明，所以在声明之前，都属于 x 的“死区”，只要用到该变量就会报错。因此，typeof 运行时就会抛出一个 ReferenceError。</p><p>作为比较，如果一个变量根本没有被声明，使用 typeof 反而不会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeof undeclared_variable // <span class="string">"undefined"</span></span><br></pre></td></tr></table></figure><p>上面代码中，undeclared_variable 是一个不存在的变量名，结果返回“undefined”。所以，在没有 let 之前，typeof 运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。</p><p>有些“死区”比较隐蔽，不太容易发现。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> bar(x = y, y = 2) &#123;</span><br><span class="line">  <span class="built_in">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar(); // 报错</span><br></pre></td></tr></table></figure><p>上面代码中，调用 bar 函数之所以报错（某些实现可能不报错），是因为参数 x 默认值等于另一个参数 y，而此时 y 还没有声明，属于”死区“。如果 y 的默认值是 x，就不会报错，因为此时 x 已经声明了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> bar(x = 2, y = x) &#123;</span><br><span class="line">  <span class="built_in">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line">bar(); // [2, 2]</span><br></pre></td></tr></table></figure><p>ES6 规定暂时性死区和 let、const 语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。</p><p>总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</p><h5 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h5><p>let 不允许在相同作用域内，重复声明同一个变量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line"><span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  <span class="built_in">let</span> a = 10;</span><br><span class="line">  var a = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 报错</span><br><span class="line"><span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  <span class="built_in">let</span> a = 10;</span><br><span class="line">  <span class="built_in">let</span> a = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，不能在函数内部重新声明参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> func(arg) &#123;</span><br><span class="line">  <span class="built_in">let</span> arg; // 报错</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> func(arg) &#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">let</span> arg; // 不报错</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h5><h6 id="为什么需要块级作用域？"><a href="#为什么需要块级作用域？" class="headerlink" title="为什么需要块级作用域？"></a>为什么需要块级作用域？</h6><p>ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。</p><p>第一种场景，内层变量可能会覆盖外层变量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var tmp = new Date();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  console.log(tmp);</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    var tmp = <span class="string">"hello world"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(); // undefined</span><br></pre></td></tr></table></figure><p>上面代码中，函数 f 执行后，输出结果为 undefined，原因在于变量提升，导致内层的 tmp 变量覆盖了外层的 tmp 变量。</p><p>第二种场景，用来计数的循环变量泄露为全局变量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var s = <span class="string">'hello'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (var i = 0; i &lt; s.length; i++) &#123;</span><br><span class="line">  console.log(s[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(i); // 5</span><br></pre></td></tr></table></figure><p>上面代码中，变量 i 只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。</p><h6 id="ES6-的块级作用域"><a href="#ES6-的块级作用域" class="headerlink" title="ES6 的块级作用域"></a>ES6 的块级作用域</h6><p>let 实际上为 JavaScript 新增了块级作用域。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f1</span></span>() &#123;</span><br><span class="line">  <span class="built_in">let</span> n = 5;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">let</span> n = 10;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(n); // 5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数有两个代码块，都声明了变量 n，运行后输出 5。这表示外层代码块不受内层代码块的影响。如果使用 var 定义变量 n，最后输出的值就是 10。</p><p>ES6 允许块级作用域的任意嵌套。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;&#123;<span class="built_in">let</span> insane = <span class="string">'Hello World'</span>&#125;&#125;&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure><p>上面代码使用了一个五层的块级作用域。外层作用域无法读取内层作用域的变量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;</span><br><span class="line">  &#123;<span class="built_in">let</span> insane = <span class="string">'Hello World'</span>&#125;</span><br><span class="line">  console.log(insane); // 报错</span><br><span class="line">&#125;&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure><p>内层作用域可以定义外层作用域的同名变量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;</span><br><span class="line">  <span class="built_in">let</span> insane = <span class="string">'Hello World'</span>;</span><br><span class="line">  &#123;<span class="built_in">let</span> insane = <span class="string">'Hello World'</span>&#125;</span><br><span class="line">&#125;&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure><p>块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// IIFE 写法</span><br><span class="line">(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  var tmp = ...;</span><br><span class="line">  ...</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">// 块级作用域写法</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">let</span> tmp = ...;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="块级作用域与函数声明"><a href="#块级作用域与函数声明" class="headerlink" title="块级作用域与函数声明"></a>块级作用域与函数声明</h6><p>函数能不能在块级作用域之中声明，是一个相当令人混淆的问题。</p><p>ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 情况一</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 情况二</span><br><span class="line">try &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;&#125;</span><br><span class="line">&#125; catch(e) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的两种函数声明，根据 ES5 的规定都是非法的。</p><p>但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。不过，“严格模式”下还是会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// ES5严格模式</span><br><span class="line"><span class="string">'use strict'</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 报错</span><br></pre></td></tr></table></figure><p>ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// ES6严格模式</span><br><span class="line"><span class="string">'use strict'</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 不报错</span><br></pre></td></tr></table></figure><p>ES6 规定，块级作用域之中，函数声明语句的行为类似于 let，在块级作用域之外不可引用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123; console.log(<span class="string">'I am outside!'</span>); &#125;</span><br><span class="line">(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    // 重复声明一次函数f</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123; console.log(<span class="string">'I am inside!'</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><p>上面代码在 ES5 中运行，会得到“I am inside!”，因为在 if 内声明的函数 f 会被提升到函数头部，实际运行的代码如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// ES5版本</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123; console.log(<span class="string">'I am outside!'</span>); &#125;</span><br><span class="line">(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123; console.log(<span class="string">'I am inside!'</span>); &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><p>ES6 的运行结果就完全不一样了，会得到“I am outside!”。因为块级作用域内声明的函数类似于 let，对作用域之外没有影响，实际运行的代码如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// ES6版本</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123; console.log(<span class="string">'I am outside!'</span>); &#125;</span><br><span class="line">(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><p>很显然，这种行为差异会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6 在附录 B 里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。</p><p>允许在块级作用域内声明函数。<br>函数声明类似于 var，即会提升到全局作用域或函数作用域的头部。<br>同时，函数声明还会提升到所在的块级作用域的头部。<br>注意，上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作 let 处理。</p><p>前面那段代码，在 Chrome 环境下运行会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// ES6的浏览器环境</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123; console.log(<span class="string">'I am outside!'</span>); &#125;</span><br><span class="line">(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    // 重复声明一次函数f</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123; console.log(<span class="string">'I am inside!'</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br><span class="line">// Uncaught TypeError: f is not a <span class="keyword">function</span></span><br></pre></td></tr></table></figure><p>上面的代码报错，是因为实际运行的是下面的代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// ES6的浏览器环境</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123; console.log(<span class="string">'I am outside!'</span>); &#125;</span><br><span class="line">(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  var f = undefined;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123; console.log(<span class="string">'I am inside!'</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br><span class="line">// Uncaught TypeError: f is not a <span class="keyword">function</span></span><br></pre></td></tr></table></figure><p>考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 函数声明语句</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">let</span> a = <span class="string">'secret'</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 函数表达式</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">let</span> a = <span class="string">'secret'</span>;</span><br><span class="line">  <span class="built_in">let</span> f = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    <span class="built_in">return</span> a;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，还有一个需要注意的地方。ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 不报错</span><br><span class="line"><span class="string">'use strict'</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 报错</span><br><span class="line"><span class="string">'use strict'</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>)</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure><h5 id="do-表达式"><a href="#do-表达式" class="headerlink" title="do 表达式"></a>do 表达式</h5><p>本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="built_in">let</span> t = f();</span><br><span class="line">  t = t * t + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，块级作用域将两个语句封装在一起。但是，在块级作用域以外，没有办法得到 t 的值，因为块级作用域不返回值，除非 t 是全局变量。</p><p>现在有一个提案，使得块级作用域可以变为表达式，也就是说可以返回值，办法就是在块级作用域之前加上 do，使它变为 do 表达式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> x = <span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="built_in">let</span> t = f();</span><br><span class="line">  t * t + 1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，变量 x 会得到整个块级作用域的返回值。</p><h4 id="const-命令"><a href="#const-命令" class="headerlink" title="const 命令"></a>const 命令</h4><p>const 声明一个只读的常量。一旦声明，常量的值就不能改变。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const PI = 3.1415;</span><br><span class="line">PI // 3.1415</span><br><span class="line"></span><br><span class="line">PI = 3;</span><br><span class="line">// TypeError: Assignment to constant variable.</span><br></pre></td></tr></table></figure><p>上面代码表明改变常量的值会报错。</p><p>const 声明的变量不得改变值，这意味着，const 一旦声明变量，就必须立即初始化，不能留到以后赋值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const foo;</span><br><span class="line">// SyntaxError: Missing initializer <span class="keyword">in</span> const declaration</span><br></pre></td></tr></table></figure><p>上面代码表示，对于 const 来说，只声明不赋值，就会报错。</p><p>const 的作用域与 let 命令相同：只在声明所在的块级作用域内有效。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  const MAX = 5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MAX // Uncaught ReferenceError: MAX is not defined</span><br></pre></td></tr></table></figure><p>const 命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  console.log(MAX); // ReferenceError</span><br><span class="line">  const MAX = 5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码在常量 MAX 声明之前就调用，结果报错。</p><p>const 声明的常量，也与 let 一样不可重复声明。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var message = <span class="string">"Hello!"</span>;</span><br><span class="line"><span class="built_in">let</span> age = 25;</span><br><span class="line"></span><br><span class="line">// 以下两行都会报错</span><br><span class="line">const message = <span class="string">"Goodbye!"</span>;</span><br><span class="line">const age = 30;</span><br></pre></td></tr></table></figure><p>对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。const 命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须非常小心。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const foo = &#123;&#125;;</span><br><span class="line">foo.prop = 123;</span><br><span class="line"></span><br><span class="line">foo.prop</span><br><span class="line">// 123</span><br><span class="line"></span><br><span class="line">foo = &#123;&#125;; // TypeError: <span class="string">"foo"</span> is <span class="built_in">read</span>-only</span><br></pre></td></tr></table></figure><p>上面代码中，常量 foo 储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把 foo 指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。</p><p>下面是另一个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const a = [];</span><br><span class="line">a.push(<span class="string">'Hello'</span>); // 可执行</span><br><span class="line">a.length = 0;    // 可执行</span><br><span class="line">a = [<span class="string">'Dave'</span>];    // 报错</span><br></pre></td></tr></table></figure><p>上面代码中，常量 a 是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给 a，就会报错。</p><p>如果真的想将对象冻结，应该使用 Object.freeze 方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const foo = Object.freeze(&#123;&#125;);</span><br><span class="line"></span><br><span class="line">// 常规模式时，下面一行不起作用；</span><br><span class="line">// 严格模式时，该行会报错</span><br><span class="line">foo.prop = 123;</span><br></pre></td></tr></table></figure><p>上面代码中，常量 foo 指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。</p><p>除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var constantize = (obj) =&gt; &#123;</span><br><span class="line">  Object.freeze(obj);</span><br><span class="line">  Object.keys(obj).forEach( (key, value) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> ( typeof obj[key] === <span class="string">'object'</span> ) &#123;</span><br><span class="line">      constantize( obj[key] );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>ES5 只有两种声明变量的方法：var 命令和 function 命令。ES6 除了添加 let 和 const 命令，后面章节还会提到，另外两种声明变量的方法：import 命令和 class 命令。所以，ES6 一共有 6 种声明变量的方法。</p><h5 id="顶层对象的属性"><a href="#顶层对象的属性" class="headerlink" title="顶层对象的属性"></a>顶层对象的属性</h5><p>顶层对象，在浏览器环境指的是 window 对象，在 Node 指的是 global 对象。ES5 之中，顶层对象的属性与全局变量是等价的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window.a = 1;</span><br><span class="line">a // 1</span><br><span class="line"></span><br><span class="line">a = 2;</span><br><span class="line">window.a // 2</span><br></pre></td></tr></table></figure><p>上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。</p><p>顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window 对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。</p><p>ES6 为了改变这一点，一方面规定，为了保持兼容性，var 命令和 function 命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let 命令、const 命令、class 命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">// 如果在Node的REPL环境，可以写成global.a</span><br><span class="line">// 或者采用通用方法，写成this.a</span><br><span class="line">window.a // 1</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> b = 1;</span><br><span class="line">window.b // undefined</span><br></pre></td></tr></table></figure><p>上面代码中，全局变量 a 由 var 命令声明，所以它是顶层对象的属性；全局变量 b 由 let 命令声明，所以它不是顶层对象的属性，返回 undefined。</p><h5 id="global-对象"><a href="#global-对象" class="headerlink" title="global 对象"></a>global 对象</h5><p>ES5 的顶层对象，本身也是一个问题，因为它在各种实现里面是不统一的。</p><p>1、浏览器里面，顶层对象是 window，但 Node 和 Web Worker 没有 window。<br>2、浏览器和 Web Worker 里面，self 也指向顶层对象，但是 Node 没有 self。<br>3、Node 里面，顶层对象是 global，但其他环境都不支持。<br>同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用 this 变量，但是有局限性。</p><p>1、全局环境中，this 会返回顶层对象。但是，Node 模块和 ES6 模块中，this 返回的是当前模块。<br>2、函数里面的 this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this 会指向顶层对象。但是，严格模式下，这时 this 会返回 undefined。<br>3、不管是严格模式，还是普通模式，new Function(‘return this’)()，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全政策），那么 eval、new Function 这些方法都可能无法使用。<br>综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 方法一</span><br><span class="line">(typeof window !== <span class="string">'undefined'</span></span><br><span class="line">   ? window</span><br><span class="line">   : (typeof process === <span class="string">'object'</span> &amp;&amp;</span><br><span class="line">      typeof require === <span class="string">'function'</span> &amp;&amp;</span><br><span class="line">      typeof global === <span class="string">'object'</span>)</span><br><span class="line">     ? global</span><br><span class="line">     : this);</span><br><span class="line"></span><br><span class="line">// 方法二</span><br><span class="line">var getGlobal = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  <span class="keyword">if</span> (typeof self !== <span class="string">'undefined'</span>) &#123; <span class="built_in">return</span> self; &#125;</span><br><span class="line">  <span class="keyword">if</span> (typeof window !== <span class="string">'undefined'</span>) &#123; <span class="built_in">return</span> window; &#125;</span><br><span class="line">  <span class="keyword">if</span> (typeof global !== <span class="string">'undefined'</span>) &#123; <span class="built_in">return</span> global; &#125;</span><br><span class="line">  throw new Error(<span class="string">'unable to locate global object'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在有一个提案，在语言标准的层面，引入 global 作为顶层对象。也就是说，在所有环境下，global 都是存在的，都可以从它拿到顶层对象。</p><p>垫片库 system.global 模拟了这个提案，可以在所有环境拿到 global。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// CommonJS的写法</span><br><span class="line">require(<span class="string">'system.global/shim'</span>)();</span><br><span class="line"></span><br><span class="line">// ES6模块的写法</span><br><span class="line">import shim from <span class="string">'system.global/shim'</span>; shim();</span><br><span class="line">上面代码可以保证各种环境里面，global对象都是存在的。</span><br><span class="line"></span><br><span class="line">// CommonJS的写法</span><br><span class="line">var global = require(<span class="string">'system.global'</span>)();</span><br><span class="line"></span><br><span class="line">// ES6模块的写法</span><br><span class="line">import getGlobal from <span class="string">'system.global'</span>;</span><br><span class="line">const global = getGlobal();</span><br></pre></td></tr></table></figure><p>上面代码将顶层对象放入变量 global。</p>]]></content>
      
      
      <categories>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css</title>
      <link href="/2018/11/01/css/"/>
      <url>/2018/11/01/css/</url>
      
        <content type="html"><![CDATA[<h4 id="1-介绍一下标准的-CSS-的盒子模型？与低版本-IE-的盒子模型有什么不同的？"><a href="#1-介绍一下标准的-CSS-的盒子模型？与低版本-IE-的盒子模型有什么不同的？" class="headerlink" title="1 介绍一下标准的 CSS 的盒子模型？与低版本 IE 的盒子模型有什么不同的？"></a>1 介绍一下标准的 CSS 的盒子模型？与低版本 IE 的盒子模型有什么不同的？</h4><p>标准盒子模型：宽度=内容的宽度（content）+ border + padding + margin<br>低版本 IE 盒子模型：宽度=内容宽度（content+border+padding）+ margin</p><h4 id="2-box-sizing-属性？"><a href="#2-box-sizing-属性？" class="headerlink" title="2 box-sizing 属性？"></a>2 box-sizing 属性？</h4><p>用来控制元素的盒子模型的解析模式，默认为 content-box<br>context-box：W3C 的标准盒子模型，设置元素的 height/width 属性指的是 content 部分的高/宽<br>border-box：IE 传统盒子模型。设置元素的 height/width 属性指的是 border + padding + content 部分的高/宽</p><h4 id="3-CSS-选择器有哪些？哪些属性可以继承？"><a href="#3-CSS-选择器有哪些？哪些属性可以继承？" class="headerlink" title="3 CSS 选择器有哪些？哪些属性可以继承？"></a>3 CSS 选择器有哪些？哪些属性可以继承？</h4><p>CSS 选择符：id 选择器(#myid)、类选择器(.myclassname)、标签选择器(div, h1, p)、相邻选择器(h1 + p)、子选择器（ul &gt; li）、后代选择器（li a）、通配符选择器（*）、属性选择器（a[rel=”external”]）、伪类选择器（a:hover, li:nth-child）<br>可继承的属性：font-size, font-family, color<br>不可继承的样式：border, padding, margin, width, height<br>优先级（就近原则）：!important &gt; [ id &gt; class &gt; tag ]<br>!important 比内联优先级高</p><h4 id="4-CSS-优先级算法如何计算？"><a href="#4-CSS-优先级算法如何计算？" class="headerlink" title="4 CSS 优先级算法如何计算？"></a>4 CSS 优先级算法如何计算？</h4><p>元素选择符： 1<br>class 选择符： 10<br>id 选择符：100<br>元素标签：1000<br>!important 声明的样式优先级最高，如果冲突再进行计算。<br>如果优先级相同，则选择最后出现的样式。<br>继承得到的样式的优先级最低。</p><h4 id="5-CSS3-新增伪类有那些"><a href="#5-CSS3-新增伪类有那些" class="headerlink" title="5 CSS3 新增伪类有那些?"></a>5 CSS3 新增伪类有那些?</h4><p>p:first-of-type 选择属于其父元素的首个元素<br>p:last-of-type 选择属于其父元素的最后元素<br>p:only-of-type 选择属于其父元素唯一的元素<br>p:only-child 选择属于其父元素的唯一子元素<br>p:nth-child(2) 选择属于其父元素的第二个子元素<br>:enabled :disabled 表单控件的禁用状态。<br>:checked 单选框或复选框被选中。</p><h4 id="6-如何居中-div？如何居中一个浮动元素？如何让绝对定位的-div-居中？"><a href="#6-如何居中-div？如何居中一个浮动元素？如何让绝对定位的-div-居中？" class="headerlink" title="6 如何居中 div？如何居中一个浮动元素？如何让绝对定位的 div 居中？"></a>6 如何居中 div？如何居中一个浮动元素？如何让绝对定位的 div 居中？</h4><p>div：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">border: 1px solid red;</span><br><span class="line">margin: 0 auto;</span><br><span class="line">height: 50px;</span><br><span class="line">width: 80px;</span><br></pre></td></tr></table></figure><p>浮动元素的上下左右居中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">border: 1px solid red;</span><br><span class="line"><span class="built_in">float</span>: left;</span><br><span class="line">position: absolute;</span><br><span class="line">width: 200px;</span><br><span class="line">height: 100px;</span><br><span class="line">left: 50%;</span><br><span class="line">top: 50%;</span><br><span class="line">margin: -50px 0 0 -100px;</span><br></pre></td></tr></table></figure><p>绝对定位的左右居中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">border: 1px solid black;</span><br><span class="line">position: absolute;</span><br><span class="line">width: 200px;</span><br><span class="line">height: 100px;</span><br><span class="line">margin: 0 auto;</span><br><span class="line">left: 0;</span><br><span class="line">right: 0;</span><br></pre></td></tr></table></figure><p>还有更加优雅的居中方式就是用 flexbox，我以后会做整理。</p><h4 id="7-display-有哪些值？说明他们的作用"><a href="#7-display-有哪些值？说明他们的作用" class="headerlink" title="7 display 有哪些值？说明他们的作用?"></a>7 display 有哪些值？说明他们的作用?</h4><p>inline（默认）–内联<br>none–隐藏<br>block–块显示<br>table–表格显示<br>list-item–项目列表<br>inline-block</p><h4 id="8-position-的值？"><a href="#8-position-的值？" class="headerlink" title="8 position 的值？"></a>8 position 的值？</h4><p>static（默认）：按照正常文档流进行排列；<br>relative（相对定位）：不脱离文档流，参考自身静态位置通过 top, bottom, left, right 定位；<br>absolute(绝对定位)：参考距其最近一个不为 static 的父级元素通过 top, bottom, left, right 定位；<br>fixed(固定定位)：所固定的参照对像是可视窗口。</p><h4 id="9-CSS3-有哪些新特性？"><a href="#9-CSS3-有哪些新特性？" class="headerlink" title="9 CSS3 有哪些新特性？"></a>9 CSS3 有哪些新特性？</h4><p>RGBA 和透明度<br>background-image background-origin(content-box/padding-box/border-box) background-size background-repeat<br>word-wrap（对长的不可分割单词换行）word-wrap：break-word<br>文字阴影：text-shadow： 5px 5px 5px #FF0000;（水平阴影，垂直阴影，模糊距离，阴影颜色）<br>font-face 属性：定义自己的字体<br>圆角（边框半径）：border-radius 属性用于创建圆角<br>边框图片：border-image: url(border.png) 30 30 round<br>盒阴影：box-shadow: 10px 10px 5px #888888<br>媒体查询：定义两套 css，当浏览器的尺寸变化时会采用不同的属性</p><h4 id="10-请解释一下-CSS3-的-flexbox（弹性盒布局模型）-以及适用场景？"><a href="#10-请解释一下-CSS3-的-flexbox（弹性盒布局模型）-以及适用场景？" class="headerlink" title="10 请解释一下 CSS3 的 flexbox（弹性盒布局模型）,以及适用场景？"></a>10 请解释一下 CSS3 的 flexbox（弹性盒布局模型）,以及适用场景？</h4><p>该布局模型的目的是提供一种更加高效的方式来对容器中的条目进行布局、对齐和分配空间。在传统的布局方式中，block 布局是把块在垂直方向从上到下依次排列的；而 inline 布局则是在水平方向来排列。弹性盒布局并没有这样内在的方向限制，可以由开发人员自由操作。<br>试用场景：弹性布局适合于移动前端开发，在 Android 和 ios 上也完美支持。</p><h4 id="11-用纯-CSS-创建一个三角形的原理是什么？"><a href="#11-用纯-CSS-创建一个三角形的原理是什么？" class="headerlink" title="11 用纯 CSS 创建一个三角形的原理是什么？"></a>11 用纯 CSS 创建一个三角形的原理是什么？</h4><p>首先，需要把元素的宽度、高度设为 0。然后设置边框样式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">width: 0;</span><br><span class="line">height: 0;</span><br><span class="line">border-top: 40px solid transparent;</span><br><span class="line">border-left: 40px solid transparent;</span><br><span class="line">border-right: 40px solid transparent;</span><br><span class="line">border-bottom: 40px solid <span class="comment">#ff0000;</span></span><br></pre></td></tr></table></figure><h4 id="12-一个满屏品字布局如何设计"><a href="#12-一个满屏品字布局如何设计" class="headerlink" title="12 一个满屏品字布局如何设计?"></a>12 一个满屏品字布局如何设计?</h4><p>第一种真正的品字：<br>三块高宽是确定的；<br>上面那块用 margin: 0 auto;居中；<br>下面两块用 float 或者 inline-block 不换行；<br>用 margin 调整位置使他们居中。<br>第二种全屏的品字布局:<br>上面的 div 设置成 100%，下面的 div 分别宽 50%，然后使用 float 或者 inline 使其不换行。</p><h4 id="13-常见的兼容性问题？"><a href="#13-常见的兼容性问题？" class="headerlink" title="13 常见的兼容性问题？"></a>13 常见的兼容性问题？</h4><p>不同浏览器的标签默认的 margin 和 padding 不一样。*{margin:0;padding:0;}</p><h5 id="IE6-双边距-bug：块属性标签-float-后，又有横行的-margin-情况下，在-IE6-显示-margin-比设置的大。"><a href="#IE6-双边距-bug：块属性标签-float-后，又有横行的-margin-情况下，在-IE6-显示-margin-比设置的大。" class="headerlink" title="IE6 双边距 bug：块属性标签 float 后，又有横行的 margin 情况下，在 IE6 显示 margin 比设置的大。"></a>IE6 双边距 bug：块属性标签 float 后，又有横行的 margin 情况下，在 IE6 显示 margin 比设置的大。</h5><p>hack：display:inline;将其转化为行内属性。<br>渐进识别的方式，从总体中逐渐排除局部。首先，巧妙的使用“9”这一标记，将 IE 浏览器从所有情况中分离出来。接着，再次使用“+”将 IE8 和 IE7、IE6 分离开来，这样 IE8 已经独立识别。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">background-color:<span class="comment">#f1ee18;/*所有识别*/</span></span><br><span class="line">.background-color:<span class="comment">#00deff\9; /*IE6、7、8识别*/</span></span><br><span class="line">+background-color:<span class="comment">#a200ff;/*IE6、7识别*/</span></span><br><span class="line">_background-color:<span class="comment">#1e0bd1;/*IE6识别*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置较小高度标签（一般小于 10px），在 IE6，IE7 中高度超出自己设置高度。hack：给超出高度的标签设置 overflow:hidden;或者设置行高 line-height 小于你设置的高度。<br>IE 下，可以使用获取常规属性的方法来获取自定义属性,也可以使用 getAttribute()获取自定义属性；Firefox 下，只能使用 getAttribute()获取自定义属性。解决方法:统一通过 getAttribute()获取自定义属性。<br>Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决。<br>超链接访问过后 hover 样式就不出现了，被点击访问过的超链接样式不再具有 hover 和 active 了。解决方法是改变 CSS 属性的排列顺序:L-V-H-A ( love hate ): a:link {} a:visited {} a:hover {} a:active {}</p><h4 id="14-为什么要初始化-CSS-样式"><a href="#14-为什么要初始化-CSS-样式" class="headerlink" title="14 为什么要初始化 CSS 样式"></a>14 为什么要初始化 CSS 样式</h4><p>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对 CSS 初始化往往会出现浏览器之间的页面显示差异。</p><h4 id="15-absolute-的-containing-block-计算方式跟正常流有什么不同？"><a href="#15-absolute-的-containing-block-计算方式跟正常流有什么不同？" class="headerlink" title="15 absolute 的 containing block 计算方式跟正常流有什么不同？"></a>15 absolute 的 containing block 计算方式跟正常流有什么不同？</h4><p>无论属于哪种，都要先找到其祖先元素中最近的 position 值不为 static 的元素，然后再判断：<br>若此元素为 inline 元素，则 containing block 为能够包含这个元素生成的第一个和最后一个 inline box 的 padding box (除 margin, border 外的区域) 的最小矩形；<br>否则,则由这个祖先元素的 padding box 构成。<br>如果都找不到，则为 initial containing block。<br>补充：<br>static(默认的)/relative：简单说就是它的父元素的内容框（即去掉 padding 的部分）<br>absolute: 向上找最近的定位为 absolute/relative 的元素<br>fixed: 它的 containing block 一律为根元素(html/body)</p><h4 id="16-CSS-里的-visibility-属性有个-collapse-属性值？在不同浏览器下以后什么区别？"><a href="#16-CSS-里的-visibility-属性有个-collapse-属性值？在不同浏览器下以后什么区别？" class="headerlink" title="16 CSS 里的 visibility 属性有个 collapse 属性值？在不同浏览器下以后什么区别？"></a>16 CSS 里的 visibility 属性有个 collapse 属性值？在不同浏览器下以后什么区别？</h4><p>当一个元素的 visibility 属性被设置成 collapse 值后，对于一般的元素，它的表现跟 hidden 是一样的。<br>chrome 中，使用 collapse 值和使用 hidden 没有区别。<br>firefox，opera 和 IE，使用 collapse 值和使用 display：none 没有什么区别。</p><h4 id="17-display-none-与-visibility：hidden-的区别？"><a href="#17-display-none-与-visibility：hidden-的区别？" class="headerlink" title="17 display:none 与 visibility：hidden 的区别？"></a>17 display:none 与 visibility：hidden 的区别？</h4><p>display：none 不显示对应的元素，在文档布局中不再分配空间（回流+重绘）<br>visibility：hidden 隐藏对应元素，在文档布局中仍保留原来的空间（重绘）</p><h4 id="18-position-跟-display、overflow、float-这些特性相互叠加后会怎么样？"><a href="#18-position-跟-display、overflow、float-这些特性相互叠加后会怎么样？" class="headerlink" title="18 position 跟 display、overflow、float 这些特性相互叠加后会怎么样？"></a>18 position 跟 display、overflow、float 这些特性相互叠加后会怎么样？</h4><p>display 属性规定元素应该生成的框的类型；position 属性规定元素的定位类型；float 属性是一种布局方式，定义元素在哪个方向浮动。<br>类似于优先级机制：position：absolute/fixed 优先级最高，有他们在时，float 不起作用，display 值需要调整。float 或者 absolute 定位的元素，只能是块元素或表格。</p><h4 id="19-对-BFC-规范-块级格式化上下文：block-formatting-context-的理解？"><a href="#19-对-BFC-规范-块级格式化上下文：block-formatting-context-的理解？" class="headerlink" title="19 对 BFC 规范(块级格式化上下文：block formatting context)的理解？"></a>19 对 BFC 规范(块级格式化上下文：block formatting context)的理解？</h4><p>BFC 规定了内部的 Block Box 如何布局。<br>定位方案：<br>内部的 Box 会在垂直方向上一个接一个放置。<br>Box 垂直方向的距离由 margin 决定，属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠。<br>每个元素的 margin box 的左边，与包含块 border box 的左边相接触。<br>BFC 的区域不会与 float box 重叠。<br>BFC 是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。<br>计算 BFC 的高度时，浮动元素也会参与计算。<br>满足下列条件之一就可触发 BFC<br>根元素，即 html<br>float 的值不为 none（默认）<br>overflow 的值不为 visible（默认）<br>display 的值为 inline-block、table-cell、table-caption<br>position 的值为 absolute 或 fixed</p><h4 id="20-为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？"><a href="#20-为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？" class="headerlink" title="20 为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？"></a>20 为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？</h4><p>浮动元素碰到包含它的边框或者浮动元素的边框停留。由于浮动元素不在文档流中，所以文档流的块框表现得就像浮动框不存在一样。浮动元素会漂浮在文档流的块框上。</p><h5 id="浮动带来的问题："><a href="#浮动带来的问题：" class="headerlink" title="浮动带来的问题："></a>浮动带来的问题：</h5><p>父元素的高度无法被撑开，影响与父元素同级的元素<br>与浮动元素同级的非浮动元素（内联元素）会跟随其后<br>若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构。</p><h5 id="清除浮动的方式："><a href="#清除浮动的方式：" class="headerlink" title="清除浮动的方式："></a>清除浮动的方式：</h5><p>父级 div 定义 height<br>最后一个浮动元素后加空 div 标签 并添加样式 clear:both。<br>包含浮动元素的父标签添加样式 overflow 为 hidden 或 auto。<br>父级 div 定义 zoom</p><h4 id="21-上下-margin-重合的问题"><a href="#21-上下-margin-重合的问题" class="headerlink" title="21 上下 margin 重合的问题"></a>21 上下 margin 重合的问题</h4><p>在重合元素外包裹一层容器，并触发该容器生成一个 BFC。<br>例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">"aside"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=<span class="string">"text"</span>&gt;</span><br><span class="line">    &lt;div class=<span class="string">"main"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--下面是css代码--&gt;</span><br><span class="line">.aside &#123;</span><br><span class="line">    margin-bottom: 100px;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 150px;</span><br><span class="line">    background: <span class="comment">#f66;</span></span><br><span class="line">&#125;</span><br><span class="line">.main &#123;</span><br><span class="line">    margin-top: 100px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    background: <span class="comment">#fcc;</span></span><br><span class="line">&#125;</span><br><span class="line">.text&#123;</span><br><span class="line">    /*盒子main的外面包一个div，通过改变此div的属性使两个盒子分属于两个不同的BFC，以此来阻止margin重叠*/</span><br><span class="line">    overflow: hidden;  //此时已经触发了BFC属性。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="22-设置元素浮动后，该元素的-display-值是多少？"><a href="#22-设置元素浮动后，该元素的-display-值是多少？" class="headerlink" title="22 设置元素浮动后，该元素的 display 值是多少？"></a>22 设置元素浮动后，该元素的 display 值是多少？</h4><p>自动变成 display:block</p><h4 id="23-移动端的布局用过媒体查询吗？"><a href="#23-移动端的布局用过媒体查询吗？" class="headerlink" title="23 移动端的布局用过媒体查询吗？"></a>23 移动端的布局用过媒体查询吗？</h4><p>通过媒体查询可以为不同大小和尺寸的媒体定义不同的 css，适应相应的设备的显示。<br>head 里边</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> <span class="built_in">type</span>=<span class="string">"text/css"</span> href=<span class="string">"xxx.css"</span></span><br><span class="line">      media=<span class="string">"only screen and (max-device-width:480px)"</span>&gt;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CSS : @media only screen and (max-device-width:480px) &#123;/css样式/&#125;</span><br></pre></td></tr></table></figure><h4 id="24-使用-CSS-预处理器吗？"><a href="#24-使用-CSS-预处理器吗？" class="headerlink" title="24 使用 CSS 预处理器吗？"></a>24 使用 CSS 预处理器吗？</h4><p>Less sass</p><h4 id="25-CSS-优化、提高性能的方法有哪些？"><a href="#25-CSS-优化、提高性能的方法有哪些？" class="headerlink" title="25 CSS 优化、提高性能的方法有哪些？"></a>25 CSS 优化、提高性能的方法有哪些？</h4><pre>避免过度约束避免后代选择符避免链式选择符使用紧凑的语法避免不必要的命名空间避免不必要的重复最好使用表示语义的名字。一个好的类名应该是描述他是什么而不是像什么避免！important，可以选择其他选择器尽可能的精简规则，你可以合并不同类里的重复规则</pre><h4 id="26-浏览器是怎样解析-CSS-选择器的？"><a href="#26-浏览器是怎样解析-CSS-选择器的？" class="headerlink" title="26 浏览器是怎样解析 CSS 选择器的？"></a>26 浏览器是怎样解析 CSS 选择器的？</h4><p>CSS 选择器的解析是从右向左解析的。若从左向右的匹配，发现不符合规则，需要进行回溯，会损失很多性能。若从右向左匹配，先找到所有的最右节点，对于每一个节点，向上寻找其父节点直到找到根元素或满足条件的匹配规则，则结束这个分支的遍历。两种匹配规则的性能差别很大，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点（叶子节点），而从左向右的匹配规则的性能都浪费在了失败的查找上面。<br>而在 CSS 解析完毕后，需要将解析的结果与 DOM Tree 的内容一起进行分析建立一棵 Render Tree，最终用来进行绘图。在建立 Render Tree 时（WebKit 中的「Attachment」过程），浏览器就要为每个 DOM Tree 中的元素根据 CSS 的解析结果（Style Rules）来确定生成怎样的 Render Tree。</p><h4 id="27-在网页中的应该使用奇数还是偶数的字体？为什么呢？"><a href="#27-在网页中的应该使用奇数还是偶数的字体？为什么呢？" class="headerlink" title="27 在网页中的应该使用奇数还是偶数的字体？为什么呢？"></a>27 在网页中的应该使用奇数还是偶数的字体？为什么呢？</h4><p>使用偶数字体。偶数字号相对更容易和 web 设计的其他部分构成比例关系。Windows 自带的点阵宋体（中易宋体）从 Vista 开始只提供 12、14、16 px 这三个大小的点阵，而 13、15、17 px 时用的是小一号的点。（即每个字占的空间大了 1 px，但点阵没变），于是略显稀疏。</p><h4 id="28-margin-和-padding-分别适合什么场景使用？"><a href="#28-margin-和-padding-分别适合什么场景使用？" class="headerlink" title="28 margin 和 padding 分别适合什么场景使用？"></a>28 margin 和 padding 分别适合什么场景使用？</h4><h5 id="何时使用-margin："><a href="#何时使用-margin：" class="headerlink" title="何时使用 margin："></a>何时使用 margin：</h5><p>需要在 border 外侧添加空白<br>空白处不需要背景色<br>上下相连的两个盒子之间的空白，需要相互抵消时。</p><h5 id="何时使用-padding："><a href="#何时使用-padding：" class="headerlink" title="何时使用 padding："></a>何时使用 padding：</h5><p>需要在 border 内侧添加空白<br>空白处需要背景颜色<br>上下相连的两个盒子的空白，希望为两者之和。 #####兼容性的问题：<br>在 IE5 IE6 中，为 float 的盒子指定 margin 时，左侧的 margin 可能会变成两倍的宽度。通过改变 padding 或者指定盒子的 display：inline 解决。</p><h4 id="29-元素竖向的百分比设定是相对于容器的高度吗？"><a href="#29-元素竖向的百分比设定是相对于容器的高度吗？" class="headerlink" title="29 元素竖向的百分比设定是相对于容器的高度吗？"></a>29 元素竖向的百分比设定是相对于容器的高度吗？</h4><p>当按百分比设定一个元素的宽度时，它是相对于父容器的宽度计算的，但是，对于一些表示竖向距离的属性，例如 padding-top , padding-bottom , margin-top , margin-bottom 等，当按百分比设定它们时，依据的也是父容器的宽度，而不是高度。</p><h4 id="30-全屏滚动的原理是什么？用到了-CSS-的哪些属性？"><a href="#30-全屏滚动的原理是什么？用到了-CSS-的哪些属性？" class="headerlink" title="30 全屏滚动的原理是什么？用到了 CSS 的哪些属性？"></a>30 全屏滚动的原理是什么？用到了 CSS 的哪些属性？</h4><p>原理：有点类似于轮播，整体的元素一直排列下去，假设有 5 个需要展示的全屏页面，那么高度是 500%，只是展示 100%，剩下的可以通过 transform 进行 y 轴定位，也可以通过 margin-top 实现</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">overflow：hidden;transition：all 1000ms ease;</span><br></pre></td></tr></table></figure><h4 id="31-什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的-IE？"><a href="#31-什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的-IE？" class="headerlink" title="31 什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的 IE？"></a>31 什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的 IE？</h4><p>响应式网站设计(Responsive Web design)是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。<br>基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理。<br>页面头部必须有 meta 声明的 viewport。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=<span class="string">"viewport"</span></span><br><span class="line">      content=<span class="string">"width=device-width, initial-scale=1. maximum-scale=1,user-scalable=no"</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="32-视差滚动效果？"><a href="#32-视差滚动效果？" class="headerlink" title="32 视差滚动效果？"></a>32 视差滚动效果？</h4><p>视差滚动（Parallax Scrolling）通过在网页向下滚动的时候，控制背景的移动速度比前景的移动速度慢来创建出令人惊叹的 3D 效果。</p><h5 id="CSS3-实现"><a href="#CSS3-实现" class="headerlink" title="CSS3 实现"></a>CSS3 实现</h5><p>优点：开发时间短、性能和开发效率比较好，缺点是不能兼容到低版本的浏览器</p><h5 id="jQuery-实现"><a href="#jQuery-实现" class="headerlink" title="jQuery 实现"></a>jQuery 实现</h5><p>通过控制不同层滚动速度，计算每一层的时间，控制滚动效果。<br>优点：能兼容到各个版本的，效果可控性好<br>缺点：开发起来对制作者要求高<br>插件实现方式<br>例如：parallax-scrolling，兼容性十分好</p><h4 id="33-before-和-after-中双冒号和单冒号有什么区别？解释一下这-2-个伪元素的作用"><a href="#33-before-和-after-中双冒号和单冒号有什么区别？解释一下这-2-个伪元素的作用" class="headerlink" title="33 ::before 和 :after 中双冒号和单冒号有什么区别？解释一下这 2 个伪元素的作用"></a>33 ::before 和 :after 中双冒号和单冒号有什么区别？解释一下这 2 个伪元素的作用</h4><p>单冒号(:)用于 CSS3 伪类，双冒号(::)用于 CSS3 伪元素。<br>::before 就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于 dom 之中，只存在在页面之中。<br>:before 和 :after 这两个伪元素，是在 CSS2.1 里新出现的。起初，伪元素的前缀使用的是单冒号语法，但随着 Web 的进化，在 CSS3 的规范里，伪元素的语法被修改成使用双冒号，成为::before ::after</p><h4 id="34-你对-line-height-是如何理解的？"><a href="#34-你对-line-height-是如何理解的？" class="headerlink" title="34 你对 line-height 是如何理解的？"></a>34 你对 line-height 是如何理解的？</h4><p>行高是指一行文字的高度，具体说是两行文字间基线的距离。CSS 中起高度作用的是 height 和 line-height，没有定义 height 属性，最终其表现作用一定是 line-height。<br>单行文本垂直居中：把 line-height 值设置为 height 一样大小的值可以实现单行文字的垂直居中，其实也可以把 height 删除。<br>多行文本垂直居中：需要设置 display 属性为 inline-block。</p><h4 id="35-怎么让-Chrome-支持小于-12px-的文字？"><a href="#35-怎么让-Chrome-支持小于-12px-的文字？" class="headerlink" title="35 怎么让 Chrome 支持小于 12px 的文字？"></a>35 怎么让 Chrome 支持小于 12px 的文字？</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p&#123;font-size:10px;-webkit-transform:scale(0.8);&#125; //0.8是缩放比例</span><br></pre></td></tr></table></figure><h4 id="36-让页面里的字体变清晰，变细用-CSS-怎么做？"><a href="#36-让页面里的字体变清晰，变细用-CSS-怎么做？" class="headerlink" title="36 让页面里的字体变清晰，变细用 CSS 怎么做？"></a>36 让页面里的字体变清晰，变细用 CSS 怎么做？</h4><p>-webkit-font-smoothing 在 window 系统下没有起作用，但是在 IOS 设备上起作用-webkit-font-smoothing：antialiased 是最佳的，灰度平滑。</p><h4 id="37-position-fixed-在-android-下无效怎么处理？"><a href="#37-position-fixed-在-android-下无效怎么处理？" class="headerlink" title="37 position:fixed;在 android 下无效怎么处理？"></a>37 position:fixed;在 android 下无效怎么处理？</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=<span class="string">"viewport"</span></span><br><span class="line">      content=<span class="string">"width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0,</span></span><br><span class="line"><span class="string">      user-scalable=no"</span>/&gt;</span><br></pre></td></tr></table></figure><h4 id="38-如果需要手动写动画，你认为最小时间间隔是多久，为什么？"><a href="#38-如果需要手动写动画，你认为最小时间间隔是多久，为什么？" class="headerlink" title="38 如果需要手动写动画，你认为最小时间间隔是多久，为什么？"></a>38 如果需要手动写动画，你认为最小时间间隔是多久，为什么？</h4><p>多数显示器默认频率是 60Hz，即 1 秒刷新 60 次，所以理论上最小间隔为 1/60＊1000ms ＝ 16.7ms。</p><h4 id="39-li-与-li-之间有看不见的空白间隔是什么原因引起的？有什么解决办法？"><a href="#39-li-与-li-之间有看不见的空白间隔是什么原因引起的？有什么解决办法？" class="headerlink" title="39 li 与 li 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？"></a>39 li 与 li 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</h4><p>行框的排列会受到中间空白（回车空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为 0，就没有空格了。<br>解决方法：</p><pre>可以将li代码全部写在一排浮动li中float：left在ul中用font-size：0（谷歌不支持）；可以使用letter-space：-3px</pre><h4 id="40-display-inline-block-什么时候会显示间隙？"><a href="#40-display-inline-block-什么时候会显示间隙？" class="headerlink" title="40 display:inline-block 什么时候会显示间隙？"></a>40 display:inline-block 什么时候会显示间隙？</h4><p>有空格时候会有间隙 解决：移除空格<br>margin 正值的时候 解决：margin 使用负值<br>使用 font-size 时候 解决：font-size:0、letter-spacing、word-spacing</p><h4 id="41-有一个高度自适应的-div，里面有两个-div，一个高度-100px，希望另一个填满剩下的高度"><a href="#41-有一个高度自适应的-div，里面有两个-div，一个高度-100px，希望另一个填满剩下的高度" class="headerlink" title="41 有一个高度自适应的 div，里面有两个 div，一个高度 100px，希望另一个填满剩下的高度"></a>41 有一个高度自适应的 div，里面有两个 div，一个高度 100px，希望另一个填满剩下的高度</h4><p>外层 div 使用 position：relative；高度要求自适应的 div 使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">position: absolute; top: 100px; bottom: 0; left: 0</span><br></pre></td></tr></table></figure><h4 id="42-png、jpg、gif-这些图片格式解释一下，分别什么时候用。有没有了解过-webp？"><a href="#42-png、jpg、gif-这些图片格式解释一下，分别什么时候用。有没有了解过-webp？" class="headerlink" title="42 png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过 webp？"></a>42 png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过 webp？</h4><p>png 是便携式网络图片（Portable Network Graphics）是一种无损数据压缩位图文件格式.优点是：压缩比高，色彩好。 大多数地方都可以用。<br>jpg 是一种针对相片使用的一种失真压缩方法，是一种破坏性的压缩，在色调及颜色平滑变化做的不错。在 www 上，被用来储存和传输照片的格式。<br>gif 是一种位图文件格式，以 8 位色重现真色彩的图像。可以实现动画效果.<br>webp 格式是谷歌在 2010 年推出的图片格式，压缩率只有 jpg 的 2/3，大小比 png 小了 45%。缺点是压缩的时间更久了，兼容性不好，目前谷歌和 opera 支持。</p><h4 id="43-style-标签写在-body-后与-body-前有什么区别？"><a href="#43-style-标签写在-body-后与-body-前有什么区别？" class="headerlink" title="43 style 标签写在 body 后与 body 前有什么区别？"></a>43 style 标签写在 body 后与 body 前有什么区别？</h4><p>页面加载自上而下 当然是先加载样式。<br>写在 body 标签后由于浏览器以逐行方式对 HTML 文档进行解析，当解析到写在尾部的样式表（外联或写在 style 标签）会导致浏览器停止之前的渲染，等待加载且解析样式表完成之后重新渲染，在 windows 的 IE 下可能会出现 FOUC 现象（即样式失效导致的页面闪烁问题）</p><h4 id="44-CSS-属性-overflow-属性定义溢出元素内容区的内容会如何处理"><a href="#44-CSS-属性-overflow-属性定义溢出元素内容区的内容会如何处理" class="headerlink" title="44 CSS 属性 overflow 属性定义溢出元素内容区的内容会如何处理?"></a>44 CSS 属性 overflow 属性定义溢出元素内容区的内容会如何处理?</h4><p>参数是 scroll 时候，必会出现滚动条。<br>参数是 auto 时候，子元素内容大于父元素时出现滚动条。<br>参数是 visible 时候，溢出的内容出现在父元素之外。<br>参数是 hidden 时候，溢出隐藏。</p><h4 id="45-阐述一下-CSS-Sprites"><a href="#45-阐述一下-CSS-Sprites" class="headerlink" title="45 阐述一下 CSS Sprites"></a>45 阐述一下 CSS Sprites</h4><p>将一个页面涉及到的所有图片都包含到一张大图中去，然后利用 CSS 的 background-image，background- repeat，background-position 的组合进行背景定位。利用 CSS Sprites 能很好地减少网页的 http 请求，从而大大的提高页面的性能；CSS Sprites 能减少图片的字节。</p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mvvm</title>
      <link href="/2018/10/26/mvvm/"/>
      <url>/2018/10/26/mvvm/</url>
      
        <content type="html"><![CDATA[<h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><pre>涉及面试题：什么是 MVVM？比之 MVC 有什么区别？</pre><p>首先先申明一点，不管是 React 还是 Vue，它们都不是 MVVM 框架，只是有借鉴 MVVM 的思路。文中拿 Vue 举例也是为了更好地理解 MVVM 的概念。</p><p>接下来先说下 View 和 Model：</p><pre>View 很简单，就是用户看到的视图Model 同样很简单，一般就是本地数据和数据库中的数据</pre><p>基本上，我们写的产品就是通过接口从数据库中读取数据，然后将数据经过处理展现到用户看到的视图上。当然我们还可以从视图上读取用户的输入，然后又将用户的输入通过接口写入到数据库中。但是，如何将数据展示到视图上，然后又如何将用户的输入写入到数据中，不同的人就产生了不同的看法，从此出现了很多种架构设计。</p><p>传统的 MVC 架构通常是使用控制器更新模型，视图从模型中获取数据去渲染。当用户有输入时，会通过控制器去更新模型，并且通知视图进行更新。</p><p>但是 MVC 有一个巨大的缺陷就是控制器承担的责任太大了，随着项目愈加复杂，控制器中的代码会越来越臃肿，导致出现不利于维护的情况。</p><p>在 MVVM 架构中，引入了  ViewModel  的概念。ViewModel 只关心数据和业务的处理，不关心 View 如何处理数据，在这种情况下，View 和 Model 都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可复用的逻辑放在一个 ViewModel 中，让多个 View 复用这个 ViewModel。</p><p>以 Vue 框架来举例:</p><pre>ViewModel 就是组件的实例。View 就是模板。Model 的话在引入 Vuex 的情况下是完全可以和组件分离的。</pre><p>除了以上三个部分，其实在 MVVM 中还引入了一个隐式的 Binder 层，实现了 View 和 ViewModel 的绑定。</p><p>同样以 Vue 框架来举例，这个隐式的 Binder 层就是 Vue 通过解析模板中的插值和指令从而实现 View 与 ViewModel 的绑定。</p><p>对于 MVVM 来说，其实最重要的并不是通过双向绑定或者其他的方式将 View 与 ViewModel 绑定起来，而是通过 ViewModel 将视图中的状态和用户的行为分离出一个抽象，这才是 MVVM 的精髓。</p><h4 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h4><pre>涉及面试题：什么是 Virtual DOM？为什么 Virtual DOM 比原生 DOM 快？</pre><p>大家都知道操作 DOM 是很慢的，为什么慢的原因已经在「浏览器渲染原理」章节中说过，这里就不再赘述了。<br>那么相较于 DOM 来说，操作 JS 对象会快很多，并且我们也可以通过 JS 来模拟 DOM</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const ul = &#123;</span><br><span class="line">  tag: <span class="string">'ul'</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    class: <span class="string">'list'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  children: &#123;</span><br><span class="line">    tag: <span class="string">'li'</span>,</span><br><span class="line">    children: <span class="string">'1'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码对应的 DOM 就是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul class=<span class="string">'list'</span>&gt;</span><br><span class="line">  &lt;li&gt;1&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>那么既然 DOM 可以通过 JS 对象来模拟，反之也可以通过 JS 对象来渲染出对应的 DOM。当然了，通过 JS 来模拟 DOM 并且渲染对应的 DOM 只是第一步，难点在于如何判断新旧两个 JS 对象的最小差异并且实现局部更新  DOM。<br>首先 DOM 是一个多叉树的结构，如果需要完整的对比两颗树的差异，那么需要的时间复杂度会是 O(n ^ 3)，这个复杂度肯定是不能接受的。于是 React 团队优化了算法，实现了 O(n) 的复杂度来对比差异。 实现 O(n) 复杂度的关键就是只对比同层的节点，而不是跨层对比，这也是考虑到在实际业务中很少会去跨层的移动 DOM 元素。 所以判断差异的算法就分为了两步<br>首先从上至下，从左往右遍历对象，也就是树的深度遍历，这一步中会给每个节点添加索引，便于最后渲染差异<br>一旦节点有子元素，就去判断子元素是否有不同<br>在第一步算法中我们需要判断新旧节点的  tagName  是否相同，如果不相同的话就代表节点被替换了。如果没有更改  tagName  的话，就需要判断是否有子元素，有的话就进行第二步算法。<br>在第二步算法中，我们需要判断原本的列表中是否有节点被移除，在新的列表中需要判断是否有新的节点加入，还需要判断节点是否有移动。<br>举个例子来说，假设页面中只有一个列表，我们对列表中的元素进行了变更</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 假设这里模拟一个 ul，其中包含了 5 个 li</span><br><span class="line">[1, 2, 3, 4, 5]</span><br><span class="line">// 这里替换上面的 li</span><br><span class="line">[1, 2, 5, 4]</span><br></pre></td></tr></table></figure><p>从上述例子中，我们一眼就可以看出先前的  ul  中的第三个  li  被移除了，四五替换了位置。<br>那么在实际的算法中，我们如何去识别改动的是哪个节点呢？这就引入了  key  这个属性，想必大家在 Vue 或者 React 的列表中都用过这个属性。这个属性是用来给每一个节点打标志的，用于判断是否是同一个节点。<br>当然在判断以上差异的过程中，我们还需要判断节点的属性是否有变化等等。<br>当我们判断出以上的差异后，就可以把这些差异记录下来。当对比完两棵树以后，就可以通过差异去局部更新 DOM，实现性能的最优化。<br>另外再来回答「为什么 Virtual DOM 比原生 DOM 快」这个问题。首先这个问题得分场景来说，如果无脑替换所有的 DOM 这种场景来说，Virtual DOM 的局部更新肯定要来的快。但是如果你可以人肉也同样去局部替换 DOM，那么 Virtual DOM 必然没有你直接操作 DOM 来的快，毕竟还有一层 diff 算法的损耗。<br>当然了 Virtual DOM 提高性能是其中一个优势，其实最大的优势还是在于：</p><pre>将 Virtual DOM 作为一个兼容层，让我们还能对接非 Web 端的系统，实现跨端开发。同样的，通过 Virtual DOM 我们可以渲染到其他的平台，比如实现 SSR、同构渲染等等。实现组件的高度抽象化</pre><h4 id="路由原理"><a href="#路由原理" class="headerlink" title="路由原理"></a>路由原理</h4><pre>涉及面试题：前端路由原理？两种实现方式有什么区别？</pre><p>前端路由实现起来其实很简单，本质就是监听 URL 的变化，然后匹配路由规则，显示相应的页面，并且无须刷新页面。目前前端使用的路由就只有两种实现方式</p><pre>Hash 模式History 模式</pre><h5 id="Hash-模式"><a href="#Hash-模式" class="headerlink" title="Hash 模式"></a>Hash 模式</h5><p><a href="http://www.test.com/#/" target="_blank" rel="noopener">www.test.com/#/</a>  就是 Hash URL，当  #  后面的哈希值发生变化时，可以通过  hashchange  事件来监听到 URL 的变化，从而进行跳转页面，并且无论哈希值如何变化，服务端接收到的 URL 请求永远是  <a href="http://www.test.com。" target="_blank" rel="noopener">www.test.com。</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(<span class="string">'hashchange'</span>, () =&gt; &#123;</span><br><span class="line">  // ... 具体逻辑</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Hash 模式相对来说更简单，并且兼容性也更好。</p><h5 id="History-模式"><a href="#History-模式" class="headerlink" title="History 模式"></a>History 模式</h5><p>History 模式是 HTML5 新推出的功能，主要使用  history.pushState  和  history.replaceState  改变 URL。<br>通过 History 模式改变 URL 同样不会引起页面的刷新，只会更新浏览器的历史记录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 新增历史记录</span><br><span class="line">history.pushState(stateObject, title, URL)</span><br><span class="line">// 替换当前历史记录</span><br><span class="line">history.replaceState(stateObject, title, URL)</span><br><span class="line">当用户做出浏览器动作时，比如点击后退按钮时会触发 popState 事件</span><br><span class="line">window.addEventListener(<span class="string">'popstate'</span>, e =&gt; &#123;</span><br><span class="line">  // e.state 就是 pushState(stateObject) 中的 stateObject</span><br><span class="line">  console.log(e.state)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h6 id="两种模式对比"><a href="#两种模式对比" class="headerlink" title="两种模式对比"></a>两种模式对比</h6><pre>Hash 模式只可以更改  #  后面的内容，History 模式可以通过 API 设置任意的同源 URLHistory 模式可以通过 API 添加任意类型的数据到历史记录中，Hash 模式只能更改哈希值，也就是字符串Hash 模式无需后端配置，并且兼容性好。History 模式在用户手动输入地址或者刷新页面的时候会发起 URL 请求，        后端需要配置  index.html  页面用于匹配不到静态资源的时候</pre><h4 id="Vue-和-React-之间的区别"><a href="#Vue-和-React-之间的区别" class="headerlink" title="Vue 和 React 之间的区别"></a>Vue 和 React 之间的区别</h4><p>Vue 的表单可以使用  v-model  支持双向绑定，相比于 React 来说开发上更加方便，当然了  v-model 其实就是个语法糖，本质上和 React 写表单的方式没什么区别。<br>改变数据方式不同，Vue 修改状态相比来说要简单许多，React 需要使用  setState  来改变状态，并且使用这个 API 也有一些坑点。并且 Vue 的底层使用了依赖追踪，页面更新渲染已经是最优的了，但是 React 还是需要用户手动去优化这方面的问题。<br>React 16 以后，有些钩子函数会执行多次，这是因为引入 Fiber 的原因，这在后续的章节中会讲到。<br>React 需要使用 JSX，有一定的上手成本，并且需要一整套的工具链支持，但是完全可以通过 JS 来控制页面，更加的灵活。Vue 使用了模板语法，相比于 JSX 来说没有那么灵活，但是完全可以脱离工具链，通过直接编写  render  函数就能在浏览器中运行。<br>在生态上来说，两者其实没多大的差距，当然 React 的用户是远远高于 Vue 的。<br>在上手成本上来说，Vue 一开始的定位就是尽可能的降低前端开发的门槛，然而 React 更多的是去改变用户去接受它的概念和思想，相较于 Vue 来说上手成本略高。</p><h4 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h4><p>Vue 内部使用了  Object.defineProperty()  来实现数据响应式，通过这个函数可以监听到  set  和  get  的事件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">var data = &#123; name: <span class="string">'yck'</span> &#125;</span><br><span class="line">observe(data)</span><br><span class="line"><span class="built_in">let</span> name = data.name // -&gt; get value</span><br><span class="line">data.name = <span class="string">'yyy'</span> // -&gt; change value</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> observe(obj) &#123;</span><br><span class="line">  // 判断类型</span><br><span class="line">  <span class="keyword">if</span> (!obj || typeof obj !== <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="built_in">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  Object.keys(obj).forEach(key =&gt; &#123;</span><br><span class="line">    defineReactive(obj, key, obj[key])</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> defineReactive(obj, key, val) &#123;</span><br><span class="line">  // 递归子属性</span><br><span class="line">  observe(val)</span><br><span class="line">  Object.defineProperty(obj, key, &#123;</span><br><span class="line">    // 可枚举</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    // 可配置</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    // 自定义函数</span><br><span class="line">    get: <span class="keyword">function</span> <span class="function"><span class="title">reactiveGetter</span></span>() &#123;</span><br><span class="line">      console.log(<span class="string">'get value'</span>)</span><br><span class="line">      <span class="built_in">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">set</span>: <span class="keyword">function</span> reactiveSetter(newVal) &#123;</span><br><span class="line">      console.log(<span class="string">'change value'</span>)</span><br><span class="line">      val = newVal</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码简单的实现了如何监听数据的  set  和  get  的事件，但是仅仅如此是不够的，因为自定义的函数一开始是不会执行的。只有先执行了依赖收集，才能在属性更新的时候派发更新，所以接下来我们需要先触发依赖收集。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;&#123;name&#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>在解析如上模板代码时，遇到    就会进行依赖收集。<br>接下来我们先来实现一个  Dep  类，用于解耦属性的依赖收集和派发更新操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 通过 Dep 解耦属性的依赖和更新操作</span><br><span class="line">class Dep &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    this.subs = []</span><br><span class="line">  &#125;</span><br><span class="line">  // 添加依赖</span><br><span class="line">  addSub(sub) &#123;</span><br><span class="line">    this.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line">  // 更新</span><br><span class="line">  <span class="function"><span class="title">notify</span></span>() &#123;</span><br><span class="line">    this.subs.forEach(sub =&gt; &#123;</span><br><span class="line">      sub.update()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 全局属性，通过该属性配置 Watcher</span><br><span class="line">Dep.target = null</span><br></pre></td></tr></table></figure><p>以上的代码实现很简单，当需要依赖收集的时候调用  addSub，当需要派发更新的时候调用  notify。</p><h4 id="Vue-组件挂载时添加响应式的过程。"><a href="#Vue-组件挂载时添加响应式的过程。" class="headerlink" title="Vue 组件挂载时添加响应式的过程。"></a>Vue 组件挂载时添加响应式的过程。</h4><p>在组件挂载时，会先对所有需要的属性调用  Object.defineProperty()，然后实例化  Watcher，传入组件更新的回调。在实例化过程中，会对模板中的属性进行求值，触发依赖收集。<br>因为这一小节主要目的是学习响应式原理的细节，所以接下来的代码会简略的表达触发依赖收集时的操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Watcher &#123;</span><br><span class="line">  constructor(obj, key, cb) &#123;</span><br><span class="line">    // 将 Dep.target 指向自己</span><br><span class="line">    // 然后触发属性的 getter 添加监听</span><br><span class="line">    // 最后将 Dep.target 置空</span><br><span class="line">    Dep.target = this</span><br><span class="line">    this.cb = cb</span><br><span class="line">    this.obj = obj</span><br><span class="line">    this.key = key</span><br><span class="line">    this.value = obj[key]</span><br><span class="line">    Dep.target = null</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">update</span></span>() &#123;</span><br><span class="line">    // 获得新值</span><br><span class="line">    this.value = this.obj[this.key]</span><br><span class="line">    // 调用 update 方法更新 Dom</span><br><span class="line">    this.cb(this.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是  Watcher  的简单实现，在执行构造函数的时候将  Dep.target  指向自身，从而使得收集到了对应的  Watcher，在派发更新的时候取出对应的  Watcher  然后执行  update  函数。<br>接下来，需要对  defineReactive  函数进行改造，在自定义函数中添加依赖收集和派发更新相关的代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> defineReactive(obj, key, val) &#123;</span><br><span class="line">  // 递归子属性</span><br><span class="line">  observe(val)</span><br><span class="line">  <span class="built_in">let</span> dp = new Dep()</span><br><span class="line">  Object.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    get: <span class="keyword">function</span> <span class="function"><span class="title">reactiveGetter</span></span>() &#123;</span><br><span class="line">      console.log(<span class="string">'get value'</span>)</span><br><span class="line">      // 将 Watcher 添加到订阅</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        dp.addSub(Dep.target)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">set</span>: <span class="keyword">function</span> reactiveSetter(newVal) &#123;</span><br><span class="line">      console.log(<span class="string">'change value'</span>)</span><br><span class="line">      val = newVal</span><br><span class="line">      // 执行 watcher 的 update 方法</span><br><span class="line">      dp.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上所有代码实现了一个简易的数据响应式，核心思路就是手动触发一次属性的 getter 来实现依赖收集。<br>现在我们就来测试下代码的效果，只需要把所有的代码复制到浏览器中执行，就会发现页面的内容全部被替换了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var data = &#123; name: <span class="string">'yck'</span> &#125;</span><br><span class="line">observe(data)</span><br><span class="line"><span class="keyword">function</span> update(value) &#123;</span><br><span class="line">  document.querySelector(<span class="string">'div'</span>).innerText = value</span><br><span class="line">&#125;</span><br><span class="line">// 模拟解析到 `&#123;&#123;name&#125;&#125;` 触发的操作</span><br><span class="line">new Watcher(data, <span class="string">'name'</span>, update)</span><br><span class="line">// update Dom innerText</span><br><span class="line">data.name = <span class="string">'yyy'</span></span><br></pre></td></tr></table></figure><h4 id="Object-defineProperty-的缺陷"><a href="#Object-defineProperty-的缺陷" class="headerlink" title="Object.defineProperty 的缺陷"></a>Object.defineProperty 的缺陷</h4><p>以上已经分析完了 Vue 的响应式原理，接下来说一点  Object.defineProperty  中的缺陷。<br>如果通过下标方式修改数组数据或者给对象新增属性并不会触发组件的重新渲染，因为  Object.defineProperty  不能拦截到这些操作，更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过重写函数的方式解决了这个问题。<br>对于第一个问题，Vue 提供了一个 API 解决</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> <span class="built_in">set</span> (target: Array&lt;any&gt; | Object, key: any, val: any): any &#123;</span><br><span class="line">  // 判断是否为数组且下标是否有效</span><br><span class="line">  <span class="keyword">if</span> (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123;</span><br><span class="line">    // 调用 splice 函数触发派发更新</span><br><span class="line">    // 该函数已被重写</span><br><span class="line">    target.length = Math.max(target.length, key)</span><br><span class="line">    target.splice(key, 1, val)</span><br><span class="line">    <span class="built_in">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  // 判断 key 是否已经存在</span><br><span class="line">  <span class="keyword">if</span> (key <span class="keyword">in</span> target &amp;&amp; !(key <span class="keyword">in</span> Object.prototype)) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    <span class="built_in">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  const ob = (target: any).__ob__</span><br><span class="line">  // 如果对象不是响应式对象，就赋值返回</span><br><span class="line">  <span class="keyword">if</span> (!ob) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    <span class="built_in">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  // 进行双向绑定</span><br><span class="line">  defineReactive(ob.value, key, val)</span><br><span class="line">  // 手动派发更新</span><br><span class="line">  ob.dep.notify()</span><br><span class="line">  <span class="built_in">return</span> val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于数组而言，Vue 内部重写了以下函数实现派发更新</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 获得数组原型</span><br><span class="line">const arrayProto = Array.prototype</span><br><span class="line"><span class="built_in">export</span> const arrayMethods = Object.create(arrayProto)</span><br><span class="line">// 重写以下函数</span><br><span class="line">const methodsToPatch = [ <span class="string">'push'</span>, <span class="string">'pop'</span>, <span class="string">'shift'</span>, <span class="string">'unshift'</span>, <span class="string">'splice'</span>, <span class="string">'sort'</span>, <span class="string">'reverse'</span> ]</span><br><span class="line">methodsToPatch.forEach(<span class="keyword">function</span> (method) &#123;</span><br><span class="line">  // 缓存原生函数 const original = arrayProto[method]</span><br><span class="line">  // 重写函数</span><br><span class="line">  def(arrayMethods, method, <span class="keyword">function</span> mutator (...args) &#123;</span><br><span class="line">    // 先调用原生函数获得结果</span><br><span class="line">    const result = original.apply(this, args) const ob = this.__ob__ <span class="built_in">let</span> inserted</span><br><span class="line">    // 调用以下几个函数时，监听新数据</span><br><span class="line">    switch (method) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'push'</span>: <span class="keyword">case</span> <span class="string">'unshift'</span>: inserted = args <span class="built_in">break</span> <span class="keyword">case</span> <span class="string">'splice'</span>: inserted = args.slice(2) <span class="built_in">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inserted) ob.observeArray(inserted)</span><br><span class="line">    // 手动派发更新</span><br><span class="line">    ob.dep.notify() <span class="built_in">return</span> result</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h4><p>想必大家在使用 Vue 开发的过程中，基本都是使用模板的方式。那么你有过「模板是怎么在浏览器中运行的」这种疑虑嘛？<br>首先直接把模板丢到浏览器中肯定是不能运行的，模板只是为了方便开发者进行开发。Vue 会通过编译器将模板通过几个阶段最终编译为  render  函数，然后通过执行  render  函数生成 Virtual DOM 最终映射为真实 DOM。<br>接下来我们就来学习这个编译的过程，了解这个过程中大概发生了什么事情。这个过程其中又分为三个阶段，分别为：<br>将模板解析为 AST</p><h5 id="优化-AST"><a href="#优化-AST" class="headerlink" title="优化 AST"></a>优化 AST</h5><p>将 AST 转换为  render  函数<br>在第一个阶段中，最主要的事情还是通过各种各样的正则表达式去匹配模板中的内容，然后将内容提取出来做各种逻辑操作，接下来会生成一个最基本的 AST 对象</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // 类型</span><br><span class="line">    <span class="built_in">type</span>: 1,</span><br><span class="line">    // 标签</span><br><span class="line">    tag,</span><br><span class="line">    // 属性列表</span><br><span class="line">    attrsList: attrs,</span><br><span class="line">    // 属性映射</span><br><span class="line">    attrsMap: makeAttrsMap(attrs),</span><br><span class="line">    // 父节点</span><br><span class="line">    parent,</span><br><span class="line">    // 子节点</span><br><span class="line">    children: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后会根据这个最基本的 AST 对象中的属性，进一步扩展 AST。<br>当然在这一阶段中，还会进行其他的一些判断逻辑。比如说对比前后开闭标签是否一致，判断根组件是否只存在一个，判断是否符合 HTML5 Content Model  规范等等问题。<br>接下来就是优化 AST 的阶段。在当前版本下，Vue 进行的优化内容其实还是不多的。只是对节点进行了静态内容提取，也就是将永远不会变动的节点提取了出来，实现复用 Virtual DOM，跳过对比算法的功能。在下一个大版本中，Vue 会在优化 AST 的阶段继续发力，实现更多的优化功能，尽可能的在编译阶段压榨更多的性能，比如说提取静态的属性等等优化行为。<br>最后一个阶段就是通过 AST 生成  render  函数了。其实这一阶段虽然分支有很多，但是最主要的目的就是遍历整个 AST，根据不同的条件生成不同的代码罢了。</p><h5 id="NextTick-原理分析"><a href="#NextTick-原理分析" class="headerlink" title="NextTick 原理分析"></a>NextTick 原理分析</h5><p>nextTick  可以让我们在下次 DOM 更新循环结束之后执行延迟回调，用于获得更新后的 DOM。<br>在 Vue 2.4 之前都是使用的 microtasks，但是 microtasks 的优先级过高，在某些情况下可能会出现比事件冒泡更快的情况，但如果都使用 macrotasks 又可能会出现渲染的性能问题。所以在新版本中，会默认使用 microtasks，但在特殊情况下会使用 macrotasks，比如 v-on。<br>对于实现 macrotasks ，会先判断是否能使用  setImmediate ，不能的话降级为  MessageChannel ，以上都不行的话就使用  setTimeout</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (typeof setImmediate !== <span class="string">'undefined'</span> &amp;&amp; isNative(setImmediate)) &#123;</span><br><span class="line">  macroTimerFunc = () =&gt; &#123;</span><br><span class="line">    setImmediate(flushCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">  typeof MessageChannel !== <span class="string">'undefined'</span> &amp;&amp;</span><br><span class="line">  (isNative(MessageChannel) ||</span><br><span class="line">    // PhantomJS</span><br><span class="line">    MessageChannel.toString() === <span class="string">'[object MessageChannelConstructor]'</span>)</span><br><span class="line">) &#123;</span><br><span class="line">  const channel = new MessageChannel()</span><br><span class="line">  const port = channel.port2</span><br><span class="line">  channel.port1.onmessage = flushCallbacks</span><br><span class="line">  macroTimerFunc = () =&gt; &#123;</span><br><span class="line">    port.postMessage(1)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  macroTimerFunc = () =&gt; &#123;</span><br><span class="line">    setTimeout(flushCallbacks, 0)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码很简单，就是判断能不能使用相应的 API。</p>]]></content>
      
      
      <categories>
          
          <category> mvvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mvvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack</title>
      <link href="/2018/10/03/webpack/"/>
      <url>/2018/10/03/webpack/</url>
      
        <content type="html"><![CDATA[<h3 id="Webpack-性能优化"><a href="#Webpack-性能优化" class="headerlink" title="Webpack 性能优化"></a>Webpack 性能优化</h3><pre>有哪些方式可以减少 Webpack 的打包时间有哪些方式可以让 Webpack 打出来的包更小</pre><h4 id="减少-Webpack-打包时间"><a href="#减少-Webpack-打包时间" class="headerlink" title="减少 Webpack 打包时间"></a>减少 Webpack 打包时间</h4><h5 id="优化-Loader"><a href="#优化-Loader" class="headerlink" title="优化 Loader"></a>优化 Loader</h5><p>对于 Loader 来说，影响打包效率首当其冲必属 Babel 了。因为 Babel 会将代码转为字符串生成 AST，然后对 AST 继续进行转变最后再生成新的代码，项目越大，转换代码越多，效率就越低。当然了，我们是有办法优化的。</p><h6 id="首先我们可以优化-Loader-的文件搜索范围"><a href="#首先我们可以优化-Loader-的文件搜索范围" class="headerlink" title="首先我们可以优化 Loader 的文件搜索范围"></a>首先我们可以优化 Loader 的文件搜索范围</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        // js 文件才使用 babel</span><br><span class="line">        <span class="built_in">test</span>: /\.js\$/,</span><br><span class="line">        loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">        // 只在 src 文件夹下查找</span><br><span class="line">        include: [resolve(<span class="string">'src'</span>)],</span><br><span class="line">        // 不会去查找的路径</span><br><span class="line">        exclude: /node_modules/</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="对于-Babel-来说，我们肯定是希望只作用在-JS-代码上的，然后-node-modules-中使用的代码都是编译过的，所以我们也完全没有必要再去处理一遍。"><a href="#对于-Babel-来说，我们肯定是希望只作用在-JS-代码上的，然后-node-modules-中使用的代码都是编译过的，所以我们也完全没有必要再去处理一遍。" class="headerlink" title="对于 Babel 来说，我们肯定是希望只作用在 JS 代码上的，然后 node_modules 中使用的代码都是编译过的，所以我们也完全没有必要再去处理一遍。"></a>对于 Babel 来说，我们肯定是希望只作用在 JS 代码上的，然后 node_modules 中使用的代码都是编译过的，所以我们也完全没有必要再去处理一遍。</h6><h6 id="当然这样做还不够，我们还可以将-Babel-编译过的文件缓存起来，下次只需要编译更改过的代码文件即可，这样可以大幅度加快打包时间"><a href="#当然这样做还不够，我们还可以将-Babel-编译过的文件缓存起来，下次只需要编译更改过的代码文件即可，这样可以大幅度加快打包时间" class="headerlink" title="当然这样做还不够，我们还可以将 Babel 编译过的文件缓存起来，下次只需要编译更改过的代码文件即可，这样可以大幅度加快打包时间"></a>当然这样做还不够，我们还可以将 Babel 编译过的文件缓存起来，下次只需要编译更改过的代码文件即可，这样可以大幅度加快打包时间</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loader: <span class="string">'babel-loader?cacheDirectory=true'</span></span><br></pre></td></tr></table></figure><h3 id="HappyPack"><a href="#HappyPack" class="headerlink" title="HappyPack"></a>HappyPack</h3><p>受限于 Node 是单线程运行的，所以 Webpack 在打包的过程中也是单线程的，特别是在执行 Loader 的时候，长时间编译的任务很多，这样就会导致等待的情况。</p><h6 id="HappyPack-可以将-Loader-的同步执行转换为并行的，这样就能充分利用系统资源来加快打包效率了"><a href="#HappyPack-可以将-Loader-的同步执行转换为并行的，这样就能充分利用系统资源来加快打包效率了" class="headerlink" title="HappyPack 可以将 Loader 的同步执行转换为并行的，这样就能充分利用系统资源来加快打包效率了"></a>HappyPack 可以将 Loader 的同步执行转换为并行的，这样就能充分利用系统资源来加快打包效率了</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">  loaders: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">test</span>: /\.js\$/,</span><br><span class="line">      include: [resolve(<span class="string">'src'</span>)],</span><br><span class="line">      exclude: /node_modules/,</span><br><span class="line">      // id 后面的内容对应下面</span><br><span class="line">      loader: <span class="string">'happypack/loader?id=happybabel'</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br><span class="line">plugins: [</span><br><span class="line">  new HappyPack(&#123;</span><br><span class="line">    id: <span class="string">'happybabel'</span>,</span><br><span class="line">    loaders: [<span class="string">'babel-loader?cacheDirectory'</span>],</span><br><span class="line">    // 开启 4 个线程</span><br><span class="line">    threads: 4</span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="DllPlugin"><a href="#DllPlugin" class="headerlink" title="DllPlugin"></a>DllPlugin</h3><h5 id="DllPlugin-可以将特定的类库提前打包然后引入。这种方式可以极大的减少打包类库的次数，只有当类库更新版本才有需要重新打包，并且也实现了将公共代码抽离成单独文件的优化方案。"><a href="#DllPlugin-可以将特定的类库提前打包然后引入。这种方式可以极大的减少打包类库的次数，只有当类库更新版本才有需要重新打包，并且也实现了将公共代码抽离成单独文件的优化方案。" class="headerlink" title="DllPlugin 可以将特定的类库提前打包然后引入。这种方式可以极大的减少打包类库的次数，只有当类库更新版本才有需要重新打包，并且也实现了将公共代码抽离成单独文件的优化方案。"></a>DllPlugin 可以将特定的类库提前打包然后引入。这种方式可以极大的减少打包类库的次数，只有当类库更新版本才有需要重新打包，并且也实现了将公共代码抽离成单独文件的优化方案。</h5><h6 id="接下来我们就来学习如何使用-DllPlugin"><a href="#接下来我们就来学习如何使用-DllPlugin" class="headerlink" title="接下来我们就来学习如何使用 DllPlugin"></a>接下来我们就来学习如何使用 DllPlugin</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 单独配置在一个文件中</span><br><span class="line">// webpack.dll.conf.js</span><br><span class="line">const path = require(<span class="string">'path'</span>)</span><br><span class="line">const webpack = require(<span class="string">'webpack'</span>)</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">  // 想统一打包的类库</span><br><span class="line">  vendor: [<span class="string">'react'</span>]</span><br><span class="line">&#125;,</span><br><span class="line">output: &#123;</span><br><span class="line">  path: path.join(**dirname, <span class="string">'dist'</span>),</span><br><span class="line">  filename: <span class="string">'[name].dll.js'</span>,</span><br><span class="line">  library: <span class="string">'[name]-[hash]'</span></span><br><span class="line">&#125;,</span><br><span class="line">plugins: [</span><br><span class="line">  new webpack.DllPlugin(&#123;</span><br><span class="line">    // name 必须和 output.library 一致</span><br><span class="line">    name: <span class="string">'[name]-[hash]'</span>,</span><br><span class="line">    // 该属性需要与 DllReferencePlugin 中一致</span><br><span class="line">    context: **dirname,</span><br><span class="line">    path: path.join(\_\_dirname, <span class="string">'dist'</span>, <span class="string">'[name]-manifest.json'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="然后我们需要执行这个配置文件生成依赖文件，接下来我们需要使用-DllReferencePlugin-将依赖文件引入项目中"><a href="#然后我们需要执行这个配置文件生成依赖文件，接下来我们需要使用-DllReferencePlugin-将依赖文件引入项目中" class="headerlink" title="然后我们需要执行这个配置文件生成依赖文件，接下来我们需要使用 DllReferencePlugin 将依赖文件引入项目中"></a>然后我们需要执行这个配置文件生成依赖文件，接下来我们需要使用 DllReferencePlugin 将依赖文件引入项目中</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// webpack.conf.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  // ...省略其他配置</span><br><span class="line">  plugins: [</span><br><span class="line">    new webpack.DllReferencePlugin(&#123;</span><br><span class="line">      context: __dirname,</span><br><span class="line">      // manifest 就是之前打包出来的 json 文件</span><br><span class="line">      manifest: require(<span class="string">'./dist/vendor-manifest.json'</span>),</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码压缩"><a href="#代码压缩" class="headerlink" title="代码压缩"></a>代码压缩</h4><p>在 Webpack3 中，我们一般使用 UglifyJS 来压缩代码，但是这个是单线程运行的，为了加快效率，我们可以使用 webpack-parallel-uglify-plugin 来并行运行 UglifyJS，从而提高效率。</p><p>在 Webpack4 中，我们就不需要以上这些操作了，只需要将 mode 设置为 production 就可以默认开启以上功能。代码压缩也是我们必做的性能优化方案，当然我们不止可以压缩 JS 代码，还可以压缩 HTML、CSS 代码，并且在压缩 JS 代码的过程中，我们还可以通过配置实现比如删除 console.log 这类代码的功能。</p><h4 id="一些小的优化点"><a href="#一些小的优化点" class="headerlink" title="一些小的优化点"></a>一些小的优化点</h4><p>我们还可以通过一些小的优化点来加快打包速度</p><h5 id="resolve-extensions："><a href="#resolve-extensions：" class="headerlink" title="resolve.extensions："></a>resolve.extensions：</h5><p>用来表明文件后缀列表，默认查找顺序是 [‘.js’, ‘.json’]，如果你的导入文件没有添加后缀就会按照这个顺序查找文件。我们应该尽可能减少后缀列表长度，然后将出现频率高的后缀排在前面</p><h5 id="resolve-alias："><a href="#resolve-alias：" class="headerlink" title="resolve.alias："></a>resolve.alias：</h5><p>可以通过别名的方式来映射一个路径，能让 Webpack 更快找到路径</p><h5 id="module-noParse："><a href="#module-noParse：" class="headerlink" title="module.noParse："></a>module.noParse：</h5><p>如果你确定一个文件下没有其他依赖，就可以使用该属性让 Webpack 不扫描该文件，这种方式对于大型的类库很有帮助</p><h4 id="减少-Webpack-打包后的文件体积"><a href="#减少-Webpack-打包后的文件体积" class="headerlink" title="减少 Webpack 打包后的文件体积"></a>减少 Webpack 打包后的文件体积</h4><p>注意：该内容也属于性能优化领域。</p><h4 id="按需加载"><a href="#按需加载" class="headerlink" title="按需加载"></a>按需加载</h4><p>想必大家在开发 SPA 项目的时候，项目中都会存在十几甚至更多的路由页面。如果我们将这些页面全部打包进一个 JS 文件的话，虽然将多个请求合并了，但是同样也加载了很多并不需要的代码，耗费了更长的时间。那么为了首页能更快地呈现给用户，我们肯定是希望首页能加载的文件体积越小越好，这时候我们就可以使用按需加载，将每个路由页面单独打包为一个文件。当然不仅仅路由可以按需加载，对于 loadash 这种大型类库同样可以使用这个功能。</p><pre>按需加载的代码实现这里就不详细展开了，因为鉴于用的框架不同，实现起来都是不一样的。当然了，虽然他们的用法可能不同，但是底层的机制都是一样的。都是当使用的时候再去下载对应文件，返回一个 Promise，当 Promise 成功以后去执行回调。</pre><h5 id="Scope-Hoisting"><a href="#Scope-Hoisting" class="headerlink" title="Scope Hoisting"></a>Scope Hoisting</h5><p>Scope Hoisting 会分析出模块之间的依赖关系，尽可能的把打包出来的模块合并到一个函数中去。</p><p>比如我们希望打包两个文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// test.js</span><br><span class="line"><span class="built_in">export</span> const a = 1</span><br><span class="line">// index.js</span><br><span class="line">import &#123; a &#125; from <span class="string">'./test.js'</span></span><br></pre></td></tr></table></figure><p>对于这种情况，我们打包出来的代码会类似这样</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  /* 0 */</span><br><span class="line">  <span class="keyword">function</span> (module, exports, require) &#123;</span><br><span class="line">    //...</span><br><span class="line">  &#125;,</span><br><span class="line">  /* 1 */</span><br><span class="line">  <span class="keyword">function</span> (module, exports, require) &#123;</span><br><span class="line">    //...</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>但是如果我们使用 Scope Hoisting 的话，代码就会尽可能的合并到一个函数中去，也就变成了这样的类似代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  /* 0 */</span><br><span class="line">  <span class="keyword">function</span> (module, exports, require) &#123;</span><br><span class="line">    //...</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这样的打包方式生成的代码明显比之前的少多了。如果在 Webpack4 中你希望开启这个功能，只需要启用 optimization.concatenateModules 就可以了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    concatenateModules: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Tree-Shaking"><a href="#Tree-Shaking" class="headerlink" title="Tree Shaking"></a>Tree Shaking</h4><p>Tree Shaking 可以实现删除项目中未被引用的代码，比如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// test.js</span><br><span class="line"><span class="built_in">export</span> const a = 1</span><br><span class="line"><span class="built_in">export</span> const b = 2</span><br><span class="line">// index.js</span><br><span class="line">import &#123; a &#125; from <span class="string">'./test.js'</span></span><br></pre></td></tr></table></figure><p>对于以上情况，test 文件中的变量 b 如果没有在项目中使用到的话，就不会被打包到文件中。</p><p>如果你使用 Webpack 4 的话，开启生产环境就会自动启动这个优化功能。</p>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue_data</title>
      <link href="/2018/09/11/vue-data/"/>
      <url>/2018/09/11/vue-data/</url>
      
        <content type="html"><![CDATA[<h3 id="组件中-data-什么时候可以使用对象"><a href="#组件中-data-什么时候可以使用对象" class="headerlink" title="组件中 data 什么时候可以使用对象"></a>组件中 data 什么时候可以使用对象</h3><p>组件复用时所有组件实例都会共享  data，如果  data  是对象的话，就会造成一个组件修改  data  以后会影响到其他所有组件，所以需要将  data  写成函数，每次用到就调用一次函数获得新的数据。</p><p>当我们使用  new Vue()  的方式的时候，无论我们将  data  设置为对象还是函数都是可以的，因为  new Vue()  的方式是生成一个根组件，该组件不会复用，也就不存在共享  data  的情况了。</p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue_keep-alive</title>
      <link href="/2018/06/16/vue-keep-alive/"/>
      <url>/2018/06/16/vue-keep-alive/</url>
      
        <content type="html"><![CDATA[<h3 id="keep-alive-组件有什么作用"><a href="#keep-alive-组件有什么作用" class="headerlink" title="keep-alive 组件有什么作用"></a>keep-alive 组件有什么作用</h3><p>如果你需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用  keep-alive  组件包裹需要保存的组件。</p><p>对于  keep-alive  组件来说，它拥有两个独有的生命周期钩子函数，分别为  activated  和  deactivated 。用  keep-alive  包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行  deactivated  钩子函数，命中缓存渲染后会执行  actived  钩子函数。</p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue_v-show_v-if</title>
      <link href="/2018/06/02/vue-v-show-v-if/"/>
      <url>/2018/06/02/vue-v-show-v-if/</url>
      
        <content type="html"><![CDATA[<h3 id="v-show-与-v-if-区别"><a href="#v-show-与-v-if-区别" class="headerlink" title="v-show 与 v-if 区别"></a>v-show 与 v-if 区别</h3><h4 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h4><p>v-show 只是在  display: none  和  display: block  之间切换。无论初始条件是什么都会被渲染出来，后面只需要切换 CSS，DOM 还是一直保留着的。所以总的来说  v-show  在初始渲染时有更高的开销，但是切换开销很小，更适合于频繁切换的场景。</p><h4 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h4><p>v-if 的话就得说到 Vue 底层的编译了。当属性初始为  false  时，组件就不会被渲染，直到条件为  true，并且切换条件时会触发销毁/挂载组件，所以总的来说在切换时开销更高，更适合不经常切换的场景。</p><p>并且基于  v-if  的这种惰性渲染机制，可以在必要的时候才去渲染组件，减少整个页面的初始渲染开销。</p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue_computed_watch</title>
      <link href="/2018/05/10/vue-computed-watch/"/>
      <url>/2018/05/10/vue-computed-watch/</url>
      
        <content type="html"><![CDATA[<h3 id="computed-和-watch-区别"><a href="#computed-和-watch-区别" class="headerlink" title="computed 和 watch 区别"></a>computed 和 watch 区别</h3><pre>computed  是计算属性，依赖其他属性计算值，并且  computed  的值有缓存，只有当计算值变化才会返回内容。watch  监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。</pre><p>所以一般来说需要依赖别的属性来动态获得值的时候可以使用  computed，对于监听到值的变化需要做一些复杂业务逻辑的情况可以使用  watch。</p><p>另外  computed  和  watch  还都支持对象的写法，这种方式知道的人并不多。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vm.<span class="variable">$watch</span>(<span class="string">'obj'</span>, &#123;</span><br><span class="line">    // 深度遍历</span><br><span class="line">    deep: <span class="literal">true</span>,</span><br><span class="line">    // 立即触发</span><br><span class="line">    immediate: <span class="literal">true</span>,</span><br><span class="line">    // 执行的函数</span><br><span class="line">    handler: <span class="keyword">function</span>(val, oldVal) &#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  data: &#123; a: 1 &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    aPlus: &#123;</span><br><span class="line">      // this.aPlus 时触发</span><br><span class="line">      get: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        <span class="built_in">return</span> this.a + 1</span><br><span class="line">      &#125;,</span><br><span class="line">      // this.aPlus = 1 时触发</span><br><span class="line">      <span class="built_in">set</span>: <span class="keyword">function</span> (v) &#123;</span><br><span class="line">        this.a = v - 1</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue_communication</title>
      <link href="/2018/04/08/vue-communication/"/>
      <url>/2018/04/08/vue-communication/</url>
      
        <content type="html"><![CDATA[<h3 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h3><p>组件通信一般分为以下几种情况：</p><pre>父子组件通信兄弟组件通信跨多层级组件通信任意组件</pre><p>对于以上每种情况都有多种方式去实现，接下来就来学习下如何实现。</p><h4 id="父子通信"><a href="#父子通信" class="headerlink" title="父子通信"></a>父子通信</h4><p>父组件通过  props  传递数据给子组件，子组件通过  emit  发送事件传递数据给父组件，这两种方式是最常用的父子通信实现办法。</p><p>这种父子通信方式也就是典型的单向数据流，父组件通过  props  传递数据，子组件不能直接修改  props， 而是必须通过发送事件的方式告知父组件修改数据。</p><p>另外这两种方式还可以使用语法糖  v-model  来直接实现，因为  v-model  默认会解析成名为  value  的  prop  和名为  input  的事件。这种语法糖的方式是典型的双向绑定，常用于 UI 控件上，但是究其根本，还是通过事件的方法让父组件修改数据。</p><p>当然我们还可以通过访问  $parent 或者 $children  对象来访问组件实例中的方法和数据。</p><p>另外如果你使用 Vue 2.3 及以上版本的话还可以使用  \$listeners  和  .sync  这两个属性。</p><pre>$listeners 属性会将父组件中的 (不含 .native 修饰器的) v-on 事件监听器传递给子组件，     子组件可以通过访问 $listeners  来自定义监听器。.sync  属性是个语法糖，可以很简单的实现子组件与父组件通信</pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--父组件中--&gt;</span><br><span class="line">&lt;input :value.sync=<span class="string">"value"</span> /&gt;</span><br><span class="line">&lt;!--以上写法等同于--&gt;</span><br><span class="line">&lt;input :value=<span class="string">"value"</span> @update:value=<span class="string">"v =&gt; value = v"</span>&gt;&lt;/comp&gt;</span><br><span class="line">&lt;!--子组件中--&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  this.<span class="variable">$emit</span>(<span class="string">'update:value'</span>, 1)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="兄弟组件通信"><a href="#兄弟组件通信" class="headerlink" title="兄弟组件通信"></a>兄弟组件通信</h4><p>对于这种情况可以通过查找父组件中的子组件实现，也就是  this.$parent.$children，在  \$children 中可以通过组件  name  查询到需要的组件实例，然后进行通信。</p><h4 id="跨多层次组件通信"><a href="#跨多层次组件通信" class="headerlink" title="跨多层次组件通信"></a>跨多层次组件通信</h4><p>对于这种情况可以使用 Vue 2.2 新增的 API provide / inject，虽然文档中不推荐直接使用在业务中，但是如果用得好的话还是很有用的。</p><p>假设有父组件 A，然后有一个跨多层级的子组件 B</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 父组件 A</span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  provide: &#123;</span><br><span class="line">    data: 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 子组件 B</span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  inject: [<span class="string">'data'</span>],</span><br><span class="line">  <span class="function"><span class="title">mounted</span></span>() &#123;</span><br><span class="line">    // 无论跨几层都能获得父组件的 data 属性</span><br><span class="line">    console.log(this.data) // =&gt; 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="任意组件"><a href="#任意组件" class="headerlink" title="任意组件"></a>任意组件</h4><p>这种方式可以通过 Vuex 或者 Event Bus 解决，另外如果你不怕麻烦的话，可以使用这种方式解决上述所有的通信情况</p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue_mixin_mixins</title>
      <link href="/2018/04/02/vue-mixin-mixins/"/>
      <url>/2018/04/02/vue-mixin-mixins/</url>
      
        <content type="html"><![CDATA[<h3 id="mixin-和-mixins-区别"><a href="#mixin-和-mixins-区别" class="headerlink" title="mixin 和 mixins 区别"></a>mixin 和 mixins 区别</h3><p>mixin  用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.mixin(&#123;</span><br><span class="line">    <span class="function"><span class="title">beforeCreate</span></span>() &#123;</span><br><span class="line">        // ...逻辑</span><br><span class="line">        // 这种方式会影响到每个组件的 beforeCreate 钩子函数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>虽然文档不建议我们在应用中直接使用  mixin，但是如果不滥用的话也是很有帮助的，比如可以全局混入封装好的  ajax  或者一些工具函数等等。</p><p>mixins  应该是我们最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过  mixins  混入代码，比如上拉下拉加载数据这种逻辑等等。</p><p>另外需要注意的是  mixins  混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并，具体可以阅读   文档。</p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react_lifecycle</title>
      <link href="/2018/03/27/react-lifecycle/"/>
      <url>/2018/03/27/react-lifecycle/</url>
      
        <content type="html"><![CDATA[<h3 id="React-组件生命周期"><a href="#React-组件生命周期" class="headerlink" title="React 组件生命周期"></a>React 组件生命周期</h3><p>组件的生命周期可分成三个状态：</p><pre>Mounting：已插入真实 DOMUpdating：正在被重新渲染Unmounting：已移出真实 DOM</pre><h4 id="生命周期的方法有："><a href="#生命周期的方法有：" class="headerlink" title="生命周期的方法有："></a>生命周期的方法有：</h4><h5 id="componentWillMount"><a href="#componentWillMount" class="headerlink" title="componentWillMount"></a>componentWillMount</h5><p>在渲染前调用,在客户端也在服务端。</p><h5 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a>componentDidMount</h5><p>在第一次渲染后调用，只在客户端。之后组件已经生成了对应的 DOM 结构，可以通过 this.getDOMNode()来进行访问。 如果你想和其他 JavaScript 框架一起使用，可以在这个方法中调用 setTimeout, setInterval 或者发送 AJAX 请求等操作(防止异步操作阻塞 UI)。</p><h5 id="componentWillReceiveProps"><a href="#componentWillReceiveProps" class="headerlink" title="componentWillReceiveProps"></a>componentWillReceiveProps</h5><p>在组件接收到一个新的 prop (更新后)时被调用。这个方法在初始化 render 时不会被调用。</p><h5 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h5><p>返回一个布尔值。在组件接收到新的 props 或者 state 时被调用。在初始化时或者使用 forceUpdate 时不被调用。<br>可以在你确认不需要更新组件时使用。</p><h5 id="componentWillUpdate"><a href="#componentWillUpdate" class="headerlink" title="componentWillUpdate"></a>componentWillUpdate</h5><p>在组件接收到新的 props 或者 state 但还没有 render 时被调用。在初始化时不会被调用。</p><h5 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate"></a>componentDidUpdate</h5><p>在组件完成更新后立即调用。在初始化时不会被调用。</p><h5 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount"></a>componentWillUnmount</h5><p>在组件从 DOM 中移除之前立刻被调用。</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>以下实例在 Hello 组件加载以后，通过 componentDidMount 方法设置一个定时器，每隔 100 毫秒重新设置组件的透明度，并重新渲染：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Hello extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">      super(props);</span><br><span class="line">      this.state = &#123;opacity: 1.0&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span></span>() &#123;</span><br><span class="line">    this.timer = setInterval(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">      var opacity = this.state.opacity;</span><br><span class="line">      opacity -= .05;</span><br><span class="line">      <span class="keyword">if</span> (opacity &lt; 0.1) &#123;</span><br><span class="line">        opacity = 1.0;</span><br><span class="line">      &#125;</span><br><span class="line">      this.setState(&#123;</span><br><span class="line">        opacity: opacity</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;.<span class="built_in">bind</span>(this), 100);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span></span> () &#123;</span><br><span class="line">    <span class="built_in">return</span> (</span><br><span class="line">      &lt;div style=&#123;&#123;opacity: this.state.opacity&#125;&#125;&gt;</span><br><span class="line">        Hello &#123;this.props.name&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Hello name=<span class="string">"world"</span>/&gt;,</span><br><span class="line">  document.body</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>以下实例初始化 state ， setNewnumber 用于更新 state。所有生命周期在 Content 组件中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">class Button extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">      super(props);</span><br><span class="line">      this.state = &#123;data: 0&#125;;</span><br><span class="line">      this.setNewNumber = this.setNewNumber.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">setNewNumber</span></span>() &#123;</span><br><span class="line">    this.setState(&#123;data: this.state.data + 1&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">      <span class="built_in">return</span> (</span><br><span class="line">         &lt;div&gt;</span><br><span class="line">            &lt;button onClick = &#123;this.setNewNumber&#125;&gt;INCREMENT&lt;/button&gt;</span><br><span class="line">            &lt;Content myNumber = &#123;this.state.data&#125;&gt;&lt;/Content&gt;</span><br><span class="line">         &lt;/div&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Content extends React.Component &#123;</span><br><span class="line">  <span class="function"><span class="title">componentWillMount</span></span>() &#123;</span><br><span class="line">      console.log(<span class="string">'Component WILL MOUNT!'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span></span>() &#123;</span><br><span class="line">       console.log(<span class="string">'Component DID MOUNT!'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  componentWillReceiveProps(newProps) &#123;</span><br><span class="line">        console.log(<span class="string">'Component WILL RECEIVE PROPS!'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  shouldComponentUpdate(newProps, newState) &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  componentWillUpdate(nextProps, nextState) &#123;</span><br><span class="line">        console.log(<span class="string">'Component WILL UPDATE!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidUpdate(prevProps, prevState) &#123;</span><br><span class="line">        console.log(<span class="string">'Component DID UPDATE!'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">componentWillUnmount</span></span>() &#123;</span><br><span class="line">         console.log(<span class="string">'Component WILL UNMOUNT!'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">      <span class="built_in">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;h3&gt;&#123;this.props.myNumber&#125;&lt;/h3&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">   &lt;div&gt;</span><br><span class="line">      &lt;Button /&gt;</span><br><span class="line">   &lt;/div&gt;,</span><br><span class="line">  document.getElementById(<span class="string">'example'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue_lifecycle</title>
      <link href="/2018/03/26/vue-lifecycle/"/>
      <url>/2018/03/26/vue-lifecycle/</url>
      
        <content type="html"><![CDATA[<h3 id="生命周期钩子函数"><a href="#生命周期钩子函数" class="headerlink" title="生命周期钩子函数"></a>生命周期钩子函数</h3><p>在  beforeCreate  钩子函数调用的时候，是获取不到  props  或者  data  中的数据的，因为这些数据的初始化都在  initState  中。</p><p>然后会执行  created  钩子函数，在这一步的时候已经可以访问到之前不能访问到的数据，但是这时候组件还没被挂载，所以是看不到的。</p><p>接下来会先执行  beforeMount  钩子函数，开始创建 VDOM，最后执行  mounted  钩子，并将 VDOM 渲染为真实 DOM 并且渲染数据。组件中如果有子组件的话，会递归挂载子组件，只有当所有子组件全部挂载完毕，才会执行根组件的挂载钩子。</p><p>接下来是数据更新时会调用的钩子函数  beforeUpdate  和  updated，这两个钩子函数没什么好说的，就是分别在数据更新前和更新后会调用。</p><p>另外还有  keep-alive  独有的生命周期，分别为  activated  和  deactivated 。用  keep-alive  包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行  deactivated  钩子函数，命中缓存渲染后会执行  actived  钩子函数。</p><p>最后就是销毁组件的钩子函数  beforeDestroy  和  destroyed。前者适合移除事件、定时器等等，否则可能会引起内存泄露的问题。然后进行一系列的销毁操作，如果有子组件的话，也会递归销毁子组件，所有子组件都销毁完毕后才会执行根组件的  destroyed  钩子函数。</p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>REACT_组件通信</title>
      <link href="/2018/03/25/react_fscom/"/>
      <url>/2018/03/25/react_fscom/</url>
      
        <content type="html"><![CDATA[<h3 id="父子组件通信"><a href="#父子组件通信" class="headerlink" title="父子组件通信"></a>父子组件通信</h3><p>父组件通过  props  传递数据给子组件，子组件通过调用父组件传来的函数传递数据给父组件，这两种方式是最常用的父子通信实现办法。这种父子通信方式也就是典型的单向数据流，父组件通过  props  传递数据，子组件不能直接修改  props， 而是必须通过调用父组件函数的方式告知父组件修改数据。</p><h3 id="兄弟组件通信"><a href="#兄弟组件通信" class="headerlink" title="兄弟组件通信"></a>兄弟组件通信</h3><p>对于这种情况可以通过共同的父组件来管理状态和事件函数。比如说其中一个兄弟组件调用父组件传递过来的事件函数修改父组件中的状态，然后父组件将状态传递给另一个兄弟组件。</p><h3 id="跨多层次组件通信"><a href="#跨多层次组件通信" class="headerlink" title="跨多层次组件通信"></a>跨多层次组件通信</h3><p>如果你使用 16.3 以上版本的话，对于这种情况可以使用 Context API。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 创建 Context，可以在开始就传入值</span><br><span class="line">const StateContext = React.createContext()</span><br><span class="line">class Parent extends React.Component &#123;</span><br><span class="line">  <span class="function"><span class="title">render</span></span> () &#123;</span><br><span class="line">    <span class="built_in">return</span> (</span><br><span class="line">      // value 就是传入 Context 中的值</span><br><span class="line">      &lt;StateContext.Provider value=<span class="string">'yck'</span>&gt;</span><br><span class="line">        &lt;Child /&gt;</span><br><span class="line">      &lt;/StateContext.Provider&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Child extends React.Component &#123;</span><br><span class="line">  <span class="function"><span class="title">render</span></span> () &#123;</span><br><span class="line">    <span class="built_in">return</span> (</span><br><span class="line">      &lt;ThemeContext.Consumer&gt;</span><br><span class="line">        // 取出值</span><br><span class="line">        &#123;context =&gt; (</span><br><span class="line">          name is &#123; context &#125;</span><br><span class="line">        )&#125;</span><br><span class="line">      &lt;/ThemeContext.Consumer&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>REACT_setState</title>
      <link href="/2018/03/22/react_setStarte/"/>
      <url>/2018/03/22/react_setStarte/</url>
      
        <content type="html"><![CDATA[<h3 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h3><p>setState 在 React 中是经常使用的一个 API，但是它存在一些的问题经常会导致初学者出错，核心原因就是因为这个 API 是异步的。首先  setState  的调用并不会马上引起  state  的改变，并且如果你一次调用了多个  setState ，那么结果可能并不如你期待的一样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">handle</span></span>() &#123;</span><br><span class="line">  // 初始化 `count` 为 0</span><br><span class="line">  console.log(this.state.count) // -&gt; 0</span><br><span class="line">  this.setState(&#123; count: this.state.count + 1 &#125;)</span><br><span class="line">  this.setState(&#123; count: this.state.count + 1 &#125;)</span><br><span class="line">  this.setState(&#123; count: this.state.count + 1 &#125;)</span><br><span class="line">  console.log(this.state.count) // -&gt; 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一，两次的打印都为 0，因为  setState  是个异步 API，只有同步代码运行完毕才会执行。setState  异步的原因我认为在于，setState  可能会导致 DOM 的重绘，如果调用一次就马上去进行重绘，那么调用多次就会造成不必要的性能损失。设计成异步的话，就可以将多次调用放入一个队列中，在恰当的时候统一进行更新过程。</p><p>第二，虽然调用了三次  setState ，但是  count  的值还是为 1。因为多次调用会合并为一次，只有当更新结束后  state  才会改变，三次调用等同于如下代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object.assign(</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  &#123; count: this.state.count + 1 &#125;,</span><br><span class="line">  &#123; count: this.state.count + 1 &#125;,</span><br><span class="line">  &#123; count: this.state.count + 1 &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>当然你也可以通过以下方式来实现调用三次  setState  使得  count  为 3</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">handle</span></span>() &#123;</span><br><span class="line">  this.setState((prevState) =&gt; (&#123; count: prevState.count + 1 &#125;))</span><br><span class="line">  this.setState((prevState) =&gt; (&#123; count: prevState.count + 1 &#125;))</span><br><span class="line">  this.setState((prevState) =&gt; (&#123; count: prevState.count + 1 &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你想在每次调用  setState  后获得正确的  state ，可以通过如下代码实现</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">handle</span></span>() &#123;</span><br><span class="line">    this.setState((prevState) =&gt; (&#123; count: prevState.count + 1 &#125;), () =&gt; &#123;</span><br><span class="line">        console.log(this.state)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react_Refs</title>
      <link href="/2018/01/05/react-Refs/"/>
      <url>/2018/01/05/react-Refs/</url>
      
        <content type="html"><![CDATA[<h3 id="React-Refs"><a href="#React-Refs" class="headerlink" title="React Refs"></a>React Refs</h3><p>React 支持一种非常特殊的属性 Ref ，你可以用来绑定到 render() 输出的任何组件上。</p><p>这个特殊的属性允许你引用 render() 返回的相应的支撑实例（ backing instance ）。这样就可以确保在任何时间总是拿到正确的实例。</p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>绑定一个 ref 属性到 render 的返回值上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input ref=<span class="string">"myInput"</span> /&gt;</span><br></pre></td></tr></table></figure><p>在其它代码中，通过 this.refs 获取支撑实例:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var input = this.refs.myInput;</span><br><span class="line">var inputValue = input.value;</span><br><span class="line">var inputRect = input.getBoundingClientRect();</span><br></pre></td></tr></table></figure><h4 id="完整实例"><a href="#完整实例" class="headerlink" title="完整实例"></a>完整实例</h4><p>你可以通过使用 this 来获取当前 React 组件，或使用 ref 来获取组件的引用，实例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class MyComponent extends React.Component &#123;</span><br><span class="line">  <span class="function"><span class="title">handleClick</span></span>() &#123;</span><br><span class="line">    // 使用原生的 DOM API 获取焦点</span><br><span class="line">    this.refs.myInput.focus();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">    //  当组件插入到 DOM 后，ref 属性添加一个组件的引用于到 this.refs</span><br><span class="line">    <span class="built_in">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> ref=<span class="string">"myInput"</span> /&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          <span class="built_in">type</span>=<span class="string">"button"</span></span><br><span class="line">          value=<span class="string">"点我输入框获取焦点"</span></span><br><span class="line">          onClick=&#123;this.handleClick.bind(this)&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;MyComponent /&gt;,</span><br><span class="line">  document.getElementById(<span class="string">'example'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
