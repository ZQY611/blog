<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>es6_Object</title>
      <link href="/2019/02/10/es6-Object/"/>
      <url>/2019/02/10/es6-Object/</url>
      
        <content type="html"><![CDATA[<h3 id="ES6-对象的扩展"><a href="#ES6-对象的扩展" class="headerlink" title="ES6 对象的扩展"></a>ES6 对象的扩展</h3><h4 id="属性的简洁表示法"><a href="#属性的简洁表示法" class="headerlink" title="属性的简洁表示法"></a>属性的简洁表示法</h4><p>ES6 允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var foo = <span class="string">'bar'</span>;</span><br><span class="line">var baz = &#123;foo&#125;;</span><br><span class="line">baz // &#123;foo: <span class="string">"bar"</span>&#125;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">var baz = &#123;foo: foo&#125;;</span><br></pre></td></tr></table></figure><p>上面代码表明，ES6 允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。下面是另一个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> f(x, y) &#123;</span><br><span class="line">  <span class="built_in">return</span> &#123;x, y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> f(x, y) &#123;</span><br><span class="line">  <span class="built_in">return</span> &#123;x: x, y: y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(1, 2) // Object &#123;x: 1, y: 2&#125;</span><br></pre></td></tr></table></figure><p>除了属性简写，方法也可以简写。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">  <span class="function"><span class="title">method</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">"Hello!"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line"></span><br><span class="line">var o = &#123;</span><br><span class="line">  method: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">"Hello!"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面是一个实际的例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var birth = <span class="string">'2000/01/01'</span>;</span><br><span class="line"></span><br><span class="line">var Person = &#123;</span><br><span class="line"></span><br><span class="line">  name: <span class="string">'张三'</span>,</span><br><span class="line"></span><br><span class="line">  //等同于birth: birth</span><br><span class="line">  birth,</span><br><span class="line"></span><br><span class="line">  // 等同于hello: <span class="keyword">function</span> ()...</span><br><span class="line">  <span class="function"><span class="title">hello</span></span>() &#123; console.log(<span class="string">'我的名字是'</span>, this.name); &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种写法用于函数的返回值，将会非常方便。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">getPoint</span></span>() &#123;</span><br><span class="line">  var x = 1;</span><br><span class="line">  var y = 10;</span><br><span class="line">  <span class="built_in">return</span> &#123;x, y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getPoint()</span><br><span class="line">// &#123;x:1, y:10&#125;</span><br></pre></td></tr></table></figure><p>CommonJS 模块输出变量，就非常合适使用简洁写法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var ms = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> getItem (key) &#123;</span><br><span class="line">  <span class="built_in">return</span> key <span class="keyword">in</span> ms ? ms[key] : null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> setItem (key, value) &#123;</span><br><span class="line">  ms[key] = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">clear</span></span> () &#123;</span><br><span class="line">  ms = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = &#123; getItem, setItem, clear &#125;;</span><br><span class="line">// 等同于</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  getItem: getItem,</span><br><span class="line">  setItem: setItem,</span><br><span class="line">  clear: clear</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>属性的赋值器（setter）和取值器（getter），事实上也是采用这种写法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var cart = &#123;</span><br><span class="line">  _wheels: 4,</span><br><span class="line"></span><br><span class="line">  get <span class="function"><span class="title">wheels</span></span> () &#123;</span><br><span class="line">    <span class="built_in">return</span> this._wheels;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="built_in">set</span> wheels (value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; this._wheels) &#123;</span><br><span class="line">      throw new Error(<span class="string">'数值太小了！'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    this._wheels = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，简洁写法的属性名总是字符串，这会导致一些看上去比较奇怪的结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  <span class="function"><span class="title">class</span></span> () &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">  <span class="string">'class'</span>: <span class="function"><span class="title">function</span></span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，class 是字符串，所以不会因为它属于关键字，而导致语法解析报错。</p><p>如果某个方法的值是一个 Generator 函数，前面需要加上星号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  * <span class="function"><span class="title">m</span></span>()&#123;</span><br><span class="line">    yield <span class="string">'hello world'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="属性名表达式"><a href="#属性名表达式" class="headerlink" title="属性名表达式"></a>属性名表达式</h4><p>JavaScript 语言定义对象的属性，有两种方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 方法一</span><br><span class="line">obj.foo = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">// 方法二</span><br><span class="line">obj[<span class="string">'a'</span> + <span class="string">'bc'</span>] = 123;</span><br></pre></td></tr></table></figure><p>上面代码的方法一是直接用标识符作为属性名，方法二是用表达式作为属性名，这时要将表达式放在方括号之内。</p><p>但是，如果使用字面量方式定义对象（使用大括号），在 ES5 中只能使用方法一（标识符）定义属性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  foo: <span class="literal">true</span>,</span><br><span class="line">  abc: 123</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>ES6 允许字面量定义对象时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> propKey = <span class="string">'foo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> obj = &#123;</span><br><span class="line">  [propKey]: <span class="literal">true</span>,</span><br><span class="line">  [<span class="string">'a'</span> + <span class="string">'bc'</span>]: 123</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面是另一个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var lastWord = <span class="string">'last word'</span>;</span><br><span class="line"></span><br><span class="line">var a = &#123;</span><br><span class="line">  <span class="string">'first word'</span>: <span class="string">'hello'</span>,</span><br><span class="line">  [lastWord]: <span class="string">'world'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a[<span class="string">'first word'</span>] // <span class="string">"hello"</span></span><br><span class="line">a[lastWord] // <span class="string">"world"</span></span><br><span class="line">a[<span class="string">'last word'</span>] // <span class="string">"world"</span></span><br></pre></td></tr></table></figure><p>表达式还可以用于定义方法名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> obj = &#123;</span><br><span class="line">  [<span class="string">'h'</span> + <span class="string">'ello'</span>]() &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">'hi'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.hello() // hi</span><br></pre></td></tr></table></figure><p>注意，属性名表达式与简洁表示法，不能同时使用，会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line">var foo = <span class="string">'bar'</span>;</span><br><span class="line">var bar = <span class="string">'abc'</span>;</span><br><span class="line">var baz = &#123; [foo] &#125;;</span><br><span class="line"></span><br><span class="line">// 正确</span><br><span class="line">var foo = <span class="string">'bar'</span>;</span><br><span class="line">var baz = &#123; [foo]: <span class="string">'abc'</span>&#125;;</span><br></pre></td></tr></table></figure><p>注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]，这一点要特别小心。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const keyA = &#123;a: 1&#125;;</span><br><span class="line">const keyB = &#123;b: 2&#125;;</span><br><span class="line"></span><br><span class="line">const myObject = &#123;</span><br><span class="line">  [keyA]: <span class="string">'valueA'</span>,</span><br><span class="line">  [keyB]: <span class="string">'valueB'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myObject // Object &#123;[object Object]: <span class="string">"valueB"</span>&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，[keyA]和[keyB]得到的都是[object Object]，所以[keyB]会把[keyA]覆盖掉，而 myObject 最后只有一个[object Object]属性。</p><h4 id="方法的-name-属性"><a href="#方法的-name-属性" class="headerlink" title="方法的 name 属性"></a>方法的 name 属性</h4><p>函数的 name 属性，返回函数名。对象方法也是函数，因此也有 name 属性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">  <span class="function"><span class="title">sayName</span></span>() &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;,</span><br><span class="line">  get <span class="function"><span class="title">firstName</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">"Nicholas"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.sayName.name   // <span class="string">"sayName"</span></span><br><span class="line">person.firstName.name // <span class="string">"get firstName"</span></span><br></pre></td></tr></table></figure><p>上面代码中，方法的 name 属性返回函数名（即方法名）。如果使用了取值函数，则会在方法名前加上 get。如果是存值函数，方法名的前面会加上 set。</p><p>有两种特殊情况：bind 方法创造的函数，name 属性返回“bound”加上原函数的名字；Function 构造函数创造的函数，name 属性返回“anonymous”。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(new Function()).name // <span class="string">"anonymous"</span></span><br><span class="line"></span><br><span class="line">var doSomething = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;;</span><br><span class="line">doSomething.bind().name // <span class="string">"bound doSomething"</span></span><br></pre></td></tr></table></figure><p>如果对象的方法是一个 Symbol 值，那么 name 属性返回的是这个 Symbol 值的描述。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const key1 = Symbol(<span class="string">'description'</span>);</span><br><span class="line">const key2 = Symbol();</span><br><span class="line"><span class="built_in">let</span> obj = &#123;</span><br><span class="line">  [key1]() &#123;&#125;,</span><br><span class="line">  [key2]() &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">obj[key1].name // <span class="string">"[description]"</span></span><br><span class="line">obj[key2].name // <span class="string">""</span></span><br></pre></td></tr></table></figure><p>上面代码中，key1 对应的 Symbol 值有描述，key2 没有。</p><h4 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h4><p>ES5 比较两个值是否相等，只有两个运算符：相等运算符（==）和严格相等运算符（===）。它们都有缺点，前者会自动转换数据类型，后者的 NaN 不等于自身，以及+0 等于-0。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。</p><p>ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。Object.is 就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object.is(<span class="string">'foo'</span>, <span class="string">'foo'</span>)</span><br><span class="line">// <span class="literal">true</span></span><br><span class="line">Object.is(&#123;&#125;, &#123;&#125;)</span><br><span class="line">// <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>不同之处只有两个：一是+0 不等于-0，二是 NaN 等于自身。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+0 === -0 //<span class="literal">true</span></span><br><span class="line">NaN === NaN // <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">Object.is(+0, -0) // <span class="literal">false</span></span><br><span class="line">Object.is(NaN, NaN) // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>ES5 可以通过下面的代码，部署 Object.is。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty(Object, <span class="string">'is'</span>, &#123;</span><br><span class="line">  value: <span class="keyword">function</span>(x, y) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x === y) &#123;</span><br><span class="line">      // 针对+0 不等于 -0的情况</span><br><span class="line">      <span class="built_in">return</span> x !== 0 || 1 / x === 1 / y;</span><br><span class="line">    &#125;</span><br><span class="line">    // 针对NaN的情况</span><br><span class="line">    <span class="built_in">return</span> x !== x &amp;&amp; y !== y;</span><br><span class="line">  &#125;,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">  writable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h4><h5 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h5><p>Object.assign 方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var target = &#123; a: 1 &#125;;</span><br><span class="line"></span><br><span class="line">var source1 = &#123; b: 2 &#125;;</span><br><span class="line">var source2 = &#123; c: 3 &#125;;</span><br><span class="line"></span><br><span class="line">Object.assign(target, source1, source2);</span><br><span class="line">target // &#123;a:1, b:2, c:3&#125;</span><br></pre></td></tr></table></figure><p>Object.assign 方法的第一个参数是目标对象，后面的参数都是源对象。</p><p>注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var target = &#123; a: 1, b: 1 &#125;;</span><br><span class="line"></span><br><span class="line">var source1 = &#123; b: 2, c: 2 &#125;;</span><br><span class="line">var source2 = &#123; c: 3 &#125;;</span><br><span class="line"></span><br><span class="line">Object.assign(target, source1, source2);</span><br><span class="line">target // &#123;a:1, b:2, c:3&#125;</span><br></pre></td></tr></table></figure><p>如果只有一个参数，Object.assign 会直接返回该参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;a: 1&#125;;</span><br><span class="line">Object.assign(obj) === obj // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>如果该参数不是对象，则会先转成对象，然后返回。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeof Object.assign(2) // <span class="string">"object"</span></span><br></pre></td></tr></table></figure><p>由于 undefined 和 null 无法转成对象，所以如果它们作为参数，就会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.assign(undefined) // 报错</span><br><span class="line">Object.assign(null) // 报错</span><br></pre></td></tr></table></figure><p>如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果 undefined 和 null 不在首参数，就不会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> obj = &#123;a: 1&#125;;</span><br><span class="line">Object.assign(obj, undefined) === obj // <span class="literal">true</span></span><br><span class="line">Object.assign(obj, null) === obj // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var v1 = <span class="string">'abc'</span>;</span><br><span class="line">var v2 = <span class="literal">true</span>;</span><br><span class="line">var v3 = 10;</span><br><span class="line"></span><br><span class="line">var obj = Object.assign(&#123;&#125;, v1, v2, v3);</span><br><span class="line">console.log(obj); // &#123; <span class="string">"0"</span>: <span class="string">"a"</span>, <span class="string">"1"</span>: <span class="string">"b"</span>, <span class="string">"2"</span>: <span class="string">"c"</span> &#125;</span><br></pre></td></tr></table></figure><p>上面代码中，v1、v2、v3 分别是字符串、布尔值和数值，结果只有字符串合入目标对象（以字符数组的形式），数值和布尔值都会被忽略。这是因为只有字符串的包装对象，会产生可枚举属性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object(<span class="literal">true</span>) // &#123;[[PrimitiveValue]]: <span class="literal">true</span>&#125;</span><br><span class="line">Object(10)  //  &#123;[[PrimitiveValue]]: 10&#125;</span><br><span class="line">Object(<span class="string">'abc'</span>) // &#123;0: <span class="string">"a"</span>, 1: <span class="string">"b"</span>, 2: <span class="string">"c"</span>, length: 3, [[PrimitiveValue]]: <span class="string">"abc"</span>&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，布尔值、数值、字符串分别转成对应的包装对象，可以看到它们的原始值都在包装对象的内部属性[[PrimitiveValue]]上面，这个属性是不会被 Object.assign 拷贝的。只有字符串的包装对象，会产生可枚举的实义属性，那些属性则会被拷贝。</p><p>Object.assign 拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Object.assign(&#123;b: <span class="string">'c'</span>&#125;,</span><br><span class="line">  Object.defineProperty(&#123;&#125;, <span class="string">'invisible'</span>, &#123;</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    value: <span class="string">'hello'</span></span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br><span class="line">// &#123; b: <span class="string">'c'</span> &#125;</span><br></pre></td></tr></table></figure><p>上面代码中，Object.assign 要拷贝的对象只有一个不可枚举属性 invisible，这个属性并没有被拷贝进去。</p><p>属性名为 Symbol 值的属性，也会被 Object.assign 拷贝。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.assign(&#123; a: <span class="string">'b'</span> &#125;, &#123; [Symbol(<span class="string">'c'</span>)]: <span class="string">'d'</span> &#125;)</span><br><span class="line">// &#123; a: <span class="string">'b'</span>, Symbol(c): <span class="string">'d'</span> &#125;</span><br></pre></td></tr></table></figure><h5 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h5><p>Object.assign 方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = &#123;a: &#123;b: 1&#125;&#125;;</span><br><span class="line">var obj2 = Object.assign(&#123;&#125;, obj1);</span><br><span class="line"></span><br><span class="line">obj1.a.b = 2;</span><br><span class="line">obj2.a.b // 2</span><br></pre></td></tr></table></figure><p>上面代码中，源对象 obj1 的 a 属性的值是一个对象，Object.assign 拷贝得到的是这个对象的引用。这个对象的任何变化，都会反映到目标对象上面。</p><p>对于这种嵌套的对象，一旦遇到同名属性，Object.assign 的处理方法是替换，而不是添加。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var target = &#123; a: &#123; b: <span class="string">'c'</span>, d: <span class="string">'e'</span> &#125; &#125;</span><br><span class="line">var <span class="built_in">source</span> = &#123; a: &#123; b: <span class="string">'hello'</span> &#125; &#125;</span><br><span class="line">Object.assign(target, <span class="built_in">source</span>)</span><br><span class="line">// &#123; a: &#123; b: <span class="string">'hello'</span> &#125; &#125;</span><br></pre></td></tr></table></figure><p>上面代码中，target 对象的 a 属性被 source 对象的 a 属性整个替换掉了，而不会得到{ a: { b: ‘hello’, d: ‘e’ } }的结果。这通常不是开发者想要的，需要特别小心。</p><p>有一些函数库提供 Object.assign 的定制版本（比如 Lodash 的_.defaultsDeep 方法），可以解决浅拷贝的问题，得到深拷贝的合并。</p><p>注意，Object.assign 可以用来处理数组，但是会把数组视为对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.assign([1, 2, 3], [4, 5])</span><br><span class="line">// [4, 5, 3]</span><br></pre></td></tr></table></figure><p>上面代码中，Object.assign 把数组视为属性名为 0、1、2 的对象，因此目标数组的 0 号属性 4 覆盖了原数组的 0 号属性 1。</p><h5 id="常见用途"><a href="#常见用途" class="headerlink" title="常见用途"></a>常见用途</h5><p>Object.assign 方法有很多用处。</p><h6 id="为对象添加属性"><a href="#为对象添加属性" class="headerlink" title="为对象添加属性"></a>为对象添加属性</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  constructor(x, y) &#123;</span><br><span class="line">    Object.assign(this, &#123;x, y&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面方法通过 Object.assign 方法，将 x 属性和 y 属性添加到 Point 类的对象实例。</p><h6 id="为对象添加方法"><a href="#为对象添加方法" class="headerlink" title="为对象添加方法"></a>为对象添加方法</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Object.assign(SomeClass.prototype, &#123;</span><br><span class="line">  someMethod(arg1, arg2) &#123;</span><br><span class="line">    ···</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">anotherMethod</span></span>() &#123;</span><br><span class="line">    ···</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 等同于下面的写法</span><br><span class="line">SomeClass.prototype.someMethod = <span class="keyword">function</span> (arg1, arg2) &#123;</span><br><span class="line">  ···</span><br><span class="line">&#125;;</span><br><span class="line">SomeClass.prototype.anotherMethod = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  ···</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码使用了对象属性的简洁表示法，直接将两个函数放在大括号中，再使用 assign 方法添加到 SomeClass.prototype 之中。</p><h6 id="克隆对象"><a href="#克隆对象" class="headerlink" title="克隆对象"></a>克隆对象</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="built_in">clone</span>(origin) &#123;</span><br><span class="line">  <span class="built_in">return</span> Object.assign(&#123;&#125;, origin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆。</p><p>不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="built_in">clone</span>(origin) &#123;</span><br><span class="line">  <span class="built_in">let</span> originProto = Object.getPrototypeOf(origin);</span><br><span class="line">  <span class="built_in">return</span> Object.assign(Object.create(originProto), origin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="合并多个对象"><a href="#合并多个对象" class="headerlink" title="合并多个对象"></a>合并多个对象</h6><p>将多个对象合并到某个对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const merge =</span><br><span class="line">  (target, ...sources) =&gt; Object.assign(target, ...sources);</span><br></pre></td></tr></table></figure><p>如果希望合并后返回一个新对象，可以改写上面函数，对一个空对象合并。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const merge =</span><br><span class="line">  (...sources) =&gt; Object.assign(&#123;&#125;, ...sources);</span><br></pre></td></tr></table></figure><h6 id="为属性指定默认值"><a href="#为属性指定默认值" class="headerlink" title="为属性指定默认值"></a>为属性指定默认值</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const DEFAULTS = &#123;</span><br><span class="line">  logLevel: 0,</span><br><span class="line">  outputFormat: <span class="string">'html'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> processContent(options) &#123;</span><br><span class="line">  options = Object.assign(&#123;&#125;, DEFAULTS, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，DEFAULTS 对象是默认值，options 对象是用户提供的参数。Object.assign 方法将 DEFAULTS 和 options 合并成一个新对象，如果两者有同名属性，则 option 的属性值会覆盖 DEFAULTS 的属性值。</p><p>注意，由于存在深拷贝的问题，DEFAULTS 对象和 options 对象的所有属性的值，都只能是简单类型，而不能指向另一个对象。否则，将导致 DEFAULTS 对象的该属性不起作用。</p><h5 id="属性的可枚举性"><a href="#属性的可枚举性" class="headerlink" title="属性的可枚举性"></a>属性的可枚举性</h5><p>对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。Object.getOwnPropertyDescriptor 方法可以获取该属性的描述对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> obj = &#123; foo: 123 &#125;;</span><br><span class="line">Object.getOwnPropertyDescriptor(obj, <span class="string">'foo'</span>)</span><br><span class="line">//  &#123;</span><br><span class="line">//    value: 123,</span><br><span class="line">//    writable: <span class="literal">true</span>,</span><br><span class="line">//    enumerable: <span class="literal">true</span>,</span><br><span class="line">//    configurable: <span class="literal">true</span></span><br><span class="line">//  &#125;</span><br></pre></td></tr></table></figure><p>描述对象的 enumerable 属性，称为”可枚举性“，如果该属性为 false，就表示某些操作会忽略当前属性。</p><p>ES5 有三个操作会忽略 enumerable 为 false 的属性。</p><p>1.for…in 循环：只遍历对象自身的和继承的可枚举的属性<br>2.Object.keys()：返回对象自身的所有可枚举的属性的键名<br>3.JSON.stringify()：只串行化对象自身的可枚举的属性<br>ES6 新增了一个操作 Object.assign()，会忽略 enumerable 为 false 的属性，只拷贝对象自身的可枚举的属性。</p><p>这四个操作之中，只有 for…in 会返回继承的属性。实际上，引入 enumerable 的最初目的，就是让某些属性可以规避掉 for…in 操作。比如，对象原型的 toString 方法，以及数组的 length 属性，就通过这种手段，不会被 for…in 遍历到。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object.getOwnPropertyDescriptor(Object.prototype, <span class="string">'toString'</span>).enumerable</span><br><span class="line">// <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">Object.getOwnPropertyDescriptor([], <span class="string">'length'</span>).enumerable</span><br><span class="line">// <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>上面代码中，toString 和 length 属性的 enumerable 都是 false，因此 for…in 不会遍历到这两个继承自原型的属性。</p><p>另外，ES6 规定，所有 Class 的原型的方法都是不可枚举的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.getOwnPropertyDescriptor(class &#123;<span class="function"><span class="title">foo</span></span>() &#123;&#125;&#125;.prototype, <span class="string">'foo'</span>).enumerable</span><br><span class="line">// <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>总的来说，操作中引入继承的属性会让问题复杂化，大多数时候，我们只关心对象自身的属性。所以，尽量不要用 for…in 循环，而用 Object.keys()代替。</p><h5 id="属性的遍历"><a href="#属性的遍历" class="headerlink" title="属性的遍历"></a>属性的遍历</h5><p>ES6 一共有 5 种方法可以遍历对象的属性。</p><h6 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h6><p>for…in 循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。</p><h6 id="Object-keys-obj"><a href="#Object-keys-obj" class="headerlink" title="Object.keys(obj)"></a>Object.keys(obj)</h6><p>Object.keys 返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）。</p><h6 id="Object-getOwnPropertyNames-obj"><a href="#Object-getOwnPropertyNames-obj" class="headerlink" title="Object.getOwnPropertyNames(obj)"></a>Object.getOwnPropertyNames(obj)</h6><p>Object.getOwnPropertyNames 返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）。</p><h6 id="Object-getOwnPropertySymbols-obj"><a href="#Object-getOwnPropertySymbols-obj" class="headerlink" title="Object.getOwnPropertySymbols(obj)"></a>Object.getOwnPropertySymbols(obj)</h6><p>Object.getOwnPropertySymbols 返回一个数组，包含对象自身的所有 Symbol 属性。</p><h6 id="Reflect-ownKeys-obj"><a href="#Reflect-ownKeys-obj" class="headerlink" title="Reflect.ownKeys(obj)"></a>Reflect.ownKeys(obj)</h6><p>Reflect.ownKeys 返回一个数组，包含对象自身的所有属性，不管是属性名是 Symbol 或字符串，也不管是否可枚举。</p><p>以上的 5 种方法遍历对象的属性，都遵守同样的属性遍历的次序规则。</p><p>首先遍历所有属性名为数值的属性，按照数字排序。<br>其次遍历所有属性名为字符串的属性，按照生成时间排序。<br>最后遍历所有属性名为 Symbol 值的属性，按照生成时间排序。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Reflect.ownKeys(&#123; [Symbol()]:0, b:0, 10:0, 2:0, a:0 &#125;)</span><br><span class="line">// [<span class="string">'2'</span>, <span class="string">'10'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>, Symbol()]</span><br></pre></td></tr></table></figure><p>上面代码中，Reflect.ownKeys 方法返回一个数组，包含了参数对象的所有属性。这个数组的属性次序是这样的，首先是数值属性 2 和 10，其次是字符串属性 b 和 a，最后是 Symbol 属性。</p><h5 id="proto属性，Object-setPrototypeOf-，Object-getPrototypeOf"><a href="#proto属性，Object-setPrototypeOf-，Object-getPrototypeOf" class="headerlink" title="proto属性，Object.setPrototypeOf()，Object.getPrototypeOf()"></a><strong>proto</strong>属性，Object.setPrototypeOf()，Object.getPrototypeOf()</h5><h6 id="proto属性"><a href="#proto属性" class="headerlink" title="proto属性"></a><strong>proto</strong>属性</h6><p><strong>proto</strong>属性（前后各两个下划线），用来读取或设置当前对象的 prototype 对象。目前，所有浏览器（包括 IE11）都部署了这个属性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// es6的写法</span><br><span class="line">var obj = &#123;</span><br><span class="line">  method: <span class="function"><span class="title">function</span></span>() &#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.__proto__ = someOtherObj;</span><br><span class="line"></span><br><span class="line">// es5的写法</span><br><span class="line">var obj = Object.create(someOtherObj);</span><br><span class="line">obj.method = <span class="function"><span class="title">function</span></span>() &#123; ... &#125;;</span><br></pre></td></tr></table></figure><p>该属性没有写入 ES6 的正文，而是写入了附录，原因是<strong>proto</strong>前后的双下划线，说明它本质上是一个内部属性，而不是一个正式的对外的 API，只是由于浏览器广泛支持，才被加入了 ES6。标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的 Object.setPrototypeOf()（写操作）、Object.getPrototypeOf()（读操作）、Object.create()（生成操作）代替。</p><p>在实现上，<strong>proto</strong>调用的是 Object.prototype.<strong>proto</strong>，具体实现如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty(Object.prototype, <span class="string">'__proto__'</span>, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span></span>() &#123;</span><br><span class="line">    <span class="built_in">let</span> _thisObj = Object(this);</span><br><span class="line">    <span class="built_in">return</span> Object.getPrototypeOf(_thisObj);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">set</span>(proto) &#123;</span><br><span class="line">    <span class="keyword">if</span> (this === undefined || this === null) &#123;</span><br><span class="line">      throw new TypeError();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isObject(this)) &#123;</span><br><span class="line">      <span class="built_in">return</span> undefined;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isObject(proto)) &#123;</span><br><span class="line">      <span class="built_in">return</span> undefined;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">let</span> status = Reflect.setPrototypeOf(this, proto);</span><br><span class="line">    <span class="keyword">if</span> (!status) &#123;</span><br><span class="line">      throw new TypeError();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">function</span> isObject(value) &#123;</span><br><span class="line">  <span class="built_in">return</span> Object(value) === value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个对象本身部署了<strong>proto</strong>属性，则该属性的值就是对象的原型。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.getPrototypeOf(&#123; __proto__: null &#125;)</span><br><span class="line">// null</span><br></pre></td></tr></table></figure><h6 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h6><p>Object.setPrototypeOf 方法的作用与<strong>proto</strong>相同，用来设置一个对象的 prototype 对象。它是 ES6 正式推荐的设置原型对象的方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 格式</span><br><span class="line">Object.setPrototypeOf(object, prototype)</span><br><span class="line"></span><br><span class="line">// 用法</span><br><span class="line">var o = Object.setPrototypeOf(&#123;&#125;, null);</span><br></pre></td></tr></table></figure><p>该方法等同于下面的函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> (obj, proto) &#123;</span><br><span class="line">  obj.__proto__ = proto;</span><br><span class="line">  <span class="built_in">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> proto = &#123;&#125;;</span><br><span class="line"><span class="built_in">let</span> obj = &#123; x: 10 &#125;;</span><br><span class="line">Object.setPrototypeOf(obj, proto);</span><br><span class="line"></span><br><span class="line">proto.y = 20;</span><br><span class="line">proto.z = 40;</span><br><span class="line"></span><br><span class="line">obj.x // 10</span><br><span class="line">obj.y // 20</span><br><span class="line">obj.z // 40</span><br></pre></td></tr></table></figure><p>上面代码将 proto 对象设为 obj 对象的原型，所以从 obj 对象可以读取 proto 对象的属性。</p><h6 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h6><p>该方法与 setPrototypeOf 方法配套，用于读取一个对象的 prototype 对象。</p><p>Object.getPrototypeOf(obj);<br>下面是一个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Rectangle</span></span>() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var rec = new Rectangle();</span><br><span class="line"></span><br><span class="line">Object.getPrototypeOf(rec) === Rectangle.prototype</span><br><span class="line">// <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">Object.setPrototypeOf(rec, Object.prototype);</span><br><span class="line">Object.getPrototypeOf(rec) === Rectangle.prototype</span><br><span class="line">// <span class="literal">false</span></span><br></pre></td></tr></table></figure><h4 id="Object-values-，Object-entries"><a href="#Object-values-，Object-entries" class="headerlink" title="Object.values()，Object.entries()"></a>Object.values()，Object.entries()</h4><h5 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h5><p>ES5 引入了 Object.keys 方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; foo: <span class="string">"bar"</span>, baz: 42 &#125;;</span><br><span class="line">Object.keys(obj)</span><br><span class="line">// [<span class="string">"foo"</span>, <span class="string">"baz"</span>]</span><br></pre></td></tr></table></figure><p>目前，ES7 有一个提案，引入了跟 Object.keys 配套的 Object.values 和 Object.entries。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> &#123;keys, values, entries&#125; = Object;</span><br><span class="line"><span class="built_in">let</span> obj = &#123; a: 1, b: 2, c: 3 &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> key of keys(obj)) &#123;</span><br><span class="line">  console.log(key); // <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> value of values(obj)) &#123;</span><br><span class="line">  console.log(value); // 1, 2, 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> [key, value] of entries(obj)) &#123;</span><br><span class="line">  console.log([key, value]); // [<span class="string">'a'</span>, 1], [<span class="string">'b'</span>, 2], [<span class="string">'c'</span>, 3]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values()"></a>Object.values()</h5><p>Object.values 方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; foo: <span class="string">"bar"</span>, baz: 42 &#125;;</span><br><span class="line">Object.values(obj)</span><br><span class="line">// [<span class="string">"bar"</span>, 42]</span><br></pre></td></tr></table></figure><p>返回数组的成员顺序，与本章的《属性的遍历》部分介绍的排列规则一致。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; 100: <span class="string">'a'</span>, 2: <span class="string">'b'</span>, 7: <span class="string">'c'</span> &#125;;</span><br><span class="line">Object.values(obj)</span><br><span class="line">// [<span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"a"</span>]</span><br></pre></td></tr></table></figure><p>上面代码中，属性名为数值的属性，是按照数值大小，从小到大遍历的，因此返回的顺序是 b、c、a。</p><p>Object.values 只返回对象自身的可遍历属性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj = Object.create(&#123;&#125;, &#123;p: &#123;value: 42&#125;&#125;);</span><br><span class="line">Object.values(obj) // []</span><br></pre></td></tr></table></figure><p>上面代码中，Object.create 方法的第二个参数添加的对象属性（属性 p），如果不显式声明，默认是不可遍历的。Object.values 不会返回这个属性。</p><p>Object.values 会过滤属性名为 Symbol 值的属性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.values(&#123; [Symbol()]: 123, foo: <span class="string">'abc'</span> &#125;);</span><br><span class="line">// [<span class="string">'abc'</span>]</span><br></pre></td></tr></table></figure><p>如果 Object.values 方法的参数是一个字符串，会返回各个字符组成的一个数组。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.values(<span class="string">'foo'</span>)</span><br><span class="line">// [<span class="string">'f'</span>, <span class="string">'o'</span>, <span class="string">'o'</span>]</span><br></pre></td></tr></table></figure><p>上面代码中，字符串会先转成一个类似数组的对象。字符串的每个字符，就是该对象的一个属性。因此，Object.values 返回每个属性的键值，就是各个字符组成的一个数组。</p><p>如果参数不是对象，Object.values 会先将其转为对象。由于数值和布尔值的包装对象，都不会为实例添加非继承的属性。所以，Object.values 会返回空数组。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.values(42) // []</span><br><span class="line">Object.values(<span class="literal">true</span>) // []</span><br></pre></td></tr></table></figure><h5 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries"></a>Object.entries</h5><p>Object.entries 方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; foo: <span class="string">'bar'</span>, baz: 42 &#125;;</span><br><span class="line">Object.entries(obj)</span><br><span class="line">// [ [<span class="string">"foo"</span>, <span class="string">"bar"</span>], [<span class="string">"baz"</span>, 42] ]</span><br></pre></td></tr></table></figure><p>除了返回值不一样，该方法的行为与 Object.values 基本一致。</p><p>如果原对象的属性名是一个 Symbol 值，该属性会被省略。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.entries(&#123; [Symbol()]: 123, foo: <span class="string">'abc'</span> &#125;);</span><br><span class="line">// [ [ <span class="string">'foo'</span>, <span class="string">'abc'</span> ] ]</span><br></pre></td></tr></table></figure><p>上面代码中，原对象有两个属性，Object.entries 只输出属性名非 Symbol 值的属性。将来可能会有 Reflect.ownEntries()方法，返回对象自身的所有属性。</p><p>Object.entries 的基本用途是遍历对象的属性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> obj = &#123; one: 1, two: 2 &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> [k, v] of Object.entries(obj)) &#123;</span><br><span class="line">  console.log(`<span class="variable">$&#123;JSON.stringify(k)&#125;</span>: <span class="variable">$&#123;JSON.stringify(v)&#125;</span>`);</span><br><span class="line">&#125;</span><br><span class="line">// <span class="string">"one"</span>: 1</span><br><span class="line">// <span class="string">"two"</span>: 2</span><br></pre></td></tr></table></figure><p>Object.entries 方法的一个用处是，将对象转为真正的 Map 结构。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; foo: <span class="string">'bar'</span>, baz: 42 &#125;;</span><br><span class="line">var map = new Map(Object.entries(obj));</span><br><span class="line">map // Map &#123; foo: <span class="string">"bar"</span>, baz: 42 &#125;</span><br></pre></td></tr></table></figure><p>自己实现 Object.entries 方法，非常简单。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Generator函数的版本</span><br><span class="line"><span class="keyword">function</span>* entries(obj) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">let</span> key of Object.keys(obj)) &#123;</span><br><span class="line">    yield [key, obj[key]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 非Generator函数的版本</span><br><span class="line"><span class="keyword">function</span> entries(obj) &#123;</span><br><span class="line">  <span class="built_in">let</span> arr = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">let</span> key of Object.keys(obj)) &#123;</span><br><span class="line">    arr.push([key, obj[key]]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对象的扩展运算符"><a href="#对象的扩展运算符" class="headerlink" title="对象的扩展运算符"></a>对象的扩展运算符</h4><p>目前，ES7 有一个提案，将 Rest 运算符（解构赋值）/扩展运算符（…）引入对象。Babel 转码器已经支持这项功能。</p><h5 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h5><p>对象的解构赋值用于从一个对象取值，相当于将所有可遍历的、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;;</span><br><span class="line">x // 1</span><br><span class="line">y // 2</span><br><span class="line">z // &#123; a: 3, b: 4 &#125;</span><br></pre></td></tr></table></figure><p>上面代码中，变量 z 是解构赋值所在的对象。它获取等号右边的所有尚未读取的键（a 和 b），将它们连同值一起拷贝过来。</p><p>由于解构赋值要求等号右边是一个对象，所以如果等号右边是 undefined 或 null，就会报错，因为它们无法转为对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> &#123; x, y, ...z &#125; = null; // 运行时错误</span><br><span class="line"><span class="built_in">let</span> &#123; x, y, ...z &#125; = undefined; // 运行时错误</span><br></pre></td></tr></table></figure><p>解构赋值必须是最后一个参数，否则会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> &#123; ...x, y, z &#125; = obj; // 句法错误</span><br><span class="line"><span class="built_in">let</span> &#123; x, ...y, ...z &#125; = obj; // 句法错误</span><br></pre></td></tr></table></figure><p>上面代码中，解构赋值不是最后一个参数，所以会报错。</p><p>注意，解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> obj = &#123; a: &#123; b: 1 &#125; &#125;;</span><br><span class="line"><span class="built_in">let</span> &#123; ...x &#125; = obj;</span><br><span class="line">obj.a.b = 2;</span><br><span class="line">x.a.b // 2</span><br></pre></td></tr></table></figure><p>上面代码中，x 是解构赋值所在的对象，拷贝了对象 obj 的 a 属性。a 属性引用了一个对象，修改这个对象的值，会影响到解构赋值对它的引用。</p><p>另外，解构赋值不会拷贝继承自原型对象的属性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> o1 = &#123; a: 1 &#125;;</span><br><span class="line"><span class="built_in">let</span> o2 = &#123; b: 2 &#125;;</span><br><span class="line">o2.__proto__ = o1;</span><br><span class="line"><span class="built_in">let</span> o3 = &#123; ...o2 &#125;;</span><br><span class="line">o3 // &#123; b: 2 &#125;</span><br></pre></td></tr></table></figure><p>上面代码中，对象 o3 是 o2 的拷贝，但是只复制了 o2 自身的属性，没有复制它的原型对象 o1 的属性。</p><p>下面是另一个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var o = Object.create(&#123; x: 1, y: 2 &#125;);</span><br><span class="line">o.z = 3;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> &#123; x, ...&#123; y, z &#125; &#125; = o;</span><br><span class="line">x // 1</span><br><span class="line">y // undefined</span><br><span class="line">z // 3</span><br></pre></td></tr></table></figure><p>上面代码中，变量 x 是单纯的解构赋值，所以可以读取继承的属性；解构赋值产生的变量 y 和 z，只能读取对象自身的属性，所以只有变量 z 可以赋值成功。</p><p>解构赋值的一个用处，是扩展某个函数的参数，引入其他操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> baseFunction(&#123; a, b &#125;) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> wrapperFunction(&#123; x, y, ...restConfig &#125;) &#123;</span><br><span class="line">  // 使用x和y参数进行操作</span><br><span class="line">  // 其余参数传给原始函数</span><br><span class="line">  <span class="built_in">return</span> baseFunction(restConfig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，原始函数 baseFunction 接受 a 和 b 作为参数，函数 wrapperFunction 在 baseFunction 的基础上进行了扩展，能够接受多余的参数，并且保留原始函数的行为。</p><h5 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h5><p>扩展运算符（…）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> z = &#123; a: 3, b: 4 &#125;;</span><br><span class="line"><span class="built_in">let</span> n = &#123; ...z &#125;;</span><br><span class="line">n // &#123; a: 3, b: 4 &#125;</span><br></pre></td></tr></table></figure><p>这等同于使用 Object.assign 方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> aClone = &#123; ...a &#125;;</span><br><span class="line">// 等同于</span><br><span class="line"><span class="built_in">let</span> aClone = Object.assign(&#123;&#125;, a);</span><br></pre></td></tr></table></figure><p>扩展运算符可以用于合并两个对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> ab = &#123; ...a, ...b &#125;;</span><br><span class="line">// 等同于</span><br><span class="line"><span class="built_in">let</span> ab = Object.assign(&#123;&#125;, a, b);</span><br></pre></td></tr></table></figure><p>如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> aWithOverrides = &#123; ...a, x: 1, y: 2 &#125;;</span><br><span class="line">// 等同于</span><br><span class="line"><span class="built_in">let</span> aWithOverrides = &#123; ...a, ...&#123; x: 1, y: 2 &#125; &#125;;</span><br><span class="line">// 等同于</span><br><span class="line"><span class="built_in">let</span> x = 1, y = 2, aWithOverrides = &#123; ...a, x, y &#125;;</span><br><span class="line">// 等同于</span><br><span class="line"><span class="built_in">let</span> aWithOverrides = Object.assign(&#123;&#125;, a, &#123; x: 1, y: 2 &#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，a 对象的 x 属性和 y 属性，拷贝到新对象后会被覆盖掉。</p><p>这用来修改现有对象部分的部分属性就很方便了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> newVersion = &#123;</span><br><span class="line">  ...previousVersion,</span><br><span class="line">  name: <span class="string">'New Name'</span> // Override the name property</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，newVersion 对象自定义了 name 属性，其他属性全部复制自 previousVersion 对象。</p><p>如果把自定义属性放在扩展运算符前面，就变成了设置新对象的默认属性值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> aWithDefaults = &#123; x: 1, y: 2, ...a &#125;;</span><br><span class="line">// 等同于</span><br><span class="line"><span class="built_in">let</span> aWithDefaults = Object.assign(&#123;&#125;, &#123; x: 1, y: 2 &#125;, a);</span><br><span class="line">// 等同于</span><br><span class="line"><span class="built_in">let</span> aWithDefaults = Object.assign(&#123; x: 1, y: 2 &#125;, a);</span><br></pre></td></tr></table></figure><p>扩展运算符的参数对象之中，如果有取值函数 get，这个函数是会执行的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 并不会抛出错误，因为x属性只是被定义，但没执行</span><br><span class="line"><span class="built_in">let</span> aWithXGetter = &#123;</span><br><span class="line">  ...a,</span><br><span class="line">  get <span class="function"><span class="title">x</span></span>() &#123;</span><br><span class="line">    throws new Error(<span class="string">'not thrown yet'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 会抛出错误，因为x属性被执行了</span><br><span class="line"><span class="built_in">let</span> runtimeError = &#123;</span><br><span class="line">  ...a,</span><br><span class="line">  ...&#123;</span><br><span class="line">    get <span class="function"><span class="title">x</span></span>() &#123;</span><br><span class="line">      throws new Error(<span class="string">'thrown now'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果扩展运算符的参数是 null 或 undefined，这个两个值会被忽略，不会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> emptyObject = &#123; ...null, ...undefined &#125;; // 不报错</span><br></pre></td></tr></table></figure><h4 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h4><p>ES5 有一个 Object.getOwnPropertyDescriptor 方法，返回某个对象属性的描述对象（descriptor）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; p: <span class="string">'a'</span> &#125;;</span><br><span class="line"></span><br><span class="line">Object.getOwnPropertyDescriptor(obj, <span class="string">'p'</span>)</span><br><span class="line">// Object &#123; value: <span class="string">"a"</span>,</span><br><span class="line">//   writable: <span class="literal">true</span>,</span><br><span class="line">//   enumerable: <span class="literal">true</span>,</span><br><span class="line">//   configurable: <span class="literal">true</span></span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure><p>ES7 有一个提案，提出了 Object.getOwnPropertyDescriptors 方法，返回指定对象所有自身属性（非继承属性）的描述对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line">  foo: 123,</span><br><span class="line">  get <span class="function"><span class="title">bar</span></span>() &#123; <span class="built_in">return</span> <span class="string">'abc'</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.getOwnPropertyDescriptors(obj)</span><br><span class="line">// &#123; foo:</span><br><span class="line">//    &#123; value: 123,</span><br><span class="line">//      writable: <span class="literal">true</span>,</span><br><span class="line">//      enumerable: <span class="literal">true</span>,</span><br><span class="line">//      configurable: <span class="literal">true</span> &#125;,</span><br><span class="line">//   bar:</span><br><span class="line">//    &#123; get: [Function: bar],</span><br><span class="line">//      <span class="built_in">set</span>: undefined,</span><br><span class="line">//      enumerable: <span class="literal">true</span>,</span><br><span class="line">//      configurable: <span class="literal">true</span> &#125; &#125;</span><br></pre></td></tr></table></figure><p>Object.getOwnPropertyDescriptors 方法返回一个对象，所有原对象的属性名都是该对象的属性名，对应的属性值就是该属性的描述对象。</p><p>该方法的实现非常容易。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> getOwnPropertyDescriptors(obj) &#123;</span><br><span class="line">  const result = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">let</span> key of Reflect.ownKeys(obj)) &#123;</span><br><span class="line">    result[key] = Object.getOwnPropertyDescriptor(obj, key);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法的提出目的，主要是为了解决 Object.assign()无法正确拷贝 get 属性和 set 属性的问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const <span class="built_in">source</span> = &#123;</span><br><span class="line">  <span class="built_in">set</span> foo(value) &#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const target1 = &#123;&#125;;</span><br><span class="line">Object.assign(target1, <span class="built_in">source</span>);</span><br><span class="line"></span><br><span class="line">Object.getOwnPropertyDescriptor(target1, <span class="string">'foo'</span>)</span><br><span class="line">// &#123; value: undefined,</span><br><span class="line">//   writable: <span class="literal">true</span>,</span><br><span class="line">//   enumerable: <span class="literal">true</span>,</span><br><span class="line">//   configurable: <span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure><p>上面代码中，source 对象的 foo 属性的值是一个赋值函数，Object.assign 方法将这个属性拷贝给 target1 对象，结果该属性的值变成了 undefined。这是因为 Object.assign 方法总是拷贝一个属性的值，而不会拷贝它背后的赋值方法或取值方法。</p><p>这时，Object.getOwnPropertyDescriptors 方法配合 Object.defineProperties 方法，就可以实现正确拷贝。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const <span class="built_in">source</span> = &#123;</span><br><span class="line">  <span class="built_in">set</span> foo(value) &#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const target2 = &#123;&#125;;</span><br><span class="line">Object.defineProperties(target2, Object.getOwnPropertyDescriptors(<span class="built_in">source</span>));</span><br><span class="line">Object.getOwnPropertyDescriptor(target2, <span class="string">'foo'</span>)</span><br><span class="line">// &#123; get: undefined,</span><br><span class="line">//   <span class="built_in">set</span>: [Function: foo],</span><br><span class="line">//   enumerable: <span class="literal">true</span>,</span><br><span class="line">//   configurable: <span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure><p>上面代码中，将两个对象合并的逻辑提炼出来，就是下面这样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const shallowMerge = (target, <span class="built_in">source</span>) =&gt; Object.defineProperties(</span><br><span class="line">  target,</span><br><span class="line">  Object.getOwnPropertyDescriptors(<span class="built_in">source</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>Object.getOwnPropertyDescriptors 方法的另一个用处，是配合 Object.create 方法，将对象属性克隆到一个新对象。这属于浅拷贝。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const <span class="built_in">clone</span> = Object.create(Object.getPrototypeOf(obj),</span><br><span class="line">  Object.getOwnPropertyDescriptors(obj));</span><br><span class="line"></span><br><span class="line">// 或者</span><br><span class="line"></span><br><span class="line">const shallowClone = (obj) =&gt; Object.create(</span><br><span class="line">  Object.getPrototypeOf(obj),</span><br><span class="line">  Object.getOwnPropertyDescriptors(obj)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面代码会克隆对象 obj。</p><p>另外，Object.getOwnPropertyDescriptors 方法可以实现，一个对象继承另一个对象。以前，继承另一个对象，常常写成下面这样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line">  __proto__: prot,</span><br><span class="line">  foo: 123,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>ES6 规定<strong>proto</strong>只有浏览器要部署，其他环境不用部署。如果去除<strong>proto</strong>，上面代码就要改成下面这样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const obj = Object.create(prot);</span><br><span class="line">obj.foo = 123;</span><br><span class="line"></span><br><span class="line">// 或者</span><br><span class="line"></span><br><span class="line">const obj = Object.assign(</span><br><span class="line">  Object.create(prot),</span><br><span class="line">  &#123;</span><br><span class="line">    foo: 123,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>有了 Object.getOwnPropertyDescriptors，我们就有了另一种写法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const obj = Object.create(</span><br><span class="line">  prot,</span><br><span class="line">  Object.getOwnPropertyDescriptors(&#123;</span><br><span class="line">    foo: 123,</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>Object.getOwnPropertyDescriptors 也可以用来实现 Mixin（混入）模式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> mix = (object) =&gt; (&#123;</span><br><span class="line">  with: (...mixins) =&gt; mixins.reduce(</span><br><span class="line">    (c, mixin) =&gt; Object.create(</span><br><span class="line">      c, Object.getOwnPropertyDescriptors(mixin)</span><br><span class="line">    ), object)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// multiple mixins example</span><br><span class="line"><span class="built_in">let</span> a = &#123;a: <span class="string">'a'</span>&#125;;</span><br><span class="line"><span class="built_in">let</span> b = &#123;b: <span class="string">'b'</span>&#125;;</span><br><span class="line"><span class="built_in">let</span> c = &#123;c: <span class="string">'c'</span>&#125;;</span><br><span class="line"><span class="built_in">let</span> d = mix(c).with(a, b);</span><br></pre></td></tr></table></figure><p>上面代码中，对象 a 和 b 被混入了对象 c。</p><p>出于完整性的考虑，Object.getOwnPropertyDescriptors 进入标准以后，还会有 Reflect.getOwnPropertyDescriptors 方法。</p>]]></content>
      
      
      <categories>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6_Function</title>
      <link href="/2019/02/01/es6-Function/"/>
      <url>/2019/02/01/es6-Function/</url>
      
        <content type="html"><![CDATA[<h3 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h3><h4 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h4><h5 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h5><p>在 ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="built_in">log</span>(x, y) &#123;</span><br><span class="line">  y = y || <span class="string">'World'</span>;</span><br><span class="line">  console.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">log</span>(<span class="string">'Hello'</span>) // Hello World</span><br><span class="line"><span class="built_in">log</span>(<span class="string">'Hello'</span>, <span class="string">'China'</span>) // Hello China</span><br><span class="line"><span class="built_in">log</span>(<span class="string">'Hello'</span>, <span class="string">''</span>) // Hello World</span><br></pre></td></tr></table></figure><p>上面代码检查函数 log 的参数 y 有没有赋值，如果没有，则指定默认值为 World。这种写法的缺点在于，如果参数 y 赋值了，但是对应的布尔值为 false，则该赋值不起作用。就像上面代码的最后一行，参数 y 等于空字符，结果被改为默认值。</p><p>为了避免这个问题，通常需要先判断一下参数 y 是否被赋值，如果没有，再等于默认值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (typeof y === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">  y = <span class="string">'World'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="built_in">log</span>(x, y = <span class="string">'World'</span>) &#123;</span><br><span class="line">  console.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">log</span>(<span class="string">'Hello'</span>) // Hello World</span><br><span class="line"><span class="built_in">log</span>(<span class="string">'Hello'</span>, <span class="string">'China'</span>) // Hello China</span><br><span class="line"><span class="built_in">log</span>(<span class="string">'Hello'</span>, <span class="string">''</span>) // Hello</span><br></pre></td></tr></table></figure><p>可以看到，ES6 的写法比 ES5 简洁许多，而且非常自然。下面是另一个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Point(x = 0, y = 0) &#123;</span><br><span class="line">  this.x = x;</span><br><span class="line">  this.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p = new Point();</span><br><span class="line">p // &#123; x: 0, y: 0 &#125;</span><br></pre></td></tr></table></figure><p>除了简洁，ES6 的写法还有两个好处：首先，阅读代码的人，可以立刻意识到哪些参数是可以省略的，不用查看函数体或文档；其次，有利于将来的代码优化，即使未来的版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行。</p><p>参数变量是默认声明的，所以不能用 let 或 const 再次声明。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> foo(x = 5) &#123;</span><br><span class="line">  <span class="built_in">let</span> x = 1; // error</span><br><span class="line">  const x = 2; // error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，参数变量 x 是默认声明的，在函数体中，不能用 let 或 const 再次声明，否则会报错。</p><h5 id="与解构赋值默认值结合使用"><a href="#与解构赋值默认值结合使用" class="headerlink" title="与解构赋值默认值结合使用"></a>与解构赋值默认值结合使用</h5><p>参数默认值可以与解构赋值的默认值，结合起来使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> foo(&#123;x, y = 5&#125;) &#123;</span><br><span class="line">  console.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(&#123;&#125;) // undefined, 5</span><br><span class="line">foo(&#123;x: 1&#125;) // 1, 5</span><br><span class="line">foo(&#123;x: 1, y: 2&#125;) // 1, 2</span><br><span class="line">foo() // TypeError: Cannot <span class="built_in">read</span> property <span class="string">'x'</span> of undefined</span><br></pre></td></tr></table></figure><p>上面代码使用了对象的解构赋值默认值，而没有使用函数参数的默认值。只有当函数 foo 的参数是一个对象时，变量 x 和 y 才会通过解构赋值而生成。如果函数 foo 调用时参数不是对象，变量 x 和 y 就不会生成，从而报错。如果参数对象没有 y 属性，y 的默认值 5 才会生效。</p><p>下面是另一个对象的解构赋值默认值的例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> fetch(url, &#123; body = <span class="string">''</span>, method = <span class="string">'GET'</span>, headers = &#123;&#125; &#125;) &#123;</span><br><span class="line">  console.log(method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fetch(<span class="string">'http://example.com'</span>, &#123;&#125;)</span><br><span class="line">// <span class="string">"GET"</span></span><br><span class="line"></span><br><span class="line">fetch(<span class="string">'http://example.com'</span>)</span><br><span class="line">// 报错</span><br></pre></td></tr></table></figure><p>上面代码中，如果函数 fetch 的第二个参数是一个对象，就可以为它的三个属性设置默认值。</p><p>上面的写法不能省略第二个参数，如果结合函数参数的默认值，就可以省略第二个参数。这时，就出现了双重默认值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> fetch(url, &#123; method = <span class="string">'GET'</span> &#125; = &#123;&#125;) &#123;</span><br><span class="line">  console.log(method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fetch(<span class="string">'http://example.com'</span>)</span><br><span class="line">// <span class="string">"GET"</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数 fetch 没有第二个参数时，函数参数的默认值就会生效，然后才是解构赋值的默认值生效，变量 method 才会取到默认值 GET。</p><p>再请问下面两种写法有什么差别？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 写法一</span><br><span class="line"><span class="keyword">function</span> m1(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123;</span><br><span class="line">  <span class="built_in">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 写法二</span><br><span class="line"><span class="keyword">function</span> m2(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123;</span><br><span class="line">  <span class="built_in">return</span> [x, y];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两种写法都对函数的参数设定了默认值，区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 函数没有参数的情况</span><br><span class="line">m1() // [0, 0]</span><br><span class="line">m2() // [0, 0]</span><br><span class="line"></span><br><span class="line">// x和y都有值的情况</span><br><span class="line">m1(&#123;x: 3, y: 8&#125;) // [3, 8]</span><br><span class="line">m2(&#123;x: 3, y: 8&#125;) // [3, 8]</span><br><span class="line"></span><br><span class="line">// x有值，y无值的情况</span><br><span class="line">m1(&#123;x: 3&#125;) // [3, 0]</span><br><span class="line">m2(&#123;x: 3&#125;) // [3, undefined]</span><br><span class="line"></span><br><span class="line">// x和y都无值的情况</span><br><span class="line">m1(&#123;&#125;) // [0, 0];</span><br><span class="line">m2(&#123;&#125;) // [undefined, undefined]</span><br><span class="line"></span><br><span class="line">m1(&#123;z: 3&#125;) // [0, 0]</span><br><span class="line">m2(&#123;z: 3&#125;) // [undefined, undefined]</span><br></pre></td></tr></table></figure><h5 id="参数默认值的位置"><a href="#参数默认值的位置" class="headerlink" title="参数默认值的位置"></a>参数默认值的位置</h5><p>通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 例一</span><br><span class="line"><span class="keyword">function</span> f(x = 1, y) &#123;</span><br><span class="line">  <span class="built_in">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() // [1, undefined]</span><br><span class="line">f(2) // [2, undefined])</span><br><span class="line">f(, 1) // 报错</span><br><span class="line">f(undefined, 1) // [1, 1]</span><br><span class="line"></span><br><span class="line">// 例二</span><br><span class="line"><span class="keyword">function</span> f(x, y = 5, z) &#123;</span><br><span class="line">  <span class="built_in">return</span> [x, y, z];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() // [undefined, 5, undefined]</span><br><span class="line">f(1) // [1, 5, undefined]</span><br><span class="line">f(1, ,2) // 报错</span><br><span class="line">f(1, undefined, 2) // [1, 5, 2]</span><br></pre></td></tr></table></figure><p>上面代码中，有默认值的参数都不是尾参数。这时，无法只省略该参数，而不省略它后面的参数，除非显式输入 undefined。</p><p>如果传入 undefined，将触发该参数等于默认值，null 则没有这个效果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> foo(x = 5, y = 6) &#123;</span><br><span class="line">  console.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(undefined, null)</span><br><span class="line">// 5 null</span><br></pre></td></tr></table></figure><p>上面代码中，x 参数对应 undefined，结果触发了默认值，y 参数等于 null，就没有触发默认值。</p><h5 id="函数的-length-属性"><a href="#函数的-length-属性" class="headerlink" title="函数的 length 属性"></a>函数的 length 属性</h5><p>指定了默认值以后，函数的 length 属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length 属性将失真。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (a) &#123;&#125;).length // 1</span><br><span class="line">(<span class="keyword">function</span> (a = 5) &#123;&#125;).length // 0</span><br><span class="line">(<span class="keyword">function</span> (a, b, c = 5) &#123;&#125;).length // 2</span><br></pre></td></tr></table></figure><p>上面代码中，length 属性的返回值，等于函数的参数个数减去指定了默认值的参数个数。比如，上面最后一个函数，定义了 3 个参数，其中有一个参数 c 指定了默认值，因此 length 属性等于 3 减去 1，最后得到 2。</p><p>这是因为 length 属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，rest 参数也不会计入 length 属性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(...args) &#123;&#125;).length // 0</span><br></pre></td></tr></table></figure><p>如果设置了默认值的参数不是尾参数，那么 length 属性也不再计入后面的参数了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (a = 0, b, c) &#123;&#125;).length // 0</span><br><span class="line">(<span class="keyword">function</span> (a, b = 1, c) &#123;&#125;).length // 1</span><br></pre></td></tr></table></figure><h5 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h5><p>一个需要注意的地方是，如果参数默认值是一个变量，则该变量所处的作用域，与其他变量的作用域规则是一样的，即先是当前函数的作用域，然后才是全局作用域。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var x = 1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> f(x, y = x) &#123;</span><br><span class="line">  console.log(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(2) // 2</span><br></pre></td></tr></table></figure><p>上面代码中，参数 y 的默认值等于 x。调用时，由于函数作用域内部的变量 x 已经生成，所以 y 等于参数 x，而不是全局变量 x。</p><p>如果调用时，函数作用域内部的变量 x 没有生成，结果就会不一样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> x = 1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> f(y = x) &#123;</span><br><span class="line">  <span class="built_in">let</span> x = 2;</span><br><span class="line">  console.log(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() // 1</span><br></pre></td></tr></table></figure><p>上面代码中，函数调用时，y 的默认值变量 x 尚未在函数内部生成，所以 x 指向全局变量。</p><p>如果此时，全局变量 x 不存在，就会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> f(y = x) &#123;</span><br><span class="line">  <span class="built_in">let</span> x = 2;</span><br><span class="line">  console.log(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() // ReferenceError: x is not defined</span><br></pre></td></tr></table></figure><p>下面这样写，也会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var x = 1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> foo(x = x) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() // ReferenceError: x is not defined</span><br></pre></td></tr></table></figure><p>上面代码中，函数 foo 的参数 x 的默认值也是 x。这时，默认值 x 的作用域是函数作用域，而不是全局作用域。由于在函数作用域中，存在变量 x，但是默认值在 x 赋值之前先执行了，所以这时属于暂时性死区（参见《let 和 const 命令》一章），任何对 x 的操作都会报错。</p><p>如果参数的默认值是一个函数，该函数的作用域是其声明时所在的作用域。请看下面的例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> foo = <span class="string">'outer'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> bar(func = x =&gt; foo) &#123;</span><br><span class="line">  <span class="built_in">let</span> foo = <span class="string">'inner'</span>;</span><br><span class="line">  console.log(func()); // outer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar();</span><br></pre></td></tr></table></figure><p>上面代码中，函数 bar 的参数 func 的默认值是一个匿名函数，返回值为变量 foo。这个匿名函数声明时，bar 函数的作用域还没有形成，所以匿名函数里面的 foo 指向外层作用域的 foo，输出 outer。</p><p>如果写成下面这样，就会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> bar(func = () =&gt; foo) &#123;</span><br><span class="line">  <span class="built_in">let</span> foo = <span class="string">'inner'</span>;</span><br><span class="line">  console.log(func());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar() // ReferenceError: foo is not defined</span><br></pre></td></tr></table></figure><p>上面代码中，匿名函数里面的 foo 指向函数外层，但是函数外层并没有声明 foo，所以就报错了。</p><p>下面是一个更复杂的例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var x = 1;</span><br><span class="line"><span class="keyword">function</span> foo(x, y = <span class="function"><span class="title">function</span></span>() &#123; x = 2; &#125;) &#123;</span><br><span class="line">  var x = 3;</span><br><span class="line">  y();</span><br><span class="line">  console.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() // 3</span><br></pre></td></tr></table></figure><p>上面代码中，函数 foo 的参数 y 的默认值是一个匿名函数。函数 foo 调用时，它的参数 x 的值为 undefined，所以 y 函数内部的 x 一开始是 undefined，后来被重新赋值 2。但是，函数 foo 内部重新声明了一个 x，值为 3，这两个 x 是不一样的，互相不产生影响，因此最后输出 3。</p><p>如果将 var x = 3 的 var 去除，两个 x 就是一样的，最后输出的就是 2。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var x = 1;</span><br><span class="line"><span class="keyword">function</span> foo(x, y = <span class="function"><span class="title">function</span></span>() &#123; x = 2; &#125;) &#123;</span><br><span class="line">  x = 3;</span><br><span class="line">  y();</span><br><span class="line">  console.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() // 2</span><br></pre></td></tr></table></figure><h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><p>利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">throwIfMissing</span></span>() &#123;</span><br><span class="line">  throw new Error(<span class="string">'Missing parameter'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> foo(mustBeProvided = throwIfMissing()) &#123;</span><br><span class="line">  <span class="built_in">return</span> mustBeProvided;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line">// Error: Missing parameter</span><br></pre></td></tr></table></figure><p>上面代码的 foo 函数，如果调用的时候没有参数，就会调用默认值 throwIfMissing 函数，从而抛出一个错误。</p><p>从上面代码还可以看到，参数 mustBeProvided 的默认值等于 throwIfMissing 函数的运行结果（即函数名之后有一对圆括号），这表明参数的默认值不是在定义时执行，而是在运行时执行（即如果参数已经赋值，默认值中的函数就不会运行），这与 python 语言不一样。</p><p>另外，可以将参数默认值设为 undefined，表明这个参数是可以省略的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> foo(optional = undefined) &#123; ··· &#125;</span><br></pre></td></tr></table></figure><h5 id="rest-参数"><a href="#rest-参数" class="headerlink" title="rest 参数"></a>rest 参数</h5><p>ES6 引入 rest 参数（形式为“…变量名”），用于获取函数的多余参数，这样就不需要使用 arguments 对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> add(...values) &#123;</span><br><span class="line">  <span class="built_in">let</span> sum = 0;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (var val of values) &#123;</span><br><span class="line">    sum += val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(2, 5, 3) // 10</span><br></pre></td></tr></table></figure><p>上面代码的 add 函数是一个求和函数，利用 rest 参数，可以向该函数传入任意数目的参数。</p><p>下面是一个 rest 参数代替 arguments 变量的例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// arguments变量的写法</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">sortNumbers</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> Array.prototype.slice.call(arguments).sort();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// rest参数的写法</span><br><span class="line">const sortNumbers = (...numbers) =&gt; numbers.sort();</span><br></pre></td></tr></table></figure><p>上面代码的两种写法，比较后可以发现，rest 参数的写法更自然也更简洁。</p><p>rest 参数中的变量代表一个数组，所以数组特有的方法都可以用于这个变量。下面是一个利用 rest 参数改写数组 push 方法的例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> push(array, ...items) &#123;</span><br><span class="line">  items.forEach(<span class="keyword">function</span>(item) &#123;</span><br><span class="line">    array.push(item);</span><br><span class="line">    console.log(item);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = [];</span><br><span class="line">push(a, 1, 2, 3)</span><br></pre></td></tr></table></figure><p>注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line"><span class="keyword">function</span> f(a, ...b, c) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的 length 属性，不包括 rest 参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(a) &#123;&#125;).length  // 1</span><br><span class="line">(<span class="keyword">function</span>(...a) &#123;&#125;).length  // 0</span><br><span class="line">(<span class="keyword">function</span>(a, ...b) &#123;&#125;).length  // 1</span><br></pre></td></tr></table></figure><h4 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h4><h5 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h5><p>扩展运算符（spread）是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">console.log(...[1, 2, 3])</span><br><span class="line">// 1 2 3</span><br><span class="line"></span><br><span class="line">console.log(1, ...[2, 3, 4], 5)</span><br><span class="line">// 1 2 3 4 5</span><br><span class="line"></span><br><span class="line">[...document.querySelectorAll(<span class="string">'div'</span>)]</span><br><span class="line">// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]</span><br></pre></td></tr></table></figure><p>该运算符主要用于函数调用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> push(array, ...items) &#123;</span><br><span class="line">  array.push(...items);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> add(x, y) &#123;</span><br><span class="line">  <span class="built_in">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var numbers = [4, 38];</span><br><span class="line">add(...numbers) // 42</span><br></pre></td></tr></table></figure><p>上面代码中，array.push(…items)和 add(…numbers)这两行，都是函数的调用，它们的都使用了扩展运算符。该运算符将一个数组，变为参数序列。</p><p>扩展运算符与正常的函数参数可以结合使用，非常灵活。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> f(v, w, x, y, z) &#123; &#125;</span><br><span class="line">var args = [0, 1];</span><br><span class="line">f(-1, ...args, 2, ...[3]);</span><br></pre></td></tr></table></figure><h5 id="替代数组的-apply-方法"><a href="#替代数组的-apply-方法" class="headerlink" title="替代数组的 apply 方法"></a>替代数组的 apply 方法</h5><p>由于扩展运算符可以展开数组，所以不再需要 apply 方法，将数组转为函数的参数了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// ES5的写法</span><br><span class="line"><span class="keyword">function</span> f(x, y, z) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line">var args = [0, 1, 2];</span><br><span class="line">f.apply(null, args);</span><br><span class="line"></span><br><span class="line">// ES6的写法</span><br><span class="line"><span class="keyword">function</span> f(x, y, z) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line">var args = [0, 1, 2];</span><br><span class="line">f(...args);</span><br></pre></td></tr></table></figure><p>下面是扩展运算符取代 apply 方法的一个实际的例子，应用 Math.max 方法，简化求出一个数组最大元素的写法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// ES5的写法</span><br><span class="line">Math.max.apply(null, [14, 3, 77])</span><br><span class="line"></span><br><span class="line">// ES6的写法</span><br><span class="line">Math.max(...[14, 3, 77])</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">Math.max(14, 3, 77);</span><br></pre></td></tr></table></figure><p>上面代码表示，由于 JavaScript 不提供求数组最大元素的函数，所以只能套用 Math.max 函数，将数组转为一个参数序列，然后求最大值。有了扩展运算符以后，就可以直接用 Math.max 了。</p><p>另一个例子是通过 push 函数，将一个数组添加到另一个数组的尾部。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// ES5的写法</span><br><span class="line">var arr1 = [0, 1, 2];</span><br><span class="line">var arr2 = [3, 4, 5];</span><br><span class="line">Array.prototype.push.apply(arr1, arr2);</span><br><span class="line"></span><br><span class="line">// ES6的写法</span><br><span class="line">var arr1 = [0, 1, 2];</span><br><span class="line">var arr2 = [3, 4, 5];</span><br><span class="line">arr1.push(...arr2);</span><br></pre></td></tr></table></figure><p>上面代码的 ES5 写法中，push 方法的参数不能是数组，所以只好通过 apply 方法变通使用 push 方法。有了扩展运算符，就可以直接将数组传入 push 方法。</p><p>下面是另外一个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// ES5</span><br><span class="line">new (Date.bind.apply(Date, [null, 2015, 1, 1]))</span><br><span class="line">// ES6</span><br><span class="line">new Date(...[2015, 1, 1]);</span><br></pre></td></tr></table></figure><h5 id="扩展运算符的应用"><a href="#扩展运算符的应用" class="headerlink" title="扩展运算符的应用"></a>扩展运算符的应用</h5><h6 id="合并数组"><a href="#合并数组" class="headerlink" title="合并数组"></a>合并数组</h6><p>扩展运算符提供了数组合并的新写法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// ES5</span><br><span class="line">[1, 2].concat(more)</span><br><span class="line">// ES6</span><br><span class="line">[1, 2, ...more]</span><br><span class="line"></span><br><span class="line">var arr1 = [<span class="string">'a'</span>, <span class="string">'b'</span>];</span><br><span class="line">var arr2 = [<span class="string">'c'</span>];</span><br><span class="line">var arr3 = [<span class="string">'d'</span>, <span class="string">'e'</span>];</span><br><span class="line"></span><br><span class="line">// ES5的合并数组</span><br><span class="line">arr1.concat(arr2, arr3);</span><br><span class="line">// [ <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span> ]</span><br><span class="line"></span><br><span class="line">// ES6的合并数组</span><br><span class="line">[...arr1, ...arr2, ...arr3]</span><br><span class="line">// [ <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span> ]</span><br></pre></td></tr></table></figure><h6 id="与解构赋值结合"><a href="#与解构赋值结合" class="headerlink" title="与解构赋值结合"></a>与解构赋值结合</h6><p>扩展运算符可以与解构赋值结合起来，用于生成数组。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// ES5</span><br><span class="line">a = list[0], rest = list.slice(1)</span><br><span class="line">// ES6</span><br><span class="line">[a, ...rest] = list</span><br></pre></td></tr></table></figure><p>下面是另外一些例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const [first, ...rest] = [1, 2, 3, 4, 5];</span><br><span class="line">first // 1</span><br><span class="line">rest  // [2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">const [first, ...rest] = [];</span><br><span class="line">first // undefined</span><br><span class="line">rest  // []:</span><br><span class="line"></span><br><span class="line">const [first, ...rest] = [<span class="string">"foo"</span>];</span><br><span class="line">first  // <span class="string">"foo"</span></span><br><span class="line">rest   // []</span><br></pre></td></tr></table></figure><p>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const [...butLast, last] = [1, 2, 3, 4, 5];</span><br><span class="line">// 报错</span><br><span class="line"></span><br><span class="line">const [first, ...middle, last] = [1, 2, 3, 4, 5];</span><br><span class="line">// 报错</span><br></pre></td></tr></table></figure><h6 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h6><p>JavaScript 的函数只能返回一个值，如果需要返回多个值，只能返回数组或对象。扩展运算符提供了解决这个问题的一种变通方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var dateFields = readDateFields(database);</span><br><span class="line">var d = new Date(...dateFields);</span><br></pre></td></tr></table></figure><p>上面代码从数据库取出一行数据，通过扩展运算符，直接将其传入构造函数 Date。</p><h6 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h6><p>扩展运算符还可以将字符串转为真正的数组。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...<span class="string">'hello'</span>]</span><br><span class="line">// [ <span class="string">"h"</span>, <span class="string">"e"</span>, <span class="string">"l"</span>, <span class="string">"l"</span>, <span class="string">"o"</span> ]</span><br></pre></td></tr></table></figure><p>上面的写法，有一个重要的好处，那就是能够正确识别 32 位的 Unicode 字符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'x\uD83D\uDE80y'</span>.length // 4</span><br><span class="line">[...<span class="string">'x\uD83D\uDE80y'</span>].length // 3</span><br></pre></td></tr></table></figure><p>上面代码的第一种写法，JavaScript 会将 32 位 Unicode 字符，识别为 2 个字符，采用扩展运算符就没有这个问题。因此，正确返回字符串长度的函数，可以像下面这样写。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> length(str) &#123;</span><br><span class="line">  <span class="built_in">return</span> [...str].length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">length(<span class="string">'x\uD83D\uDE80y'</span>) // 3</span><br></pre></td></tr></table></figure><p>凡是涉及到操作 32 位 Unicode 字符的函数，都有这个问题。因此，最好都用扩展运算符改写。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> str = <span class="string">'x\uD83D\uDE80y'</span>;</span><br><span class="line"></span><br><span class="line">str.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</span><br><span class="line">// <span class="string">'y\uDE80\uD83Dx'</span></span><br><span class="line"></span><br><span class="line">[...str].reverse().join(<span class="string">''</span>)</span><br><span class="line">// <span class="string">'y\uD83D\uDE80x'</span></span><br></pre></td></tr></table></figure><p>上面代码中，如果不用扩展运算符，字符串的 reverse 操作就不正确。</p><h6 id="实现了-Iterator-接口的对象"><a href="#实现了-Iterator-接口的对象" class="headerlink" title="实现了 Iterator 接口的对象"></a>实现了 Iterator 接口的对象</h6><p>任何 Iterator 接口的对象，都可以用扩展运算符转为真正的数组。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var nodeList = document.querySelectorAll(<span class="string">'div'</span>);</span><br><span class="line">var array = [...nodeList];</span><br></pre></td></tr></table></figure><p>上面代码中，querySelectorAll 方法返回的是一个 nodeList 对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于 NodeList 对象实现了 Iterator 接口。</p><p>对于那些没有部署 Iterator 接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arrayLike = &#123;</span><br><span class="line">  <span class="string">'0'</span>: <span class="string">'a'</span>,</span><br><span class="line">  <span class="string">'1'</span>: <span class="string">'b'</span>,</span><br><span class="line">  <span class="string">'2'</span>: <span class="string">'c'</span>,</span><br><span class="line">  length: 3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// TypeError: Cannot spread non-iterable object.</span><br><span class="line"><span class="built_in">let</span> arr = [...arrayLike];</span><br></pre></td></tr></table></figure><p>上面代码中，arrayLike 是一个类似数组的对象，但是没有部署 Iterator 接口，扩展运算符就会报错。这时，可以改为使用 Array.from 方法将 arrayLike 转为真正的数组。</p><h6 id="Map-和-Set-结构，Generator-函数"><a href="#Map-和-Set-结构，Generator-函数" class="headerlink" title="Map 和 Set 结构，Generator 函数"></a>Map 和 Set 结构，Generator 函数</h6><p>扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符，比如 Map 结构。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> map = new Map([</span><br><span class="line">  [1, <span class="string">'one'</span>],</span><br><span class="line">  [2, <span class="string">'two'</span>],</span><br><span class="line">  [3, <span class="string">'three'</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> arr = [...map.keys()]; // [1, 2, 3]</span><br></pre></td></tr></table></figure><p>Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var go = <span class="keyword">function</span>*()&#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  yield 2;</span><br><span class="line">  yield 3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[...go()] // [1, 2, 3]</span><br></pre></td></tr></table></figure><p>上面代码中，变量 go 是一个 Generator 函数，执行后返回的是一个遍历器对象，对这个遍历器对象执行扩展运算符，就会将内部遍历得到的值，转为一个数组。</p><p>如果对没有 iterator 接口的对象，使用扩展运算符，将会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;a: 1, b: 2&#125;;</span><br><span class="line"><span class="built_in">let</span> arr = [...obj]; // TypeError: Cannot spread non-iterable object</span><br></pre></td></tr></table></figure><h5 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h5><p>从 ES5 开始，函数内部可以设定为严格模式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> doSomething(a, b) &#123;</span><br><span class="line">  <span class="string">'use strict'</span>;</span><br><span class="line">  // code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>《ECMAScript 2016 标准》做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line"><span class="keyword">function</span> doSomething(a, b = a) &#123;</span><br><span class="line">  <span class="string">'use strict'</span>;</span><br><span class="line">  // code</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 报错</span><br><span class="line">const doSomething = <span class="keyword">function</span> (&#123;a, b&#125;) &#123;</span><br><span class="line">  <span class="string">'use strict'</span>;</span><br><span class="line">  // code</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 报错</span><br><span class="line">const doSomething = (...a) =&gt; &#123;</span><br><span class="line">  <span class="string">'use strict'</span>;</span><br><span class="line">  // code</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const obj = &#123;</span><br><span class="line">  // 报错</span><br><span class="line">  doSomething(&#123;a, b&#125;) &#123;</span><br><span class="line">    <span class="string">'use strict'</span>;</span><br><span class="line">    // code</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样规定的原因是，函数内部的严格模式，同时适用于函数体代码和函数参数代码。但是，函数执行的时候，先执行函数参数代码，然后再执行函数体代码。这样就有一个不合理的地方，只有从函数体代码之中，才能知道参数代码是否应该以严格模式执行，但是参数代码却应该先于函数体代码执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line"><span class="keyword">function</span> doSomething(value = 070) &#123;</span><br><span class="line">  <span class="string">'use strict'</span>;</span><br><span class="line">  <span class="built_in">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，参数 value 的默认值是八进制数 070，但是严格模式下不能用前缀 0 表示八进制，所以应该报错。但是实际上，JavaScript 引擎会先成功执行 value = 070，然后进入函数体内部，发现需要用严格模式执行，这时才会报错。</p><p>虽然可以先解析函数体代码，再执行参数代码，但是这样无疑就增加了复杂性。因此，标准索性禁止了这种用法，只要参数使用了默认值、解构赋值、或者扩展运算符，就不能显式指定严格模式。</p><p>两种方法可以规避这种限制。第一种是设定全局性的严格模式，这是合法的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> doSomething(a, b = a) &#123;</span><br><span class="line">  // code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种是把函数包在一个无参数的立即执行函数里面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const doSomething = (<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  <span class="string">'use strict'</span>;</span><br><span class="line">  <span class="built_in">return</span> <span class="keyword">function</span>(value = 42) &#123;</span><br><span class="line">    <span class="built_in">return</span> value;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><h5 id="name-属性"><a href="#name-属性" class="headerlink" title="name 属性"></a>name 属性</h5><p>函数的 name 属性，返回该函数的函数名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;&#125;</span><br><span class="line">foo.name // <span class="string">"foo"</span></span><br></pre></td></tr></table></figure><p>这个属性早就被浏览器广泛支持，但是直到 ES6，才将其写入了标准。</p><p>需要注意的是，ES6 对这个属性的行为做出了一些修改。如果将一个匿名函数赋值给一个变量，ES5 的 name 属性，会返回空字符串，而 ES6 的 name 属性会返回实际的函数名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var func1 = <span class="function"><span class="title">function</span></span> () &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// ES5</span><br><span class="line">func1.name // <span class="string">""</span></span><br><span class="line"></span><br><span class="line">// ES6</span><br><span class="line">func1.name // <span class="string">"func1"</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量 func1 等于一个匿名函数，ES5 和 ES6 的 name 属性返回的值不一样。</p><p>如果将一个具名函数赋值给一个变量，则 ES5 和 ES6 的 name 属性都返回这个具名函数原本的名字。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const bar = <span class="keyword">function</span> <span class="function"><span class="title">baz</span></span>() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// ES5</span><br><span class="line">bar.name // <span class="string">"baz"</span></span><br><span class="line"></span><br><span class="line">// ES6</span><br><span class="line">bar.name // <span class="string">"baz"</span></span><br></pre></td></tr></table></figure><p>Function 构造函数返回的函数实例，name 属性的值为“anonymous”。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(new Function).name // <span class="string">"anonymous"</span></span><br></pre></td></tr></table></figure><p>bind 返回的函数，name 属性值会加上“bound ”前缀。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;&#125;;</span><br><span class="line">foo.bind(&#123;&#125;).name // <span class="string">"bound foo"</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="title">function</span></span>()&#123;&#125;).<span class="built_in">bind</span>(&#123;&#125;).name // <span class="string">"bound "</span></span><br></pre></td></tr></table></figure><h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><h5 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h5><p>ES6 允许使用“箭头”（=&gt;）定义函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var f = v =&gt; v;</span><br></pre></td></tr></table></figure><p>上面的箭头函数等同于：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var f = <span class="keyword">function</span>(v) &#123;</span><br><span class="line">  <span class="built_in">return</span> v;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var f = () =&gt; 5;</span><br><span class="line">// 等同于</span><br><span class="line">var f = <span class="function"><span class="title">function</span></span> () &#123; <span class="built_in">return</span> 5 &#125;;</span><br><span class="line"></span><br><span class="line">var sum = (num1, num2) =&gt; num1 + num2;</span><br><span class="line">// 等同于</span><br><span class="line">var sum = <span class="keyword">function</span>(num1, num2) &#123;</span><br><span class="line">  <span class="built_in">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用 return 语句返回。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var sum = (num1, num2) =&gt; &#123; <span class="built_in">return</span> num1 + num2; &#125;</span><br></pre></td></tr></table></figure><p>由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var getTempItem = id =&gt; (&#123; id: id, name: <span class="string">"Temp"</span> &#125;);</span><br></pre></td></tr></table></figure><p>箭头函数可以与变量解构结合使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const full = (&#123; first, last &#125;) =&gt; first + <span class="string">' '</span> + last;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line"><span class="keyword">function</span> full(person) &#123;</span><br><span class="line">  <span class="built_in">return</span> person.first + <span class="string">' '</span> + person.last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>箭头函数使得表达更加简洁。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const isEven = n =&gt; n % 2 == 0;</span><br><span class="line">const square = n =&gt; n * n;</span><br></pre></td></tr></table></figure><p>上面代码只用了两行，就定义了两个简单的工具函数。如果不用箭头函数，可能就要占用多行，而且还不如现在这样写醒目。</p><p>箭头函数的一个用处是简化回调函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 正常函数写法</span><br><span class="line">[1,2,3].map(<span class="keyword">function</span> (x) &#123;</span><br><span class="line">  <span class="built_in">return</span> x * x;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 箭头函数写法</span><br><span class="line">[1,2,3].map(x =&gt; x * x);</span><br><span class="line">另一个例子是</span><br><span class="line"></span><br><span class="line">// 正常函数写法</span><br><span class="line">var result = values.sort(<span class="keyword">function</span> (a, b) &#123;</span><br><span class="line">  <span class="built_in">return</span> a - b;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 箭头函数写法</span><br><span class="line">var result = values.sort((a, b) =&gt; a - b);</span><br></pre></td></tr></table></figure><p>下面是 rest 参数与箭头函数结合的例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const numbers = (...nums) =&gt; nums;</span><br><span class="line"></span><br><span class="line">numbers(1, 2, 3, 4, 5)</span><br><span class="line">// [1,2,3,4,5]</span><br><span class="line"></span><br><span class="line">const headAndTail = (head, ...tail) =&gt; [head, tail];</span><br><span class="line"></span><br><span class="line">headAndTail(1, 2, 3, 4, 5)</span><br><span class="line">// [1,[2,3,4,5]]</span><br></pre></td></tr></table></figure><h5 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h5><p>箭头函数有几个使用注意点。</p><p>（1）函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。</p><p>（2）不可以当作构造函数，也就是说，不可以使用 new 命令，否则会抛出一个错误。</p><p>（3）不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 Rest 参数代替。</p><p>（4）不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。</p><p>上面四点中，第一点尤其值得注意。this 对象的指向是可变的，但是在箭头函数中，它是固定的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(<span class="string">'id:'</span>, this.id);</span><br><span class="line">  &#125;, 100);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var id = 21;</span><br><span class="line"></span><br><span class="line">foo.call(&#123; id: 42 &#125;);</span><br><span class="line">// id: 42</span><br></pre></td></tr></table></figure><p>上面代码中，setTimeout 的参数是一个箭头函数，这个箭头函数的定义生效是在 foo 函数生成时，而它的真正执行要等到 100 毫秒后。如果是普通函数，执行时 this 应该指向全局对象 window，这时应该输出 21。但是，箭头函数导致 this 总是指向函数定义生效时所在的对象（本例是{id: 42}），所以输出的是 42。</p><p>箭头函数可以让 setTimeout 里面的 this，绑定定义时所在的作用域，而不是指向运行时所在的作用域。下面是另一个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Timer</span></span>() &#123;</span><br><span class="line">  this.s1 = 0;</span><br><span class="line">  this.s2 = 0;</span><br><span class="line">  // 箭头函数</span><br><span class="line">  setInterval(() =&gt; this.s1++, 1000);</span><br><span class="line">  // 普通函数</span><br><span class="line">  setInterval(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    this.s2++;</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var timer = new Timer();</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; console.log(<span class="string">'s1: '</span>, timer.s1), 3100);</span><br><span class="line">setTimeout(() =&gt; console.log(<span class="string">'s2: '</span>, timer.s2), 3100);</span><br><span class="line">// s1: 3</span><br><span class="line">// s2: 0</span><br></pre></td></tr></table></figure><p>上面代码中，Timer 函数内部设置了两个定时器，分别使用了箭头函数和普通函数。前者的 this 绑定定义时所在的作用域（即 Timer 函数），后者的 this 指向运行时所在的作用域（即全局对象）。所以，3100 毫秒之后，timer.s1 被更新了 3 次，而 timer.s2 一次都没更新。</p><p>箭头函数可以让 this 指向固定化，这种特性很有利于封装回调函数。下面是一个例子，DOM 事件的回调函数封装在一个对象里面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var handler = &#123;</span><br><span class="line">  id: <span class="string">'123456'</span>,</span><br><span class="line"></span><br><span class="line">  init: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    document.addEventListener(<span class="string">'click'</span>,</span><br><span class="line">      event =&gt; this.doSomething(event.type), <span class="literal">false</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  doSomething: <span class="keyword">function</span>(<span class="built_in">type</span>) &#123;</span><br><span class="line">    console.log(<span class="string">'Handling '</span> + <span class="built_in">type</span>  + <span class="string">' for '</span> + this.id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码的 init 方法中，使用了箭头函数，这导致这个箭头函数里面的 this，总是指向 handler 对象。否则，回调函数运行时，this.doSomething 这一行会报错，因为此时 this 指向 document 对象。</p><p>this 指向的固定化，并不是因为箭头函数内部有绑定 this 的机制，实际原因是箭头函数根本没有自己的 this，导致内部的 this 就是外层代码块的 this。正是因为它没有 this，所以也就不能用作构造函数。</p><p>所以，箭头函数转成 ES5 的代码如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// ES6</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(<span class="string">'id:'</span>, this.id);</span><br><span class="line">  &#125;, 100);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ES5</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">  var _this = this;</span><br><span class="line"></span><br><span class="line">  setTimeout(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(<span class="string">'id:'</span>, _this.id);</span><br><span class="line">  &#125;, 100);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，转换后的 ES5 版本清楚地说明了，箭头函数里面根本没有自己的 this，而是引用外层的 this。</p><p>请问下面的代码之中有几个 this？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> () =&gt; &#123;</span><br><span class="line">    <span class="built_in">return</span> () =&gt; &#123;</span><br><span class="line">      <span class="built_in">return</span> () =&gt; &#123;</span><br><span class="line">        console.log(<span class="string">'id:'</span>, this.id);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var f = foo.call(&#123;id: 1&#125;);</span><br><span class="line"></span><br><span class="line">var t1 = f.call(&#123;id: 2&#125;)()(); // id: 1</span><br><span class="line">var t2 = f().call(&#123;id: 3&#125;)(); // id: 1</span><br><span class="line">var t3 = f()().call(&#123;id: 4&#125;); // id: 1</span><br></pre></td></tr></table></figure><p>上面代码之中，只有一个 this，就是函数 foo 的 this，所以 t1、t2、t3 都输出同样的结果。因为所有的内层函数都是箭头函数，都没有自己的 this，它们的 this 其实都是最外层 foo 函数的 this。</p><p>除了 this，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：arguments、super、new.target。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(<span class="string">'args:'</span>, arguments);</span><br><span class="line">  &#125;, 100);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(2, 4, 6, 8)</span><br><span class="line">// args: [2, 4, 6, 8]</span><br></pre></td></tr></table></figure><p>上面代码中，箭头函数内部的变量 arguments，其实是函数 foo 的 arguments 变量。</p><p>另外，由于箭头函数没有自己的 this，所以当然也就不能用 call()、apply()、bind()这些方法去改变 this 的指向。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> [</span><br><span class="line">    (() =&gt; this.x).<span class="built_in">bind</span>(&#123; x: <span class="string">'inner'</span> &#125;)()</span><br><span class="line">  ];</span><br><span class="line">&#125;).call(&#123; x: <span class="string">'outer'</span> &#125;);</span><br><span class="line">// [<span class="string">'outer'</span>]</span><br></pre></td></tr></table></figure><p>上面代码中，箭头函数没有自己的 this，所以 bind 方法无效，内部的 this 指向外部的 this。</p><p>长期以来，JavaScript 语言的 this 对象一直是一个令人头痛的问题，在对象方法中使用 this，必须非常小心。箭头函数”绑定”this，很大程度上解决了这个困扰。</p><h5 id="嵌套的箭头函数"><a href="#嵌套的箭头函数" class="headerlink" title="嵌套的箭头函数"></a>嵌套的箭头函数</h5><p>箭头函数内部，还可以再使用箭头函数。下面是一个 ES5 语法的多重嵌套函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> insert(value) &#123;</span><br><span class="line">  <span class="built_in">return</span> &#123;into: <span class="keyword">function</span> (array) &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;after: <span class="keyword">function</span> (afterValue) &#123;</span><br><span class="line">      array.splice(array.indexOf(afterValue) + 1, 0, value);</span><br><span class="line">      <span class="built_in">return</span> array;</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">  &#125;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">insert(2).into([1, 3]).after(1); //[1, 2, 3]</span><br></pre></td></tr></table></figure><p>上面这个函数，可以使用箭头函数改写。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> insert = (value) =&gt; (&#123;into: (array) =&gt; (&#123;after: (afterValue) =&gt; &#123;</span><br><span class="line">  array.splice(array.indexOf(afterValue) + 1, 0, value);</span><br><span class="line">  <span class="built_in">return</span> array;</span><br><span class="line">&#125;&#125;)&#125;);</span><br><span class="line"></span><br><span class="line">insert(2).into([1, 3]).after(1); //[1, 2, 3]</span><br></pre></td></tr></table></figure><p>下面是一个部署管道机制（pipeline）的例子，即前一个函数的输出是后一个函数的输入。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const pipeline = (...funcs) =&gt;</span><br><span class="line">  val =&gt; funcs.reduce((a, b) =&gt; b(a), val);</span><br><span class="line"></span><br><span class="line">const plus1 = a =&gt; a + 1;</span><br><span class="line">const mult2 = a =&gt; a * 2;</span><br><span class="line">const addThenMult = pipeline(plus1, mult2);</span><br><span class="line"></span><br><span class="line">addThenMult(5)</span><br><span class="line">// 12</span><br></pre></td></tr></table></figure><p>如果觉得上面的写法可读性比较差，也可以采用下面的写法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const plus1 = a =&gt; a + 1;</span><br><span class="line">const mult2 = a =&gt; a * 2;</span><br><span class="line"></span><br><span class="line">mult2(plus1(5))</span><br><span class="line">// 12</span><br></pre></td></tr></table></figure><p>箭头函数还有一个功能，就是可以很方便地改写 λ 演算。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// λ演算的写法</span><br><span class="line">fix = λf.(λx.f(λv.x(x)(v)))(λx.f(λv.x(x)(v)))</span><br><span class="line"></span><br><span class="line">// ES6的写法</span><br><span class="line">var fix = f =&gt; (x =&gt; f(v =&gt; x(x)(v)))</span><br><span class="line">               (x =&gt; f(v =&gt; x(x)(v)));</span><br></pre></td></tr></table></figure><p>上面两种写法，几乎是一一对应的。由于 λ 演算对于计算机科学非常重要，这使得我们可以用 ES6 作为替代工具，探索计算机科学。</p><h5 id="绑定-this"><a href="#绑定-this" class="headerlink" title="绑定 this"></a>绑定 this</h5><p>箭头函数可以绑定 this 对象，大大减少了显式绑定 this 对象的写法（call、apply、bind）。但是，箭头函数并不适用于所有场合，所以 ES7 提出了“函数绑定”（function bind）运算符，用来取代 call、apply、bind 调用。虽然该语法还是 ES7 的一个提案，但是 Babel 转码器已经支持。</p><p>函数绑定运算符是并排的两个双冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即 this 对象），绑定到右边的函数上面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">foo::bar;</span><br><span class="line">// 等同于</span><br><span class="line">bar.bind(foo);</span><br><span class="line"></span><br><span class="line">foo::bar(...arguments);</span><br><span class="line">// 等同于</span><br><span class="line">bar.apply(foo, arguments);</span><br><span class="line"></span><br><span class="line">const hasOwnProperty = Object.prototype.hasOwnProperty;</span><br><span class="line"><span class="keyword">function</span> hasOwn(obj, key) &#123;</span><br><span class="line">  <span class="built_in">return</span> obj::hasOwnProperty(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var method = obj::obj.foo;</span><br><span class="line">// 等同于</span><br><span class="line">var method = ::obj.foo;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> <span class="built_in">log</span> = ::console.log;</span><br><span class="line">// 等同于</span><br><span class="line">var <span class="built_in">log</span> = console.log.bind(console);</span><br></pre></td></tr></table></figure><p>由于双冒号运算符返回的还是原对象，因此可以采用链式写法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 例一</span><br><span class="line">import &#123; map, takeWhile, forEach &#125; from <span class="string">"iterlib"</span>;</span><br><span class="line"></span><br><span class="line">getPlayers()</span><br><span class="line">::map(x =&gt; x.character())</span><br><span class="line">::takeWhile(x =&gt; x.strength &gt; 100)</span><br><span class="line">::forEach(x =&gt; console.log(x));</span><br><span class="line"></span><br><span class="line">// 例二</span><br><span class="line"><span class="built_in">let</span> &#123; find, html &#125; = jake;</span><br><span class="line"></span><br><span class="line">document.querySelectorAll(<span class="string">"div.myClass"</span>)</span><br><span class="line">::find(<span class="string">"p"</span>)</span><br><span class="line">::html(<span class="string">"hahaha"</span>);</span><br></pre></td></tr></table></figure><h4 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h4><h5 id="什么是尾调用？"><a href="#什么是尾调用？" class="headerlink" title="什么是尾调用？"></a>什么是尾调用？</h5><p>尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> f(x)&#123;</span><br><span class="line">  <span class="built_in">return</span> g(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，函数 f 的最后一步是调用函数 g，这就叫尾调用。</p><p>以下三种情况，都不属于尾调用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 情况一</span><br><span class="line"><span class="keyword">function</span> f(x)&#123;</span><br><span class="line">  <span class="built_in">let</span> y = g(x);</span><br><span class="line">  <span class="built_in">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 情况二</span><br><span class="line"><span class="keyword">function</span> f(x)&#123;</span><br><span class="line">  <span class="built_in">return</span> g(x) + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 情况三</span><br><span class="line"><span class="keyword">function</span> f(x)&#123;</span><br><span class="line">  g(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，情况一是调用函数 g 之后，还有赋值操作，所以不属于尾调用，即使语义完全一样。情况二也属于调用后还有操作，即使写在一行内。情况三等同于下面的代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> f(x)&#123;</span><br><span class="line">  g(x);</span><br><span class="line">  <span class="built_in">return</span> undefined;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尾调用不一定出现在函数尾部，只要是最后一步操作即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> f(x) &#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; 0) &#123;</span><br><span class="line">    <span class="built_in">return</span> m(x)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> n(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，函数 m 和 n 都属于尾调用，因为它们都是函数 f 的最后一步操作。</p><h5 id="尾调用优化-1"><a href="#尾调用优化-1" class="headerlink" title="尾调用优化"></a>尾调用优化</h5><p>尾调用之所以与其他调用不同，就在于它的特殊的调用位置。</p><p>我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数 A 的内部调用函数 B，那么在 A 的调用帧上方，还会形成一个 B 的调用帧。等到 B 运行结束，将结果返回到 A，B 的调用帧才会消失。如果函数 B 内部还调用函数 C，那就还有一个 C 的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。</p><p>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  <span class="built_in">let</span> m = 1;</span><br><span class="line">  <span class="built_in">let</span> n = 2;</span><br><span class="line">  <span class="built_in">return</span> g(m + n);</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> g(3);</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">g(3);</span><br></pre></td></tr></table></figure><p>上面代码中，如果函数 g 不是尾调用，函数 f 就需要保存内部变量 m 和 n 的值、g 的调用位置等信息。但由于调用 g 之后，函数 f 就结束了，所以执行到最后一步，完全可以删除 f(x) 的调用帧，只保留 g(3) 的调用帧。</p><p>这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。</p><p>注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> addOne(a)&#123;</span><br><span class="line">  var one = 1;</span><br><span class="line">  <span class="keyword">function</span> inner(b)&#123;</span><br><span class="line">    <span class="built_in">return</span> b + one;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> inner(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数不会进行尾调用优化，因为内层函数 inner 用到了外层函数 addOne 的内部变量 one。</p><h5 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h5><p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</p><p>递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> factorial(n) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n === 1) <span class="built_in">return</span> 1;</span><br><span class="line">  <span class="built_in">return</span> n * factorial(n - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(5) // 120</span><br></pre></td></tr></table></figure><p>上面代码是一个阶乘函数，计算 n 的阶乘，最多需要保存 n 个调用记录，复杂度 O(n) 。</p><p>如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> factorial(n, total) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n === 1) <span class="built_in">return</span> total;</span><br><span class="line">  <span class="built_in">return</span> factorial(n - 1, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(5, 1) // 120</span><br></pre></td></tr></table></figure><p>还有一个比较著名的例子，就是计算 fibonacci 数列，也能充分说明尾递归优化的重要性</p><p>如果是非尾递归的 fibonacci 递归方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Fibonacci (n) &#123;</span><br><span class="line">  <span class="keyword">if</span> ( n &lt;= 1 ) &#123;<span class="built_in">return</span> 1&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> Fibonacci(n - 1) + Fibonacci(n - 2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Fibonacci(10); // 89</span><br><span class="line">// Fibonacci(100)</span><br><span class="line">// Fibonacci(500)</span><br><span class="line">// 堆栈溢出了</span><br></pre></td></tr></table></figure><p>如果我们使用尾递归优化过的 fibonacci 递归算法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Fibonacci2 (n , ac1 = 1 , ac2 = 1) &#123;</span><br><span class="line">  <span class="keyword">if</span>( n &lt;= 1 ) &#123;<span class="built_in">return</span> ac2&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> Fibonacci2 (n - 1, ac2, ac1 + ac2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Fibonacci2(100) // 573147844013817200000</span><br><span class="line">Fibonacci2(1000) // 7.0330367711422765e+208</span><br><span class="line">Fibonacci2(10000) // Infinity</span><br></pre></td></tr></table></figure><p>由此可见，“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6 也是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署“尾调用优化”。这就是说，在 ES6 中，只要使用尾递归，就不会发生栈溢出，相对节省内存。</p><h5 id="递归函数的改写"><a href="#递归函数的改写" class="headerlink" title="递归函数的改写"></a>递归函数的改写</h5><p>尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。比如上面的例子，阶乘函数 factorial 需要用到一个中间变量 total ，那就把这个中间变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，为什么计算 5 的阶乘，需要传入两个参数 5 和 1？</p><p>两个方法可以解决这个问题。方法一是在尾递归函数之外，再提供一个正常形式的函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> tailFactorial(n, total) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n === 1) <span class="built_in">return</span> total;</span><br><span class="line">  <span class="built_in">return</span> tailFactorial(n - 1, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> factorial(n) &#123;</span><br><span class="line">  <span class="built_in">return</span> tailFactorial(n, 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(5) // 120</span><br></pre></td></tr></table></figure><p>上面代码通过一个正常形式的阶乘函数 factorial ，调用尾递归函数 tailFactorial ，看起来就正常多了。</p><p>函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> currying(fn, n) &#123;</span><br><span class="line">  <span class="built_in">return</span> <span class="keyword">function</span> (m) &#123;</span><br><span class="line">    <span class="built_in">return</span> fn.call(this, m, n);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> tailFactorial(n, total) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n === 1) <span class="built_in">return</span> total;</span><br><span class="line">  <span class="built_in">return</span> tailFactorial(n - 1, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const factorial = currying(tailFactorial, 1);</span><br><span class="line"></span><br><span class="line">factorial(5) // 120</span><br></pre></td></tr></table></figure><p>上面代码通过柯里化，将尾递归函数 tailFactorial 变为只接受 1 个参数的 factorial 。</p><p>第二种方法就简单多了，就是采用 ES6 的函数默认值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> factorial(n, total = 1) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n === 1) <span class="built_in">return</span> total;</span><br><span class="line">  <span class="built_in">return</span> factorial(n - 1, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(5) // 120</span><br></pre></td></tr></table></figure><p>上面代码中，参数 total 有默认值 1，所以调用时不用提供这个值。</p><p>总结一下，递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。对于其他支持“尾调用优化”的语言（比如 Lua，ES6），只需要知道循环可以用递归代替，而一旦使用递归，就最好使用尾递归。</p><h5 id="严格模式-1"><a href="#严格模式-1" class="headerlink" title="严格模式"></a>严格模式</h5><p>ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。</p><p>这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。</p><p>1.func.arguments：返回调用时函数的参数。<br>2.func.caller：返回调用当前函数的那个函数。<br>尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">restricted</span></span>() &#123;</span><br><span class="line">  <span class="string">"use strict"</span>;</span><br><span class="line">  restricted.caller;    // 报错</span><br><span class="line">  restricted.arguments; // 报错</span><br><span class="line">&#125;</span><br><span class="line">restricted();</span><br></pre></td></tr></table></figure><h5 id="尾递归优化的实现"><a href="#尾递归优化的实现" class="headerlink" title="尾递归优化的实现"></a>尾递归优化的实现</h5><p>尾递归优化只在严格模式下生效，那么正常模式下，或者那些不支持该功能的环境中，有没有办法也使用尾递归优化呢？回答是可以的，就是自己实现尾递归优化。</p><p>它的原理非常简单。尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是采用“循环”换掉“递归”。</p><p>下面是一个正常的递归函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> sum(x, y) &#123;</span><br><span class="line">  <span class="keyword">if</span> (y &gt; 0) &#123;</span><br><span class="line">    <span class="built_in">return</span> sum(x + 1, y - 1);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(1, 100000)</span><br><span class="line">// Uncaught RangeError: Maximum call stack size exceeded(…)</span><br></pre></td></tr></table></figure><p>上面代码中，sum 是一个递归函数，参数 x 是需要累加的值，参数 y 控制递归次数。一旦指定 sum 递归 100000 次，就会报错，提示超出调用栈的最大次数。</p><p>蹦床函数（trampoline）可以将递归执行转为循环执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> trampoline(f) &#123;</span><br><span class="line">  <span class="keyword">while</span> (f &amp;&amp; f instanceof Function) &#123;</span><br><span class="line">    f = f();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是蹦床函数的一个实现，它接受一个函数 f 作为参数。只要 f 执行后返回一个函数，就继续执行。注意，这里是返回一个函数，然后执行该函数，而不是函数里面调用函数，这样就避免了递归执行，从而就消除了调用栈过大的问题。</p><p>然后，要做的就是将原来的递归函数，改写为每一步返回另一个函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> sum(x, y) &#123;</span><br><span class="line">  <span class="keyword">if</span> (y &gt; 0) &#123;</span><br><span class="line">    <span class="built_in">return</span> sum.bind(null, x + 1, y - 1);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，sum 函数的每次执行，都会返回自身的另一个版本。</p><p>现在，使用蹦床函数执行 sum，就不会发生调用栈溢出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">trampoline(sum(1, 100000))</span><br><span class="line">// 100001</span><br></pre></td></tr></table></figure><p>蹦床函数并不是真正的尾递归优化，下面的实现才是。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> tco(f) &#123;</span><br><span class="line">  var value;</span><br><span class="line">  var active = <span class="literal">false</span>;</span><br><span class="line">  var accumulated = [];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> <span class="keyword">function</span> <span class="function"><span class="title">accumulator</span></span>() &#123;</span><br><span class="line">    accumulated.push(arguments);</span><br><span class="line">    <span class="keyword">if</span> (!active) &#123;</span><br><span class="line">      active = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">while</span> (accumulated.length) &#123;</span><br><span class="line">        value = f.apply(this, accumulated.shift());</span><br><span class="line">      &#125;</span><br><span class="line">      active = <span class="literal">false</span>;</span><br><span class="line">      <span class="built_in">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var sum = tco(<span class="keyword">function</span>(x, y) &#123;</span><br><span class="line">  <span class="keyword">if</span> (y &gt; 0) &#123;</span><br><span class="line">    <span class="built_in">return</span> sum(x + 1, y - 1)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">return</span> x</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">sum(1, 100000)</span><br><span class="line">// 100001</span><br></pre></td></tr></table></figure><p>上面代码中，tco 函数是尾递归优化的实现，它的奥妙就在于状态变量 active。默认情况下，这个变量是不激活的。一旦进入尾递归优化的过程，这个变量就激活了。然后，每一轮递归 sum 返回的都是 undefined，所以就避免了递归执行；而 accumulated 数组存放每一轮 sum 执行的参数，总是有值的，这就保证了 accumulator 函数内部的 while 循环总是会执行。这样就很巧妙地将“递归”改成了“循环”，而后一轮的参数会取代前一轮的参数，保证了调用栈只有一层。</p><h5 id="函数参数的尾逗号"><a href="#函数参数的尾逗号" class="headerlink" title="函数参数的尾逗号"></a>函数参数的尾逗号</h5><p>ECMAScript 2017 将允许函数的最后一个参数有尾逗号（trailing comma）。</p><p>此前，函数定义和调用时，都不允许最后一个参数后面出现逗号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> clownsEverywhere(</span><br><span class="line">  param1,</span><br><span class="line">  param2</span><br><span class="line">) &#123; /* ... */ &#125;</span><br><span class="line"></span><br><span class="line">clownsEverywhere(</span><br><span class="line">  <span class="string">'foo'</span>,</span><br><span class="line">  <span class="string">'bar'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面代码中，如果在 param2 或 bar 后面加一个逗号，就会报错。</p><p>这样的话，如果以后修改代码，想为函数 clownsEverywhere 添加第三个参数，就势必要在第二个参数后面添加一个逗号。这对版本管理系统来说，就会显示，添加逗号的那一行也发生了变动。这看上去有点冗余，因此新的语法允许定义和调用时，尾部直接有一个逗号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> clownsEverywhere(</span><br><span class="line">  param1,</span><br><span class="line">  param2,</span><br><span class="line">) &#123; /* ... */ &#125;</span><br><span class="line"></span><br><span class="line">clownsEverywhere(</span><br><span class="line">  <span class="string">'foo'</span>,</span><br><span class="line">  <span class="string">'bar'</span>,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6_Array</title>
      <link href="/2019/01/20/es6-Array/"/>
      <url>/2019/01/20/es6-Array/</url>
      
        <content type="html"><![CDATA[<h3 id="ES6-数组的扩展"><a href="#ES6-数组的扩展" class="headerlink" title="ES6 数组的扩展"></a>ES6 数组的扩展</h3><h4 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h4><p>Array.from 方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。</p><p>下面是一个类似数组的对象，Array.from 将它转为真正的数组。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arrayLike = &#123;</span><br><span class="line">    <span class="string">'0'</span>: <span class="string">'a'</span>,</span><br><span class="line">    <span class="string">'1'</span>: <span class="string">'b'</span>,</span><br><span class="line">    <span class="string">'2'</span>: <span class="string">'c'</span>,</span><br><span class="line">    length: 3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// ES5的写法</span><br><span class="line">var arr1 = [].slice.call(arrayLike); // [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"></span><br><span class="line">// ES6的写法</span><br><span class="line"><span class="built_in">let</span> arr2 = Array.from(arrayLike); // [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br></pre></td></tr></table></figure><p>实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的 arguments 对象。Array.from 都可以将它们转为真正的数组。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// NodeList对象</span><br><span class="line"><span class="built_in">let</span> ps = document.querySelectorAll(<span class="string">'p'</span>);</span><br><span class="line">Array.from(ps).forEach(<span class="keyword">function</span> (p) &#123;</span><br><span class="line">  console.log(p);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// arguments对象</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">  var args = Array.from(arguments);</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，querySelectorAll 方法返回的是一个类似数组的对象，只有将这个对象转为真正的数组，才能使用 forEach 方法。</p><p>只要是部署了 Iterator 接口的数据结构，Array.from 都能将其转为数组。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Array.from(<span class="string">'hello'</span>)</span><br><span class="line">// [<span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> namesSet = new Set([<span class="string">'a'</span>, <span class="string">'b'</span>])</span><br><span class="line">Array.from(namesSet) // [<span class="string">'a'</span>, <span class="string">'b'</span>]</span><br></pre></td></tr></table></figure><p>上面代码中，字符串和 Set 结构都具有 Iterator 接口，因此可以被 Array.from 转为真正的数组。</p><p>如果参数是一个真正的数组，Array.from 会返回一个一模一样的新数组。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array.from([1, 2, 3])</span><br><span class="line">// [1, 2, 3]</span><br></pre></td></tr></table></figure><p>值得提醒的是，扩展运算符（…）也可以将某些数据结构转为数组。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// arguments对象</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">  var args = [...arguments];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// NodeList对象</span><br><span class="line">[...document.querySelectorAll(<span class="string">'div'</span>)]</span><br></pre></td></tr></table></figure><p>扩展运算符背后调用的是遍历器接口（Symbol.iterator），如果一个对象没有部署这个接口，就无法转换。Array.from 方法则是还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有 length 属性。因此，任何有 length 属性的对象，都可以通过 Array.from 方法转为数组，而此时扩展运算符就无法转换。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array.from(&#123; length: 3 &#125;);</span><br><span class="line">// [ undefined, undefined, undefined ]</span><br></pre></td></tr></table></figure><p>上面代码中，Array.from 返回了一个具有三个成员的数组，每个位置的值都是 undefined。扩展运算符转换不了这个对象。</p><p>对于还没有部署该方法的浏览器，可以用 Array.prototype.slice 方法替代。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const toArray = (() =&gt;</span><br><span class="line">  Array.from ? Array.from : obj =&gt; [].slice.call(obj)</span><br><span class="line">)();</span><br></pre></td></tr></table></figure><p>Array.from 还可以接受第二个参数，作用类似于数组的 map 方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Array.from(arrayLike, x =&gt; x * x);</span><br><span class="line">// 等同于</span><br><span class="line">Array.from(arrayLike).map(x =&gt; x * x);</span><br><span class="line"></span><br><span class="line">Array.from([1, 2, 3], (x) =&gt; x * x)</span><br><span class="line">// [1, 4, 9]</span><br></pre></td></tr></table></figure><p>下面的例子是取出一组 DOM 节点的文本内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> spans = document.querySelectorAll(<span class="string">'span.name'</span>);</span><br><span class="line"></span><br><span class="line">// map()</span><br><span class="line"><span class="built_in">let</span> names1 = Array.prototype.map.call(spans, s =&gt; s.textContent);</span><br><span class="line"></span><br><span class="line">// Array.from()</span><br><span class="line"><span class="built_in">let</span> names2 = Array.from(spans, s =&gt; s.textContent)</span><br></pre></td></tr></table></figure><p>下面的例子将数组中布尔值为 false 的成员转为 0。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array.from([1, , 2, , 3], (n) =&gt; n || 0)</span><br><span class="line">// [1, 0, 2, 0, 3]</span><br></pre></td></tr></table></figure><p>另一个例子是返回各种数据的类型。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">typesOf</span></span> () &#123;</span><br><span class="line">  <span class="built_in">return</span> Array.from(arguments, value =&gt; typeof value)</span><br><span class="line">&#125;</span><br><span class="line">typesOf(null, [], NaN)</span><br><span class="line">// [<span class="string">'object'</span>, <span class="string">'object'</span>, <span class="string">'number'</span>]</span><br></pre></td></tr></table></figure><p>如果 map 函数里面用到了 this 关键字，还可以传入 Array.from 的第三个参数，用来绑定 this。</p><p>Array.from()可以将各种值转为真正的数组，并且还提供 map 功能。这实际上意味着，只要有一个原始的数据结构，你就可以先对它的值进行处理，然后转成规范的数组结构，进而就可以使用数量众多的数组方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array.from(&#123; length: 2 &#125;, () =&gt; <span class="string">'jack'</span>)</span><br><span class="line">// [<span class="string">'jack'</span>, <span class="string">'jack'</span>]</span><br></pre></td></tr></table></figure><p>上面代码中，Array.from 的第一个参数指定了第二个参数运行的次数。这种特性可以让该方法的用法变得非常灵活。</p><p>Array.from()的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种 Unicode 字符，可以避免 JavaScript 将大于\uFFFF 的 Unicode 字符，算作两个字符的 bug。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> countSymbols(string) &#123;</span><br><span class="line">  <span class="built_in">return</span> Array.from(string).length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h4><p>Array.of 方法用于将一组值，转换为数组。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Array.of(3, 11, 8) // [3,11,8]</span><br><span class="line">Array.of(3) // [3]</span><br><span class="line">Array.of(3).length // 1</span><br></pre></td></tr></table></figure><p>这个方法的主要目的，是弥补数组构造函数 Array()的不足。因为参数个数的不同，会导致 Array()的行为有差异。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Array() // []</span><br><span class="line">Array(3) // [, , ,]</span><br><span class="line">Array(3, 11, 8) // [3, 11, 8]</span><br></pre></td></tr></table></figure><p>上面代码中，Array 方法没有参数、一个参数、三个参数时，返回结果都不一样。只有当参数个数不少于 2 个时，Array()才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。</p><p>Array.of 基本上可以用来替代 Array()或 new Array()，并且不存在由于参数不同而导致的重载。它的行为非常统一。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Array.of() // []</span><br><span class="line">Array.of(undefined) // [undefined]</span><br><span class="line">Array.of(1) // [1]</span><br><span class="line">Array.of(1, 2) // [1, 2]</span><br></pre></td></tr></table></figure><p>Array.of 总是返回参数值组成的数组。如果没有参数，就返回一个空数组。</p><p>Array.of 方法可以用下面的代码模拟实现。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">ArrayOf</span></span>()&#123;</span><br><span class="line">  <span class="built_in">return</span> [].slice.call(arguments);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组实例的-copyWithin"><a href="#数组实例的-copyWithin" class="headerlink" title="数组实例的 copyWithin()"></a>数组实例的 copyWithin()</h4><p>数组实例的 copyWithin 方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。</p><p>Array.prototype.copyWithin(target, start = 0, end = this.length)<br>它接受三个参数。</p><p>1.target（必需）：从该位置开始替换数据。<br>2.start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示倒数。<br>3.end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。<br>这三个参数都应该是数值，如果不是，会自动转为数值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4, 5].copyWithin(0, 3)</span><br><span class="line">// [4, 5, 3, 4, 5]</span><br></pre></td></tr></table></figure><p>上面代码表示将从 3 号位直到数组结束的成员（4 和 5），复制到从 0 号位开始的位置，结果覆盖了原来的 1 和 2。</p><p>下面是更多例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 将3号位复制到0号位</span><br><span class="line">[1, 2, 3, 4, 5].copyWithin(0, 3, 4)</span><br><span class="line">// [4, 2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">// -2相当于3号位，-1相当于4号位</span><br><span class="line">[1, 2, 3, 4, 5].copyWithin(0, -2, -1)</span><br><span class="line">// [4, 2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">// 将3号位复制到0号位</span><br><span class="line">[].copyWithin.call(&#123;length: 5, 3: 1&#125;, 0, 3)</span><br><span class="line">// &#123;0: 1, 3: 1, length: 5&#125;</span><br><span class="line"></span><br><span class="line">// 将2号位到数组结束，复制到0号位</span><br><span class="line">var i32a = new Int32Array([1, 2, 3, 4, 5]);</span><br><span class="line">i32a.copyWithin(0, 2);</span><br><span class="line">// Int32Array [3, 4, 5, 4, 5]</span><br><span class="line"></span><br><span class="line">// 对于没有部署TypedArray的copyWithin方法的平台</span><br><span class="line">// 需要采用下面的写法</span><br><span class="line">[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4);</span><br><span class="line">// Int32Array [4, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure><h4 id="数组实例的-find-和-findIndex"><a href="#数组实例的-find-和-findIndex" class="headerlink" title="数组实例的 find()和 findIndex()"></a>数组实例的 find()和 findIndex()</h4><p>数组实例的 find 方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为 true 的成员，然后返回该成员。如果没有符合条件的成员，则返回 undefined。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 4, -5, 10].find((n) =&gt; n &lt; 0)</span><br><span class="line">// -5</span><br></pre></td></tr></table></figure><p>上面代码找出数组中第一个小于 0 的成员。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[1, 5, 10, 15].find(<span class="keyword">function</span>(value, index, arr) &#123;</span><br><span class="line">  <span class="built_in">return</span> value &gt; 9;</span><br><span class="line">&#125;) // 10</span><br></pre></td></tr></table></figure><p>上面代码中，find 方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。</p><p>数组实例的 findIndex 方法的用法与 find 方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[1, 5, 10, 15].findIndex(<span class="keyword">function</span>(value, index, arr) &#123;</span><br><span class="line">  <span class="built_in">return</span> value &gt; 9;</span><br><span class="line">&#125;) // 2</span><br></pre></td></tr></table></figure><p>这两个方法都可以接受第二个参数，用来绑定回调函数的 this 对象。</p><p>另外，这两个方法都可以发现 NaN，弥补了数组的 IndexOf 方法的不足。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[NaN].indexOf(NaN)</span><br><span class="line">// -1</span><br><span class="line"></span><br><span class="line">[NaN].findIndex(y =&gt; Object.is(NaN, y))</span><br><span class="line">// 0</span><br></pre></td></tr></table></figure><p>上面代码中，indexOf 方法无法识别数组的 NaN 成员，但是 findIndex 方法可以借助 Object.is 方法做到。</p><h4 id="数组实例的-fill"><a href="#数组实例的-fill" class="headerlink" title="数组实例的 fill()"></a>数组实例的 fill()</h4><p>fill 方法使用给定值，填充一个数组。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].fill(7)</span><br><span class="line">// [7, 7, 7]</span><br><span class="line"></span><br><span class="line">new Array(3).fill(7)</span><br><span class="line">// [7, 7, 7]</span><br></pre></td></tr></table></figure><p>上面代码表明，fill 方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。</p><p>fill 方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].fill(7, 1, 2)</span><br><span class="line">// [<span class="string">'a'</span>, 7, <span class="string">'c'</span>]</span><br></pre></td></tr></table></figure><p>上面代码表示，fill 方法从 1 号位开始，向原数组填充 7，到 2 号位之前结束。</p><h4 id="数组实例的-entries-，keys-和-values"><a href="#数组实例的-entries-，keys-和-values" class="headerlink" title="数组实例的 entries()，keys()和 values()"></a>数组实例的 entries()，keys()和 values()</h4><p>ES6 提供三个新的方法——entries()，keys()和 values()——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用 for…of 循环进行遍历，唯一的区别是 keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> index of [<span class="string">'a'</span>, <span class="string">'b'</span>].keys()) &#123;</span><br><span class="line">  console.log(index);</span><br><span class="line">&#125;</span><br><span class="line">// 0</span><br><span class="line">// 1</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> elem of [<span class="string">'a'</span>, <span class="string">'b'</span>].values()) &#123;</span><br><span class="line">  console.log(elem);</span><br><span class="line">&#125;</span><br><span class="line">// <span class="string">'a'</span></span><br><span class="line">// <span class="string">'b'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> [index, elem] of [<span class="string">'a'</span>, <span class="string">'b'</span>].entries()) &#123;</span><br><span class="line">  console.log(index, elem);</span><br><span class="line">&#125;</span><br><span class="line">// 0 <span class="string">"a"</span></span><br><span class="line">// 1 <span class="string">"b"</span></span><br></pre></td></tr></table></figure><p>如果不使用 for…of 循环，可以手动调用遍历器对象的 next 方法，进行遍历。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> letter = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="built_in">let</span> entries = letter.entries();</span><br><span class="line">console.log(entries.next().value); // [0, <span class="string">'a'</span>]</span><br><span class="line">console.log(entries.next().value); // [1, <span class="string">'b'</span>]</span><br><span class="line">console.log(entries.next().value); // [2, <span class="string">'c'</span>]</span><br></pre></td></tr></table></figure><h4 id="数组实例的-includes"><a href="#数组实例的-includes" class="headerlink" title="数组实例的 includes()"></a>数组实例的 includes()</h4><p>Array.prototype.includes 方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的 includes 方法类似。该方法属于 ES7，但 Babel 转码器已经支持。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3].includes(2);     // <span class="literal">true</span></span><br><span class="line">[1, 2, 3].includes(4);     // <span class="literal">false</span></span><br><span class="line">[1, 2, NaN].includes(NaN); // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>该方法的第二个参数表示搜索的起始位置，默认为 0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为 3），则会重置为从 0 开始。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3].includes(3, 3);  // <span class="literal">false</span></span><br><span class="line">[1, 2, 3].includes(3, -1); // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>没有该方法之前，我们通常使用数组的 indexOf 方法，检查是否包含某个值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (arr.indexOf(el) !== -1) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>indexOf 方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相当运算符（===）进行判断，这会导致对 NaN 的误判。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[NaN].indexOf(NaN)</span><br><span class="line">// -1</span><br><span class="line">includes使用的是不一样的判断算法，就没有这个问题。</span><br><span class="line"></span><br><span class="line">[NaN].includes(NaN)</span><br><span class="line">// <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>下面代码用来检查当前环境是否支持该方法，如果不支持，部署一个简易的替代版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const contains = (() =&gt;</span><br><span class="line">  Array.prototype.includes</span><br><span class="line">    ? (arr, value) =&gt; arr.includes(value)</span><br><span class="line">    : (arr, value) =&gt; arr.some(el =&gt; el === value)</span><br><span class="line">)();</span><br><span class="line">contains([<span class="string">"foo"</span>, <span class="string">"bar"</span>], <span class="string">"baz"</span>); // =&gt; <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>另外，Map 和 Set 数据结构有一个 has 方法，需要注意与 includes 区分。</p><p>1.Map 结构的 has 方法，是用来查找键名的，比如 Map.prototype.has(key)、WeakMap.prototype.has(key)、Reflect.has(target, propertyKey)。<br>2.Set 结构的 has 方法，是用来查找值的，比如 Set.prototype.has(value)、WeakSet.prototype.has(value)。</p><h4 id="数组的空位"><a href="#数组的空位" class="headerlink" title="数组的空位"></a>数组的空位</h4><p>数组的空位指，数组的某一个位置没有任何值。比如，Array 构造函数返回的数组都是空位。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array(3) // [, , ,]</span><br></pre></td></tr></table></figure><p>上面代码中，Array(3)返回一个具有 3 个空位的数组。</p><p>注意，空位不是 undefined，一个位置的值等于 undefined，依然是有值的。空位是没有任何值，in 运算符可以说明这一点。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 <span class="keyword">in</span> [undefined, undefined, undefined] // <span class="literal">true</span></span><br><span class="line">0 <span class="keyword">in</span> [, , ,] // <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>上面代码说明，第一个数组的 0 号位置是有值的，第二个数组的 0 号位置没有值。</p><p>ES5 对空位的处理，已经很不一致了，大多数情况下会忽略空位。</p><p>forEach(), filter(), every() 和 some()都会跳过空位。<br>map()会跳过空位，但会保留这个值<br>join()和 toString()会将空位视为 undefined，而 undefined 和 null 会被处理成空字符串。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// forEach方法</span><br><span class="line">[,<span class="string">'a'</span>].forEach((x,i) =&gt; console.log(i)); // 1</span><br><span class="line"></span><br><span class="line">// filter方法</span><br><span class="line">[<span class="string">'a'</span>,,<span class="string">'b'</span>].filter(x =&gt; <span class="literal">true</span>) // [<span class="string">'a'</span>,<span class="string">'b'</span>]</span><br><span class="line"></span><br><span class="line">// every方法</span><br><span class="line">[,<span class="string">'a'</span>].every(x =&gt; x===<span class="string">'a'</span>) // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">// some方法</span><br><span class="line">[,<span class="string">'a'</span>].some(x =&gt; x !== <span class="string">'a'</span>) // <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">// map方法</span><br><span class="line">[,<span class="string">'a'</span>].map(x =&gt; 1) // [,1]</span><br><span class="line"></span><br><span class="line">// join方法</span><br><span class="line">[,<span class="string">'a'</span>,undefined,null].join(<span class="string">'#'</span>) // <span class="string">"#a##"</span></span><br><span class="line"></span><br><span class="line">// toString方法</span><br><span class="line">[,<span class="string">'a'</span>,undefined,null].toString() // <span class="string">",a,,"</span></span><br></pre></td></tr></table></figure><p>ES6 则是明确将空位转为 undefined。</p><p>Array.from 方法会将数组的空位，转为 undefined，也就是说，这个方法不会忽略空位。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array.from([<span class="string">'a'</span>,,<span class="string">'b'</span>])</span><br><span class="line">// [ <span class="string">"a"</span>, undefined, <span class="string">"b"</span> ]</span><br></pre></td></tr></table></figure><p>扩展运算符（…）也会将空位转为 undefined。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...[<span class="string">'a'</span>,,<span class="string">'b'</span>]]</span><br><span class="line">// [ <span class="string">"a"</span>, undefined, <span class="string">"b"</span> ]</span><br></pre></td></tr></table></figure><p>copyWithin()会连空位一起拷贝。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[,<span class="string">'a'</span>,<span class="string">'b'</span>,,].copyWithin(2,0) // [,<span class="string">"a"</span>,,<span class="string">"a"</span>]</span><br></pre></td></tr></table></figure><p>fill()会将空位视为正常的数组位置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Array(3).fill(<span class="string">'a'</span>) // [<span class="string">"a"</span>,<span class="string">"a"</span>,<span class="string">"a"</span>]</span><br></pre></td></tr></table></figure><p>for…of 循环也会遍历空位。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arr = [, ,];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i of arr) &#123;</span><br><span class="line">  console.log(1);</span><br><span class="line">&#125;</span><br><span class="line">// 1</span><br><span class="line">// 1</span><br></pre></td></tr></table></figure><p>上面代码中，数组 arr 有两个空位，for…of 并没有忽略它们。如果改成 map 方法遍历，空位是会跳过的。</p><p>entries()、keys()、values()、find()和 findIndex()会将空位处理成 undefined。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// entries()</span><br><span class="line">[...[,<span class="string">'a'</span>].entries()] // [[0,undefined], [1,<span class="string">"a"</span>]]</span><br><span class="line"></span><br><span class="line">// keys()</span><br><span class="line">[...[,<span class="string">'a'</span>].keys()] // [0,1]</span><br><span class="line"></span><br><span class="line">// values()</span><br><span class="line">[...[,<span class="string">'a'</span>].values()] // [undefined,<span class="string">"a"</span>]</span><br><span class="line"></span><br><span class="line">// find()</span><br><span class="line">[,<span class="string">'a'</span>].find(x =&gt; <span class="literal">true</span>) // undefined</span><br><span class="line"></span><br><span class="line">// findIndex()</span><br><span class="line">[,<span class="string">'a'</span>].findIndex(x =&gt; <span class="literal">true</span>) // 0</span><br></pre></td></tr></table></figure><p>由于空位的处理规则非常不统一，所以建议避免出现空位。</p>]]></content>
      
      
      <categories>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6_Number</title>
      <link href="/2019/01/15/es6-Number/"/>
      <url>/2019/01/15/es6-Number/</url>
      
        <content type="html"><![CDATA[<h3 id="ES6-数值的扩展"><a href="#ES6-数值的扩展" class="headerlink" title="ES6 数值的扩展"></a>ES6 数值的扩展</h3><h4 id="二进制和八进制表示法"><a href="#二进制和八进制表示法" class="headerlink" title="二进制和八进制表示法"></a>二进制和八进制表示法</h4><p>ES6 提供了二进制和八进制数值的新的写法，分别用前缀 0b（或 0B）和 0o（或 0O）表示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0b111110111 === 503 // <span class="literal">true</span></span><br><span class="line">0o767 === 503 // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>从 ES5 开始，在严格模式之中，八进制就不再允许使用前缀 0 表示，ES6 进一步明确，要使用前缀 0o 表示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 非严格模式</span><br><span class="line">(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">  console.log(0o11 === 011);</span><br><span class="line">&#125;)() // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">// 严格模式</span><br><span class="line">(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">  <span class="string">'use strict'</span>;</span><br><span class="line">  console.log(0o11 === 011);</span><br><span class="line">&#125;)() // Uncaught SyntaxError: Octal literals are not allowed <span class="keyword">in</span> strict mode.</span><br></pre></td></tr></table></figure><p>如果要将 0b 和 0o 前缀的字符串数值转为十进制，要使用 Number 方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Number(<span class="string">'0b111'</span>)  // 7</span><br><span class="line">Number(<span class="string">'0o10'</span>)  // 8</span><br></pre></td></tr></table></figure><h4 id="Number-isFinite-Number-isNaN"><a href="#Number-isFinite-Number-isNaN" class="headerlink" title="Number.isFinite(), Number.isNaN()"></a>Number.isFinite(), Number.isNaN()</h4><p>ES6 在 Number 对象上，新提供了 Number.isFinite()和 Number.isNaN()两个方法。</p><p>Number.isFinite()用来检查一个数值是否为有限的（finite）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Number.isFinite(15); // <span class="literal">true</span></span><br><span class="line">Number.isFinite(0.8); // <span class="literal">true</span></span><br><span class="line">Number.isFinite(NaN); // <span class="literal">false</span></span><br><span class="line">Number.isFinite(Infinity); // <span class="literal">false</span></span><br><span class="line">Number.isFinite(-Infinity); // <span class="literal">false</span></span><br><span class="line">Number.isFinite(<span class="string">'foo'</span>); // <span class="literal">false</span></span><br><span class="line">Number.isFinite(<span class="string">'15'</span>); // <span class="literal">false</span></span><br><span class="line">Number.isFinite(<span class="literal">true</span>); // <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>ES5 可以通过下面的代码，部署 Number.isFinite 方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (global) &#123;</span><br><span class="line">  var global_isFinite = global.isFinite;</span><br><span class="line"></span><br><span class="line">  Object.defineProperty(Number, <span class="string">'isFinite'</span>, &#123;</span><br><span class="line">    value: <span class="keyword">function</span> isFinite(value) &#123;</span><br><span class="line">      <span class="built_in">return</span> typeof value === <span class="string">'number'</span> &amp;&amp; global_isFinite(value);</span><br><span class="line">    &#125;,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    writable: <span class="literal">true</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)(this);</span><br></pre></td></tr></table></figure><p>Number.isNaN()用来检查一个值是否为 NaN。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Number.isNaN(NaN) // <span class="literal">true</span></span><br><span class="line">Number.isNaN(15) // <span class="literal">false</span></span><br><span class="line">Number.isNaN(<span class="string">'15'</span>) // <span class="literal">false</span></span><br><span class="line">Number.isNaN(<span class="literal">true</span>) // <span class="literal">false</span></span><br><span class="line">Number.isNaN(9/NaN) // <span class="literal">true</span></span><br><span class="line">Number.isNaN(<span class="string">'true'</span>/0) // <span class="literal">true</span></span><br><span class="line">Number.isNaN(<span class="string">'true'</span>/<span class="string">'true'</span>) // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>ES5 通过下面的代码，部署 Number.isNaN()。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (global) &#123;</span><br><span class="line">  var global_isNaN = global.isNaN;</span><br><span class="line"></span><br><span class="line">  Object.defineProperty(Number, <span class="string">'isNaN'</span>, &#123;</span><br><span class="line">    value: <span class="keyword">function</span> isNaN(value) &#123;</span><br><span class="line">      <span class="built_in">return</span> typeof value === <span class="string">'number'</span> &amp;&amp; global_isNaN(value);</span><br><span class="line">    &#125;,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    writable: <span class="literal">true</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)(this);</span><br></pre></td></tr></table></figure><p>它们与传统的全局方法 isFinite()和 isNaN()的区别在于，传统方法先调用 Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，非数值一律返回 false。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">isFinite(25) // <span class="literal">true</span></span><br><span class="line">isFinite(<span class="string">"25"</span>) // <span class="literal">true</span></span><br><span class="line">Number.isFinite(25) // <span class="literal">true</span></span><br><span class="line">Number.isFinite(<span class="string">"25"</span>) // <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">isNaN(NaN) // <span class="literal">true</span></span><br><span class="line">isNaN(<span class="string">"NaN"</span>) // <span class="literal">true</span></span><br><span class="line">Number.isNaN(NaN) // <span class="literal">true</span></span><br><span class="line">Number.isNaN(<span class="string">"NaN"</span>) // <span class="literal">false</span></span><br></pre></td></tr></table></figure><h4 id="Number-parseInt-Number-parseFloat"><a href="#Number-parseInt-Number-parseFloat" class="headerlink" title="Number.parseInt(), Number.parseFloat()"></a>Number.parseInt(), Number.parseFloat()</h4><p>ES6 将全局方法 parseInt()和 parseFloat()，移植到 Number 对象上面，行为完全保持不变。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// ES5的写法</span><br><span class="line">parseInt(<span class="string">'12.34'</span>) // 12</span><br><span class="line">parseFloat(<span class="string">'123.45#'</span>) // 123.45</span><br><span class="line"></span><br><span class="line">// ES6的写法</span><br><span class="line">Number.parseInt(<span class="string">'12.34'</span>) // 12</span><br><span class="line">Number.parseFloat(<span class="string">'123.45#'</span>) // 123.45</span><br></pre></td></tr></table></figure><p>这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Number.parseInt === parseInt // <span class="literal">true</span></span><br><span class="line">Number.parseFloat === parseFloat // <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="Number-isInteger"><a href="#Number-isInteger" class="headerlink" title="Number.isInteger()"></a>Number.isInteger()</h4><p>Number.isInteger()用来判断一个值是否为整数。需要注意的是，在 JavaScript 内部，整数和浮点数是同样的储存方法，所以 3 和 3.0 被视为同一个值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Number.isInteger(25) // <span class="literal">true</span></span><br><span class="line">Number.isInteger(25.0) // <span class="literal">true</span></span><br><span class="line">Number.isInteger(25.1) // <span class="literal">false</span></span><br><span class="line">Number.isInteger(<span class="string">"15"</span>) // <span class="literal">false</span></span><br><span class="line">Number.isInteger(<span class="literal">true</span>) // <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>ES5 可以通过下面的代码，部署 Number.isInteger()。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (global) &#123;</span><br><span class="line">  var floor = Math.floor,</span><br><span class="line">    isFinite = global.isFinite;</span><br><span class="line"></span><br><span class="line">  Object.defineProperty(Number, <span class="string">'isInteger'</span>, &#123;</span><br><span class="line">    value: <span class="keyword">function</span> isInteger(value) &#123;</span><br><span class="line">      <span class="built_in">return</span> typeof value === <span class="string">'number'</span> &amp;&amp; isFinite(value) &amp;&amp;</span><br><span class="line">        value &gt; -9007199254740992 &amp;&amp; value &lt; 9007199254740992 &amp;&amp;</span><br><span class="line">        floor(value) === value;</span><br><span class="line">    &#125;,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    writable: <span class="literal">true</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)(this);</span><br></pre></td></tr></table></figure><h4 id="Number-EPSILON"><a href="#Number-EPSILON" class="headerlink" title="Number.EPSILON"></a>Number.EPSILON</h4><p>ES6 在 Number 对象上面，新增一个极小的常量 Number.EPSILON。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Number.EPSILON</span><br><span class="line">// 2.220446049250313e-16</span><br><span class="line">Number.EPSILON.toFixed(20)</span><br><span class="line">// <span class="string">'0.00000000000000022204'</span></span><br></pre></td></tr></table></figure><p>引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。我们知道浮点数计算是不精确的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0.1 + 0.2</span><br><span class="line">// 0.30000000000000004</span><br><span class="line"></span><br><span class="line">0.1 + 0.2 - 0.3</span><br><span class="line">// 5.551115123125783e-17</span><br><span class="line"></span><br><span class="line">5.551115123125783e-17.toFixed(20)</span><br><span class="line">// <span class="string">'0.00000000000000005551'</span></span><br></pre></td></tr></table></figure><p>但是如果这个误差能够小于 Number.EPSILON，我们就可以认为得到了正确结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5.551115123125783e-17 &lt; Number.EPSILON</span><br><span class="line">// <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>因此，Number.EPSILON 的实质是一个可以接受的误差范围。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> withinErrorMargin (left, right) &#123;</span><br><span class="line">  <span class="built_in">return</span> Math.abs(left - right) &lt; Number.EPSILON;</span><br><span class="line">&#125;</span><br><span class="line">withinErrorMargin(0.1 + 0.2, 0.3)</span><br><span class="line">// <span class="literal">true</span></span><br><span class="line">withinErrorMargin(0.2 + 0.2, 0.3)</span><br><span class="line">// <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>上面的代码为浮点数运算，部署了一个误差检查函数。</p><h4 id="安全整数和-Number-isSafeInteger"><a href="#安全整数和-Number-isSafeInteger" class="headerlink" title="安全整数和 Number.isSafeInteger()"></a>安全整数和 Number.isSafeInteger()</h4><p>JavaScript 能够准确表示的整数范围在-2^53 到 2^53 之间（不含两个端点），超过这个范围，无法精确表示这个值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Math.pow(2, 53) // 9007199254740992</span><br><span class="line"></span><br><span class="line">9007199254740992  // 9007199254740992</span><br><span class="line">9007199254740993  // 9007199254740992</span><br><span class="line"></span><br><span class="line">Math.pow(2, 53) === Math.pow(2, 53) + 1</span><br><span class="line">// <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>上面代码中，超出 2 的 53 次方之后，一个数就不精确了。</p><p>ES6 引入了 Number.MAX_SAFE_INTEGER 和 Number.MIN_SAFE_INTEGER 这两个常量，用来表示这个范围的上下限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Number.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1</span><br><span class="line">// <span class="literal">true</span></span><br><span class="line">Number.MAX_SAFE_INTEGER === 9007199254740991</span><br><span class="line">// <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">Number.MIN_SAFE_INTEGER === -Number.MAX_SAFE_INTEGER</span><br><span class="line">// <span class="literal">true</span></span><br><span class="line">Number.MIN_SAFE_INTEGER === -9007199254740991</span><br><span class="line">// <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>上面代码中，可以看到 JavaScript 能够精确表示的极限。</p><p>Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Number.isSafeInteger(<span class="string">'a'</span>) // <span class="literal">false</span></span><br><span class="line">Number.isSafeInteger(null) // <span class="literal">false</span></span><br><span class="line">Number.isSafeInteger(NaN) // <span class="literal">false</span></span><br><span class="line">Number.isSafeInteger(Infinity) // <span class="literal">false</span></span><br><span class="line">Number.isSafeInteger(-Infinity) // <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">Number.isSafeInteger(3) // <span class="literal">true</span></span><br><span class="line">Number.isSafeInteger(1.2) // <span class="literal">false</span></span><br><span class="line">Number.isSafeInteger(9007199254740990) // <span class="literal">true</span></span><br><span class="line">Number.isSafeInteger(9007199254740992) // <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">Number.isSafeInteger(Number.MIN_SAFE_INTEGER - 1) // <span class="literal">false</span></span><br><span class="line">Number.isSafeInteger(Number.MIN_SAFE_INTEGER) // <span class="literal">true</span></span><br><span class="line">Number.isSafeInteger(Number.MAX_SAFE_INTEGER) // <span class="literal">true</span></span><br><span class="line">Number.isSafeInteger(Number.MAX_SAFE_INTEGER + 1) // <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>这个函数的实现很简单，就是跟安全整数的两个边界值比较一下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Number.isSafeInteger = <span class="keyword">function</span> (n) &#123;</span><br><span class="line">  <span class="built_in">return</span> (typeof n === <span class="string">'number'</span> &amp;&amp;</span><br><span class="line">    Math.round(n) === n &amp;&amp;</span><br><span class="line">    Number.MIN_SAFE_INTEGER &lt;= n &amp;&amp;</span><br><span class="line">    n &lt;= Number.MAX_SAFE_INTEGER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际使用这个函数时，需要注意。验证运算结果是否落在安全整数的范围内，不要只验证运算结果，而要同时验证参与运算的每个值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Number.isSafeInteger(9007199254740993)</span><br><span class="line">// <span class="literal">false</span></span><br><span class="line">Number.isSafeInteger(990)</span><br><span class="line">// <span class="literal">true</span></span><br><span class="line">Number.isSafeInteger(9007199254740993 - 990)</span><br><span class="line">// <span class="literal">true</span></span><br><span class="line">9007199254740993 - 990</span><br><span class="line">// 返回结果 9007199254740002</span><br><span class="line">// 正确答案应该是 9007199254740003</span><br></pre></td></tr></table></figure><p>上面代码中，9007199254740993 不是一个安全整数，但是 Number.isSafeInteger 会返回结果，显示计算结果是安全的。这是因为，这个数超出了精度范围，导致在计算机内部，以 9007199254740992 的形式储存。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">9007199254740993 === 9007199254740992</span><br><span class="line">// <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>所以，如果只验证运算结果是否为安全整数，很可能得到错误结果。下面的函数可以同时验证两个运算数和运算结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> trusty (left, right, result) &#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    Number.isSafeInteger(left) &amp;&amp;</span><br><span class="line">    Number.isSafeInteger(right) &amp;&amp;</span><br><span class="line">    Number.isSafeInteger(result)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="built_in">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  throw new RangeError(<span class="string">'Operation cannot be trusted!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trusty(9007199254740993, 990, 9007199254740993 - 990)</span><br><span class="line">// RangeError: Operation cannot be trusted!</span><br><span class="line"></span><br><span class="line">trusty(1, 2, 3)</span><br><span class="line">// 3</span><br></pre></td></tr></table></figure><h4 id="Math-对象的扩展"><a href="#Math-对象的扩展" class="headerlink" title="Math 对象的扩展"></a>Math 对象的扩展</h4><p>ES6 在 Math 对象上新增了 17 个与数学相关的方法。所有这些方法都是静态方法，只能在 Math 对象上调用。</p><h5 id="Math-trunc"><a href="#Math-trunc" class="headerlink" title="Math.trunc()"></a>Math.trunc()</h5><p>Math.trunc 方法用于去除一个数的小数部分，返回整数部分。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Math.trunc(4.1) // 4</span><br><span class="line">Math.trunc(4.9) // 4</span><br><span class="line">Math.trunc(-4.1) // -4</span><br><span class="line">Math.trunc(-4.9) // -4</span><br><span class="line">Math.trunc(-0.1234) // -0</span><br></pre></td></tr></table></figure><p>对于非数值，Math.trunc 内部使用 Number 方法将其先转为数值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.trunc(<span class="string">'123.456'</span>)</span><br><span class="line">// 123</span><br></pre></td></tr></table></figure><p>对于空值和无法截取整数的值，返回 NaN。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Math.trunc(NaN);      // NaN</span><br><span class="line">Math.trunc(<span class="string">'foo'</span>);    // NaN</span><br><span class="line">Math.trunc();         // NaN</span><br></pre></td></tr></table></figure><p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Math.trunc = Math.trunc || <span class="keyword">function</span>(x) &#123;</span><br><span class="line">  <span class="built_in">return</span> x &lt; 0 ? Math.ceil(x) : Math.floor(x);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="Math-sign"><a href="#Math-sign" class="headerlink" title="Math.sign()"></a>Math.sign()</h5><p>Math.sign 方法用来判断一个数到底是正数、负数、还是零。</p><p>它会返回五种值。</p><pre>参数为正数，返回+1；参数为负数，返回-1；参数为 0，返回 0；参数为-0，返回-0;其他值，返回 NaN。</pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Math.sign(-5) // -1</span><br><span class="line">Math.sign(5) // +1</span><br><span class="line">Math.sign(0) // +0</span><br><span class="line">Math.sign(-0) // -0</span><br><span class="line">Math.sign(NaN) // NaN</span><br><span class="line">Math.sign(<span class="string">'foo'</span>); // NaN</span><br><span class="line">Math.sign();      // NaN</span><br></pre></td></tr></table></figure><p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Math.sign = Math.sign || <span class="keyword">function</span>(x) &#123;</span><br><span class="line">  x = +x; // convert to a number</span><br><span class="line">  <span class="keyword">if</span> (x === 0 || isNaN(x)) &#123;</span><br><span class="line">    <span class="built_in">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> x &gt; 0 ? 1 : -1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="Math-cbrt"><a href="#Math-cbrt" class="headerlink" title="Math.cbrt()"></a>Math.cbrt()</h5><p>Math.cbrt 方法用于计算一个数的立方根。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Math.cbrt(-1) // -1</span><br><span class="line">Math.cbrt(0)  // 0</span><br><span class="line">Math.cbrt(1)  // 1</span><br><span class="line">Math.cbrt(2)  // 1.2599210498948734</span><br></pre></td></tr></table></figure><p>对于非数值，Math.cbrt 方法内部也是先使用 Number 方法将其转为数值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.cbrt(<span class="string">'8'</span>) // 2</span><br><span class="line">Math.cbrt(<span class="string">'hello'</span>) // NaN</span><br></pre></td></tr></table></figure><p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Math.cbrt = Math.cbrt || <span class="keyword">function</span>(x) &#123;</span><br><span class="line">  var y = Math.pow(Math.abs(x), 1/3);</span><br><span class="line">  <span class="built_in">return</span> x &lt; 0 ? -y : y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="Math-clz32"><a href="#Math-clz32" class="headerlink" title="Math.clz32()"></a>Math.clz32()</h5><p>JavaScript 的整数使用 32 位二进制形式表示，Math.clz32 方法返回一个数的 32 位无符号整数形式有多少个前导 0。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Math.clz32(0) // 32</span><br><span class="line">Math.clz32(1) // 31</span><br><span class="line">Math.clz32(1000) // 22</span><br><span class="line">Math.clz32(0b01000000000000000000000000000000) // 1</span><br><span class="line">Math.clz32(0b00100000000000000000000000000000) // 2</span><br></pre></td></tr></table></figure><p>上面代码中，0 的二进制形式全为 0，所以有 32 个前导 0；1 的二进制形式是 0b1，只占 1 位，所以 32 位之中有 31 个前导 0；1000 的二进制形式是 0b1111101000，一共有 10 位，所以 32 位之中有 22 个前导 0。</p><p>clz32 这个函数名就来自”count leading zero bits in 32-bit binary representations of a number“（计算 32 位整数的前导 0）的缩写。</p><p>左移运算符（&lt;&lt;）与 Math.clz32 方法直接相关。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Math.clz32(0) // 32</span><br><span class="line">Math.clz32(1) // 31</span><br><span class="line">Math.clz32(1 &lt;&lt; 1) // 30</span><br><span class="line">Math.clz32(1 &lt;&lt; 2) // 29</span><br><span class="line">Math.clz32(1 &lt;&lt; 29) // 2</span><br></pre></td></tr></table></figure><p>对于小数，Math.clz32 方法只考虑整数部分。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.clz32(3.2) // 30</span><br><span class="line">Math.clz32(3.9) // 30</span><br></pre></td></tr></table></figure><p>对于空值或其他类型的值，Math.clz32 方法会将它们先转为数值，然后再计算。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Math.clz32() // 32</span><br><span class="line">Math.clz32(NaN) // 32</span><br><span class="line">Math.clz32(Infinity) // 32</span><br><span class="line">Math.clz32(null) // 32</span><br><span class="line">Math.clz32(<span class="string">'foo'</span>) // 32</span><br><span class="line">Math.clz32([]) // 32</span><br><span class="line">Math.clz32(&#123;&#125;) // 32</span><br><span class="line">Math.clz32(<span class="literal">true</span>) // 31</span><br></pre></td></tr></table></figure><h5 id="Math-imul"><a href="#Math-imul" class="headerlink" title="Math.imul()"></a>Math.imul()</h5><p>Math.imul 方法返回两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Math.imul(2, 4)   // 8</span><br><span class="line">Math.imul(-1, 8)  // -8</span><br><span class="line">Math.imul(-2, -2) // 4</span><br></pre></td></tr></table></figure><p>如果只考虑最后 32 位，大多数情况下，Math.imul(a, b)与 a _ b 的结果是相同的，即该方法等同于(a _ b)|0 的效果（超过 32 位的部分溢出）。之所以需要部署这个方法，是因为 JavaScript 有精度限制，超过 2 的 53 次方的值无法精确表示。这就是说，对于那些很大的数的乘法，低位数值往往都是不精确的，Math.imul 方法可以返回正确的低位数值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(0x7fffffff * 0x7fffffff)|0 // 0</span><br></pre></td></tr></table></figure><p>上面这个乘法算式，返回结果为 0。但是由于这两个二进制数的最低位都是 1，所以这个结果肯定是不正确的，因为根据二进制乘法，计算结果的二进制最低位应该也是 1。这个错误就是因为它们的乘积超过了 2 的 53 次方，JavaScript 无法保存额外的精度，就把低位的值都变成了 0。Math.imul 方法可以返回正确的值 1。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.imul(0x7fffffff, 0x7fffffff) // 1</span><br></pre></td></tr></table></figure><h5 id="Math-fround"><a href="#Math-fround" class="headerlink" title="Math.fround()"></a>Math.fround()</h5><p>Math.fround 方法返回一个数的单精度浮点数形式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Math.fround(0)     // 0</span><br><span class="line">Math.fround(1)     // 1</span><br><span class="line">Math.fround(1.337) // 1.3370000123977661</span><br><span class="line">Math.fround(1.5)   // 1.5</span><br><span class="line">Math.fround(NaN)   // NaN</span><br></pre></td></tr></table></figure><p>对于整数来说，Math.fround 方法返回结果不会有任何不同，区别主要是那些无法用 64 个二进制位精确表示的小数。这时，Math.fround 方法会返回最接近这个小数的单精度浮点数。</p><p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Math.fround = Math.fround || <span class="keyword">function</span>(x) &#123;</span><br><span class="line">  <span class="built_in">return</span> new Float32Array([x])[0];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="Math-hypot"><a href="#Math-hypot" class="headerlink" title="Math.hypot()"></a>Math.hypot()</h5><p>Math.hypot 方法返回所有参数的平方和的平方根。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Math.hypot(3, 4);        // 5</span><br><span class="line">Math.hypot(3, 4, 5);     // 7.0710678118654755</span><br><span class="line">Math.hypot();            // 0</span><br><span class="line">Math.hypot(NaN);         // NaN</span><br><span class="line">Math.hypot(3, 4, <span class="string">'foo'</span>); // NaN</span><br><span class="line">Math.hypot(3, 4, <span class="string">'5'</span>);   // 7.0710678118654755</span><br><span class="line">Math.hypot(-3);          // 3</span><br></pre></td></tr></table></figure><p>上面代码中，3 的平方加上 4 的平方，等于 5 的平方。</p><p>如果参数不是数值，Math.hypot 方法会将其转为数值。只要有一个参数无法转为数值，就会返回 NaN。</p><h4 id="对数方法"><a href="#对数方法" class="headerlink" title="对数方法"></a>对数方法</h4><p>ES6 新增了 4 个对数相关方法。</p><p>（1） Math.expm1()</p><p>Math.expm1(x)返回 ex - 1，即 Math.exp(x) - 1。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Math.expm1(-1) // -0.6321205588285577</span><br><span class="line">Math.expm1(0)  // 0</span><br><span class="line">Math.expm1(1)  // 1.718281828459045</span><br></pre></td></tr></table></figure><p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Math.expm1 = Math.expm1 || <span class="keyword">function</span>(x) &#123;</span><br><span class="line">  <span class="built_in">return</span> Math.exp(x) - 1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>（2）Math.log1p()</p><p>Math.log1p(x)方法返回 1 + x 的自然对数，即 Math.log(1 + x)。如果 x 小于-1，返回 NaN。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Math.log1p(1)  // 0.6931471805599453</span><br><span class="line">Math.log1p(0)  // 0</span><br><span class="line">Math.log1p(-1) // -Infinity</span><br><span class="line">Math.log1p(-2) // NaN</span><br></pre></td></tr></table></figure><p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Math.log1p = Math.log1p || <span class="keyword">function</span>(x) &#123;</span><br><span class="line">  <span class="built_in">return</span> Math.log(1 + x);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>（3）Math.log10()</p><p>Math.log10(x)返回以 10 为底的 x 的对数。如果 x 小于 0，则返回 NaN。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Math.log10(2)      // 0.3010299956639812</span><br><span class="line">Math.log10(1)      // 0</span><br><span class="line">Math.log10(0)      // -Infinity</span><br><span class="line">Math.log10(-2)     // NaN</span><br><span class="line">Math.log10(100000) // 5</span><br></pre></td></tr></table></figure><p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Math.log10 = Math.log10 || <span class="keyword">function</span>(x) &#123;</span><br><span class="line">  <span class="built_in">return</span> Math.log(x) / Math.LN10;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>（4）Math.log2()</p><p>Math.log2(x)返回以 2 为底的 x 的对数。如果 x 小于 0，则返回 NaN。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Math.log2(3)       // 1.584962500721156</span><br><span class="line">Math.log2(2)       // 1</span><br><span class="line">Math.log2(1)       // 0</span><br><span class="line">Math.log2(0)       // -Infinity</span><br><span class="line">Math.log2(-2)      // NaN</span><br><span class="line">Math.log2(1024)    // 10</span><br><span class="line">Math.log2(1 &lt;&lt; 29) // 29</span><br></pre></td></tr></table></figure><p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Math.log2 = Math.log2 || <span class="keyword">function</span>(x) &#123;</span><br><span class="line">  <span class="built_in">return</span> Math.log(x) / Math.LN2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="三角函数方法"><a href="#三角函数方法" class="headerlink" title="三角函数方法"></a>三角函数方法</h4><p>ES6 新增了 6 个三角函数方法。</p><p>1.Math.sinh(x) 返回 x 的双曲正弦（hyperbolic sine）<br>2.Math.cosh(x) 返回 x 的双曲余弦（hyperbolic cosine）<br>3.Math.tanh(x) 返回 x 的双曲正切（hyperbolic tangent）<br>4.Math.asinh(x) 返回 x 的反双曲正弦（inverse hyperbolic sine）<br>5.Math.acosh(x) 返回 x 的反双曲余弦（inverse hyperbolic cosine）<br>6.Math.atanh(x) 返回 x 的反双曲正切（inverse hyperbolic tangent）</p><h4 id="指数运算符"><a href="#指数运算符" class="headerlink" title="指数运算符"></a>指数运算符</h4><p>ES7 新增了一个指数运算符（**），目前 Babel 转码器已经支持。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 ** 2 // 4</span><br><span class="line">2 ** 3 // 8</span><br></pre></td></tr></table></figure><p>指数运算符可以与等号结合，形成一个新的赋值运算符（**=）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> a = 2;</span><br><span class="line">a **= 2;</span><br><span class="line">// 等同于 a = a * a;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> b = 3;</span><br><span class="line">b **= 3;</span><br><span class="line">// 等同于 b = b * b * b;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6_RegExp</title>
      <link href="/2019/01/10/es6-RegExp/"/>
      <url>/2019/01/10/es6-RegExp/</url>
      
        <content type="html"><![CDATA[<h3 id="ES6-正则的扩展"><a href="#ES6-正则的扩展" class="headerlink" title="ES6 正则的扩展"></a>ES6 正则的扩展</h3><h4 id="RegExp-构造函数"><a href="#RegExp-构造函数" class="headerlink" title="RegExp 构造函数"></a>RegExp 构造函数</h4><p>在 ES5 中，RegExp 构造函数的参数有两种情况。</p><p>第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var regex = new RegExp(<span class="string">'xyz'</span>, <span class="string">'i'</span>);</span><br><span class="line">// 等价于</span><br><span class="line">var regex = /xyz/i;</span><br></pre></td></tr></table></figure><p>第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var regex = new RegExp(/xyz/i);</span><br><span class="line">// 等价于</span><br><span class="line">var regex = /xyz/i;</span><br></pre></td></tr></table></figure><p>但是，ES5 不允许此时使用第二个参数，添加修饰符，否则会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var regex = new RegExp(/xyz/, <span class="string">'i'</span>);</span><br><span class="line">// Uncaught TypeError: Cannot supply flags when constructing one RegExp from another</span><br></pre></td></tr></table></figure><p>ES6 改变了这种行为。如果 RegExp 构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new RegExp(/abc/ig, <span class="string">'i'</span>).flags</span><br><span class="line">// <span class="string">"i"</span></span><br></pre></td></tr></table></figure><p>上面代码中，原有正则对象的修饰符是 ig，它会被第二个参数 i 覆盖。</p><h4 id="字符串的正则方法"><a href="#字符串的正则方法" class="headerlink" title="字符串的正则方法"></a>字符串的正则方法</h4><p>字符串对象共有 4 个方法，可以使用正则表达式：match()、replace()、search()和 split()。</p><p>ES6 将这 4 个方法，在语言内部全部调用 RegExp 的实例方法，从而做到所有与正则相关的方法，全都定义在 RegExp 对象上。</p><p>1.String.prototype.match 调用 RegExp.prototype[Symbol.match]<br>2.String.prototype.replace 调用 RegExp.prototype[Symbol.replace]<br>3.String.prototype.search 调用 RegExp.prototype[Symbol.search]<br>4.String.prototype.split 调用 RegExp.prototype[Symbol.split]</p><h4 id="u-修饰符"><a href="#u-修饰符" class="headerlink" title="u 修饰符"></a>u 修饰符</h4><p>ES6 对正则表达式添加了 u 修饰符，含义为“Unicode 模式”，用来正确处理大于\uFFFF 的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/^\uD83D/u.test(<span class="string">'\uD83D\uDC2A'</span>)</span><br><span class="line">// <span class="literal">false</span></span><br><span class="line">/^\uD83D/.<span class="built_in">test</span>(<span class="string">'\uD83D\uDC2A'</span>)</span><br><span class="line">// <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>上面代码中，\uD83D\uDC2A 是一个四个字节的 UTF-16 编码，代表一个字符。但是，ES5 不支持四个字节的 UTF-16 编码，会将其识别为两个字符，导致第二行代码结果为 true。加了 u 修饰符以后，ES6 就会识别其为一个字符，所以第一行代码结果为 false。</p><p>一旦加上 u 修饰符号，就会修改下面这些正则表达式的行为。</p><p>（1）点字符</p><p>点（.）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于 0xFFFF 的 Unicode 字符，点字符不能识别，必须加上 u 修饰符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var s = <span class="string">'𠮷'</span>;</span><br><span class="line">/^.$/.<span class="built_in">test</span>(s) // <span class="literal">false</span></span><br><span class="line">/^.$/u.test(s) // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>上面代码表示，如果不添加 u 修饰符，正则表达式就会认为字符串为两个字符，从而匹配失败。</p><p>（2）Unicode 字符表示法</p><p>ES6 新增了使用大括号表示 Unicode 字符，这种表示法在正则表达式中必须加上 u 修饰符，才能识别。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/\u&#123;61&#125;/.<span class="built_in">test</span>(<span class="string">'a'</span>) // <span class="literal">false</span></span><br><span class="line">/\u&#123;61&#125;/u.test(<span class="string">'a'</span>) // <span class="literal">true</span></span><br><span class="line">/\u&#123;20BB7&#125;/u.test(<span class="string">'𠮷'</span>) // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>上面代码表示，如果不加 u 修饰符，正则表达式无法识别\u{61}这种表示法，只会认为这匹配 61 个连续的 u。</p><p>（3）量词</p><p>使用 u 修饰符后，所有量词都会正确识别码点大于 0xFFFF 的 Unicode 字符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/a&#123;2&#125;/.<span class="built_in">test</span>(<span class="string">'aa'</span>) // <span class="literal">true</span></span><br><span class="line">/a&#123;2&#125;/u.test(<span class="string">'aa'</span>) // <span class="literal">true</span></span><br><span class="line">/𠮷&#123;2&#125;/.<span class="built_in">test</span>(<span class="string">'𠮷𠮷'</span>) // <span class="literal">false</span></span><br><span class="line">/𠮷&#123;2&#125;/u.test(<span class="string">'𠮷𠮷'</span>) // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>另外，只有在使用 u 修饰符的情况下，Unicode 表达式当中的大括号才会被正确解读，否则会被解读为量词。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/^\u&#123;3&#125;$/.<span class="built_in">test</span>(<span class="string">'uuu'</span>) // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>上面代码中，由于正则表达式没有 u 修饰符，所以大括号被解读为量词。加上 u 修饰符，就会被解读为 Unicode 表达式。</p><p>（4）预定义模式</p><p>u 修饰符也影响到预定义模式，能否正确识别码点大于 0xFFFF 的 Unicode 字符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/^\S$/.<span class="built_in">test</span>(<span class="string">'𠮷'</span>) // <span class="literal">false</span></span><br><span class="line">/^\S$/u.test(<span class="string">'𠮷'</span>) // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>上面代码的\S 是预定义模式，匹配所有不是空格的字符。只有加了 u 修饰符，它才能正确匹配码点大于 0xFFFF 的 Unicode 字符。</p><p>利用这一点，可以写出一个正确返回字符串长度的函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> codePointLength(text) &#123;</span><br><span class="line">  var result = text.match(/[\s\S]/gu);</span><br><span class="line">  <span class="built_in">return</span> result ? result.length : 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var s = <span class="string">'𠮷𠮷'</span>;</span><br><span class="line"></span><br><span class="line">s.length // 4</span><br><span class="line">codePointLength(s) // 2</span><br></pre></td></tr></table></figure><p>（5）i 修饰符</p><p>有些 Unicode 字符的编码不同，但是字型很相近，比如，\u004B 与\u212A 都是大写的 K。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/[a-z]/i.test(<span class="string">'\u212A'</span>) // <span class="literal">false</span></span><br><span class="line">/[a-z]/iu.test(<span class="string">'\u212A'</span>) // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>上面代码中，不加 u 修饰符，就无法识别非规范的 K 字符。</p><h4 id="y-修饰符"><a href="#y-修饰符" class="headerlink" title="y 修饰符"></a>y 修饰符</h4><p>除了 u 修饰符，ES6 还为正则表达式添加了 y 修饰符，叫做“粘连”（sticky）修饰符。</p><p>y 修饰符的作用与 g 修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g 修饰符只要剩余位置中存在匹配就可，而 y 修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var s = <span class="string">'aaa_aa_a'</span>;</span><br><span class="line">var r1 = /a+/g;</span><br><span class="line">var r2 = /a+/y;</span><br><span class="line"></span><br><span class="line">r1.exec(s) // [<span class="string">"aaa"</span>]</span><br><span class="line">r2.exec(s) // [<span class="string">"aaa"</span>]</span><br><span class="line"></span><br><span class="line">r1.exec(s) // [<span class="string">"aa"</span>]</span><br><span class="line">r2.exec(s) // null</span><br></pre></td></tr></table></figure><p>上面代码有两个正则表达式，一个使用 g 修饰符，另一个使用 y 修饰符。这两个正则表达式各执行了两次，第一次执行的时候，两者行为相同，剩余字符串都是_aa_a。由于 g 修饰没有位置要求，所以第二次执行会返回结果，而 y 修饰符要求匹配必须从头部开始，所以返回 null。</p><p>如果改一下正则表达式，保证每次都能头部匹配，y 修饰符就会返回结果了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var s = <span class="string">'aaa_aa_a'</span>;</span><br><span class="line">var r = /a+_/y;</span><br><span class="line"></span><br><span class="line">r.exec(s) // [<span class="string">"aaa_"</span>]</span><br><span class="line">r.exec(s) // [<span class="string">"aa_"</span>]</span><br></pre></td></tr></table></figure><p>上面代码每次匹配，都是从剩余字符串的头部开始。</p><p>使用 lastIndex 属性，可以更好地说明 y 修饰符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const REGEX = /a/g;</span><br><span class="line"></span><br><span class="line">// 指定从2号位置（y）开始匹配</span><br><span class="line">REGEX.lastIndex = 2;</span><br><span class="line"></span><br><span class="line">// 匹配成功</span><br><span class="line">const match = REGEX.exec(<span class="string">'xaya'</span>);</span><br><span class="line"></span><br><span class="line">// 在3号位置匹配成功</span><br><span class="line">match.index // 3</span><br><span class="line"></span><br><span class="line">// 下一次匹配从4号位开始</span><br><span class="line">REGEX.lastIndex // 4</span><br><span class="line"></span><br><span class="line">// 4号位开始匹配失败</span><br><span class="line">REGEX.exec(<span class="string">'xaxa'</span>) // null</span><br></pre></td></tr></table></figure><p>上面代码中，lastIndex 属性指定每次搜索的开始位置，g 修饰符从这个位置开始向后搜索，直到发现匹配为止。</p><p>y 修饰符同样遵守 lastIndex 属性，但是要求必须在 lastIndex 指定的位置发现匹配。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const REGEX = /a/y;</span><br><span class="line"></span><br><span class="line">// 指定从2号位置开始匹配</span><br><span class="line">REGEX.lastIndex = 2;</span><br><span class="line"></span><br><span class="line">// 不是粘连，匹配失败</span><br><span class="line">REGEX.exec(<span class="string">'xaya'</span>) // null</span><br><span class="line"></span><br><span class="line">// 指定从3号位置开始匹配</span><br><span class="line">REGEX.lastIndex = 3;</span><br><span class="line"></span><br><span class="line">// 3号位置是粘连，匹配成功</span><br><span class="line">const match = REGEX.exec(<span class="string">'xaxa'</span>);</span><br><span class="line">match.index // 3</span><br><span class="line">REGEX.lastIndex // 4</span><br></pre></td></tr></table></figure><p>进一步说，y 修饰符号隐含了头部匹配的标志^。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/b/y.exec(<span class="string">'aba'</span>)</span><br><span class="line">// null</span><br></pre></td></tr></table></figure><p>上面代码由于不能保证头部匹配，所以返回 null。y 修饰符的设计本意，就是让头部匹配的标志^在全局匹配中都有效。</p><p>在 split 方法中使用 y 修饰符，原字符串必须以分隔符开头。这也意味着，只要匹配成功，数组的第一个成员肯定是空字符串。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 没有找到匹配</span><br><span class="line"><span class="string">'x##'</span>.split(/<span class="comment">#/y)</span></span><br><span class="line">// [ <span class="string">'x##'</span> ]</span><br><span class="line"></span><br><span class="line">// 找到两个匹配</span><br><span class="line"><span class="string">'##x'</span>.split(/<span class="comment">#/y)</span></span><br><span class="line">// [ <span class="string">''</span>, <span class="string">''</span>, <span class="string">'x'</span> ]</span><br></pre></td></tr></table></figure><p>后续的分隔符只有紧跟前面的分隔符，才会被识别。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'#x#'</span>.split(/<span class="comment">#/y)</span></span><br><span class="line">// [ <span class="string">''</span>, <span class="string">'x#'</span> ]</span><br><span class="line"></span><br><span class="line"><span class="string">'##'</span>.split(/<span class="comment">#/y)</span></span><br><span class="line">// [ <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span> ]</span><br></pre></td></tr></table></figure><p>下面是字符串对象的 replace 方法的例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const REGEX = /a/gy;</span><br><span class="line"><span class="string">'aaxa'</span>.replace(REGEX, <span class="string">'-'</span>) // <span class="string">'--xa'</span></span><br></pre></td></tr></table></figure><p>上面代码中，最后一个 a 因为不是出现下一次匹配的头部，所以不会被替换。</p><p>单单一个 y 修饰符对 match 方法，只能返回第一个匹配，必须与 g 修饰符联用，才能返回所有匹配。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'a1a2a3'</span>.match(/a\d/y) // [<span class="string">"a1"</span>]</span><br><span class="line"><span class="string">'a1a2a3'</span>.match(/a\d/gy) // [<span class="string">"a1"</span>, <span class="string">"a2"</span>, <span class="string">"a3"</span>]</span><br></pre></td></tr></table></figure><p>y 修饰符的一个应用，是从字符串提取 token（词元），y 修饰符确保了匹配之间不会有漏掉的字符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const TOKEN_Y = /\s*(\+|[0-9]+)\s*/y;</span><br><span class="line">const TOKEN_G  = /\s*(\+|[0-9]+)\s*/g;</span><br><span class="line"></span><br><span class="line">tokenize(TOKEN_Y, <span class="string">'3 + 4'</span>)</span><br><span class="line">// [ <span class="string">'3'</span>, <span class="string">'+'</span>, <span class="string">'4'</span> ]</span><br><span class="line">tokenize(TOKEN_G, <span class="string">'3 + 4'</span>)</span><br><span class="line">// [ <span class="string">'3'</span>, <span class="string">'+'</span>, <span class="string">'4'</span> ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> tokenize(TOKEN_REGEX, str) &#123;</span><br><span class="line">  <span class="built_in">let</span> result = [];</span><br><span class="line">  <span class="built_in">let</span> match;</span><br><span class="line">  <span class="keyword">while</span> (match = TOKEN_REGEX.exec(str)) &#123;</span><br><span class="line">    result.push(match[1]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，如果字符串里面没有非法字符，y 修饰符与 g 修饰符的提取结果是一样的。但是，一旦出现非法字符，两者的行为就不一样了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tokenize(TOKEN_Y, <span class="string">'3x + 4'</span>)</span><br><span class="line">// [ <span class="string">'3'</span> ]</span><br><span class="line">tokenize(TOKEN_G, <span class="string">'3x + 4'</span>)</span><br><span class="line">// [ <span class="string">'3'</span>, <span class="string">'+'</span>, <span class="string">'4'</span> ]</span><br></pre></td></tr></table></figure><p>上面代码中，g 修饰符会忽略非法字符，而 y 修饰符不会，这样就很容易发现错误。</p><h4 id="sticky-属性"><a href="#sticky-属性" class="headerlink" title="sticky 属性"></a>sticky 属性</h4><p>与 y 修饰符相匹配，ES6 的正则对象多了 sticky 属性，表示是否设置了 y 修饰符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var r = /hello\d/y;</span><br><span class="line">r.sticky // <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="flags-属性"><a href="#flags-属性" class="headerlink" title="flags 属性"></a>flags 属性</h4><p>ES6 为正则表达式新增了 flags 属性，会返回正则表达式的修饰符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// ES5的<span class="built_in">source</span>属性</span><br><span class="line">// 返回正则表达式的正文</span><br><span class="line">/abc/ig.source</span><br><span class="line">// <span class="string">"abc"</span></span><br><span class="line"></span><br><span class="line">// ES6的flags属性</span><br><span class="line">// 返回正则表达式的修饰符</span><br><span class="line">/abc/ig.flags</span><br><span class="line">// <span class="string">'gi'</span></span><br></pre></td></tr></table></figure><h4 id="RegExp-escape"><a href="#RegExp-escape" class="headerlink" title="RegExp.escape()"></a>RegExp.escape()</h4><p>字符串必须转义，才能作为正则模式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> escapeRegExp(str) &#123;</span><br><span class="line">  <span class="built_in">return</span> str.replace(/[\-\[\]\/\&#123;\&#125;\(\)\*\+\?\.\\\^\$\|]/g, <span class="string">'\\$&amp;'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> str = <span class="string">'/path/to/resource.html?search=query'</span>;</span><br><span class="line">escapeRegExp(str)</span><br><span class="line">// <span class="string">"\/path\/to\/resource\.html\?search=query"</span></span><br></pre></td></tr></table></figure><p>上面代码中，str 是一个正常字符串，必须使用反斜杠对其中的特殊字符转义，才能用来作为一个正则匹配的模式。</p><p>已经有提议将这个需求标准化，作为 RegExp 对象的静态方法 RegExp.escape()，放入 ES7。2015 年 7 月 31 日，TC39 认为，这个方法有安全风险，又不愿这个方法变得过于复杂，没有同意将其列入 ES7，但这不失为一个真实的需求。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RegExp.escape(<span class="string">'The Quick Brown Fox'</span>);</span><br><span class="line">// <span class="string">"The Quick Brown Fox"</span></span><br><span class="line"></span><br><span class="line">RegExp.escape(<span class="string">'Buy it. use it. break it. fix it.'</span>);</span><br><span class="line">// <span class="string">"Buy it\. use it\. break it\. fix it\."</span></span><br><span class="line"></span><br><span class="line">RegExp.escape(<span class="string">'(*.*)'</span>);</span><br><span class="line">// <span class="string">"\(\*\.\*\)"</span></span><br></pre></td></tr></table></figure><p>字符串转义以后，可以使用 RegExp 构造函数生成正则模式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str = <span class="string">'hello. how are you?'</span>;</span><br><span class="line">var regex = new RegExp(RegExp.escape(str), <span class="string">'g'</span>);</span><br><span class="line">assert.equal(String(regex), <span class="string">'/hello\. how are you\?/g'</span>);</span><br></pre></td></tr></table></figure><p>目前，该方法可以用上文的 escapeRegExp 函数或者垫片模块 regexp.escape 实现。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var escape = require(<span class="string">'regexp.escape'</span>);</span><br><span class="line">escape(<span class="string">'hi. how are you?'</span>);</span><br><span class="line">// <span class="string">"hi\\. how are you\\?"</span></span><br></pre></td></tr></table></figure><h4 id="s-修饰符：dotAll-模式"><a href="#s-修饰符：dotAll-模式" class="headerlink" title="s 修饰符：dotAll 模式"></a>s 修饰符：dotAll 模式</h4><p>正则表达式中，点（.）是一个特殊字符，代表任意的单个字符，但是行终止符（line terminator character）除外。</p><p>以下四个字符属于”行终止符“。</p><pre>U+000A 换行符（\n）U+000D 回车符（\r）U+2028 行分隔符（line separator）U+2029 段分隔符（paragraph separator）</pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/foo.bar/.<span class="built_in">test</span>(<span class="string">'foo\nbar'</span>)</span><br><span class="line">// <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>上面代码中，因为.不匹配\n，所以正则表达式返回 false。</p><p>但是，很多时候我们希望匹配的是任意单个字符，这时有一种变通的写法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/foo[^]bar/.<span class="built_in">test</span>(<span class="string">'foo\nbar'</span>)</span><br><span class="line">// <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>这种解决方案毕竟不太符合直觉，所以现在有一个提案，引入/s 修饰符，使得.可以匹配任意单个字符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/foo.bar/s.test(<span class="string">'foo\nbar'</span>) // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>这被称为 dotAll 模式，即点（dot）代表一切字符。所以，正则表达式还引入了一个 dotAll 属性，返回一个布尔值，表示该正则表达式是否处在 dotAll 模式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const re = /foo.bar/s;</span><br><span class="line">// 另一种写法</span><br><span class="line">// const re = new RegExp(<span class="string">'foo.bar'</span>, <span class="string">'s'</span>);</span><br><span class="line"></span><br><span class="line">re.test(<span class="string">'foo\nbar'</span>) // <span class="literal">true</span></span><br><span class="line">re.dotAll // <span class="literal">true</span></span><br><span class="line">re.flags // <span class="string">'s'</span></span><br></pre></td></tr></table></figure><p>/s 修饰符和多行修饰符/m 不冲突，两者一起使用的情况下，.匹配所有字符，而^和\$匹配每一行的行首和行尾。</p><h4 id="后行断言"><a href="#后行断言" class="headerlink" title="后行断言"></a>后行断言</h4><p>JavaScript 语言的正则表达式，只支持先行断言（lookahead）和先行否定断言（negative lookahead），不支持后行断言（lookbehind）和后行否定断言（negative lookbehind）。</p><p>目前，有一个提案，在 ES7 加入后行断言。V8 引擎 4.9 版已经支持，Chrome 浏览器 49 版打开”experimental JavaScript features“开关（地址栏键入 about:flags），就可以使用这项功能。</p><p>”先行断言“指的是，x 只有在 y 前面才匹配，必须写成/x(?=y)/。比如，只匹配百分号之前的数字，要写成/\d+(?=%)/。”先行否定断言“指的是，x 只有不在 y 前面才匹配，必须写成/x(?!y)/。比如，只匹配不在百分号之前的数字，要写成/\d+(?!%)/。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/\d+(?=%)/.<span class="built_in">exec</span>(<span class="string">'100% of US presidents have been male'</span>)  // [<span class="string">"100"</span>]</span><br><span class="line">/\d+(?!%)/.<span class="built_in">exec</span>(<span class="string">'that’s all 44 of them'</span>)                 // [<span class="string">"44"</span>]</span><br></pre></td></tr></table></figure><p>上面两个字符串，如果互换正则表达式，就会匹配失败。另外，还可以看到，”先行断言“括号之中的部分（(?=%)），是不计入返回结果的。</p><p>“后行断言”正好与”先行断言”相反，x 只有在 y 后面才匹配，必须写成/(?&lt;=y)x/。比如，只匹配美元符号之后的数字，要写成/(?&lt;=\$)\d+/。”后行否定断言“则与”先行否定断言“相反，x 只有不在 y 后面才匹配，必须写成/(?&lt;!y)x/。比如，只匹配不在美元符号后面的数字，要写成/(?&lt;!\$)\d+/。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/(?&lt;=\$)\d+/.<span class="built_in">exec</span>(<span class="string">'Benjamin Franklin is on the $100 bill'</span>)  // [<span class="string">"100"</span>]</span><br><span class="line">/(?&lt;!\$)\d+/.<span class="built_in">exec</span>(<span class="string">'it’s is worth about €90'</span>)                // [<span class="string">"90"</span>]</span><br></pre></td></tr></table></figure><p>上面的例子中，”后行断言”的括号之中的部分（(?&lt;=\$)），也是不计入返回结果。</p><p>“后行断言”的实现，需要先匹配/(?&lt;=y)x/的 x，然后再回到左边，匹配 y 的部分。这种”先右后左”的执行顺序，与所有其他正则操作相反，导致了一些不符合预期的行为。</p><p>首先，”后行断言“的组匹配，与正常情况下结果是不一样的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/(?&lt;=(\d+)(\d+))$/.<span class="built_in">exec</span>(<span class="string">'1053'</span>) // [<span class="string">""</span>, <span class="string">"1"</span>, <span class="string">"053"</span>]</span><br><span class="line">/^(\d+)(\d+)$/.<span class="built_in">exec</span>(<span class="string">'1053'</span>) // [<span class="string">"1053"</span>, <span class="string">"105"</span>, <span class="string">"3"</span>]</span><br></pre></td></tr></table></figure><p>上面代码中，需要捕捉两个组匹配。没有”后行断言”时，第一个括号是贪婪模式，第二个括号只能捕获一个字符，所以结果是 105 和 3。而”后行断言”时，由于执行顺序是从右到左，第二个括号是贪婪模式，第一个括号只能捕获一个字符，所以结果是 1 和 053。</p><p>其次，”后行断言”的反斜杠引用，也与通常的顺序相反，必须放在对应的那个括号之前。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/(?&lt;=(o)d\1)r/.<span class="built_in">exec</span>(<span class="string">'hodor'</span>)  // null</span><br><span class="line">/(?&lt;=\1d(o))r/.<span class="built_in">exec</span>(<span class="string">'hodor'</span>)  // [<span class="string">"r"</span>, <span class="string">"o"</span>]</span><br></pre></td></tr></table></figure><p>上面代码中，如果后行断言的反斜杠引用（\1）放在括号的后面，就不会得到匹配结果，必须放在前面才可以。</p><h4 id="Unicode-属性类"><a href="#Unicode-属性类" class="headerlink" title="Unicode 属性类"></a>Unicode 属性类</h4><p>目前，有一个提案，引入了一种新的类的写法\p{…}和\P{…}，允许正则表达式匹配符合 Unicode 某种属性的所有字符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const regexGreekSymbol = /\p&#123;Script=Greek&#125;/u;</span><br><span class="line">regexGreekSymbol.test(<span class="string">'π'</span>) // u</span><br></pre></td></tr></table></figure><p>上面代码中，\p{Script=Greek}指定匹配一个希腊文字母，所以匹配 π 成功。</p><p>Unicode 属性类要指定属性名和属性值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\p&#123;UnicodePropertyName=UnicodePropertyValue&#125;</span><br></pre></td></tr></table></figure><p>对于某些属性，可以只写属性名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\p&#123;UnicodePropertyName&#125;</span><br></pre></td></tr></table></figure><p>\P{…}是\p{…}的反向匹配，即匹配不满足条件的字符。</p><p>注意，这两种类只对 Unicode 有效，所以使用的时候一定要加上 u 修饰符。如果不加 u 修饰符，正则表达式使用\p 和\P 会报错，ECMAScript 预留了这两个类。</p><p>由于 Unicode 的各种属性非常多，所以这种新的类的表达能力非常强。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const regex = /^\p&#123;Decimal_Number&#125;+$/u;</span><br><span class="line">regex.test(<span class="string">'𝟏𝟐𝟑𝟜𝟝𝟞𝟩𝟪𝟫𝟬𝟭𝟮𝟯𝟺𝟻𝟼'</span>) // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>上面代码中，属性类指定匹配所有十进制字符，可以看到各种字型的十进制字符都会匹配成功。</p><p>\p{Number}甚至能匹配罗马数字。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 匹配所有数字</span><br><span class="line">const regex = /^\p&#123;Number&#125;+$/u;</span><br><span class="line">regex.test(<span class="string">'²³¹¼½¾'</span>) // <span class="literal">true</span></span><br><span class="line">regex.test(<span class="string">'㉛㉜㉝'</span>) // <span class="literal">true</span></span><br><span class="line">regex.test(<span class="string">'ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫ'</span>) // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>下面是其他一些例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 匹配各种文字的所有字母，等同于Unicode版的\w</span><br><span class="line">[\p&#123;Alphabetic&#125;\p&#123;Mark&#125;\p&#123;Decimal_Number&#125;\p&#123;Connector_Punctuation&#125;\p&#123;Join_Control&#125;]</span><br><span class="line"></span><br><span class="line">// 匹配各种文字的所有非字母的字符，等同于Unicode版的\W</span><br><span class="line">[\p&#123;Alphabetic&#125;\p&#123;Mark&#125;\p&#123;Decimal_Number&#125;\p&#123;Connector_Punctuation&#125;\p&#123;Join_Control&#125;]</span><br><span class="line"></span><br><span class="line">// 匹配所有的箭头字符</span><br><span class="line">const regexArrows = /^\p&#123;Block=Arrows&#125;+$/u;</span><br><span class="line">regexArrows.test(<span class="string">'←↑→↓↔↕↖↗↘↙⇏⇐⇑⇒⇓⇔⇕⇖⇗⇘⇙⇧⇩'</span>) // <span class="literal">true</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6_Unicode</title>
      <link href="/2019/01/05/es6-Unicode/"/>
      <url>/2019/01/05/es6-Unicode/</url>
      
        <content type="html"><![CDATA[<h3 id="ES6-字符串的扩展"><a href="#ES6-字符串的扩展" class="headerlink" title="ES6 字符串的扩展"></a>ES6 字符串的扩展</h3><p>ES6 加强了对 Unicode 的支持，并且扩展了字符串对象。</p><h4 id="字符的-Unicode-表示法"><a href="#字符的-Unicode-表示法" class="headerlink" title="字符的 Unicode 表示法"></a>字符的 Unicode 表示法</h4><p>JavaScript 允许采用\uxxxx 形式表示一个字符，其中“xxxx”表示字符的码点。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"\u0061"</span></span><br><span class="line">// <span class="string">"a"</span></span><br></pre></td></tr></table></figure><p>但是，这种表示法只限于\u0000——\uFFFF 之间的字符。超出这个范围的字符，必须用两个双字节的形式表达。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"\uD842\uDFB7"</span></span><br><span class="line">// <span class="string">"𠮷"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"\u20BB7"</span></span><br><span class="line">// <span class="string">" 7"</span></span><br></pre></td></tr></table></figure><p>上面代码表示，如果直接在\u 后面跟上超过 0xFFFF 的数值（比如\u20BB7），JavaScript 会理解成\u20BB+7。由于\u20BB 是一个不可打印字符，所以只会显示一个空格，后面跟着一个 7。</p><p>ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"\u&#123;20BB7&#125;"</span></span><br><span class="line">// <span class="string">"𠮷"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"\u&#123;41&#125;\u&#123;42&#125;\u&#123;43&#125;"</span></span><br><span class="line">// <span class="string">"ABC"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> hello = 123;</span><br><span class="line">hell\u&#123;6F&#125; // 123</span><br><span class="line"></span><br><span class="line"><span class="string">'\u&#123;1F680&#125;'</span> === <span class="string">'\uD83D\uDE80'</span></span><br><span class="line">// <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>上面代码中，最后一个例子表明，大括号表示法与四字节的 UTF-16 编码是等价的。</p><p>有了这种表示法之后，JavaScript 共有 6 种方法可以表示一个字符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'\z'</span> === <span class="string">'z'</span>  // <span class="literal">true</span></span><br><span class="line"><span class="string">'\172'</span> === <span class="string">'z'</span> // <span class="literal">true</span></span><br><span class="line"><span class="string">'\x7A'</span> === <span class="string">'z'</span> // <span class="literal">true</span></span><br><span class="line"><span class="string">'\u007A'</span> === <span class="string">'z'</span> // <span class="literal">true</span></span><br><span class="line"><span class="string">'\u&#123;7A&#125;'</span> === <span class="string">'z'</span> // <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="codePointAt"><a href="#codePointAt" class="headerlink" title="codePointAt()"></a>codePointAt()</h4><p>JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为 2 个字节。对于那些需要 4 个字节储存的字符（Unicode 码点大于 0xFFFF 的字符），JavaScript 会认为它们是两个字符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var s = <span class="string">"𠮷"</span>;</span><br><span class="line"></span><br><span class="line">s.length // 2</span><br><span class="line">s.charAt(0) // <span class="string">''</span></span><br><span class="line">s.charAt(1) // <span class="string">''</span></span><br><span class="line">s.charCodeAt(0) // 55362</span><br><span class="line">s.charCodeAt(1) // 57271</span><br></pre></td></tr></table></figure><p>上面代码中，汉字“𠮷”（注意，这个字不是”吉祥“的”吉“）的码点是 0x20BB7，UTF-16 编码为 0xD842 0xDFB7（十进制为 55362 57271），需要 4 个字节储存。对于这种 4 个字节的字符，JavaScript 不能正确处理，字符串长度会误判为 2，而且 charAt 方法无法读取整个字符，charCodeAt 方法只能分别返回前两个字节和后两个字节的值。</p><p>ES6 提供了 codePointAt 方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var s = <span class="string">'𠮷a'</span>;</span><br><span class="line"></span><br><span class="line">s.codePointAt(0) // 134071</span><br><span class="line">s.codePointAt(1) // 57271</span><br><span class="line"></span><br><span class="line">s.codePointAt(2) // 97</span><br></pre></td></tr></table></figure><p>codePointAt 方法的参数，是字符在字符串中的位置（从 0 开始）。上面代码中，JavaScript 将“𠮷 a”视为三个字符，codePointAt 方法在第一个字符上，正确地识别了“𠮷”，返回了它的十进制码点 134071（即十六进制的 20BB7）。在第二个字符（即“𠮷”的后两个字节）和第三个字符“a”上，codePointAt 方法的结果与 charCodeAt 方法相同。</p><p>总之，codePointAt 方法会正确返回 32 位的 UTF-16 字符的码点。对于那些两个字节储存的常规字符，它的返回结果与 charCodeAt 方法相同。</p><p>codePointAt 方法返回的是码点的十进制值，如果想要十六进制的值，可以使用 toString 方法转换一下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var s = <span class="string">'𠮷a'</span>;</span><br><span class="line"></span><br><span class="line">s.codePointAt(0).toString(16) // <span class="string">"20bb7"</span></span><br><span class="line">s.codePointAt(2).toString(16) // <span class="string">"61"</span></span><br></pre></td></tr></table></figure><p>你可能注意到了，codePointAt 方法的参数，仍然是不正确的。比如，上面代码中，字符 a 在字符串 s 的正确位置序号应该是 1，但是必须向 codePointAt 方法传入 2。解决这个问题的一个办法是使用 for…of 循环，因为它会正确识别 32 位的 UTF-16 字符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var s = <span class="string">'𠮷a'</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> ch of s) &#123;</span><br><span class="line">  console.log(ch.codePointAt(0).toString(16));</span><br><span class="line">&#125;</span><br><span class="line">// 20bb7</span><br><span class="line">// 61</span><br></pre></td></tr></table></figure><p>codePointAt 方法是测试一个字符由两个字节还是由四个字节组成的最简单方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> is32Bit(c) &#123;</span><br><span class="line">  <span class="built_in">return</span> c.codePointAt(0) &gt; 0xFFFF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">is32Bit(<span class="string">"𠮷"</span>) // <span class="literal">true</span></span><br><span class="line">is32Bit(<span class="string">"a"</span>) // <span class="literal">false</span></span><br></pre></td></tr></table></figure><h4 id="String-fromCodePoint"><a href="#String-fromCodePoint" class="headerlink" title="String.fromCodePoint()"></a>String.fromCodePoint()</h4><p>ES5 提供 String.fromCharCode 方法，用于从码点返回对应字符，但是这个方法不能识别 32 位的 UTF-16 字符（Unicode 编号大于 0xFFFF）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String.fromCharCode(0x20BB7)</span><br><span class="line">// <span class="string">"ஷ"</span></span><br></pre></td></tr></table></figure><p>上面代码中，String.fromCharCode 不能识别大于 0xFFFF 的码点，所以 0x20BB7 就发生了溢出，最高位 2 被舍弃了，最后返回码点 U+0BB7 对应的字符，而不是码点 U+20BB7 对应的字符。</p><p>ES6 提供了 String.fromCodePoint 方法，可以识别 0xFFFF 的字符，弥补了 String.fromCharCode 方法的不足。在作用上，正好与 codePointAt 方法相反。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String.fromCodePoint(0x20BB7)</span><br><span class="line">// <span class="string">"𠮷"</span></span><br><span class="line">String.fromCodePoint(0x78, 0x1f680, 0x79) === <span class="string">'x\uD83D\uDE80y'</span></span><br><span class="line">// <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>上面代码中，如果 String.fromCodePoint 方法有多个参数，则它们会被合并成一个字符串返回。</p><p>注意，fromCodePoint 方法定义在 String 对象上，而 codePointAt 方法定义在字符串的实例对象上。</p><h4 id="字符串的遍历器接口"><a href="#字符串的遍历器接口" class="headerlink" title="字符串的遍历器接口"></a>字符串的遍历器接口</h4><p>ES6 为字符串添加了遍历器接口（详见《Iterator》一章），使得字符串可以被 for…of 循环遍历。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> codePoint of <span class="string">'foo'</span>) &#123;</span><br><span class="line">  console.log(codePoint)</span><br><span class="line">&#125;</span><br><span class="line">// <span class="string">"f"</span></span><br><span class="line">// <span class="string">"o"</span></span><br><span class="line">// <span class="string">"o"</span></span><br></pre></td></tr></table></figure><p>除了遍历字符串，这个遍历器最大的优点是可以识别大于 0xFFFF 的码点，传统的 for 循环无法识别这样的码点。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var text = String.fromCodePoint(0x20BB7);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; text.length; i++) &#123;</span><br><span class="line">  console.log(text[i]);</span><br><span class="line">&#125;</span><br><span class="line">// <span class="string">" "</span></span><br><span class="line">// <span class="string">" "</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i of text) &#123;</span><br><span class="line">  console.log(i);</span><br><span class="line">&#125;</span><br><span class="line">// <span class="string">"𠮷"</span></span><br></pre></td></tr></table></figure><p>上面代码中，字符串 text 只有一个字符，但是 for 循环会认为它包含两个字符（都不可打印），而 for…of 循环会正确识别出这一个字符。</p><h4 id="at"><a href="#at" class="headerlink" title="at()"></a>at()</h4><p>ES5 对字符串对象提供 charAt 方法，返回字符串给定位置的字符。该方法不能识别码点大于 0xFFFF 的字符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'abc'</span>.charAt(0) // <span class="string">"a"</span></span><br><span class="line"><span class="string">'𠮷'</span>.charAt(0) // <span class="string">"\uD842"</span></span><br></pre></td></tr></table></figure><p>上面代码中，charAt 方法返回的是 UTF-16 编码的第一个字节，实际上是无法显示的。</p><p>目前，有一个提案，提出字符串实例的 at 方法，可以识别 Unicode 编号大于 0xFFFF 的字符，返回正确的字符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'abc'</span>.at(0) // <span class="string">"a"</span></span><br><span class="line"><span class="string">'𠮷'</span>.at(0) // <span class="string">"𠮷"</span></span><br></pre></td></tr></table></figure><p>这个方法可以通过垫片库实现。</p><h4 id="normalize"><a href="#normalize" class="headerlink" title="normalize()"></a>normalize()</h4><p>许多欧洲语言有语调符号和重音符号。为了表示它们，Unicode 提供了两种方法。一种是直接提供带重音符号的字符，比如 Ǒ（\u01D1）。另一种是提供合成符号（combining character），即原字符与重音符号的合成，两个字符合成一个字符，比如 O（\u004F）和 ˇ（\u030C）合成 Ǒ（\u004F\u030C）。</p><p>这两种表示方法，在视觉和语义上都等价，但是 JavaScript 不能识别。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'\u01D1'</span>===<span class="string">'\u004F\u030C'</span> //<span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="string">'\u01D1'</span>.length // 1</span><br><span class="line"><span class="string">'\u004F\u030C'</span>.length // 2</span><br></pre></td></tr></table></figure><p>上面代码表示，JavaScript 将合成字符视为两个字符，导致两种表示方法不相等。</p><p>ES6 提供字符串实例的 normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'\u01D1'</span>.normalize() === <span class="string">'\u004F\u030C'</span>.normalize()</span><br><span class="line">// <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>normalize 方法可以接受一个参数来指定 normalize 的方式，参数的四个可选值如下。</p><p>1.NFC，默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。<br>2.NFD，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。<br>3.NFKC，表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，normalize 方法不能识别中文。）<br>4.NFKD，表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'\u004F\u030C'</span>.normalize(<span class="string">'NFC'</span>).length // 1</span><br><span class="line"><span class="string">'\u004F\u030C'</span>.normalize(<span class="string">'NFD'</span>).length // 2</span><br></pre></td></tr></table></figure><p>上面代码表示，NFC 参数返回字符的合成形式，NFD 参数返回字符的分解形式。</p><p>不过，normalize 方法目前不能识别三个或三个以上字符的合成。这种情况下，还是只能使用正则表达式，通过 Unicode 编号区间判断。</p><h4 id="includes-startsWith-endsWith"><a href="#includes-startsWith-endsWith" class="headerlink" title="includes(), startsWith(), endsWith()"></a>includes(), startsWith(), endsWith()</h4><p>传统上，JavaScript 只有 indexOf 方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。</p><p>1.includes()：返回布尔值，表示是否找到了参数字符串。<br>2.startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。<br>3.endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var s = <span class="string">'Hello world!'</span>;</span><br><span class="line"></span><br><span class="line">s.startsWith(<span class="string">'Hello'</span>) // <span class="literal">true</span></span><br><span class="line">s.endsWith(<span class="string">'!'</span>) // <span class="literal">true</span></span><br><span class="line">s.includes(<span class="string">'o'</span>) // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>这三个方法都支持第二个参数，表示开始搜索的位置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var s = <span class="string">'Hello world!'</span>;</span><br><span class="line"></span><br><span class="line">s.startsWith(<span class="string">'world'</span>, 6) // <span class="literal">true</span></span><br><span class="line">s.endsWith(<span class="string">'Hello'</span>, 5) // <span class="literal">true</span></span><br><span class="line">s.includes(<span class="string">'Hello'</span>, 6) // <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>上面代码表示，使用第二个参数 n 时，endsWith 的行为与其他两个方法有所不同。它针对前 n 个字符，而其他两个方法针对从第 n 个位置直到字符串结束。</p><h4 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h4><p>repeat 方法返回一个新字符串，表示将原字符串重复 n 次。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'x'</span>.repeat(3) // <span class="string">"xxx"</span></span><br><span class="line"><span class="string">'hello'</span>.repeat(2) // <span class="string">"hellohello"</span></span><br><span class="line"><span class="string">'na'</span>.repeat(0) // <span class="string">""</span></span><br></pre></td></tr></table></figure><p>参数如果是小数，会被取整。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'na'</span>.repeat(2.9) // <span class="string">"nana"</span></span><br></pre></td></tr></table></figure><p>如果 repeat 的参数是负数或者 Infinity，会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'na'</span>.repeat(Infinity)</span><br><span class="line">// RangeError</span><br><span class="line"><span class="string">'na'</span>.repeat(-1)</span><br><span class="line">// RangeError</span><br></pre></td></tr></table></figure><p>但是，如果参数是 0 到-1 之间的小数，则等同于 0，这是因为会先进行取整运算。0 到-1 之间的小数，取整以后等于-0，repeat 视同为 0。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'na'</span>.repeat(-0.9) // <span class="string">""</span></span><br></pre></td></tr></table></figure><p>参数 NaN 等同于 0。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'na'</span>.repeat(NaN) // <span class="string">""</span></span><br></pre></td></tr></table></figure><p>如果 repeat 的参数是字符串，则会先转换成数字。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'na'</span>.repeat(<span class="string">'na'</span>) // <span class="string">""</span></span><br><span class="line"><span class="string">'na'</span>.repeat(<span class="string">'3'</span>) // <span class="string">"nanana"</span></span><br></pre></td></tr></table></figure><h4 id="padStart-，padEnd"><a href="#padStart-，padEnd" class="headerlink" title="padStart()，padEnd()"></a>padStart()，padEnd()</h4><p>ES7 推出了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart 用于头部补全，padEnd 用于尾部补全。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'x'</span>.padStart(5, <span class="string">'ab'</span>) // <span class="string">'ababx'</span></span><br><span class="line"><span class="string">'x'</span>.padStart(4, <span class="string">'ab'</span>) // <span class="string">'abax'</span></span><br><span class="line"></span><br><span class="line"><span class="string">'x'</span>.padEnd(5, <span class="string">'ab'</span>) // <span class="string">'xabab'</span></span><br><span class="line"><span class="string">'x'</span>.padEnd(4, <span class="string">'ab'</span>) // <span class="string">'xaba'</span></span><br></pre></td></tr></table></figure><p>上面代码中，padStart 和 padEnd 一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。</p><p>如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'xxx'</span>.padStart(2, <span class="string">'ab'</span>) // <span class="string">'xxx'</span></span><br><span class="line"><span class="string">'xxx'</span>.padEnd(2, <span class="string">'ab'</span>) // <span class="string">'xxx'</span></span><br></pre></td></tr></table></figure><p>如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'abc'</span>.padStart(10, <span class="string">'0123456789'</span>)</span><br><span class="line">// <span class="string">'0123456abc'</span></span><br></pre></td></tr></table></figure><p>如果省略第二个参数，则会用空格补全长度。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'x'</span>.padStart(4) // <span class="string">'   x'</span></span><br><span class="line"><span class="string">'x'</span>.padEnd(4) // <span class="string">'x   '</span></span><br></pre></td></tr></table></figure><p>padStart 的常见用途是为数值补全指定位数。下面代码生成 10 位的数值字符串。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'1'</span>.padStart(10, <span class="string">'0'</span>) // <span class="string">"0000000001"</span></span><br><span class="line"><span class="string">'12'</span>.padStart(10, <span class="string">'0'</span>) // <span class="string">"0000000012"</span></span><br><span class="line"><span class="string">'123456'</span>.padStart(10, <span class="string">'0'</span>) // <span class="string">"0000123456"</span></span><br></pre></td></tr></table></figure><p>另一个用途是提示字符串格式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'12'</span>.padStart(10, <span class="string">'YYYY-MM-DD'</span>) // <span class="string">"YYYY-MM-12"</span></span><br><span class="line"><span class="string">'09-12'</span>.padStart(10, <span class="string">'YYYY-MM-DD'</span>) // <span class="string">"YYYY-09-12"</span></span><br></pre></td></tr></table></figure><h4 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h4><p>传统的 JavaScript 语言，输出模板通常是这样写的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#result'</span>).append(</span><br><span class="line">  <span class="string">'There are &lt;b&gt;'</span> + basket.count + <span class="string">'&lt;/b&gt; '</span> +</span><br><span class="line">  <span class="string">'items in your basket, '</span> +</span><br><span class="line">  <span class="string">'&lt;em&gt;'</span> + basket.onSale +</span><br><span class="line">  <span class="string">'&lt;/em&gt; are on sale!'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面这种写法相当繁琐不方便，ES6 引入了模板字符串解决这个问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#result'</span>).append(`</span><br><span class="line">  There are &lt;b&gt;<span class="variable">$&#123;basket.count&#125;</span>&lt;/b&gt; items</span><br><span class="line">   <span class="keyword">in</span> your basket, &lt;em&gt;<span class="variable">$&#123;basket.onSale&#125;</span>&lt;/em&gt;</span><br><span class="line">  are on sale!</span><br><span class="line">`);</span><br></pre></td></tr></table></figure><p>模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 普通字符串</span><br><span class="line">`In JavaScript <span class="string">'\n'</span> is a line-feed.`</span><br><span class="line"></span><br><span class="line">// 多行字符串</span><br><span class="line">`In JavaScript this is</span><br><span class="line"> not legal.`</span><br><span class="line"></span><br><span class="line">console.log(`string text line 1</span><br><span class="line">string text line 2`);</span><br><span class="line"></span><br><span class="line">// 字符串中嵌入变量</span><br><span class="line">var name = <span class="string">"Bob"</span>, time = <span class="string">"today"</span>;</span><br><span class="line">`Hello <span class="variable">$&#123;name&#125;</span>, how are you <span class="variable">$&#123;time&#125;</span>?`</span><br></pre></td></tr></table></figure><p>上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var greeting = `\`Yo\` World!`;</span><br></pre></td></tr></table></figure><p>如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#list'</span>).html(`</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;first&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;second&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">`);</span><br></pre></td></tr></table></figure><p>上面代码中，所有模板字符串的空格和换行，都是被保留的，比如<ul>标签前面会有一个换行。如果你不想要这个换行，可以使用 trim 方法消除它。</ul></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#list'</span>).html(`</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;first&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;second&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">`.trim());</span><br></pre></td></tr></table></figure><p>模板字符串中嵌入变量，需要将变量名写在\${}之中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> authorize(user, action) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!user.hasPrivilege(action)) &#123;</span><br><span class="line">    throw new Error(</span><br><span class="line">      // 传统写法为</span><br><span class="line">      // <span class="string">'User '</span></span><br><span class="line">      // + user.name</span><br><span class="line">      // + <span class="string">' is not authorized to do '</span></span><br><span class="line">      // + action</span><br><span class="line">      // + <span class="string">'.'</span></span><br><span class="line">      `User <span class="variable">$&#123;user.name&#125;</span> is not authorized to <span class="keyword">do</span> <span class="variable">$&#123;action&#125;</span>.`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var x = 1;</span><br><span class="line">var y = 2;</span><br><span class="line"></span><br><span class="line">`<span class="variable">$&#123;x&#125;</span> + <span class="variable">$&#123;y&#125;</span> = <span class="variable">$&#123;x + y&#125;</span>`</span><br><span class="line">// <span class="string">"1 + 2 = 3"</span></span><br><span class="line"></span><br><span class="line">`<span class="variable">$&#123;x&#125;</span> + <span class="variable">$&#123;y * 2&#125;</span> = <span class="variable">$&#123;x + y * 2&#125;</span>`</span><br><span class="line">// <span class="string">"1 + 4 = 5"</span></span><br><span class="line"></span><br><span class="line">var obj = &#123;x: 1, y: 2&#125;;</span><br><span class="line">`<span class="variable">$&#123;obj.x + obj.y&#125;</span>`</span><br><span class="line">// 3</span><br></pre></td></tr></table></figure><p>模板字符串之中还能调用函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fn</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> <span class="string">"Hello World"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">`foo <span class="variable">$&#123;fn()&#125;</span> bar`</span><br><span class="line">// foo Hello World bar</span><br></pre></td></tr></table></figure><p>如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的 toString 方法。</p><p>如果模板字符串中的变量没有声明，将报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 变量place没有声明</span><br><span class="line">var msg = `Hello, <span class="variable">$&#123;place&#125;</span>`;</span><br><span class="line">// 报错</span><br></pre></td></tr></table></figure><p>由于模板字符串的大括号内部，就是执行 JavaScript 代码，因此如果大括号内部是一个字符串，将会原样输出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">`Hello <span class="variable">$&#123;'World'&#125;</span>`</span><br><span class="line">// <span class="string">"Hello World"</span></span><br></pre></td></tr></table></figure><p>模板字符串甚至还能嵌套。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const tmpl = addrs =&gt; `</span><br><span class="line">  &lt;table&gt;</span><br><span class="line">  $&#123;addrs.map(addr =&gt; `</span><br><span class="line">    &lt;tr&gt;&lt;td&gt;<span class="variable">$&#123;addr.first&#125;</span>&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">    &lt;tr&gt;&lt;td&gt;<span class="variable">$&#123;addr.last&#125;</span>&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">  `).join(<span class="string">''</span>)&#125;</span><br><span class="line">  &lt;/table&gt;</span><br><span class="line">`;</span><br></pre></td></tr></table></figure><p>上面代码中，模板字符串的变量之中，又嵌入了另一个模板字符串，使用方法如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const data = [</span><br><span class="line">    &#123; first: <span class="string">'&lt;Jane&gt;'</span>, last: <span class="string">'Bond'</span> &#125;,</span><br><span class="line">    &#123; first: <span class="string">'Lars'</span>, last: <span class="string">'&lt;Croft&gt;'</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">console.log(tmpl(data));</span><br><span class="line">// &lt;table&gt;</span><br><span class="line">//</span><br><span class="line">//   &lt;tr&gt;&lt;td&gt;&lt;Jane&gt;&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">//   &lt;tr&gt;&lt;td&gt;Bond&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">//</span><br><span class="line">//   &lt;tr&gt;&lt;td&gt;Lars&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">//   &lt;tr&gt;&lt;td&gt;&lt;Croft&gt;&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">//</span><br><span class="line">// &lt;/table&gt;</span><br></pre></td></tr></table></figure><p>如果需要引用模板字符串本身，在需要时执行，可以像下面这样写。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 写法一</span><br><span class="line"><span class="built_in">let</span> str = <span class="string">'return '</span> + <span class="string">'`Hello $&#123;name&#125;!`'</span>;</span><br><span class="line"><span class="built_in">let</span> func = new Function(<span class="string">'name'</span>, str);</span><br><span class="line">func(<span class="string">'Jack'</span>) // <span class="string">"Hello Jack!"</span></span><br><span class="line"></span><br><span class="line">// 写法二</span><br><span class="line"><span class="built_in">let</span> str = <span class="string">'(name) =&gt; `Hello $&#123;name&#125;!`'</span>;</span><br><span class="line"><span class="built_in">let</span> func = eval.call(null, str);</span><br><span class="line">func(<span class="string">'Jack'</span>) // <span class="string">"Hello Jack!"</span></span><br></pre></td></tr></table></figure><h4 id="实例：模板编译"><a href="#实例：模板编译" class="headerlink" title="实例：模板编译"></a>实例：模板编译</h4><p>下面，我们来看一个通过模板字符串，生成正式模板的实例。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var template = `</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;% <span class="keyword">for</span>(var i=0; i &lt; data.supplies.length; i++) &#123; %&gt;</span><br><span class="line">    &lt;li&gt;&lt;%= data.supplies[i] %&gt;&lt;/li&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">`;</span><br></pre></td></tr></table></figure><p>上面代码在模板字符串之中，放置了一个常规模板。该模板使用&lt;%…%&gt;放置 JavaScript 代码，使用&lt;%= … %&gt;输出 JavaScript 表达式。</p><p>怎么编译这个模板字符串呢？</p><p>一种思路是将其转换为 JavaScript 表达式字符串。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span>(<span class="string">'&lt;ul&gt;'</span>);</span><br><span class="line"><span class="keyword">for</span>(var i=0; i &lt; data.supplies.length; i++) &#123;</span><br><span class="line">  <span class="built_in">echo</span>(<span class="string">'&lt;li&gt;'</span>);</span><br><span class="line">  <span class="built_in">echo</span>(data.supplies[i]);</span><br><span class="line">  <span class="built_in">echo</span>(<span class="string">'&lt;/li&gt;'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">echo</span>(<span class="string">'&lt;/ul&gt;'</span>);</span><br></pre></td></tr></table></figure><p>这个转换使用正则表达式就行了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var evalExpr = /&lt;%=(.+?)%&gt;/g;</span><br><span class="line">var expr = /&lt;%([\s\S]+?)%&gt;/g;</span><br><span class="line"></span><br><span class="line">template = template</span><br><span class="line">  .replace(evalExpr, <span class="string">'`); \n  echo( $1 ); \n  echo(`'</span>)</span><br><span class="line">  .replace(expr, <span class="string">'`); \n $1 \n  echo(`'</span>);</span><br><span class="line"></span><br><span class="line">template = <span class="string">'echo(`'</span> + template + <span class="string">'`);'</span>;</span><br></pre></td></tr></table></figure><p>然后，将 template 封装在一个函数里面返回，就可以了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var script =</span><br><span class="line">`(<span class="keyword">function</span> parse(data)&#123;</span><br><span class="line">  var output = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="built_in">echo</span>(html)&#123;</span><br><span class="line">    output += html;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable">$&#123; template &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> output;</span><br><span class="line">&#125;)`;</span><br><span class="line"></span><br><span class="line"><span class="built_in">return</span> script;</span><br></pre></td></tr></table></figure><p>将上面的内容拼装成一个模板编译函数 compile。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> compile(template)&#123;</span><br><span class="line">  var evalExpr = /&lt;%=(.+?)%&gt;/g;</span><br><span class="line">  var expr = /&lt;%([\s\S]+?)%&gt;/g;</span><br><span class="line"></span><br><span class="line">  template = template</span><br><span class="line">    .replace(evalExpr, <span class="string">'`); \n  echo( $1 ); \n  echo(`'</span>)</span><br><span class="line">    .replace(expr, <span class="string">'`); \n $1 \n  echo(`'</span>);</span><br><span class="line"></span><br><span class="line">  template = <span class="string">'echo(`'</span> + template + <span class="string">'`);'</span>;</span><br><span class="line"></span><br><span class="line">  var script =</span><br><span class="line">  `(<span class="keyword">function</span> parse(data)&#123;</span><br><span class="line">    var output = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="built_in">echo</span>(html)&#123;</span><br><span class="line">      output += html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">$&#123; template &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> output;</span><br><span class="line">  &#125;)`;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> script;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>compile 函数的用法如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var parse = <span class="built_in">eval</span>(compile(template));</span><br><span class="line">div.innerHTML = parse(&#123; supplies: [ <span class="string">"broom"</span>, <span class="string">"mop"</span>, <span class="string">"cleaner"</span> ] &#125;);</span><br><span class="line">//   &lt;ul&gt;</span><br><span class="line">//     &lt;li&gt;broom&lt;/li&gt;</span><br><span class="line">//     &lt;li&gt;mop&lt;/li&gt;</span><br><span class="line">//     &lt;li&gt;cleaner&lt;/li&gt;</span><br><span class="line">//   &lt;/ul&gt;</span><br></pre></td></tr></table></figure><h4 id="标签模板"><a href="#标签模板" class="headerlink" title="标签模板"></a>标签模板</h4><p>模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert`123`</span><br><span class="line">// 等同于</span><br><span class="line">alert(123)</span><br></pre></td></tr></table></figure><p>标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。</p><p>但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = 5;</span><br><span class="line">var b = 10;</span><br><span class="line"></span><br><span class="line">tag`Hello <span class="variable">$&#123; a + b &#125;</span> world <span class="variable">$&#123; a * b &#125;</span>`;</span><br><span class="line">// 等同于</span><br><span class="line">tag([<span class="string">'Hello '</span>, <span class="string">' world '</span>, <span class="string">''</span>], 15, 50);</span><br></pre></td></tr></table></figure><p>上面代码中，模板字符串前面有一个标识名 tag，它是一个函数。整个表达式的返回值，就是 tag 函数处理模板字符串后的返回值。</p><p>函数 tag 依次会接收到多个参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> tag(stringArr, value1, value2)&#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> tag(stringArr, ...values)&#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tag 函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。</p><p>tag 函数的其他参数，都是模板字符串各个变量被替换后的值。由于本例中，模板字符串含有两个变量，因此 tag 会接受到 value1 和 value2 两个参数。</p><p>tag 函数所有参数的实际值如下。</p><p>1.第一个参数：[‘Hello ‘, ‘ world ‘, ‘’] 2.第二个参数: 15 3.第三个参数：50<br>也就是说，tag 函数实际上以下面的形式调用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tag([<span class="string">'Hello '</span>, <span class="string">' world '</span>, <span class="string">''</span>], 15, 50)</span><br></pre></td></tr></table></figure><p>我们可以按照需要编写 tag 函数的代码。下面是 tag 函数的一种写法，以及运行结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var a = 5;</span><br><span class="line">var b = 10;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> tag(s, v1, v2) &#123;</span><br><span class="line">  console.log(s[0]);</span><br><span class="line">  console.log(s[1]);</span><br><span class="line">  console.log(s[2]);</span><br><span class="line">  console.log(v1);</span><br><span class="line">  console.log(v2);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> <span class="string">"OK"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tag`Hello <span class="variable">$&#123; a + b &#125;</span> world <span class="variable">$&#123; a * b&#125;</span>`;</span><br><span class="line">// <span class="string">"Hello "</span></span><br><span class="line">// <span class="string">" world "</span></span><br><span class="line">// <span class="string">""</span></span><br><span class="line">// 15</span><br><span class="line">// 50</span><br><span class="line">// <span class="string">"OK"</span></span><br></pre></td></tr></table></figure><p>下面是一个更复杂的例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var total = 30;</span><br><span class="line">var msg = passthru`The total is <span class="variable">$&#123;total&#125;</span> (<span class="variable">$&#123;total*1.05&#125;</span> with tax)`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> passthru(literals) &#123;</span><br><span class="line">  var result = <span class="string">''</span>;</span><br><span class="line">  var i = 0;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i &lt; literals.length) &#123;</span><br><span class="line">    result += literals[i++];</span><br><span class="line">    <span class="keyword">if</span> (i &lt; arguments.length) &#123;</span><br><span class="line">      result += arguments[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">msg // <span class="string">"The total is 30 (31.5 with tax)"</span></span><br></pre></td></tr></table></figure><p>上面这个例子展示了，如何将各个参数按照原来的位置拼合回去。</p><p>passthru 函数采用 rest 参数的写法如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> passthru(literals, ...values) &#123;</span><br><span class="line">  var output = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">for</span> (var index = 0; index &lt; values.length; index++) &#123;</span><br><span class="line">    output += literals[index] + values[index];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  output += literals[index]</span><br><span class="line">  <span class="built_in">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“标签模板”的一个重要应用，就是过滤 HTML 字符串，防止用户输入恶意内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var message =</span><br><span class="line">  SaferHTML`&lt;p&gt;<span class="variable">$&#123;sender&#125;</span> has sent you a message.&lt;/p&gt;`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> SaferHTML(templateData) &#123;</span><br><span class="line">  var s = templateData[0];</span><br><span class="line">  <span class="keyword">for</span> (var i = 1; i &lt; arguments.length; i++) &#123;</span><br><span class="line">    var arg = String(arguments[i]);</span><br><span class="line"></span><br><span class="line">    // Escape special characters <span class="keyword">in</span> the substitution.</span><br><span class="line">    s += arg.replace(/&amp;/g, <span class="string">"&amp;amp;"</span>)</span><br><span class="line">            .replace(/&lt;/g, <span class="string">"&amp;lt;"</span>)</span><br><span class="line">            .replace(/&gt;/g, <span class="string">"&amp;gt;"</span>);</span><br><span class="line"></span><br><span class="line">    // Don<span class="string">'t escape special characters in the template.</span></span><br><span class="line"><span class="string">    s += templateData[i];</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  return s;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，sender 变量往往是用户提供的，经过 SaferHTML 函数处理，里面的特殊字符都会被转义。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var sender = <span class="string">'&lt;script&gt;alert("abc")&lt;/script&gt;'</span>; // 恶意代码</span><br><span class="line">var message = SaferHTML`&lt;p&gt;<span class="variable">$&#123;sender&#125;</span> has sent you a message.&lt;/p&gt;`;</span><br><span class="line"></span><br><span class="line">message</span><br><span class="line">// &lt;p&gt;&amp;lt;script&amp;gt;alert(<span class="string">"abc"</span>)&amp;lt;/script&amp;gt; has sent you a message.&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>标签模板的另一个应用，就是多语言转换（国际化处理）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i18n`Welcome to <span class="variable">$&#123;siteName&#125;</span>, you are visitor number <span class="variable">$&#123;visitorNumber&#125;</span>!`</span><br><span class="line">// <span class="string">"欢迎访问xxx，您是第xxxx位访问者！"</span></span><br></pre></td></tr></table></figure><p>模板字符串本身并不能取代 Mustache 之类的模板库，因为没有条件判断和循环处理功能，但是通过标签函数，你可以自己添加这些功能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 下面的hashTemplate函数</span><br><span class="line">// 是一个自定义的模板处理函数</span><br><span class="line">var libraryHtml = hashTemplate`</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    <span class="comment">#for book in $&#123;myBooks&#125;</span></span><br><span class="line">      &lt;li&gt;&lt;i&gt;<span class="comment">#&#123;book.title&#125;&lt;/i&gt; by #&#123;book.author&#125;&lt;/li&gt;</span></span><br><span class="line">    <span class="comment">#end</span></span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">`;</span><br></pre></td></tr></table></figure><p>除此之外，你甚至可以使用标签模板，在 JavaScript 语言之中嵌入其他语言。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">jsx`</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input</span><br><span class="line">      ref=<span class="string">'input'</span></span><br><span class="line">      onChange=<span class="string">'$&#123;this.handleChange&#125;'</span></span><br><span class="line">      defaultValue=<span class="string">'$&#123;this.state.value&#125;'</span> /&gt;</span><br><span class="line">      <span class="variable">$&#123;this.state.value&#125;</span></span><br><span class="line">   &lt;/div&gt;</span><br><span class="line">`</span><br></pre></td></tr></table></figure><p>上面的代码通过 jsx 函数，将一个 DOM 字符串转为 React 对象。你可以在 Github 找到 jsx 函数的具体实现。</p><p>下面则是一个假想的例子，通过 java 函数，在 JavaScript 代码之中运行 Java 代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java`</span><br><span class="line">class HelloWorldApp &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    System.out.println(“Hello World!”); // Display the string.</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">`</span><br><span class="line">HelloWorldApp.main();</span><br></pre></td></tr></table></figure><p>模板处理函数的第一个参数（模板字符串数组），还有一个 raw 属性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log`123`</span><br><span class="line">// [<span class="string">"123"</span>, raw: Array[1]]</span><br></pre></td></tr></table></figure><p>上面代码中，console.log 接受的参数，实际上是一个数组。该数组有一个 raw 属性，保存的是转义后的原字符串。</p><p>请看下面的例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tag`First line\nSecond line`</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> tag(strings) &#123;</span><br><span class="line">  console.log(strings.raw[0]);</span><br><span class="line">  // <span class="string">"First line\\nSecond line"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，tag 函数的第一个参数 strings，有一个 raw 属性，也指向一个数组。该数组的成员与 strings 数组完全一致。比如，strings 数组是[“First line\nSecond line”]，那么 strings.raw 数组就是[“First line\nSecond line”]。两者唯一的区别，就是字符串里面的斜杠都被转义了。比如，strings.raw 数组会将\n 视为\和 n 两个字符，而不是换行符。这是为了方便取得转义之前的原始模板而设计的。</p><h4 id="String-raw"><a href="#String-raw" class="headerlink" title="String.raw()"></a>String.raw()</h4><p>ES6 还为原生的 String 对象，提供了一个 raw 方法。</p><p>String.raw 方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String.raw`Hi\n<span class="variable">$&#123;2+3&#125;</span>!`;</span><br><span class="line">// <span class="string">"Hi\\n5!"</span></span><br><span class="line"></span><br><span class="line">String.raw`Hi\u000A!`;</span><br><span class="line">// <span class="string">'Hi\\u000A!'</span></span><br></pre></td></tr></table></figure><p>如果原字符串的斜杠已经转义，那么 String.raw 不会做任何处理。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String.raw`Hi\\n`</span><br><span class="line">// <span class="string">"Hi\\n"</span></span><br></pre></td></tr></table></figure><p>String.raw 的代码基本如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String.raw = <span class="keyword">function</span> (strings, ...values) &#123;</span><br><span class="line">  var output = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">for</span> (var index = 0; index &lt; values.length; index++) &#123;</span><br><span class="line">    output += strings.raw[index] + values[index];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  output += strings.raw[index]</span><br><span class="line">  <span class="built_in">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>String.raw 方法可以作为处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。</p><p>String.raw 方法也可以作为正常的函数使用。这时，它的第一个参数，应该是一个具有 raw 属性的对象，且 raw 属性的值应该是一个数组。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String.raw(&#123; raw: <span class="string">'test'</span> &#125;, 0, 1, 2);</span><br><span class="line">// <span class="string">'t0e1s2t'</span></span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">String.raw(&#123; raw: [<span class="string">'t'</span>,<span class="string">'e'</span>,<span class="string">'s'</span>,<span class="string">'t'</span>] &#125;, 0, 1, 2);</span><br></pre></td></tr></table></figure><h4 id="模板字符串的限制"><a href="#模板字符串的限制" class="headerlink" title="模板字符串的限制"></a>模板字符串的限制</h4><p>前面提到标签模板里面，可以内嵌其他语言。但是，模板字符串默认会将字符串转义，因此导致了无法嵌入其他语言。</p><p>举例来说，在标签模板里面可以嵌入 Latex 语言。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> latex(strings) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> document = latex`</span><br><span class="line">\newcommand&#123;\fun&#125;&#123;\textbf&#123;Fun!&#125;&#125;  // 正常工作</span><br><span class="line">\newcommand&#123;\unicode&#125;&#123;\textbf&#123;Unicode!&#125;&#125; // 报错</span><br><span class="line">\newcommand&#123;\xerxes&#125;&#123;\textbf&#123;King!&#125;&#125; // 报错</span><br><span class="line"></span><br><span class="line">Breve over the h goes \u&#123;h&#125;ere // 报错</span><br><span class="line">`</span><br></pre></td></tr></table></figure><p>上面代码中，变量 document 内嵌的模板字符串，对于 Latex 语言来说完全是合法的，但是 JavaScript 引擎会报错。原因就在于字符串的转义。</p><p>模板字符串会将\u00FF 和\u{42}当作 Unicode 字符进行转义，所以\unicode 解析时报错；而\x56 会被当作十六进制字符串转义，所以\xerxes 会报错。</p><p>为了解决这个问题，现在有一个提案，放松对标签模板里面的字符串转义的限制。如果遇到不合法的字符串转义，就返回 undefined，而不是报错，并且从 raw 属性上面可以得到原始字符串。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> tag(strs) &#123;</span><br><span class="line">  strs[0] === undefined</span><br><span class="line">  strs.raw[0] === <span class="string">"\\unicode and \\u&#123;55&#125;"</span>;</span><br><span class="line">&#125;</span><br><span class="line">tag`\unicode and \u&#123;55&#125;`</span><br></pre></td></tr></table></figure><p>上面代码中，模板字符串原本是应该报错的，但是由于放松了对字符串转义的限制，所以不报错了，JavaScript 引擎将第一个字符设置为 undefined，但是 raw 属性依然可以得到原始字符串，因此 tag 函数还是可以对原字符串进行处理。</p><p>注意，这种对字符串转义的放松，只在标签模板解析字符串时生效，不是标签模板的场合，依然会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> bad = `bad escape sequence: \unicode`; // 报错</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6_Destructuring</title>
      <link href="/2018/12/31/es6-Destructuring/"/>
      <url>/2018/12/31/es6-Destructuring/</url>
      
        <content type="html"><![CDATA[<h3 id="ES6-变量的解构赋值"><a href="#ES6-变量的解构赋值" class="headerlink" title="ES6 变量的解构赋值"></a>ES6 变量的解构赋值</h3><h4 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h4><h5 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h5><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p><p>以前，为变量赋值，只能直接指定值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">var b = 2;</span><br><span class="line">var c = 3;</span><br><span class="line">ES6允许写成下面这样。</span><br><span class="line"></span><br><span class="line">var [a, b, c] = [1, 2, 3];</span><br></pre></td></tr></table></figure><p>上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。</p><p>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> [foo, [[bar], baz]] = [1, [[2], 3]];</span><br><span class="line">foo // 1</span><br><span class="line">bar // 2</span><br><span class="line">baz // 3</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> [ , , third] = [<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"baz"</span>];</span><br><span class="line">third // <span class="string">"baz"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> [x, , y] = [1, 2, 3];</span><br><span class="line">x // 1</span><br><span class="line">y // 3</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> [head, ...tail] = [1, 2, 3, 4];</span><br><span class="line">head // 1</span><br><span class="line">tail // [2, 3, 4]</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> [x, y, ...z] = [<span class="string">'a'</span>];</span><br><span class="line">x // <span class="string">"a"</span></span><br><span class="line">y // undefined</span><br><span class="line">z // []</span><br></pre></td></tr></table></figure><p>如果解构不成功，变量的值就等于 undefined。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var [foo] = [];</span><br><span class="line">var [bar, foo] = [1];</span><br></pre></td></tr></table></figure><p>以上两种情况都属于解构不成功，foo 的值都会等于 undefined。</p><p>另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> [x, y] = [1, 2, 3];</span><br><span class="line">x // 1</span><br><span class="line">y // 2</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> [a, [b], d] = [1, [2, 3], 4];</span><br><span class="line">a // 1</span><br><span class="line">b // 2</span><br><span class="line">d // 4</span><br></pre></td></tr></table></figure><p>上面两个例子，都属于不完全解构，但是可以成功。</p><p>如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line"><span class="built_in">let</span> [foo] = 1;</span><br><span class="line"><span class="built_in">let</span> [foo] = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">let</span> [foo] = NaN;</span><br><span class="line"><span class="built_in">let</span> [foo] = undefined;</span><br><span class="line"><span class="built_in">let</span> [foo] = null;</span><br><span class="line"><span class="built_in">let</span> [foo] = &#123;&#125;;</span><br></pre></td></tr></table></figure><p>上面的表达式都会报错，因为等号右边的值，要么转为对象以后不具备 Iterator 接口（前五个表达式），要么本身就不具备 Iterator 接口（最后一个表达式）。</p><p>解构赋值不仅适用于 var 命令，也适用于 let 和 const 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var [v1, v2, ..., vN ] = array;</span><br><span class="line"><span class="built_in">let</span> [v1, v2, ..., vN ] = array;</span><br><span class="line">const [v1, v2, ..., vN ] = array;</span><br></pre></td></tr></table></figure><p>对于 Set 结构，也可以使用数组的解构赋值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> [x, y, z] = new Set([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]);</span><br><span class="line">x // <span class="string">"a"</span></span><br></pre></td></tr></table></figure><p>事实上，只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">fibs</span></span>() &#123;</span><br><span class="line">  var a = 0;</span><br><span class="line">  var b = 1;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    yield a;</span><br><span class="line">    [a, b] = [b, a + b];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var [first, second, third, fourth, fifth, sixth] = fibs();</span><br><span class="line">sixth // 5</span><br></pre></td></tr></table></figure><p>上面代码中，fibs 是一个 Generator 函数，原生具有 Iterator 接口。解构赋值会依次从这个接口获取值。</p><h5 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h5><p>解构赋值允许指定默认值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var [foo = <span class="literal">true</span>] = [];</span><br><span class="line">foo // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>]; // x=<span class="string">'a'</span>, y=<span class="string">'b'</span></span><br><span class="line">[x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>, undefined]; // x=<span class="string">'a'</span>, y=<span class="string">'b'</span></span><br></pre></td></tr></table></figure><p>注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格等于 undefined，默认值是不会生效的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var [x = 1] = [undefined];</span><br><span class="line">x // 1</span><br><span class="line"></span><br><span class="line">var [x = 1] = [null];</span><br><span class="line">x // null</span><br></pre></td></tr></table></figure><p>上面代码中，如果一个数组成员是 null，默认值就不会生效，因为 null 不严格等于 undefined。</p><p>如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">'aaa'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> [x = f()] = [1];</span><br></pre></td></tr></table></figure><p>上面代码中，因为 x 能取到值，所以函数 f 根本不会执行。上面的代码其实等价于下面的代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> x;</span><br><span class="line"><span class="keyword">if</span> ([1][0] === undefined) &#123;</span><br><span class="line">  x = f();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  x = [1][0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认值可以引用解构赋值的其他变量，但该变量必须已经声明。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> [x = 1, y = x] = [];     // x=1; y=1</span><br><span class="line"><span class="built_in">let</span> [x = 1, y = x] = [2];    // x=2; y=2</span><br><span class="line"><span class="built_in">let</span> [x = 1, y = x] = [1, 2]; // x=1; y=2</span><br><span class="line"><span class="built_in">let</span> [x = y, y = 1] = [];     // ReferenceError</span><br></pre></td></tr></table></figure><p>上面最后一个表达式之所以会报错，是因为 x 用到默认值 y 时，y 还没有声明。</p><h4 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h4><p>解构不仅可以用于数组，还可以用于对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var &#123; foo, bar &#125; = &#123; foo: <span class="string">"aaa"</span>, bar: <span class="string">"bbb"</span> &#125;;</span><br><span class="line">foo // <span class="string">"aaa"</span></span><br><span class="line">bar // <span class="string">"bbb"</span></span><br></pre></td></tr></table></figure><p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var &#123; bar, foo &#125; = &#123; foo: <span class="string">"aaa"</span>, bar: <span class="string">"bbb"</span> &#125;;</span><br><span class="line">foo // <span class="string">"aaa"</span></span><br><span class="line">bar // <span class="string">"bbb"</span></span><br><span class="line"></span><br><span class="line">var &#123; baz &#125; = &#123; foo: <span class="string">"aaa"</span>, bar: <span class="string">"bbb"</span> &#125;;</span><br><span class="line">baz // undefined</span><br></pre></td></tr></table></figure><p>上面代码的第一个例子，等号左边的两个变量的次序，与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。第二个例子的变量没有对应的同名属性，导致取不到值，最后等于 undefined。</p><p>如果变量名与属性名不一致，必须写成下面这样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var &#123; foo: baz &#125; = &#123; foo: <span class="string">'aaa'</span>, bar: <span class="string">'bbb'</span> &#125;;</span><br><span class="line">baz // <span class="string">"aaa"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> obj = &#123; first: <span class="string">'hello'</span>, last: <span class="string">'world'</span> &#125;;</span><br><span class="line"><span class="built_in">let</span> &#123; first: f, last: l &#125; = obj;</span><br><span class="line">f // <span class="string">'hello'</span></span><br><span class="line">l // <span class="string">'world'</span></span><br></pre></td></tr></table></figure><p>这实际上说明，对象的解构赋值是下面形式的简写（参见《对象的扩展》一章）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var &#123; foo: foo, bar: bar &#125; = &#123; foo: <span class="string">"aaa"</span>, bar: <span class="string">"bbb"</span> &#125;;</span><br></pre></td></tr></table></figure><p>也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var &#123; foo: baz &#125; = &#123; foo: <span class="string">"aaa"</span>, bar: <span class="string">"bbb"</span> &#125;;</span><br><span class="line">baz // <span class="string">"aaa"</span></span><br><span class="line">foo // error: foo is not defined</span><br></pre></td></tr></table></figure><p>上面代码中，foo 是匹配的模式，baz 才是变量。真正被赋值的是变量 baz，而不是模式 foo。</p><p>注意，采用这种写法时，变量的声明和赋值是一体的。对于 let 和 const 来说，变量不能重新声明，所以一旦赋值的变量以前声明过，就会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> foo;</span><br><span class="line"><span class="built_in">let</span> &#123;foo&#125; = &#123;foo: 1&#125;; // SyntaxError: Duplicate declaration <span class="string">"foo"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> baz;</span><br><span class="line"><span class="built_in">let</span> &#123;bar: baz&#125; = &#123;bar: 1&#125;; // SyntaxError: Duplicate declaration <span class="string">"baz"</span></span><br></pre></td></tr></table></figure><p>上面代码中，解构赋值的变量都会重新声明，所以报错了。不过，因为 var 命令允许重新声明，所以这个错误只会在使用 let 和 const 命令时出现。如果没有第二个 let 命令，上面的代码就不会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> foo;</span><br><span class="line">(&#123;foo&#125; = &#123;foo: 1&#125;); // 成功</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> baz;</span><br><span class="line">(&#123;bar: baz&#125; = &#123;bar: 1&#125;); // 成功</span><br></pre></td></tr></table></figure><p>上面代码中，let 命令下面一行的圆括号是必须的，否则会报错。因为解析器会将起首的大括号，理解成一个代码块，而不是赋值语句。</p><p>和数组一样，解构也可以用于嵌套结构的对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  p: [</span><br><span class="line">    <span class="string">'Hello'</span>,</span><br><span class="line">    &#123; y: <span class="string">'World'</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var &#123; p: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">x // <span class="string">"Hello"</span></span><br><span class="line">y // <span class="string">"World"</span></span><br></pre></td></tr></table></figure><p>注意，这时 p 是模式，不是变量，因此不会被赋值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var node = &#123;</span><br><span class="line">  loc: &#123;</span><br><span class="line">    start: &#123;</span><br><span class="line">      line: 1,</span><br><span class="line">      column: 5</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var &#123; loc: &#123; start: &#123; line &#125;&#125; &#125; = node;</span><br><span class="line">line // 1</span><br><span class="line">loc  // error: loc is undefined</span><br><span class="line">start // error: start is undefined</span><br></pre></td></tr></table></figure><p>上面代码中，只有 line 是变量，loc 和 start 都是模式，不会被赋值。</p><p>下面是嵌套赋值的例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">let</span> arr = [];</span><br><span class="line"></span><br><span class="line">(&#123; foo: obj.prop, bar: arr[0] &#125; = &#123; foo: 123, bar: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line">obj // &#123;prop:123&#125;</span><br><span class="line">arr // [<span class="literal">true</span>]</span><br></pre></td></tr></table></figure><p>对象的解构也可以指定默认值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var &#123;x = 3&#125; = &#123;&#125;;</span><br><span class="line">x // 3</span><br><span class="line"></span><br><span class="line">var &#123;x, y = 5&#125; = &#123;x: 1&#125;;</span><br><span class="line">x // 1</span><br><span class="line">y // 5</span><br><span class="line"></span><br><span class="line">var &#123;x:y = 3&#125; = &#123;&#125;;</span><br><span class="line">y // 3</span><br><span class="line"></span><br><span class="line">var &#123;x:y = 3&#125; = &#123;x: 5&#125;;</span><br><span class="line">y // 5</span><br><span class="line"></span><br><span class="line">var &#123; message: msg = <span class="string">'Something went wrong'</span> &#125; = &#123;&#125;;</span><br><span class="line">msg // <span class="string">"Something went wrong"</span></span><br></pre></td></tr></table></figure><p>默认值生效的条件是，对象的属性值严格等于 undefined。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var &#123;x = 3&#125; = &#123;x: undefined&#125;;</span><br><span class="line">x // 3</span><br><span class="line"></span><br><span class="line">var &#123;x = 3&#125; = &#123;x: null&#125;;</span><br><span class="line">x // null</span><br></pre></td></tr></table></figure><p>上面代码中，如果 x 属性等于 null，就不严格相等于 undefined，导致默认值不会生效。</p><p>如果解构失败，变量的值等于 undefined。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var &#123;foo&#125; = &#123;bar: <span class="string">'baz'</span>&#125;;</span><br><span class="line">foo // undefined</span><br></pre></td></tr></table></figure><p>如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line">var &#123;foo: &#123;bar&#125;&#125; = &#123;baz: <span class="string">'baz'</span>&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，等号左边对象的 foo 属性，对应一个子对象。该子对象的 bar 属性，解构时会报错。原因很简单，因为 foo 这时等于 undefined，再取子属性就会报错，请看下面的代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var _tmp = &#123;baz: <span class="string">'baz'</span>&#125;;</span><br><span class="line">_tmp.foo.bar // 报错</span><br></pre></td></tr></table></figure><p>如果要将一个已经声明的变量用于解构赋值，必须非常小心。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 错误的写法</span><br><span class="line">var x;</span><br><span class="line">&#123;x&#125; = &#123;x: 1&#125;;</span><br><span class="line">// SyntaxError: syntax error</span><br></pre></td></tr></table></figure><p>上面代码的写法会报错，因为 JavaScript 引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 正确的写法</span><br><span class="line">(&#123;x&#125; = &#123;x: 1&#125;);</span><br></pre></td></tr></table></figure><p>上面代码将整个解构赋值语句，放在一个圆括号里面，就可以正确执行。关于圆括号与解构赋值的关系，参见下文。</p><p>解构赋值允许，等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(&#123;&#125; = [<span class="literal">true</span>, <span class="literal">false</span>]);</span><br><span class="line">(&#123;&#125; = <span class="string">'abc'</span>);</span><br><span class="line">(&#123;&#125; = []);</span><br></pre></td></tr></table></figure><p>上面的表达式虽然毫无意义，但是语法是合法的，可以执行。</p><p>对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> &#123; <span class="built_in">log</span>, sin, cos &#125; = Math;</span><br></pre></td></tr></table></figure><p>上面代码将 Math 对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。</p><p>由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3];</span><br><span class="line">var &#123;0 : first, [arr.length - 1] : last&#125; = arr;</span><br><span class="line">first // 1</span><br><span class="line">last // 3</span><br></pre></td></tr></table></figure><p>上面代码对数组进行对象解构。数组 arr 的 0 键对应的值是 1，[arr.length - 1]就是 2 键，对应的值是 3。方括号这种写法，属于“属性名表达式”，参见《对象的扩展》一章。</p><h4 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h4><p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const [a, b, c, d, e] = <span class="string">'hello'</span>;</span><br><span class="line">a // <span class="string">"h"</span></span><br><span class="line">b // <span class="string">"e"</span></span><br><span class="line">c // <span class="string">"l"</span></span><br><span class="line">d // <span class="string">"l"</span></span><br><span class="line">e // <span class="string">"o"</span></span><br></pre></td></tr></table></figure><p>类似数组的对象都有一个 length 属性，因此还可以对这个属性解构赋值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> &#123;length : len&#125; = <span class="string">'hello'</span>;</span><br><span class="line">len // 5</span><br></pre></td></tr></table></figure><h4 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h4><p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> &#123;toString: s&#125; = 123;</span><br><span class="line">s === Number.prototype.toString // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> &#123;toString: s&#125; = <span class="literal">true</span>;</span><br><span class="line">s === Boolean.prototype.toString // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>上面代码中，数值和布尔值的包装对象都有 toString 属性，因此变量 s 都能取到值。</p><p>解构赋值的规则是，只要等号右边的值不是对象，就先将其转为对象。由于 undefined 和 null 无法转为对象，所以对它们进行解构赋值，都会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> &#123; prop: x &#125; = undefined; // TypeError</span><br><span class="line"><span class="built_in">let</span> &#123; prop: y &#125; = null; // TypeError</span><br></pre></td></tr></table></figure><h4 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h4><p>函数的参数也可以使用解构赋值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> add([x, y])&#123;</span><br><span class="line">  <span class="built_in">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add([1, 2]); // 3</span><br></pre></td></tr></table></figure><p>上面代码中，函数 add 的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量 x 和 y。对于函数内部的代码来说，它们能感受到的参数就是 x 和 y。</p><p>下面是另一个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);</span><br><span class="line">// [ 3, 7 ]</span><br></pre></td></tr></table></figure><p>函数参数的解构也可以使用默认值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123;</span><br><span class="line">  <span class="built_in">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">move(&#123;x: 3, y: 8&#125;); // [3, 8]</span><br><span class="line">move(&#123;x: 3&#125;); // [3, 0]</span><br><span class="line">move(&#123;&#125;); // [0, 0]</span><br><span class="line">move(); // [0, 0]</span><br></pre></td></tr></table></figure><p>上面代码中，函数 move 的参数是一个对象，通过对这个对象进行解构，得到变量 x 和 y 的值。如果解构失败，x 和 y 等于默认值。</p><p>注意，下面的写法会得到不一样的结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> move(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123;</span><br><span class="line">  <span class="built_in">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">move(&#123;x: 3, y: 8&#125;); // [3, 8]</span><br><span class="line">move(&#123;x: 3&#125;); // [3, undefined]</span><br><span class="line">move(&#123;&#125;); // [undefined, undefined]</span><br><span class="line">move(); // [0, 0]</span><br></pre></td></tr></table></figure><p>上面代码是为函数 move 的参数指定默认值，而不是为变量 x 和 y 指定默认值，所以会得到与前一种写法不同的结果。</p><p>undefined 就会触发函数参数的默认值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, undefined, 3].map((x = <span class="string">'yes'</span>) =&gt; x);</span><br><span class="line">// [ 1, <span class="string">'yes'</span>, 3 ]</span><br></pre></td></tr></table></figure><h4 id="圆括号问题"><a href="#圆括号问题" class="headerlink" title="圆括号问题"></a>圆括号问题</h4><p>解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。</p><p>由此带来的问题是，如果模式中出现圆括号怎么处理。ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。</p><p>但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。</p><h5 id="不能使用圆括号的情况"><a href="#不能使用圆括号的情况" class="headerlink" title="不能使用圆括号的情况"></a>不能使用圆括号的情况</h5><p>以下三种解构赋值不得使用圆括号。</p><p>（1）变量声明语句中，不能带有圆括号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 全部报错</span><br><span class="line">var [(a)] = [1];</span><br><span class="line"></span><br><span class="line">var &#123;x: (c)&#125; = &#123;&#125;;</span><br><span class="line">var (&#123;x: c&#125;) = &#123;&#125;;</span><br><span class="line">var &#123;(x: c)&#125; = &#123;&#125;;</span><br><span class="line">var &#123;(x): c&#125; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">var &#123; o: (&#123; p: p &#125;) &#125; = &#123; o: &#123; p: 2 &#125; &#125;;</span><br></pre></td></tr></table></figure><p>上面三个语句都会报错，因为它们都是变量声明语句，模式不能使用圆括号。</p><p>（2）函数参数中，模式不能带有圆括号。</p><p>函数参数也属于变量声明，因此不能带有圆括号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line"><span class="keyword">function</span> f([(z)]) &#123; <span class="built_in">return</span> z; &#125;</span><br></pre></td></tr></table></figure><p>（3）赋值语句中，不能将整个模式，或嵌套模式中的一层，放在圆括号之中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 全部报错</span><br><span class="line">(&#123; p: a &#125;) = &#123; p: 42 &#125;;</span><br><span class="line">([a]) = [5];</span><br></pre></td></tr></table></figure><p>上面代码将整个模式放在圆括号之中，导致报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line">[(&#123; p: a &#125;), &#123; x: c &#125;] = [&#123;&#125;, &#123;&#125;];</span><br></pre></td></tr></table></figure><p>上面代码将嵌套模式的一层，放在圆括号之中，导致报错。</p><h5 id="可以使用圆括号的情况"><a href="#可以使用圆括号的情况" class="headerlink" title="可以使用圆括号的情况"></a>可以使用圆括号的情况</h5><p>可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[(b)] = [3]; // 正确</span><br><span class="line">(&#123; p: (d) &#125; = &#123;&#125;); // 正确</span><br><span class="line">[(parseInt.prop)] = [3]; // 正确</span><br></pre></td></tr></table></figure><p>上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是 p，而不是 d；第三行语句与第一行语句的性质一致。</p><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><p>变量的解构赋值用途很多。</p><p>（1）交换变量的值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x, y] = [y, x];</span><br></pre></td></tr></table></figure><p>上面代码交换变量 x 和 y 的值，这样的写法不仅简洁，而且易读，语义非常清晰。</p><p>（2）从函数返回多个值</p><p>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 返回一个数组</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">example</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> [1, 2, 3];</span><br><span class="line">&#125;</span><br><span class="line">var [a, b, c] = example();</span><br><span class="line"></span><br><span class="line">// 返回一个对象</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">example</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> &#123;</span><br><span class="line">    foo: 1,</span><br><span class="line">    bar: 2</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var &#123; foo, bar &#125; = example();</span><br></pre></td></tr></table></figure><p>（3）函数参数的定义</p><p>解构赋值可以方便地将一组参数与变量名对应起来。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 参数是一组有次序的值</span><br><span class="line"><span class="keyword">function</span> f([x, y, z]) &#123; ... &#125;</span><br><span class="line">f([1, 2, 3]);</span><br><span class="line"></span><br><span class="line">// 参数是一组无次序的值</span><br><span class="line"><span class="keyword">function</span> f(&#123;x, y, z&#125;) &#123; ... &#125;</span><br><span class="line">f(&#123;z: 3, y: 2, x: 1&#125;);</span><br></pre></td></tr></table></figure><p>（4）提取 JSON 数据</p><p>解构赋值对提取 JSON 对象中的数据，尤其有用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var jsonData = &#123;</span><br><span class="line">  id: 42,</span><br><span class="line">  status: <span class="string">"OK"</span>,</span><br><span class="line">  data: [867, 5309]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> &#123; id, status, data: number &#125; = jsonData;</span><br><span class="line"></span><br><span class="line">console.log(id, status, number);</span><br><span class="line">// 42, <span class="string">"OK"</span>, [867, 5309]</span><br></pre></td></tr></table></figure><p>上面代码可以快速提取 JSON 数据的值。</p><p>（5）函数参数的默认值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jQuery.ajax = <span class="keyword">function</span> (url, &#123;</span><br><span class="line">  async = <span class="literal">true</span>,</span><br><span class="line">  beforeSend = <span class="function"><span class="title">function</span></span> () &#123;&#125;,</span><br><span class="line">  cache = <span class="literal">true</span>,</span><br><span class="line">  complete = <span class="function"><span class="title">function</span></span> () &#123;&#125;,</span><br><span class="line">  crossDomain = <span class="literal">false</span>,</span><br><span class="line">  global = <span class="literal">true</span>,</span><br><span class="line">  // ... more config</span><br><span class="line">&#125;) &#123;</span><br><span class="line">  // ... <span class="keyword">do</span> stuff</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>指定参数的默认值，就避免了在函数体内部再写 var foo = config.foo || ‘default foo’;这样的语句。</p><p>（6）遍历 Map 结构</p><p>任何部署了 Iterator 接口的对象，都可以用 for…of 循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var map = new Map();</span><br><span class="line">map.set(<span class="string">'first'</span>, <span class="string">'hello'</span>);</span><br><span class="line">map.set(<span class="string">'second'</span>, <span class="string">'world'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> [key, value] of map) &#123;</span><br><span class="line">  console.log(key + <span class="string">" is "</span> + value);</span><br><span class="line">&#125;</span><br><span class="line">// first is hello</span><br><span class="line">// second is world</span><br></pre></td></tr></table></figure><p>如果只想获取键名，或者只想获取键值，可以写成下面这样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 获取键名</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> [key] of map) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取键值</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> [,value] of map) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（7）输入模块的指定方法</p><p>加载模块时，往往需要指定输入那些方法。解构赋值使得输入语句非常清晰。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const &#123; SourceMapConsumer, SourceNode &#125; = require(<span class="string">"source-map"</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6_let_const</title>
      <link href="/2018/12/15/es6_let_const/"/>
      <url>/2018/12/15/es6_let_const/</url>
      
        <content type="html"><![CDATA[<h3 id="let-与-const-变量"><a href="#let-与-const-变量" class="headerlink" title="let 与 const 变量"></a>let 与 const 变量</h3><h4 id="let"><a href="#let" class="headerlink" title="let"></a>let</h4><p>ES6 新增了 let 命令，用来声明变量。它的用法类似于 var，但是所声明的变量，只在 let 命令所在的代码块内有效。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="built_in">let</span> a = 10;</span><br><span class="line">  var b = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a // ReferenceError: a is not defined.</span><br><span class="line">b // 1</span><br></pre></td></tr></table></figure><p>上面代码在代码块之中，分别用 let 和 var 声明了两个变量。然后在代码块之外调用这两个变量，结果 let 声明的变量报错，var 声明的变量返回了正确的值。这表明，let 声明的变量只在它所在的代码块有效。</p><p>for 循环的计数器，就很合适使用 let 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; 10; i++) &#123;&#125;</span><br><span class="line"></span><br><span class="line">console.log(i);</span><br><span class="line">//ReferenceError: i is not defined</span><br></pre></td></tr></table></figure><p>上面代码中，计数器 i 只在 for 循环体内有效，在循环体外引用就会报错。</p><p>下面的代码如果使用 var，最后输出的是 10。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = [];</span><br><span class="line"><span class="keyword">for</span> (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[6](); // 10</span><br></pre></td></tr></table></figure><p>上面代码中，变量 i 是 var 声明的，在全局范围内都有效。所以每一次循环，新的 i 值都会覆盖旧值，导致最后输出的是最后一轮的 i 的值。</p><p>如果使用 let，声明的变量仅在块级作用域内有效，最后输出的是 6。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[6](); // 6</span><br></pre></td></tr></table></figure><p>上面代码中，变量 i 是 let 声明的，当前的 i 只在本轮循环有效，所以每一次循环的 i 其实都是一个新的变量，所以最后输出的是 6。</p><h5 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h5><p>let 不像 var 那样会发生“变量提升”现象。所以，变量一定要在声明后使用，否则报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(foo); // 输出undefined</span><br><span class="line">console.log(bar); // 报错ReferenceError</span><br><span class="line"></span><br><span class="line">var foo = 2;</span><br><span class="line"><span class="built_in">let</span> bar = 2;</span><br></pre></td></tr></table></figure><p>上面代码中，变量 foo 用 var 命令声明，会发生变量提升，即脚本开始运行时，变量 foo 已经存在了，但是没有值，所以会输出 undefined。变量 bar 用 let 命令声明，不会发生变量提升。这表示在声明它之前，变量 bar 是不存在的，这时如果用到它，就会抛出一个错误。</p><h5 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h5><p>只要块级作用域内存在 let 命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var tmp = 123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  tmp = <span class="string">'abc'</span>; // ReferenceError</span><br><span class="line">  <span class="built_in">let</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，存在全局变量 tmp，但是块级作用域内 let 又声明了一个局部变量 tmp，导致后者绑定这个块级作用域，所以在 let 声明变量前，对 tmp 赋值会报错。</p><p>ES6 明确规定，如果区块中存在 let 和 const 命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p><p>总之，在代码块内，使用 let 命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  // TDZ开始</span><br><span class="line">  tmp = <span class="string">'abc'</span>; // ReferenceError</span><br><span class="line">  console.log(tmp); // ReferenceError</span><br><span class="line"></span><br><span class="line">  <span class="built_in">let</span> tmp; // TDZ结束</span><br><span class="line">  console.log(tmp); // undefined</span><br><span class="line"></span><br><span class="line">  tmp = 123;</span><br><span class="line">  console.log(tmp); // 123</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，在 let 命令声明变量 tmp 之前，都属于变量 tmp 的“死区”。</p><p>“暂时性死区”也意味着 typeof 不再是一个百分之百安全的操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typeof x; // ReferenceError</span><br><span class="line"><span class="built_in">let</span> x;</span><br></pre></td></tr></table></figure><p>上面代码中，变量 x 使用 let 命令声明，所以在声明之前，都属于 x 的“死区”，只要用到该变量就会报错。因此，typeof 运行时就会抛出一个 ReferenceError。</p><p>作为比较，如果一个变量根本没有被声明，使用 typeof 反而不会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeof undeclared_variable // <span class="string">"undefined"</span></span><br></pre></td></tr></table></figure><p>上面代码中，undeclared_variable 是一个不存在的变量名，结果返回“undefined”。所以，在没有 let 之前，typeof 运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。</p><p>有些“死区”比较隐蔽，不太容易发现。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> bar(x = y, y = 2) &#123;</span><br><span class="line">  <span class="built_in">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar(); // 报错</span><br></pre></td></tr></table></figure><p>上面代码中，调用 bar 函数之所以报错（某些实现可能不报错），是因为参数 x 默认值等于另一个参数 y，而此时 y 还没有声明，属于”死区“。如果 y 的默认值是 x，就不会报错，因为此时 x 已经声明了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> bar(x = 2, y = x) &#123;</span><br><span class="line">  <span class="built_in">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line">bar(); // [2, 2]</span><br></pre></td></tr></table></figure><p>ES6 规定暂时性死区和 let、const 语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。</p><p>总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</p><h5 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h5><p>let 不允许在相同作用域内，重复声明同一个变量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line"><span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  <span class="built_in">let</span> a = 10;</span><br><span class="line">  var a = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 报错</span><br><span class="line"><span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  <span class="built_in">let</span> a = 10;</span><br><span class="line">  <span class="built_in">let</span> a = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，不能在函数内部重新声明参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> func(arg) &#123;</span><br><span class="line">  <span class="built_in">let</span> arg; // 报错</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> func(arg) &#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">let</span> arg; // 不报错</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h5><h6 id="为什么需要块级作用域？"><a href="#为什么需要块级作用域？" class="headerlink" title="为什么需要块级作用域？"></a>为什么需要块级作用域？</h6><p>ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。</p><p>第一种场景，内层变量可能会覆盖外层变量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var tmp = new Date();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  console.log(tmp);</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    var tmp = <span class="string">"hello world"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(); // undefined</span><br></pre></td></tr></table></figure><p>上面代码中，函数 f 执行后，输出结果为 undefined，原因在于变量提升，导致内层的 tmp 变量覆盖了外层的 tmp 变量。</p><p>第二种场景，用来计数的循环变量泄露为全局变量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var s = <span class="string">'hello'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (var i = 0; i &lt; s.length; i++) &#123;</span><br><span class="line">  console.log(s[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(i); // 5</span><br></pre></td></tr></table></figure><p>上面代码中，变量 i 只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。</p><h6 id="ES6-的块级作用域"><a href="#ES6-的块级作用域" class="headerlink" title="ES6 的块级作用域"></a>ES6 的块级作用域</h6><p>let 实际上为 JavaScript 新增了块级作用域。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f1</span></span>() &#123;</span><br><span class="line">  <span class="built_in">let</span> n = 5;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">let</span> n = 10;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(n); // 5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数有两个代码块，都声明了变量 n，运行后输出 5。这表示外层代码块不受内层代码块的影响。如果使用 var 定义变量 n，最后输出的值就是 10。</p><p>ES6 允许块级作用域的任意嵌套。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;&#123;<span class="built_in">let</span> insane = <span class="string">'Hello World'</span>&#125;&#125;&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure><p>上面代码使用了一个五层的块级作用域。外层作用域无法读取内层作用域的变量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;</span><br><span class="line">  &#123;<span class="built_in">let</span> insane = <span class="string">'Hello World'</span>&#125;</span><br><span class="line">  console.log(insane); // 报错</span><br><span class="line">&#125;&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure><p>内层作用域可以定义外层作用域的同名变量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;</span><br><span class="line">  <span class="built_in">let</span> insane = <span class="string">'Hello World'</span>;</span><br><span class="line">  &#123;<span class="built_in">let</span> insane = <span class="string">'Hello World'</span>&#125;</span><br><span class="line">&#125;&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure><p>块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// IIFE 写法</span><br><span class="line">(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  var tmp = ...;</span><br><span class="line">  ...</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">// 块级作用域写法</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">let</span> tmp = ...;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="块级作用域与函数声明"><a href="#块级作用域与函数声明" class="headerlink" title="块级作用域与函数声明"></a>块级作用域与函数声明</h6><p>函数能不能在块级作用域之中声明，是一个相当令人混淆的问题。</p><p>ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 情况一</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 情况二</span><br><span class="line">try &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;&#125;</span><br><span class="line">&#125; catch(e) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的两种函数声明，根据 ES5 的规定都是非法的。</p><p>但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。不过，“严格模式”下还是会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// ES5严格模式</span><br><span class="line"><span class="string">'use strict'</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 报错</span><br></pre></td></tr></table></figure><p>ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// ES6严格模式</span><br><span class="line"><span class="string">'use strict'</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 不报错</span><br></pre></td></tr></table></figure><p>ES6 规定，块级作用域之中，函数声明语句的行为类似于 let，在块级作用域之外不可引用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123; console.log(<span class="string">'I am outside!'</span>); &#125;</span><br><span class="line">(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    // 重复声明一次函数f</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123; console.log(<span class="string">'I am inside!'</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><p>上面代码在 ES5 中运行，会得到“I am inside!”，因为在 if 内声明的函数 f 会被提升到函数头部，实际运行的代码如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// ES5版本</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123; console.log(<span class="string">'I am outside!'</span>); &#125;</span><br><span class="line">(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123; console.log(<span class="string">'I am inside!'</span>); &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><p>ES6 的运行结果就完全不一样了，会得到“I am outside!”。因为块级作用域内声明的函数类似于 let，对作用域之外没有影响，实际运行的代码如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// ES6版本</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123; console.log(<span class="string">'I am outside!'</span>); &#125;</span><br><span class="line">(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><p>很显然，这种行为差异会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6 在附录 B 里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。</p><p>允许在块级作用域内声明函数。<br>函数声明类似于 var，即会提升到全局作用域或函数作用域的头部。<br>同时，函数声明还会提升到所在的块级作用域的头部。<br>注意，上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作 let 处理。</p><p>前面那段代码，在 Chrome 环境下运行会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// ES6的浏览器环境</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123; console.log(<span class="string">'I am outside!'</span>); &#125;</span><br><span class="line">(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    // 重复声明一次函数f</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123; console.log(<span class="string">'I am inside!'</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br><span class="line">// Uncaught TypeError: f is not a <span class="keyword">function</span></span><br></pre></td></tr></table></figure><p>上面的代码报错，是因为实际运行的是下面的代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// ES6的浏览器环境</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123; console.log(<span class="string">'I am outside!'</span>); &#125;</span><br><span class="line">(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  var f = undefined;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123; console.log(<span class="string">'I am inside!'</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br><span class="line">// Uncaught TypeError: f is not a <span class="keyword">function</span></span><br></pre></td></tr></table></figure><p>考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 函数声明语句</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">let</span> a = <span class="string">'secret'</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 函数表达式</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">let</span> a = <span class="string">'secret'</span>;</span><br><span class="line">  <span class="built_in">let</span> f = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    <span class="built_in">return</span> a;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，还有一个需要注意的地方。ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 不报错</span><br><span class="line"><span class="string">'use strict'</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 报错</span><br><span class="line"><span class="string">'use strict'</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>)</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure><h5 id="do-表达式"><a href="#do-表达式" class="headerlink" title="do 表达式"></a>do 表达式</h5><p>本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="built_in">let</span> t = f();</span><br><span class="line">  t = t * t + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，块级作用域将两个语句封装在一起。但是，在块级作用域以外，没有办法得到 t 的值，因为块级作用域不返回值，除非 t 是全局变量。</p><p>现在有一个提案，使得块级作用域可以变为表达式，也就是说可以返回值，办法就是在块级作用域之前加上 do，使它变为 do 表达式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> x = <span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="built_in">let</span> t = f();</span><br><span class="line">  t * t + 1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，变量 x 会得到整个块级作用域的返回值。</p><h4 id="const-命令"><a href="#const-命令" class="headerlink" title="const 命令"></a>const 命令</h4><p>const 声明一个只读的常量。一旦声明，常量的值就不能改变。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const PI = 3.1415;</span><br><span class="line">PI // 3.1415</span><br><span class="line"></span><br><span class="line">PI = 3;</span><br><span class="line">// TypeError: Assignment to constant variable.</span><br></pre></td></tr></table></figure><p>上面代码表明改变常量的值会报错。</p><p>const 声明的变量不得改变值，这意味着，const 一旦声明变量，就必须立即初始化，不能留到以后赋值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const foo;</span><br><span class="line">// SyntaxError: Missing initializer <span class="keyword">in</span> const declaration</span><br></pre></td></tr></table></figure><p>上面代码表示，对于 const 来说，只声明不赋值，就会报错。</p><p>const 的作用域与 let 命令相同：只在声明所在的块级作用域内有效。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  const MAX = 5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MAX // Uncaught ReferenceError: MAX is not defined</span><br></pre></td></tr></table></figure><p>const 命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  console.log(MAX); // ReferenceError</span><br><span class="line">  const MAX = 5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码在常量 MAX 声明之前就调用，结果报错。</p><p>const 声明的常量，也与 let 一样不可重复声明。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var message = <span class="string">"Hello!"</span>;</span><br><span class="line"><span class="built_in">let</span> age = 25;</span><br><span class="line"></span><br><span class="line">// 以下两行都会报错</span><br><span class="line">const message = <span class="string">"Goodbye!"</span>;</span><br><span class="line">const age = 30;</span><br></pre></td></tr></table></figure><p>对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。const 命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须非常小心。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const foo = &#123;&#125;;</span><br><span class="line">foo.prop = 123;</span><br><span class="line"></span><br><span class="line">foo.prop</span><br><span class="line">// 123</span><br><span class="line"></span><br><span class="line">foo = &#123;&#125;; // TypeError: <span class="string">"foo"</span> is <span class="built_in">read</span>-only</span><br></pre></td></tr></table></figure><p>上面代码中，常量 foo 储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把 foo 指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。</p><p>下面是另一个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const a = [];</span><br><span class="line">a.push(<span class="string">'Hello'</span>); // 可执行</span><br><span class="line">a.length = 0;    // 可执行</span><br><span class="line">a = [<span class="string">'Dave'</span>];    // 报错</span><br></pre></td></tr></table></figure><p>上面代码中，常量 a 是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给 a，就会报错。</p><p>如果真的想将对象冻结，应该使用 Object.freeze 方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const foo = Object.freeze(&#123;&#125;);</span><br><span class="line"></span><br><span class="line">// 常规模式时，下面一行不起作用；</span><br><span class="line">// 严格模式时，该行会报错</span><br><span class="line">foo.prop = 123;</span><br></pre></td></tr></table></figure><p>上面代码中，常量 foo 指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。</p><p>除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var constantize = (obj) =&gt; &#123;</span><br><span class="line">  Object.freeze(obj);</span><br><span class="line">  Object.keys(obj).forEach( (key, value) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> ( typeof obj[key] === <span class="string">'object'</span> ) &#123;</span><br><span class="line">      constantize( obj[key] );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>ES5 只有两种声明变量的方法：var 命令和 function 命令。ES6 除了添加 let 和 const 命令，后面章节还会提到，另外两种声明变量的方法：import 命令和 class 命令。所以，ES6 一共有 6 种声明变量的方法。</p><h5 id="顶层对象的属性"><a href="#顶层对象的属性" class="headerlink" title="顶层对象的属性"></a>顶层对象的属性</h5><p>顶层对象，在浏览器环境指的是 window 对象，在 Node 指的是 global 对象。ES5 之中，顶层对象的属性与全局变量是等价的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window.a = 1;</span><br><span class="line">a // 1</span><br><span class="line"></span><br><span class="line">a = 2;</span><br><span class="line">window.a // 2</span><br></pre></td></tr></table></figure><p>上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。</p><p>顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window 对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。</p><p>ES6 为了改变这一点，一方面规定，为了保持兼容性，var 命令和 function 命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let 命令、const 命令、class 命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">// 如果在Node的REPL环境，可以写成global.a</span><br><span class="line">// 或者采用通用方法，写成this.a</span><br><span class="line">window.a // 1</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> b = 1;</span><br><span class="line">window.b // undefined</span><br></pre></td></tr></table></figure><p>上面代码中，全局变量 a 由 var 命令声明，所以它是顶层对象的属性；全局变量 b 由 let 命令声明，所以它不是顶层对象的属性，返回 undefined。</p><h5 id="global-对象"><a href="#global-对象" class="headerlink" title="global 对象"></a>global 对象</h5><p>ES5 的顶层对象，本身也是一个问题，因为它在各种实现里面是不统一的。</p><p>1、浏览器里面，顶层对象是 window，但 Node 和 Web Worker 没有 window。<br>2、浏览器和 Web Worker 里面，self 也指向顶层对象，但是 Node 没有 self。<br>3、Node 里面，顶层对象是 global，但其他环境都不支持。<br>同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用 this 变量，但是有局限性。</p><p>1、全局环境中，this 会返回顶层对象。但是，Node 模块和 ES6 模块中，this 返回的是当前模块。<br>2、函数里面的 this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this 会指向顶层对象。但是，严格模式下，这时 this 会返回 undefined。<br>3、不管是严格模式，还是普通模式，new Function(‘return this’)()，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全政策），那么 eval、new Function 这些方法都可能无法使用。<br>综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 方法一</span><br><span class="line">(typeof window !== <span class="string">'undefined'</span></span><br><span class="line">   ? window</span><br><span class="line">   : (typeof process === <span class="string">'object'</span> &amp;&amp;</span><br><span class="line">      typeof require === <span class="string">'function'</span> &amp;&amp;</span><br><span class="line">      typeof global === <span class="string">'object'</span>)</span><br><span class="line">     ? global</span><br><span class="line">     : this);</span><br><span class="line"></span><br><span class="line">// 方法二</span><br><span class="line">var getGlobal = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  <span class="keyword">if</span> (typeof self !== <span class="string">'undefined'</span>) &#123; <span class="built_in">return</span> self; &#125;</span><br><span class="line">  <span class="keyword">if</span> (typeof window !== <span class="string">'undefined'</span>) &#123; <span class="built_in">return</span> window; &#125;</span><br><span class="line">  <span class="keyword">if</span> (typeof global !== <span class="string">'undefined'</span>) &#123; <span class="built_in">return</span> global; &#125;</span><br><span class="line">  throw new Error(<span class="string">'unable to locate global object'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在有一个提案，在语言标准的层面，引入 global 作为顶层对象。也就是说，在所有环境下，global 都是存在的，都可以从它拿到顶层对象。</p><p>垫片库 system.global 模拟了这个提案，可以在所有环境拿到 global。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// CommonJS的写法</span><br><span class="line">require(<span class="string">'system.global/shim'</span>)();</span><br><span class="line"></span><br><span class="line">// ES6模块的写法</span><br><span class="line">import shim from <span class="string">'system.global/shim'</span>; shim();</span><br><span class="line">上面代码可以保证各种环境里面，global对象都是存在的。</span><br><span class="line"></span><br><span class="line">// CommonJS的写法</span><br><span class="line">var global = require(<span class="string">'system.global'</span>)();</span><br><span class="line"></span><br><span class="line">// ES6模块的写法</span><br><span class="line">import getGlobal from <span class="string">'system.global'</span>;</span><br><span class="line">const global = getGlobal();</span><br></pre></td></tr></table></figure><p>上面代码将顶层对象放入变量 global。</p>]]></content>
      
      
      <categories>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css</title>
      <link href="/2018/11/01/css/"/>
      <url>/2018/11/01/css/</url>
      
        <content type="html"><![CDATA[<h4 id="1-介绍一下标准的-CSS-的盒子模型？与低版本-IE-的盒子模型有什么不同的？"><a href="#1-介绍一下标准的-CSS-的盒子模型？与低版本-IE-的盒子模型有什么不同的？" class="headerlink" title="1 介绍一下标准的 CSS 的盒子模型？与低版本 IE 的盒子模型有什么不同的？"></a>1 介绍一下标准的 CSS 的盒子模型？与低版本 IE 的盒子模型有什么不同的？</h4><p>标准盒子模型：宽度=内容的宽度（content）+ border + padding + margin<br>低版本 IE 盒子模型：宽度=内容宽度（content+border+padding）+ margin</p><h4 id="2-box-sizing-属性？"><a href="#2-box-sizing-属性？" class="headerlink" title="2 box-sizing 属性？"></a>2 box-sizing 属性？</h4><p>用来控制元素的盒子模型的解析模式，默认为 content-box<br>context-box：W3C 的标准盒子模型，设置元素的 height/width 属性指的是 content 部分的高/宽<br>border-box：IE 传统盒子模型。设置元素的 height/width 属性指的是 border + padding + content 部分的高/宽</p><h4 id="3-CSS-选择器有哪些？哪些属性可以继承？"><a href="#3-CSS-选择器有哪些？哪些属性可以继承？" class="headerlink" title="3 CSS 选择器有哪些？哪些属性可以继承？"></a>3 CSS 选择器有哪些？哪些属性可以继承？</h4><p>CSS 选择符：id 选择器(#myid)、类选择器(.myclassname)、标签选择器(div, h1, p)、相邻选择器(h1 + p)、子选择器（ul &gt; li）、后代选择器（li a）、通配符选择器（*）、属性选择器（a[rel=”external”]）、伪类选择器（a:hover, li:nth-child）<br>可继承的属性：font-size, font-family, color<br>不可继承的样式：border, padding, margin, width, height<br>优先级（就近原则）：!important &gt; [ id &gt; class &gt; tag ]<br>!important 比内联优先级高</p><h4 id="4-CSS-优先级算法如何计算？"><a href="#4-CSS-优先级算法如何计算？" class="headerlink" title="4 CSS 优先级算法如何计算？"></a>4 CSS 优先级算法如何计算？</h4><p>元素选择符： 1<br>class 选择符： 10<br>id 选择符：100<br>元素标签：1000<br>!important 声明的样式优先级最高，如果冲突再进行计算。<br>如果优先级相同，则选择最后出现的样式。<br>继承得到的样式的优先级最低。</p><h4 id="5-CSS3-新增伪类有那些"><a href="#5-CSS3-新增伪类有那些" class="headerlink" title="5 CSS3 新增伪类有那些?"></a>5 CSS3 新增伪类有那些?</h4><p>p:first-of-type 选择属于其父元素的首个元素<br>p:last-of-type 选择属于其父元素的最后元素<br>p:only-of-type 选择属于其父元素唯一的元素<br>p:only-child 选择属于其父元素的唯一子元素<br>p:nth-child(2) 选择属于其父元素的第二个子元素<br>:enabled :disabled 表单控件的禁用状态。<br>:checked 单选框或复选框被选中。</p><h4 id="6-如何居中-div？如何居中一个浮动元素？如何让绝对定位的-div-居中？"><a href="#6-如何居中-div？如何居中一个浮动元素？如何让绝对定位的-div-居中？" class="headerlink" title="6 如何居中 div？如何居中一个浮动元素？如何让绝对定位的 div 居中？"></a>6 如何居中 div？如何居中一个浮动元素？如何让绝对定位的 div 居中？</h4><p>div：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">border: 1px solid red;</span><br><span class="line">margin: 0 auto;</span><br><span class="line">height: 50px;</span><br><span class="line">width: 80px;</span><br></pre></td></tr></table></figure><p>浮动元素的上下左右居中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">border: 1px solid red;</span><br><span class="line"><span class="built_in">float</span>: left;</span><br><span class="line">position: absolute;</span><br><span class="line">width: 200px;</span><br><span class="line">height: 100px;</span><br><span class="line">left: 50%;</span><br><span class="line">top: 50%;</span><br><span class="line">margin: -50px 0 0 -100px;</span><br></pre></td></tr></table></figure><p>绝对定位的左右居中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">border: 1px solid black;</span><br><span class="line">position: absolute;</span><br><span class="line">width: 200px;</span><br><span class="line">height: 100px;</span><br><span class="line">margin: 0 auto;</span><br><span class="line">left: 0;</span><br><span class="line">right: 0;</span><br></pre></td></tr></table></figure><p>还有更加优雅的居中方式就是用 flexbox，我以后会做整理。</p><h4 id="7-display-有哪些值？说明他们的作用"><a href="#7-display-有哪些值？说明他们的作用" class="headerlink" title="7 display 有哪些值？说明他们的作用?"></a>7 display 有哪些值？说明他们的作用?</h4><p>inline（默认）–内联<br>none–隐藏<br>block–块显示<br>table–表格显示<br>list-item–项目列表<br>inline-block</p><h4 id="8-position-的值？"><a href="#8-position-的值？" class="headerlink" title="8 position 的值？"></a>8 position 的值？</h4><p>static（默认）：按照正常文档流进行排列；<br>relative（相对定位）：不脱离文档流，参考自身静态位置通过 top, bottom, left, right 定位；<br>absolute(绝对定位)：参考距其最近一个不为 static 的父级元素通过 top, bottom, left, right 定位；<br>fixed(固定定位)：所固定的参照对像是可视窗口。</p><h4 id="9-CSS3-有哪些新特性？"><a href="#9-CSS3-有哪些新特性？" class="headerlink" title="9 CSS3 有哪些新特性？"></a>9 CSS3 有哪些新特性？</h4><p>RGBA 和透明度<br>background-image background-origin(content-box/padding-box/border-box) background-size background-repeat<br>word-wrap（对长的不可分割单词换行）word-wrap：break-word<br>文字阴影：text-shadow： 5px 5px 5px #FF0000;（水平阴影，垂直阴影，模糊距离，阴影颜色）<br>font-face 属性：定义自己的字体<br>圆角（边框半径）：border-radius 属性用于创建圆角<br>边框图片：border-image: url(border.png) 30 30 round<br>盒阴影：box-shadow: 10px 10px 5px #888888<br>媒体查询：定义两套 css，当浏览器的尺寸变化时会采用不同的属性</p><h4 id="10-请解释一下-CSS3-的-flexbox（弹性盒布局模型）-以及适用场景？"><a href="#10-请解释一下-CSS3-的-flexbox（弹性盒布局模型）-以及适用场景？" class="headerlink" title="10 请解释一下 CSS3 的 flexbox（弹性盒布局模型）,以及适用场景？"></a>10 请解释一下 CSS3 的 flexbox（弹性盒布局模型）,以及适用场景？</h4><p>该布局模型的目的是提供一种更加高效的方式来对容器中的条目进行布局、对齐和分配空间。在传统的布局方式中，block 布局是把块在垂直方向从上到下依次排列的；而 inline 布局则是在水平方向来排列。弹性盒布局并没有这样内在的方向限制，可以由开发人员自由操作。<br>试用场景：弹性布局适合于移动前端开发，在 Android 和 ios 上也完美支持。</p><h4 id="11-用纯-CSS-创建一个三角形的原理是什么？"><a href="#11-用纯-CSS-创建一个三角形的原理是什么？" class="headerlink" title="11 用纯 CSS 创建一个三角形的原理是什么？"></a>11 用纯 CSS 创建一个三角形的原理是什么？</h4><p>首先，需要把元素的宽度、高度设为 0。然后设置边框样式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">width: 0;</span><br><span class="line">height: 0;</span><br><span class="line">border-top: 40px solid transparent;</span><br><span class="line">border-left: 40px solid transparent;</span><br><span class="line">border-right: 40px solid transparent;</span><br><span class="line">border-bottom: 40px solid <span class="comment">#ff0000;</span></span><br></pre></td></tr></table></figure><h4 id="12-一个满屏品字布局如何设计"><a href="#12-一个满屏品字布局如何设计" class="headerlink" title="12 一个满屏品字布局如何设计?"></a>12 一个满屏品字布局如何设计?</h4><p>第一种真正的品字：<br>三块高宽是确定的；<br>上面那块用 margin: 0 auto;居中；<br>下面两块用 float 或者 inline-block 不换行；<br>用 margin 调整位置使他们居中。<br>第二种全屏的品字布局:<br>上面的 div 设置成 100%，下面的 div 分别宽 50%，然后使用 float 或者 inline 使其不换行。</p><h4 id="13-常见的兼容性问题？"><a href="#13-常见的兼容性问题？" class="headerlink" title="13 常见的兼容性问题？"></a>13 常见的兼容性问题？</h4><p>不同浏览器的标签默认的 margin 和 padding 不一样。*{margin:0;padding:0;}</p><h5 id="IE6-双边距-bug：块属性标签-float-后，又有横行的-margin-情况下，在-IE6-显示-margin-比设置的大。"><a href="#IE6-双边距-bug：块属性标签-float-后，又有横行的-margin-情况下，在-IE6-显示-margin-比设置的大。" class="headerlink" title="IE6 双边距 bug：块属性标签 float 后，又有横行的 margin 情况下，在 IE6 显示 margin 比设置的大。"></a>IE6 双边距 bug：块属性标签 float 后，又有横行的 margin 情况下，在 IE6 显示 margin 比设置的大。</h5><p>hack：display:inline;将其转化为行内属性。<br>渐进识别的方式，从总体中逐渐排除局部。首先，巧妙的使用“9”这一标记，将 IE 浏览器从所有情况中分离出来。接着，再次使用“+”将 IE8 和 IE7、IE6 分离开来，这样 IE8 已经独立识别。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">background-color:<span class="comment">#f1ee18;/*所有识别*/</span></span><br><span class="line">.background-color:<span class="comment">#00deff\9; /*IE6、7、8识别*/</span></span><br><span class="line">+background-color:<span class="comment">#a200ff;/*IE6、7识别*/</span></span><br><span class="line">_background-color:<span class="comment">#1e0bd1;/*IE6识别*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置较小高度标签（一般小于 10px），在 IE6，IE7 中高度超出自己设置高度。hack：给超出高度的标签设置 overflow:hidden;或者设置行高 line-height 小于你设置的高度。<br>IE 下，可以使用获取常规属性的方法来获取自定义属性,也可以使用 getAttribute()获取自定义属性；Firefox 下，只能使用 getAttribute()获取自定义属性。解决方法:统一通过 getAttribute()获取自定义属性。<br>Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决。<br>超链接访问过后 hover 样式就不出现了，被点击访问过的超链接样式不再具有 hover 和 active 了。解决方法是改变 CSS 属性的排列顺序:L-V-H-A ( love hate ): a:link {} a:visited {} a:hover {} a:active {}</p><h4 id="14-为什么要初始化-CSS-样式"><a href="#14-为什么要初始化-CSS-样式" class="headerlink" title="14 为什么要初始化 CSS 样式"></a>14 为什么要初始化 CSS 样式</h4><p>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对 CSS 初始化往往会出现浏览器之间的页面显示差异。</p><h4 id="15-absolute-的-containing-block-计算方式跟正常流有什么不同？"><a href="#15-absolute-的-containing-block-计算方式跟正常流有什么不同？" class="headerlink" title="15 absolute 的 containing block 计算方式跟正常流有什么不同？"></a>15 absolute 的 containing block 计算方式跟正常流有什么不同？</h4><p>无论属于哪种，都要先找到其祖先元素中最近的 position 值不为 static 的元素，然后再判断：<br>若此元素为 inline 元素，则 containing block 为能够包含这个元素生成的第一个和最后一个 inline box 的 padding box (除 margin, border 外的区域) 的最小矩形；<br>否则,则由这个祖先元素的 padding box 构成。<br>如果都找不到，则为 initial containing block。<br>补充：<br>static(默认的)/relative：简单说就是它的父元素的内容框（即去掉 padding 的部分）<br>absolute: 向上找最近的定位为 absolute/relative 的元素<br>fixed: 它的 containing block 一律为根元素(html/body)</p><h4 id="16-CSS-里的-visibility-属性有个-collapse-属性值？在不同浏览器下以后什么区别？"><a href="#16-CSS-里的-visibility-属性有个-collapse-属性值？在不同浏览器下以后什么区别？" class="headerlink" title="16 CSS 里的 visibility 属性有个 collapse 属性值？在不同浏览器下以后什么区别？"></a>16 CSS 里的 visibility 属性有个 collapse 属性值？在不同浏览器下以后什么区别？</h4><p>当一个元素的 visibility 属性被设置成 collapse 值后，对于一般的元素，它的表现跟 hidden 是一样的。<br>chrome 中，使用 collapse 值和使用 hidden 没有区别。<br>firefox，opera 和 IE，使用 collapse 值和使用 display：none 没有什么区别。</p><h4 id="17-display-none-与-visibility：hidden-的区别？"><a href="#17-display-none-与-visibility：hidden-的区别？" class="headerlink" title="17 display:none 与 visibility：hidden 的区别？"></a>17 display:none 与 visibility：hidden 的区别？</h4><p>display：none 不显示对应的元素，在文档布局中不再分配空间（回流+重绘）<br>visibility：hidden 隐藏对应元素，在文档布局中仍保留原来的空间（重绘）</p><h4 id="18-position-跟-display、overflow、float-这些特性相互叠加后会怎么样？"><a href="#18-position-跟-display、overflow、float-这些特性相互叠加后会怎么样？" class="headerlink" title="18 position 跟 display、overflow、float 这些特性相互叠加后会怎么样？"></a>18 position 跟 display、overflow、float 这些特性相互叠加后会怎么样？</h4><p>display 属性规定元素应该生成的框的类型；position 属性规定元素的定位类型；float 属性是一种布局方式，定义元素在哪个方向浮动。<br>类似于优先级机制：position：absolute/fixed 优先级最高，有他们在时，float 不起作用，display 值需要调整。float 或者 absolute 定位的元素，只能是块元素或表格。</p><h4 id="19-对-BFC-规范-块级格式化上下文：block-formatting-context-的理解？"><a href="#19-对-BFC-规范-块级格式化上下文：block-formatting-context-的理解？" class="headerlink" title="19 对 BFC 规范(块级格式化上下文：block formatting context)的理解？"></a>19 对 BFC 规范(块级格式化上下文：block formatting context)的理解？</h4><p>BFC 规定了内部的 Block Box 如何布局。<br>定位方案：<br>内部的 Box 会在垂直方向上一个接一个放置。<br>Box 垂直方向的距离由 margin 决定，属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠。<br>每个元素的 margin box 的左边，与包含块 border box 的左边相接触。<br>BFC 的区域不会与 float box 重叠。<br>BFC 是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。<br>计算 BFC 的高度时，浮动元素也会参与计算。<br>满足下列条件之一就可触发 BFC<br>根元素，即 html<br>float 的值不为 none（默认）<br>overflow 的值不为 visible（默认）<br>display 的值为 inline-block、table-cell、table-caption<br>position 的值为 absolute 或 fixed</p><h4 id="20-为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？"><a href="#20-为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？" class="headerlink" title="20 为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？"></a>20 为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？</h4><p>浮动元素碰到包含它的边框或者浮动元素的边框停留。由于浮动元素不在文档流中，所以文档流的块框表现得就像浮动框不存在一样。浮动元素会漂浮在文档流的块框上。</p><h5 id="浮动带来的问题："><a href="#浮动带来的问题：" class="headerlink" title="浮动带来的问题："></a>浮动带来的问题：</h5><p>父元素的高度无法被撑开，影响与父元素同级的元素<br>与浮动元素同级的非浮动元素（内联元素）会跟随其后<br>若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构。</p><h5 id="清除浮动的方式："><a href="#清除浮动的方式：" class="headerlink" title="清除浮动的方式："></a>清除浮动的方式：</h5><p>父级 div 定义 height<br>最后一个浮动元素后加空 div 标签 并添加样式 clear:both。<br>包含浮动元素的父标签添加样式 overflow 为 hidden 或 auto。<br>父级 div 定义 zoom</p><h4 id="21-上下-margin-重合的问题"><a href="#21-上下-margin-重合的问题" class="headerlink" title="21 上下 margin 重合的问题"></a>21 上下 margin 重合的问题</h4><p>在重合元素外包裹一层容器，并触发该容器生成一个 BFC。<br>例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">"aside"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=<span class="string">"text"</span>&gt;</span><br><span class="line">    &lt;div class=<span class="string">"main"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--下面是css代码--&gt;</span><br><span class="line">.aside &#123;</span><br><span class="line">    margin-bottom: 100px;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 150px;</span><br><span class="line">    background: <span class="comment">#f66;</span></span><br><span class="line">&#125;</span><br><span class="line">.main &#123;</span><br><span class="line">    margin-top: 100px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    background: <span class="comment">#fcc;</span></span><br><span class="line">&#125;</span><br><span class="line">.text&#123;</span><br><span class="line">    /*盒子main的外面包一个div，通过改变此div的属性使两个盒子分属于两个不同的BFC，以此来阻止margin重叠*/</span><br><span class="line">    overflow: hidden;  //此时已经触发了BFC属性。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="22-设置元素浮动后，该元素的-display-值是多少？"><a href="#22-设置元素浮动后，该元素的-display-值是多少？" class="headerlink" title="22 设置元素浮动后，该元素的 display 值是多少？"></a>22 设置元素浮动后，该元素的 display 值是多少？</h4><p>自动变成 display:block</p><h4 id="23-移动端的布局用过媒体查询吗？"><a href="#23-移动端的布局用过媒体查询吗？" class="headerlink" title="23 移动端的布局用过媒体查询吗？"></a>23 移动端的布局用过媒体查询吗？</h4><p>通过媒体查询可以为不同大小和尺寸的媒体定义不同的 css，适应相应的设备的显示。<br>head 里边</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> <span class="built_in">type</span>=<span class="string">"text/css"</span> href=<span class="string">"xxx.css"</span></span><br><span class="line">      media=<span class="string">"only screen and (max-device-width:480px)"</span>&gt;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CSS : @media only screen and (max-device-width:480px) &#123;/css样式/&#125;</span><br></pre></td></tr></table></figure><h4 id="24-使用-CSS-预处理器吗？"><a href="#24-使用-CSS-预处理器吗？" class="headerlink" title="24 使用 CSS 预处理器吗？"></a>24 使用 CSS 预处理器吗？</h4><p>Less sass</p><h4 id="25-CSS-优化、提高性能的方法有哪些？"><a href="#25-CSS-优化、提高性能的方法有哪些？" class="headerlink" title="25 CSS 优化、提高性能的方法有哪些？"></a>25 CSS 优化、提高性能的方法有哪些？</h4><pre>避免过度约束避免后代选择符避免链式选择符使用紧凑的语法避免不必要的命名空间避免不必要的重复最好使用表示语义的名字。一个好的类名应该是描述他是什么而不是像什么避免！important，可以选择其他选择器尽可能的精简规则，你可以合并不同类里的重复规则</pre><h4 id="26-浏览器是怎样解析-CSS-选择器的？"><a href="#26-浏览器是怎样解析-CSS-选择器的？" class="headerlink" title="26 浏览器是怎样解析 CSS 选择器的？"></a>26 浏览器是怎样解析 CSS 选择器的？</h4><p>CSS 选择器的解析是从右向左解析的。若从左向右的匹配，发现不符合规则，需要进行回溯，会损失很多性能。若从右向左匹配，先找到所有的最右节点，对于每一个节点，向上寻找其父节点直到找到根元素或满足条件的匹配规则，则结束这个分支的遍历。两种匹配规则的性能差别很大，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点（叶子节点），而从左向右的匹配规则的性能都浪费在了失败的查找上面。<br>而在 CSS 解析完毕后，需要将解析的结果与 DOM Tree 的内容一起进行分析建立一棵 Render Tree，最终用来进行绘图。在建立 Render Tree 时（WebKit 中的「Attachment」过程），浏览器就要为每个 DOM Tree 中的元素根据 CSS 的解析结果（Style Rules）来确定生成怎样的 Render Tree。</p><h4 id="27-在网页中的应该使用奇数还是偶数的字体？为什么呢？"><a href="#27-在网页中的应该使用奇数还是偶数的字体？为什么呢？" class="headerlink" title="27 在网页中的应该使用奇数还是偶数的字体？为什么呢？"></a>27 在网页中的应该使用奇数还是偶数的字体？为什么呢？</h4><p>使用偶数字体。偶数字号相对更容易和 web 设计的其他部分构成比例关系。Windows 自带的点阵宋体（中易宋体）从 Vista 开始只提供 12、14、16 px 这三个大小的点阵，而 13、15、17 px 时用的是小一号的点。（即每个字占的空间大了 1 px，但点阵没变），于是略显稀疏。</p><h4 id="28-margin-和-padding-分别适合什么场景使用？"><a href="#28-margin-和-padding-分别适合什么场景使用？" class="headerlink" title="28 margin 和 padding 分别适合什么场景使用？"></a>28 margin 和 padding 分别适合什么场景使用？</h4><h5 id="何时使用-margin："><a href="#何时使用-margin：" class="headerlink" title="何时使用 margin："></a>何时使用 margin：</h5><p>需要在 border 外侧添加空白<br>空白处不需要背景色<br>上下相连的两个盒子之间的空白，需要相互抵消时。</p><h5 id="何时使用-padding："><a href="#何时使用-padding：" class="headerlink" title="何时使用 padding："></a>何时使用 padding：</h5><p>需要在 border 内侧添加空白<br>空白处需要背景颜色<br>上下相连的两个盒子的空白，希望为两者之和。 #####兼容性的问题：<br>在 IE5 IE6 中，为 float 的盒子指定 margin 时，左侧的 margin 可能会变成两倍的宽度。通过改变 padding 或者指定盒子的 display：inline 解决。</p><h4 id="29-元素竖向的百分比设定是相对于容器的高度吗？"><a href="#29-元素竖向的百分比设定是相对于容器的高度吗？" class="headerlink" title="29 元素竖向的百分比设定是相对于容器的高度吗？"></a>29 元素竖向的百分比设定是相对于容器的高度吗？</h4><p>当按百分比设定一个元素的宽度时，它是相对于父容器的宽度计算的，但是，对于一些表示竖向距离的属性，例如 padding-top , padding-bottom , margin-top , margin-bottom 等，当按百分比设定它们时，依据的也是父容器的宽度，而不是高度。</p><h4 id="30-全屏滚动的原理是什么？用到了-CSS-的哪些属性？"><a href="#30-全屏滚动的原理是什么？用到了-CSS-的哪些属性？" class="headerlink" title="30 全屏滚动的原理是什么？用到了 CSS 的哪些属性？"></a>30 全屏滚动的原理是什么？用到了 CSS 的哪些属性？</h4><p>原理：有点类似于轮播，整体的元素一直排列下去，假设有 5 个需要展示的全屏页面，那么高度是 500%，只是展示 100%，剩下的可以通过 transform 进行 y 轴定位，也可以通过 margin-top 实现</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">overflow：hidden;transition：all 1000ms ease;</span><br></pre></td></tr></table></figure><h4 id="31-什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的-IE？"><a href="#31-什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的-IE？" class="headerlink" title="31 什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的 IE？"></a>31 什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的 IE？</h4><p>响应式网站设计(Responsive Web design)是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。<br>基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理。<br>页面头部必须有 meta 声明的 viewport。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=<span class="string">"viewport"</span></span><br><span class="line">      content=<span class="string">"width=device-width, initial-scale=1. maximum-scale=1,user-scalable=no"</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="32-视差滚动效果？"><a href="#32-视差滚动效果？" class="headerlink" title="32 视差滚动效果？"></a>32 视差滚动效果？</h4><p>视差滚动（Parallax Scrolling）通过在网页向下滚动的时候，控制背景的移动速度比前景的移动速度慢来创建出令人惊叹的 3D 效果。</p><h5 id="CSS3-实现"><a href="#CSS3-实现" class="headerlink" title="CSS3 实现"></a>CSS3 实现</h5><p>优点：开发时间短、性能和开发效率比较好，缺点是不能兼容到低版本的浏览器</p><h5 id="jQuery-实现"><a href="#jQuery-实现" class="headerlink" title="jQuery 实现"></a>jQuery 实现</h5><p>通过控制不同层滚动速度，计算每一层的时间，控制滚动效果。<br>优点：能兼容到各个版本的，效果可控性好<br>缺点：开发起来对制作者要求高<br>插件实现方式<br>例如：parallax-scrolling，兼容性十分好</p><h4 id="33-before-和-after-中双冒号和单冒号有什么区别？解释一下这-2-个伪元素的作用"><a href="#33-before-和-after-中双冒号和单冒号有什么区别？解释一下这-2-个伪元素的作用" class="headerlink" title="33 ::before 和 :after 中双冒号和单冒号有什么区别？解释一下这 2 个伪元素的作用"></a>33 ::before 和 :after 中双冒号和单冒号有什么区别？解释一下这 2 个伪元素的作用</h4><p>单冒号(:)用于 CSS3 伪类，双冒号(::)用于 CSS3 伪元素。<br>::before 就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于 dom 之中，只存在在页面之中。<br>:before 和 :after 这两个伪元素，是在 CSS2.1 里新出现的。起初，伪元素的前缀使用的是单冒号语法，但随着 Web 的进化，在 CSS3 的规范里，伪元素的语法被修改成使用双冒号，成为::before ::after</p><h4 id="34-你对-line-height-是如何理解的？"><a href="#34-你对-line-height-是如何理解的？" class="headerlink" title="34 你对 line-height 是如何理解的？"></a>34 你对 line-height 是如何理解的？</h4><p>行高是指一行文字的高度，具体说是两行文字间基线的距离。CSS 中起高度作用的是 height 和 line-height，没有定义 height 属性，最终其表现作用一定是 line-height。<br>单行文本垂直居中：把 line-height 值设置为 height 一样大小的值可以实现单行文字的垂直居中，其实也可以把 height 删除。<br>多行文本垂直居中：需要设置 display 属性为 inline-block。</p><h4 id="35-怎么让-Chrome-支持小于-12px-的文字？"><a href="#35-怎么让-Chrome-支持小于-12px-的文字？" class="headerlink" title="35 怎么让 Chrome 支持小于 12px 的文字？"></a>35 怎么让 Chrome 支持小于 12px 的文字？</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p&#123;font-size:10px;-webkit-transform:scale(0.8);&#125; //0.8是缩放比例</span><br></pre></td></tr></table></figure><h4 id="36-让页面里的字体变清晰，变细用-CSS-怎么做？"><a href="#36-让页面里的字体变清晰，变细用-CSS-怎么做？" class="headerlink" title="36 让页面里的字体变清晰，变细用 CSS 怎么做？"></a>36 让页面里的字体变清晰，变细用 CSS 怎么做？</h4><p>-webkit-font-smoothing 在 window 系统下没有起作用，但是在 IOS 设备上起作用-webkit-font-smoothing：antialiased 是最佳的，灰度平滑。</p><h4 id="37-position-fixed-在-android-下无效怎么处理？"><a href="#37-position-fixed-在-android-下无效怎么处理？" class="headerlink" title="37 position:fixed;在 android 下无效怎么处理？"></a>37 position:fixed;在 android 下无效怎么处理？</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=<span class="string">"viewport"</span></span><br><span class="line">      content=<span class="string">"width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0,</span></span><br><span class="line"><span class="string">      user-scalable=no"</span>/&gt;</span><br></pre></td></tr></table></figure><h4 id="38-如果需要手动写动画，你认为最小时间间隔是多久，为什么？"><a href="#38-如果需要手动写动画，你认为最小时间间隔是多久，为什么？" class="headerlink" title="38 如果需要手动写动画，你认为最小时间间隔是多久，为什么？"></a>38 如果需要手动写动画，你认为最小时间间隔是多久，为什么？</h4><p>多数显示器默认频率是 60Hz，即 1 秒刷新 60 次，所以理论上最小间隔为 1/60＊1000ms ＝ 16.7ms。</p><h4 id="39-li-与-li-之间有看不见的空白间隔是什么原因引起的？有什么解决办法？"><a href="#39-li-与-li-之间有看不见的空白间隔是什么原因引起的？有什么解决办法？" class="headerlink" title="39 li 与 li 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？"></a>39 li 与 li 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</h4><p>行框的排列会受到中间空白（回车空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为 0，就没有空格了。<br>解决方法：</p><pre>可以将li代码全部写在一排浮动li中float：left在ul中用font-size：0（谷歌不支持）；可以使用letter-space：-3px</pre><h4 id="40-display-inline-block-什么时候会显示间隙？"><a href="#40-display-inline-block-什么时候会显示间隙？" class="headerlink" title="40 display:inline-block 什么时候会显示间隙？"></a>40 display:inline-block 什么时候会显示间隙？</h4><p>有空格时候会有间隙 解决：移除空格<br>margin 正值的时候 解决：margin 使用负值<br>使用 font-size 时候 解决：font-size:0、letter-spacing、word-spacing</p><h4 id="41-有一个高度自适应的-div，里面有两个-div，一个高度-100px，希望另一个填满剩下的高度"><a href="#41-有一个高度自适应的-div，里面有两个-div，一个高度-100px，希望另一个填满剩下的高度" class="headerlink" title="41 有一个高度自适应的 div，里面有两个 div，一个高度 100px，希望另一个填满剩下的高度"></a>41 有一个高度自适应的 div，里面有两个 div，一个高度 100px，希望另一个填满剩下的高度</h4><p>外层 div 使用 position：relative；高度要求自适应的 div 使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">position: absolute; top: 100px; bottom: 0; left: 0</span><br></pre></td></tr></table></figure><h4 id="42-png、jpg、gif-这些图片格式解释一下，分别什么时候用。有没有了解过-webp？"><a href="#42-png、jpg、gif-这些图片格式解释一下，分别什么时候用。有没有了解过-webp？" class="headerlink" title="42 png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过 webp？"></a>42 png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过 webp？</h4><p>png 是便携式网络图片（Portable Network Graphics）是一种无损数据压缩位图文件格式.优点是：压缩比高，色彩好。 大多数地方都可以用。<br>jpg 是一种针对相片使用的一种失真压缩方法，是一种破坏性的压缩，在色调及颜色平滑变化做的不错。在 www 上，被用来储存和传输照片的格式。<br>gif 是一种位图文件格式，以 8 位色重现真色彩的图像。可以实现动画效果.<br>webp 格式是谷歌在 2010 年推出的图片格式，压缩率只有 jpg 的 2/3，大小比 png 小了 45%。缺点是压缩的时间更久了，兼容性不好，目前谷歌和 opera 支持。</p><h4 id="43-style-标签写在-body-后与-body-前有什么区别？"><a href="#43-style-标签写在-body-后与-body-前有什么区别？" class="headerlink" title="43 style 标签写在 body 后与 body 前有什么区别？"></a>43 style 标签写在 body 后与 body 前有什么区别？</h4><p>页面加载自上而下 当然是先加载样式。<br>写在 body 标签后由于浏览器以逐行方式对 HTML 文档进行解析，当解析到写在尾部的样式表（外联或写在 style 标签）会导致浏览器停止之前的渲染，等待加载且解析样式表完成之后重新渲染，在 windows 的 IE 下可能会出现 FOUC 现象（即样式失效导致的页面闪烁问题）</p><h4 id="44-CSS-属性-overflow-属性定义溢出元素内容区的内容会如何处理"><a href="#44-CSS-属性-overflow-属性定义溢出元素内容区的内容会如何处理" class="headerlink" title="44 CSS 属性 overflow 属性定义溢出元素内容区的内容会如何处理?"></a>44 CSS 属性 overflow 属性定义溢出元素内容区的内容会如何处理?</h4><p>参数是 scroll 时候，必会出现滚动条。<br>参数是 auto 时候，子元素内容大于父元素时出现滚动条。<br>参数是 visible 时候，溢出的内容出现在父元素之外。<br>参数是 hidden 时候，溢出隐藏。</p><h4 id="45-阐述一下-CSS-Sprites"><a href="#45-阐述一下-CSS-Sprites" class="headerlink" title="45 阐述一下 CSS Sprites"></a>45 阐述一下 CSS Sprites</h4><p>将一个页面涉及到的所有图片都包含到一张大图中去，然后利用 CSS 的 background-image，background- repeat，background-position 的组合进行背景定位。利用 CSS Sprites 能很好地减少网页的 http 请求，从而大大的提高页面的性能；CSS Sprites 能减少图片的字节。</p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mvvm</title>
      <link href="/2018/10/26/mvvm/"/>
      <url>/2018/10/26/mvvm/</url>
      
        <content type="html"><![CDATA[<h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><pre>涉及面试题：什么是 MVVM？比之 MVC 有什么区别？</pre><p>首先先申明一点，不管是 React 还是 Vue，它们都不是 MVVM 框架，只是有借鉴 MVVM 的思路。文中拿 Vue 举例也是为了更好地理解 MVVM 的概念。</p><p>接下来先说下 View 和 Model：</p><pre>View 很简单，就是用户看到的视图Model 同样很简单，一般就是本地数据和数据库中的数据</pre><p>基本上，我们写的产品就是通过接口从数据库中读取数据，然后将数据经过处理展现到用户看到的视图上。当然我们还可以从视图上读取用户的输入，然后又将用户的输入通过接口写入到数据库中。但是，如何将数据展示到视图上，然后又如何将用户的输入写入到数据中，不同的人就产生了不同的看法，从此出现了很多种架构设计。</p><p>传统的 MVC 架构通常是使用控制器更新模型，视图从模型中获取数据去渲染。当用户有输入时，会通过控制器去更新模型，并且通知视图进行更新。</p><p>但是 MVC 有一个巨大的缺陷就是控制器承担的责任太大了，随着项目愈加复杂，控制器中的代码会越来越臃肿，导致出现不利于维护的情况。</p><p>在 MVVM 架构中，引入了  ViewModel  的概念。ViewModel 只关心数据和业务的处理，不关心 View 如何处理数据，在这种情况下，View 和 Model 都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可复用的逻辑放在一个 ViewModel 中，让多个 View 复用这个 ViewModel。</p><p>以 Vue 框架来举例:</p><pre>ViewModel 就是组件的实例。View 就是模板。Model 的话在引入 Vuex 的情况下是完全可以和组件分离的。</pre><p>除了以上三个部分，其实在 MVVM 中还引入了一个隐式的 Binder 层，实现了 View 和 ViewModel 的绑定。</p><p>同样以 Vue 框架来举例，这个隐式的 Binder 层就是 Vue 通过解析模板中的插值和指令从而实现 View 与 ViewModel 的绑定。</p><p>对于 MVVM 来说，其实最重要的并不是通过双向绑定或者其他的方式将 View 与 ViewModel 绑定起来，而是通过 ViewModel 将视图中的状态和用户的行为分离出一个抽象，这才是 MVVM 的精髓。</p><h4 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h4><pre>涉及面试题：什么是 Virtual DOM？为什么 Virtual DOM 比原生 DOM 快？</pre><p>大家都知道操作 DOM 是很慢的，为什么慢的原因已经在「浏览器渲染原理」章节中说过，这里就不再赘述了。<br>那么相较于 DOM 来说，操作 JS 对象会快很多，并且我们也可以通过 JS 来模拟 DOM</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const ul = &#123;</span><br><span class="line">  tag: <span class="string">'ul'</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    class: <span class="string">'list'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  children: &#123;</span><br><span class="line">    tag: <span class="string">'li'</span>,</span><br><span class="line">    children: <span class="string">'1'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码对应的 DOM 就是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul class=<span class="string">'list'</span>&gt;</span><br><span class="line">  &lt;li&gt;1&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>那么既然 DOM 可以通过 JS 对象来模拟，反之也可以通过 JS 对象来渲染出对应的 DOM。当然了，通过 JS 来模拟 DOM 并且渲染对应的 DOM 只是第一步，难点在于如何判断新旧两个 JS 对象的最小差异并且实现局部更新  DOM。<br>首先 DOM 是一个多叉树的结构，如果需要完整的对比两颗树的差异，那么需要的时间复杂度会是 O(n ^ 3)，这个复杂度肯定是不能接受的。于是 React 团队优化了算法，实现了 O(n) 的复杂度来对比差异。 实现 O(n) 复杂度的关键就是只对比同层的节点，而不是跨层对比，这也是考虑到在实际业务中很少会去跨层的移动 DOM 元素。 所以判断差异的算法就分为了两步<br>首先从上至下，从左往右遍历对象，也就是树的深度遍历，这一步中会给每个节点添加索引，便于最后渲染差异<br>一旦节点有子元素，就去判断子元素是否有不同<br>在第一步算法中我们需要判断新旧节点的  tagName  是否相同，如果不相同的话就代表节点被替换了。如果没有更改  tagName  的话，就需要判断是否有子元素，有的话就进行第二步算法。<br>在第二步算法中，我们需要判断原本的列表中是否有节点被移除，在新的列表中需要判断是否有新的节点加入，还需要判断节点是否有移动。<br>举个例子来说，假设页面中只有一个列表，我们对列表中的元素进行了变更</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 假设这里模拟一个 ul，其中包含了 5 个 li</span><br><span class="line">[1, 2, 3, 4, 5]</span><br><span class="line">// 这里替换上面的 li</span><br><span class="line">[1, 2, 5, 4]</span><br></pre></td></tr></table></figure><p>从上述例子中，我们一眼就可以看出先前的  ul  中的第三个  li  被移除了，四五替换了位置。<br>那么在实际的算法中，我们如何去识别改动的是哪个节点呢？这就引入了  key  这个属性，想必大家在 Vue 或者 React 的列表中都用过这个属性。这个属性是用来给每一个节点打标志的，用于判断是否是同一个节点。<br>当然在判断以上差异的过程中，我们还需要判断节点的属性是否有变化等等。<br>当我们判断出以上的差异后，就可以把这些差异记录下来。当对比完两棵树以后，就可以通过差异去局部更新 DOM，实现性能的最优化。<br>另外再来回答「为什么 Virtual DOM 比原生 DOM 快」这个问题。首先这个问题得分场景来说，如果无脑替换所有的 DOM 这种场景来说，Virtual DOM 的局部更新肯定要来的快。但是如果你可以人肉也同样去局部替换 DOM，那么 Virtual DOM 必然没有你直接操作 DOM 来的快，毕竟还有一层 diff 算法的损耗。<br>当然了 Virtual DOM 提高性能是其中一个优势，其实最大的优势还是在于：</p><pre>将 Virtual DOM 作为一个兼容层，让我们还能对接非 Web 端的系统，实现跨端开发。同样的，通过 Virtual DOM 我们可以渲染到其他的平台，比如实现 SSR、同构渲染等等。实现组件的高度抽象化</pre><h4 id="路由原理"><a href="#路由原理" class="headerlink" title="路由原理"></a>路由原理</h4><pre>涉及面试题：前端路由原理？两种实现方式有什么区别？</pre><p>前端路由实现起来其实很简单，本质就是监听 URL 的变化，然后匹配路由规则，显示相应的页面，并且无须刷新页面。目前前端使用的路由就只有两种实现方式</p><pre>Hash 模式History 模式</pre><h5 id="Hash-模式"><a href="#Hash-模式" class="headerlink" title="Hash 模式"></a>Hash 模式</h5><p><a href="http://www.test.com/#/" target="_blank" rel="noopener">www.test.com/#/</a>  就是 Hash URL，当  #  后面的哈希值发生变化时，可以通过  hashchange  事件来监听到 URL 的变化，从而进行跳转页面，并且无论哈希值如何变化，服务端接收到的 URL 请求永远是  <a href="http://www.test.com。" target="_blank" rel="noopener">www.test.com。</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(<span class="string">'hashchange'</span>, () =&gt; &#123;</span><br><span class="line">  // ... 具体逻辑</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Hash 模式相对来说更简单，并且兼容性也更好。</p><h5 id="History-模式"><a href="#History-模式" class="headerlink" title="History 模式"></a>History 模式</h5><p>History 模式是 HTML5 新推出的功能，主要使用  history.pushState  和  history.replaceState  改变 URL。<br>通过 History 模式改变 URL 同样不会引起页面的刷新，只会更新浏览器的历史记录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 新增历史记录</span><br><span class="line">history.pushState(stateObject, title, URL)</span><br><span class="line">// 替换当前历史记录</span><br><span class="line">history.replaceState(stateObject, title, URL)</span><br><span class="line">当用户做出浏览器动作时，比如点击后退按钮时会触发 popState 事件</span><br><span class="line">window.addEventListener(<span class="string">'popstate'</span>, e =&gt; &#123;</span><br><span class="line">  // e.state 就是 pushState(stateObject) 中的 stateObject</span><br><span class="line">  console.log(e.state)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h6 id="两种模式对比"><a href="#两种模式对比" class="headerlink" title="两种模式对比"></a>两种模式对比</h6><pre>Hash 模式只可以更改  #  后面的内容，History 模式可以通过 API 设置任意的同源 URLHistory 模式可以通过 API 添加任意类型的数据到历史记录中，Hash 模式只能更改哈希值，也就是字符串Hash 模式无需后端配置，并且兼容性好。History 模式在用户手动输入地址或者刷新页面的时候会发起 URL 请求，        后端需要配置  index.html  页面用于匹配不到静态资源的时候</pre><h4 id="Vue-和-React-之间的区别"><a href="#Vue-和-React-之间的区别" class="headerlink" title="Vue 和 React 之间的区别"></a>Vue 和 React 之间的区别</h4><p>Vue 的表单可以使用  v-model  支持双向绑定，相比于 React 来说开发上更加方便，当然了  v-model 其实就是个语法糖，本质上和 React 写表单的方式没什么区别。<br>改变数据方式不同，Vue 修改状态相比来说要简单许多，React 需要使用  setState  来改变状态，并且使用这个 API 也有一些坑点。并且 Vue 的底层使用了依赖追踪，页面更新渲染已经是最优的了，但是 React 还是需要用户手动去优化这方面的问题。<br>React 16 以后，有些钩子函数会执行多次，这是因为引入 Fiber 的原因，这在后续的章节中会讲到。<br>React 需要使用 JSX，有一定的上手成本，并且需要一整套的工具链支持，但是完全可以通过 JS 来控制页面，更加的灵活。Vue 使用了模板语法，相比于 JSX 来说没有那么灵活，但是完全可以脱离工具链，通过直接编写  render  函数就能在浏览器中运行。<br>在生态上来说，两者其实没多大的差距，当然 React 的用户是远远高于 Vue 的。<br>在上手成本上来说，Vue 一开始的定位就是尽可能的降低前端开发的门槛，然而 React 更多的是去改变用户去接受它的概念和思想，相较于 Vue 来说上手成本略高。</p><h4 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h4><p>Vue 内部使用了  Object.defineProperty()  来实现数据响应式，通过这个函数可以监听到  set  和  get  的事件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">var data = &#123; name: <span class="string">'yck'</span> &#125;</span><br><span class="line">observe(data)</span><br><span class="line"><span class="built_in">let</span> name = data.name // -&gt; get value</span><br><span class="line">data.name = <span class="string">'yyy'</span> // -&gt; change value</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> observe(obj) &#123;</span><br><span class="line">  // 判断类型</span><br><span class="line">  <span class="keyword">if</span> (!obj || typeof obj !== <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="built_in">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  Object.keys(obj).forEach(key =&gt; &#123;</span><br><span class="line">    defineReactive(obj, key, obj[key])</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> defineReactive(obj, key, val) &#123;</span><br><span class="line">  // 递归子属性</span><br><span class="line">  observe(val)</span><br><span class="line">  Object.defineProperty(obj, key, &#123;</span><br><span class="line">    // 可枚举</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    // 可配置</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    // 自定义函数</span><br><span class="line">    get: <span class="keyword">function</span> <span class="function"><span class="title">reactiveGetter</span></span>() &#123;</span><br><span class="line">      console.log(<span class="string">'get value'</span>)</span><br><span class="line">      <span class="built_in">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">set</span>: <span class="keyword">function</span> reactiveSetter(newVal) &#123;</span><br><span class="line">      console.log(<span class="string">'change value'</span>)</span><br><span class="line">      val = newVal</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码简单的实现了如何监听数据的  set  和  get  的事件，但是仅仅如此是不够的，因为自定义的函数一开始是不会执行的。只有先执行了依赖收集，才能在属性更新的时候派发更新，所以接下来我们需要先触发依赖收集。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;&#123;name&#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>在解析如上模板代码时，遇到    就会进行依赖收集。<br>接下来我们先来实现一个  Dep  类，用于解耦属性的依赖收集和派发更新操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 通过 Dep 解耦属性的依赖和更新操作</span><br><span class="line">class Dep &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    this.subs = []</span><br><span class="line">  &#125;</span><br><span class="line">  // 添加依赖</span><br><span class="line">  addSub(sub) &#123;</span><br><span class="line">    this.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line">  // 更新</span><br><span class="line">  <span class="function"><span class="title">notify</span></span>() &#123;</span><br><span class="line">    this.subs.forEach(sub =&gt; &#123;</span><br><span class="line">      sub.update()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 全局属性，通过该属性配置 Watcher</span><br><span class="line">Dep.target = null</span><br></pre></td></tr></table></figure><p>以上的代码实现很简单，当需要依赖收集的时候调用  addSub，当需要派发更新的时候调用  notify。</p><h4 id="Vue-组件挂载时添加响应式的过程。"><a href="#Vue-组件挂载时添加响应式的过程。" class="headerlink" title="Vue 组件挂载时添加响应式的过程。"></a>Vue 组件挂载时添加响应式的过程。</h4><p>在组件挂载时，会先对所有需要的属性调用  Object.defineProperty()，然后实例化  Watcher，传入组件更新的回调。在实例化过程中，会对模板中的属性进行求值，触发依赖收集。<br>因为这一小节主要目的是学习响应式原理的细节，所以接下来的代码会简略的表达触发依赖收集时的操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Watcher &#123;</span><br><span class="line">  constructor(obj, key, cb) &#123;</span><br><span class="line">    // 将 Dep.target 指向自己</span><br><span class="line">    // 然后触发属性的 getter 添加监听</span><br><span class="line">    // 最后将 Dep.target 置空</span><br><span class="line">    Dep.target = this</span><br><span class="line">    this.cb = cb</span><br><span class="line">    this.obj = obj</span><br><span class="line">    this.key = key</span><br><span class="line">    this.value = obj[key]</span><br><span class="line">    Dep.target = null</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">update</span></span>() &#123;</span><br><span class="line">    // 获得新值</span><br><span class="line">    this.value = this.obj[this.key]</span><br><span class="line">    // 调用 update 方法更新 Dom</span><br><span class="line">    this.cb(this.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是  Watcher  的简单实现，在执行构造函数的时候将  Dep.target  指向自身，从而使得收集到了对应的  Watcher，在派发更新的时候取出对应的  Watcher  然后执行  update  函数。<br>接下来，需要对  defineReactive  函数进行改造，在自定义函数中添加依赖收集和派发更新相关的代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> defineReactive(obj, key, val) &#123;</span><br><span class="line">  // 递归子属性</span><br><span class="line">  observe(val)</span><br><span class="line">  <span class="built_in">let</span> dp = new Dep()</span><br><span class="line">  Object.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    get: <span class="keyword">function</span> <span class="function"><span class="title">reactiveGetter</span></span>() &#123;</span><br><span class="line">      console.log(<span class="string">'get value'</span>)</span><br><span class="line">      // 将 Watcher 添加到订阅</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        dp.addSub(Dep.target)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">set</span>: <span class="keyword">function</span> reactiveSetter(newVal) &#123;</span><br><span class="line">      console.log(<span class="string">'change value'</span>)</span><br><span class="line">      val = newVal</span><br><span class="line">      // 执行 watcher 的 update 方法</span><br><span class="line">      dp.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上所有代码实现了一个简易的数据响应式，核心思路就是手动触发一次属性的 getter 来实现依赖收集。<br>现在我们就来测试下代码的效果，只需要把所有的代码复制到浏览器中执行，就会发现页面的内容全部被替换了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var data = &#123; name: <span class="string">'yck'</span> &#125;</span><br><span class="line">observe(data)</span><br><span class="line"><span class="keyword">function</span> update(value) &#123;</span><br><span class="line">  document.querySelector(<span class="string">'div'</span>).innerText = value</span><br><span class="line">&#125;</span><br><span class="line">// 模拟解析到 `&#123;&#123;name&#125;&#125;` 触发的操作</span><br><span class="line">new Watcher(data, <span class="string">'name'</span>, update)</span><br><span class="line">// update Dom innerText</span><br><span class="line">data.name = <span class="string">'yyy'</span></span><br></pre></td></tr></table></figure><h4 id="Object-defineProperty-的缺陷"><a href="#Object-defineProperty-的缺陷" class="headerlink" title="Object.defineProperty 的缺陷"></a>Object.defineProperty 的缺陷</h4><p>以上已经分析完了 Vue 的响应式原理，接下来说一点  Object.defineProperty  中的缺陷。<br>如果通过下标方式修改数组数据或者给对象新增属性并不会触发组件的重新渲染，因为  Object.defineProperty  不能拦截到这些操作，更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过重写函数的方式解决了这个问题。<br>对于第一个问题，Vue 提供了一个 API 解决</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> <span class="built_in">set</span> (target: Array&lt;any&gt; | Object, key: any, val: any): any &#123;</span><br><span class="line">  // 判断是否为数组且下标是否有效</span><br><span class="line">  <span class="keyword">if</span> (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123;</span><br><span class="line">    // 调用 splice 函数触发派发更新</span><br><span class="line">    // 该函数已被重写</span><br><span class="line">    target.length = Math.max(target.length, key)</span><br><span class="line">    target.splice(key, 1, val)</span><br><span class="line">    <span class="built_in">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  // 判断 key 是否已经存在</span><br><span class="line">  <span class="keyword">if</span> (key <span class="keyword">in</span> target &amp;&amp; !(key <span class="keyword">in</span> Object.prototype)) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    <span class="built_in">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  const ob = (target: any).__ob__</span><br><span class="line">  // 如果对象不是响应式对象，就赋值返回</span><br><span class="line">  <span class="keyword">if</span> (!ob) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    <span class="built_in">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  // 进行双向绑定</span><br><span class="line">  defineReactive(ob.value, key, val)</span><br><span class="line">  // 手动派发更新</span><br><span class="line">  ob.dep.notify()</span><br><span class="line">  <span class="built_in">return</span> val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于数组而言，Vue 内部重写了以下函数实现派发更新</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 获得数组原型</span><br><span class="line">const arrayProto = Array.prototype</span><br><span class="line"><span class="built_in">export</span> const arrayMethods = Object.create(arrayProto)</span><br><span class="line">// 重写以下函数</span><br><span class="line">const methodsToPatch = [ <span class="string">'push'</span>, <span class="string">'pop'</span>, <span class="string">'shift'</span>, <span class="string">'unshift'</span>, <span class="string">'splice'</span>, <span class="string">'sort'</span>, <span class="string">'reverse'</span> ]</span><br><span class="line">methodsToPatch.forEach(<span class="keyword">function</span> (method) &#123;</span><br><span class="line">  // 缓存原生函数 const original = arrayProto[method]</span><br><span class="line">  // 重写函数</span><br><span class="line">  def(arrayMethods, method, <span class="keyword">function</span> mutator (...args) &#123;</span><br><span class="line">    // 先调用原生函数获得结果</span><br><span class="line">    const result = original.apply(this, args) const ob = this.__ob__ <span class="built_in">let</span> inserted</span><br><span class="line">    // 调用以下几个函数时，监听新数据</span><br><span class="line">    switch (method) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'push'</span>: <span class="keyword">case</span> <span class="string">'unshift'</span>: inserted = args <span class="built_in">break</span> <span class="keyword">case</span> <span class="string">'splice'</span>: inserted = args.slice(2) <span class="built_in">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inserted) ob.observeArray(inserted)</span><br><span class="line">    // 手动派发更新</span><br><span class="line">    ob.dep.notify() <span class="built_in">return</span> result</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h4><p>想必大家在使用 Vue 开发的过程中，基本都是使用模板的方式。那么你有过「模板是怎么在浏览器中运行的」这种疑虑嘛？<br>首先直接把模板丢到浏览器中肯定是不能运行的，模板只是为了方便开发者进行开发。Vue 会通过编译器将模板通过几个阶段最终编译为  render  函数，然后通过执行  render  函数生成 Virtual DOM 最终映射为真实 DOM。<br>接下来我们就来学习这个编译的过程，了解这个过程中大概发生了什么事情。这个过程其中又分为三个阶段，分别为：<br>将模板解析为 AST</p><h5 id="优化-AST"><a href="#优化-AST" class="headerlink" title="优化 AST"></a>优化 AST</h5><p>将 AST 转换为  render  函数<br>在第一个阶段中，最主要的事情还是通过各种各样的正则表达式去匹配模板中的内容，然后将内容提取出来做各种逻辑操作，接下来会生成一个最基本的 AST 对象</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // 类型</span><br><span class="line">    <span class="built_in">type</span>: 1,</span><br><span class="line">    // 标签</span><br><span class="line">    tag,</span><br><span class="line">    // 属性列表</span><br><span class="line">    attrsList: attrs,</span><br><span class="line">    // 属性映射</span><br><span class="line">    attrsMap: makeAttrsMap(attrs),</span><br><span class="line">    // 父节点</span><br><span class="line">    parent,</span><br><span class="line">    // 子节点</span><br><span class="line">    children: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后会根据这个最基本的 AST 对象中的属性，进一步扩展 AST。<br>当然在这一阶段中，还会进行其他的一些判断逻辑。比如说对比前后开闭标签是否一致，判断根组件是否只存在一个，判断是否符合 HTML5 Content Model  规范等等问题。<br>接下来就是优化 AST 的阶段。在当前版本下，Vue 进行的优化内容其实还是不多的。只是对节点进行了静态内容提取，也就是将永远不会变动的节点提取了出来，实现复用 Virtual DOM，跳过对比算法的功能。在下一个大版本中，Vue 会在优化 AST 的阶段继续发力，实现更多的优化功能，尽可能的在编译阶段压榨更多的性能，比如说提取静态的属性等等优化行为。<br>最后一个阶段就是通过 AST 生成  render  函数了。其实这一阶段虽然分支有很多，但是最主要的目的就是遍历整个 AST，根据不同的条件生成不同的代码罢了。</p><h5 id="NextTick-原理分析"><a href="#NextTick-原理分析" class="headerlink" title="NextTick 原理分析"></a>NextTick 原理分析</h5><p>nextTick  可以让我们在下次 DOM 更新循环结束之后执行延迟回调，用于获得更新后的 DOM。<br>在 Vue 2.4 之前都是使用的 microtasks，但是 microtasks 的优先级过高，在某些情况下可能会出现比事件冒泡更快的情况，但如果都使用 macrotasks 又可能会出现渲染的性能问题。所以在新版本中，会默认使用 microtasks，但在特殊情况下会使用 macrotasks，比如 v-on。<br>对于实现 macrotasks ，会先判断是否能使用  setImmediate ，不能的话降级为  MessageChannel ，以上都不行的话就使用  setTimeout</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (typeof setImmediate !== <span class="string">'undefined'</span> &amp;&amp; isNative(setImmediate)) &#123;</span><br><span class="line">  macroTimerFunc = () =&gt; &#123;</span><br><span class="line">    setImmediate(flushCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">  typeof MessageChannel !== <span class="string">'undefined'</span> &amp;&amp;</span><br><span class="line">  (isNative(MessageChannel) ||</span><br><span class="line">    // PhantomJS</span><br><span class="line">    MessageChannel.toString() === <span class="string">'[object MessageChannelConstructor]'</span>)</span><br><span class="line">) &#123;</span><br><span class="line">  const channel = new MessageChannel()</span><br><span class="line">  const port = channel.port2</span><br><span class="line">  channel.port1.onmessage = flushCallbacks</span><br><span class="line">  macroTimerFunc = () =&gt; &#123;</span><br><span class="line">    port.postMessage(1)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  macroTimerFunc = () =&gt; &#123;</span><br><span class="line">    setTimeout(flushCallbacks, 0)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码很简单，就是判断能不能使用相应的 API。</p>]]></content>
      
      
      <categories>
          
          <category> mvvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mvvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack</title>
      <link href="/2018/10/03/webpack/"/>
      <url>/2018/10/03/webpack/</url>
      
        <content type="html"><![CDATA[<h3 id="Webpack-性能优化"><a href="#Webpack-性能优化" class="headerlink" title="Webpack 性能优化"></a>Webpack 性能优化</h3><pre>有哪些方式可以减少 Webpack 的打包时间有哪些方式可以让 Webpack 打出来的包更小</pre><h4 id="减少-Webpack-打包时间"><a href="#减少-Webpack-打包时间" class="headerlink" title="减少 Webpack 打包时间"></a>减少 Webpack 打包时间</h4><h5 id="优化-Loader"><a href="#优化-Loader" class="headerlink" title="优化 Loader"></a>优化 Loader</h5><p>对于 Loader 来说，影响打包效率首当其冲必属 Babel 了。因为 Babel 会将代码转为字符串生成 AST，然后对 AST 继续进行转变最后再生成新的代码，项目越大，转换代码越多，效率就越低。当然了，我们是有办法优化的。</p><h6 id="首先我们可以优化-Loader-的文件搜索范围"><a href="#首先我们可以优化-Loader-的文件搜索范围" class="headerlink" title="首先我们可以优化 Loader 的文件搜索范围"></a>首先我们可以优化 Loader 的文件搜索范围</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        // js 文件才使用 babel</span><br><span class="line">        <span class="built_in">test</span>: /\.js\$/,</span><br><span class="line">        loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">        // 只在 src 文件夹下查找</span><br><span class="line">        include: [resolve(<span class="string">'src'</span>)],</span><br><span class="line">        // 不会去查找的路径</span><br><span class="line">        exclude: /node_modules/</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="对于-Babel-来说，我们肯定是希望只作用在-JS-代码上的，然后-node-modules-中使用的代码都是编译过的，所以我们也完全没有必要再去处理一遍。"><a href="#对于-Babel-来说，我们肯定是希望只作用在-JS-代码上的，然后-node-modules-中使用的代码都是编译过的，所以我们也完全没有必要再去处理一遍。" class="headerlink" title="对于 Babel 来说，我们肯定是希望只作用在 JS 代码上的，然后 node_modules 中使用的代码都是编译过的，所以我们也完全没有必要再去处理一遍。"></a>对于 Babel 来说，我们肯定是希望只作用在 JS 代码上的，然后 node_modules 中使用的代码都是编译过的，所以我们也完全没有必要再去处理一遍。</h6><h6 id="当然这样做还不够，我们还可以将-Babel-编译过的文件缓存起来，下次只需要编译更改过的代码文件即可，这样可以大幅度加快打包时间"><a href="#当然这样做还不够，我们还可以将-Babel-编译过的文件缓存起来，下次只需要编译更改过的代码文件即可，这样可以大幅度加快打包时间" class="headerlink" title="当然这样做还不够，我们还可以将 Babel 编译过的文件缓存起来，下次只需要编译更改过的代码文件即可，这样可以大幅度加快打包时间"></a>当然这样做还不够，我们还可以将 Babel 编译过的文件缓存起来，下次只需要编译更改过的代码文件即可，这样可以大幅度加快打包时间</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loader: <span class="string">'babel-loader?cacheDirectory=true'</span></span><br></pre></td></tr></table></figure><h3 id="HappyPack"><a href="#HappyPack" class="headerlink" title="HappyPack"></a>HappyPack</h3><p>受限于 Node 是单线程运行的，所以 Webpack 在打包的过程中也是单线程的，特别是在执行 Loader 的时候，长时间编译的任务很多，这样就会导致等待的情况。</p><h6 id="HappyPack-可以将-Loader-的同步执行转换为并行的，这样就能充分利用系统资源来加快打包效率了"><a href="#HappyPack-可以将-Loader-的同步执行转换为并行的，这样就能充分利用系统资源来加快打包效率了" class="headerlink" title="HappyPack 可以将 Loader 的同步执行转换为并行的，这样就能充分利用系统资源来加快打包效率了"></a>HappyPack 可以将 Loader 的同步执行转换为并行的，这样就能充分利用系统资源来加快打包效率了</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">  loaders: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">test</span>: /\.js\$/,</span><br><span class="line">      include: [resolve(<span class="string">'src'</span>)],</span><br><span class="line">      exclude: /node_modules/,</span><br><span class="line">      // id 后面的内容对应下面</span><br><span class="line">      loader: <span class="string">'happypack/loader?id=happybabel'</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br><span class="line">plugins: [</span><br><span class="line">  new HappyPack(&#123;</span><br><span class="line">    id: <span class="string">'happybabel'</span>,</span><br><span class="line">    loaders: [<span class="string">'babel-loader?cacheDirectory'</span>],</span><br><span class="line">    // 开启 4 个线程</span><br><span class="line">    threads: 4</span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="DllPlugin"><a href="#DllPlugin" class="headerlink" title="DllPlugin"></a>DllPlugin</h3><h5 id="DllPlugin-可以将特定的类库提前打包然后引入。这种方式可以极大的减少打包类库的次数，只有当类库更新版本才有需要重新打包，并且也实现了将公共代码抽离成单独文件的优化方案。"><a href="#DllPlugin-可以将特定的类库提前打包然后引入。这种方式可以极大的减少打包类库的次数，只有当类库更新版本才有需要重新打包，并且也实现了将公共代码抽离成单独文件的优化方案。" class="headerlink" title="DllPlugin 可以将特定的类库提前打包然后引入。这种方式可以极大的减少打包类库的次数，只有当类库更新版本才有需要重新打包，并且也实现了将公共代码抽离成单独文件的优化方案。"></a>DllPlugin 可以将特定的类库提前打包然后引入。这种方式可以极大的减少打包类库的次数，只有当类库更新版本才有需要重新打包，并且也实现了将公共代码抽离成单独文件的优化方案。</h5><h6 id="接下来我们就来学习如何使用-DllPlugin"><a href="#接下来我们就来学习如何使用-DllPlugin" class="headerlink" title="接下来我们就来学习如何使用 DllPlugin"></a>接下来我们就来学习如何使用 DllPlugin</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 单独配置在一个文件中</span><br><span class="line">// webpack.dll.conf.js</span><br><span class="line">const path = require(<span class="string">'path'</span>)</span><br><span class="line">const webpack = require(<span class="string">'webpack'</span>)</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">  // 想统一打包的类库</span><br><span class="line">  vendor: [<span class="string">'react'</span>]</span><br><span class="line">&#125;,</span><br><span class="line">output: &#123;</span><br><span class="line">  path: path.join(**dirname, <span class="string">'dist'</span>),</span><br><span class="line">  filename: <span class="string">'[name].dll.js'</span>,</span><br><span class="line">  library: <span class="string">'[name]-[hash]'</span></span><br><span class="line">&#125;,</span><br><span class="line">plugins: [</span><br><span class="line">  new webpack.DllPlugin(&#123;</span><br><span class="line">    // name 必须和 output.library 一致</span><br><span class="line">    name: <span class="string">'[name]-[hash]'</span>,</span><br><span class="line">    // 该属性需要与 DllReferencePlugin 中一致</span><br><span class="line">    context: **dirname,</span><br><span class="line">    path: path.join(\_\_dirname, <span class="string">'dist'</span>, <span class="string">'[name]-manifest.json'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="然后我们需要执行这个配置文件生成依赖文件，接下来我们需要使用-DllReferencePlugin-将依赖文件引入项目中"><a href="#然后我们需要执行这个配置文件生成依赖文件，接下来我们需要使用-DllReferencePlugin-将依赖文件引入项目中" class="headerlink" title="然后我们需要执行这个配置文件生成依赖文件，接下来我们需要使用 DllReferencePlugin 将依赖文件引入项目中"></a>然后我们需要执行这个配置文件生成依赖文件，接下来我们需要使用 DllReferencePlugin 将依赖文件引入项目中</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// webpack.conf.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  // ...省略其他配置</span><br><span class="line">  plugins: [</span><br><span class="line">    new webpack.DllReferencePlugin(&#123;</span><br><span class="line">      context: __dirname,</span><br><span class="line">      // manifest 就是之前打包出来的 json 文件</span><br><span class="line">      manifest: require(<span class="string">'./dist/vendor-manifest.json'</span>),</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码压缩"><a href="#代码压缩" class="headerlink" title="代码压缩"></a>代码压缩</h4><p>在 Webpack3 中，我们一般使用 UglifyJS 来压缩代码，但是这个是单线程运行的，为了加快效率，我们可以使用 webpack-parallel-uglify-plugin 来并行运行 UglifyJS，从而提高效率。</p><p>在 Webpack4 中，我们就不需要以上这些操作了，只需要将 mode 设置为 production 就可以默认开启以上功能。代码压缩也是我们必做的性能优化方案，当然我们不止可以压缩 JS 代码，还可以压缩 HTML、CSS 代码，并且在压缩 JS 代码的过程中，我们还可以通过配置实现比如删除 console.log 这类代码的功能。</p><h4 id="一些小的优化点"><a href="#一些小的优化点" class="headerlink" title="一些小的优化点"></a>一些小的优化点</h4><p>我们还可以通过一些小的优化点来加快打包速度</p><h5 id="resolve-extensions："><a href="#resolve-extensions：" class="headerlink" title="resolve.extensions："></a>resolve.extensions：</h5><p>用来表明文件后缀列表，默认查找顺序是 [‘.js’, ‘.json’]，如果你的导入文件没有添加后缀就会按照这个顺序查找文件。我们应该尽可能减少后缀列表长度，然后将出现频率高的后缀排在前面</p><h5 id="resolve-alias："><a href="#resolve-alias：" class="headerlink" title="resolve.alias："></a>resolve.alias：</h5><p>可以通过别名的方式来映射一个路径，能让 Webpack 更快找到路径</p><h5 id="module-noParse："><a href="#module-noParse：" class="headerlink" title="module.noParse："></a>module.noParse：</h5><p>如果你确定一个文件下没有其他依赖，就可以使用该属性让 Webpack 不扫描该文件，这种方式对于大型的类库很有帮助</p><h4 id="减少-Webpack-打包后的文件体积"><a href="#减少-Webpack-打包后的文件体积" class="headerlink" title="减少 Webpack 打包后的文件体积"></a>减少 Webpack 打包后的文件体积</h4><p>注意：该内容也属于性能优化领域。</p><h4 id="按需加载"><a href="#按需加载" class="headerlink" title="按需加载"></a>按需加载</h4><p>想必大家在开发 SPA 项目的时候，项目中都会存在十几甚至更多的路由页面。如果我们将这些页面全部打包进一个 JS 文件的话，虽然将多个请求合并了，但是同样也加载了很多并不需要的代码，耗费了更长的时间。那么为了首页能更快地呈现给用户，我们肯定是希望首页能加载的文件体积越小越好，这时候我们就可以使用按需加载，将每个路由页面单独打包为一个文件。当然不仅仅路由可以按需加载，对于 loadash 这种大型类库同样可以使用这个功能。</p><pre>按需加载的代码实现这里就不详细展开了，因为鉴于用的框架不同，实现起来都是不一样的。当然了，虽然他们的用法可能不同，但是底层的机制都是一样的。都是当使用的时候再去下载对应文件，返回一个 Promise，当 Promise 成功以后去执行回调。</pre><h5 id="Scope-Hoisting"><a href="#Scope-Hoisting" class="headerlink" title="Scope Hoisting"></a>Scope Hoisting</h5><p>Scope Hoisting 会分析出模块之间的依赖关系，尽可能的把打包出来的模块合并到一个函数中去。</p><p>比如我们希望打包两个文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// test.js</span><br><span class="line"><span class="built_in">export</span> const a = 1</span><br><span class="line">// index.js</span><br><span class="line">import &#123; a &#125; from <span class="string">'./test.js'</span></span><br></pre></td></tr></table></figure><p>对于这种情况，我们打包出来的代码会类似这样</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  /* 0 */</span><br><span class="line">  <span class="keyword">function</span> (module, exports, require) &#123;</span><br><span class="line">    //...</span><br><span class="line">  &#125;,</span><br><span class="line">  /* 1 */</span><br><span class="line">  <span class="keyword">function</span> (module, exports, require) &#123;</span><br><span class="line">    //...</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>但是如果我们使用 Scope Hoisting 的话，代码就会尽可能的合并到一个函数中去，也就变成了这样的类似代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  /* 0 */</span><br><span class="line">  <span class="keyword">function</span> (module, exports, require) &#123;</span><br><span class="line">    //...</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这样的打包方式生成的代码明显比之前的少多了。如果在 Webpack4 中你希望开启这个功能，只需要启用 optimization.concatenateModules 就可以了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    concatenateModules: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Tree-Shaking"><a href="#Tree-Shaking" class="headerlink" title="Tree Shaking"></a>Tree Shaking</h4><p>Tree Shaking 可以实现删除项目中未被引用的代码，比如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// test.js</span><br><span class="line"><span class="built_in">export</span> const a = 1</span><br><span class="line"><span class="built_in">export</span> const b = 2</span><br><span class="line">// index.js</span><br><span class="line">import &#123; a &#125; from <span class="string">'./test.js'</span></span><br></pre></td></tr></table></figure><p>对于以上情况，test 文件中的变量 b 如果没有在项目中使用到的话，就不会被打包到文件中。</p><p>如果你使用 Webpack 4 的话，开启生产环境就会自动启动这个优化功能。</p>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue_data</title>
      <link href="/2018/09/11/vue-data/"/>
      <url>/2018/09/11/vue-data/</url>
      
        <content type="html"><![CDATA[<h3 id="组件中-data-什么时候可以使用对象"><a href="#组件中-data-什么时候可以使用对象" class="headerlink" title="组件中 data 什么时候可以使用对象"></a>组件中 data 什么时候可以使用对象</h3><p>组件复用时所有组件实例都会共享  data，如果  data  是对象的话，就会造成一个组件修改  data  以后会影响到其他所有组件，所以需要将  data  写成函数，每次用到就调用一次函数获得新的数据。</p><p>当我们使用  new Vue()  的方式的时候，无论我们将  data  设置为对象还是函数都是可以的，因为  new Vue()  的方式是生成一个根组件，该组件不会复用，也就不存在共享  data  的情况了。</p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue_keep-alive</title>
      <link href="/2018/06/16/vue-keep-alive/"/>
      <url>/2018/06/16/vue-keep-alive/</url>
      
        <content type="html"><![CDATA[<h3 id="keep-alive-组件有什么作用"><a href="#keep-alive-组件有什么作用" class="headerlink" title="keep-alive 组件有什么作用"></a>keep-alive 组件有什么作用</h3><p>如果你需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用  keep-alive  组件包裹需要保存的组件。</p><p>对于  keep-alive  组件来说，它拥有两个独有的生命周期钩子函数，分别为  activated  和  deactivated 。用  keep-alive  包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行  deactivated  钩子函数，命中缓存渲染后会执行  actived  钩子函数。</p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue_v-show_v-if</title>
      <link href="/2018/06/02/vue-v-show-v-if/"/>
      <url>/2018/06/02/vue-v-show-v-if/</url>
      
        <content type="html"><![CDATA[<h3 id="v-show-与-v-if-区别"><a href="#v-show-与-v-if-区别" class="headerlink" title="v-show 与 v-if 区别"></a>v-show 与 v-if 区别</h3><h4 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h4><p>v-show 只是在  display: none  和  display: block  之间切换。无论初始条件是什么都会被渲染出来，后面只需要切换 CSS，DOM 还是一直保留着的。所以总的来说  v-show  在初始渲染时有更高的开销，但是切换开销很小，更适合于频繁切换的场景。</p><h4 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h4><p>v-if 的话就得说到 Vue 底层的编译了。当属性初始为  false  时，组件就不会被渲染，直到条件为  true，并且切换条件时会触发销毁/挂载组件，所以总的来说在切换时开销更高，更适合不经常切换的场景。</p><p>并且基于  v-if  的这种惰性渲染机制，可以在必要的时候才去渲染组件，减少整个页面的初始渲染开销。</p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue_computed_watch</title>
      <link href="/2018/05/10/vue-computed-watch/"/>
      <url>/2018/05/10/vue-computed-watch/</url>
      
        <content type="html"><![CDATA[<h3 id="computed-和-watch-区别"><a href="#computed-和-watch-区别" class="headerlink" title="computed 和 watch 区别"></a>computed 和 watch 区别</h3><pre>computed  是计算属性，依赖其他属性计算值，并且  computed  的值有缓存，只有当计算值变化才会返回内容。watch  监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。</pre><p>所以一般来说需要依赖别的属性来动态获得值的时候可以使用  computed，对于监听到值的变化需要做一些复杂业务逻辑的情况可以使用  watch。</p><p>另外  computed  和  watch  还都支持对象的写法，这种方式知道的人并不多。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vm.<span class="variable">$watch</span>(<span class="string">'obj'</span>, &#123;</span><br><span class="line">    // 深度遍历</span><br><span class="line">    deep: <span class="literal">true</span>,</span><br><span class="line">    // 立即触发</span><br><span class="line">    immediate: <span class="literal">true</span>,</span><br><span class="line">    // 执行的函数</span><br><span class="line">    handler: <span class="keyword">function</span>(val, oldVal) &#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  data: &#123; a: 1 &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    aPlus: &#123;</span><br><span class="line">      // this.aPlus 时触发</span><br><span class="line">      get: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        <span class="built_in">return</span> this.a + 1</span><br><span class="line">      &#125;,</span><br><span class="line">      // this.aPlus = 1 时触发</span><br><span class="line">      <span class="built_in">set</span>: <span class="keyword">function</span> (v) &#123;</span><br><span class="line">        this.a = v - 1</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue_communication</title>
      <link href="/2018/04/08/vue-communication/"/>
      <url>/2018/04/08/vue-communication/</url>
      
        <content type="html"><![CDATA[<h3 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h3><p>组件通信一般分为以下几种情况：</p><pre>父子组件通信兄弟组件通信跨多层级组件通信任意组件</pre><p>对于以上每种情况都有多种方式去实现，接下来就来学习下如何实现。</p><h4 id="父子通信"><a href="#父子通信" class="headerlink" title="父子通信"></a>父子通信</h4><p>父组件通过  props  传递数据给子组件，子组件通过  emit  发送事件传递数据给父组件，这两种方式是最常用的父子通信实现办法。</p><p>这种父子通信方式也就是典型的单向数据流，父组件通过  props  传递数据，子组件不能直接修改  props， 而是必须通过发送事件的方式告知父组件修改数据。</p><p>另外这两种方式还可以使用语法糖  v-model  来直接实现，因为  v-model  默认会解析成名为  value  的  prop  和名为  input  的事件。这种语法糖的方式是典型的双向绑定，常用于 UI 控件上，但是究其根本，还是通过事件的方法让父组件修改数据。</p><p>当然我们还可以通过访问  $parent 或者 $children  对象来访问组件实例中的方法和数据。</p><p>另外如果你使用 Vue 2.3 及以上版本的话还可以使用  \$listeners  和  .sync  这两个属性。</p><pre>$listeners 属性会将父组件中的 (不含 .native 修饰器的) v-on 事件监听器传递给子组件，     子组件可以通过访问 $listeners  来自定义监听器。.sync  属性是个语法糖，可以很简单的实现子组件与父组件通信</pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--父组件中--&gt;</span><br><span class="line">&lt;input :value.sync=<span class="string">"value"</span> /&gt;</span><br><span class="line">&lt;!--以上写法等同于--&gt;</span><br><span class="line">&lt;input :value=<span class="string">"value"</span> @update:value=<span class="string">"v =&gt; value = v"</span>&gt;&lt;/comp&gt;</span><br><span class="line">&lt;!--子组件中--&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  this.<span class="variable">$emit</span>(<span class="string">'update:value'</span>, 1)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="兄弟组件通信"><a href="#兄弟组件通信" class="headerlink" title="兄弟组件通信"></a>兄弟组件通信</h4><p>对于这种情况可以通过查找父组件中的子组件实现，也就是  this.$parent.$children，在  \$children 中可以通过组件  name  查询到需要的组件实例，然后进行通信。</p><h4 id="跨多层次组件通信"><a href="#跨多层次组件通信" class="headerlink" title="跨多层次组件通信"></a>跨多层次组件通信</h4><p>对于这种情况可以使用 Vue 2.2 新增的 API provide / inject，虽然文档中不推荐直接使用在业务中，但是如果用得好的话还是很有用的。</p><p>假设有父组件 A，然后有一个跨多层级的子组件 B</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 父组件 A</span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  provide: &#123;</span><br><span class="line">    data: 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 子组件 B</span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  inject: [<span class="string">'data'</span>],</span><br><span class="line">  <span class="function"><span class="title">mounted</span></span>() &#123;</span><br><span class="line">    // 无论跨几层都能获得父组件的 data 属性</span><br><span class="line">    console.log(this.data) // =&gt; 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="任意组件"><a href="#任意组件" class="headerlink" title="任意组件"></a>任意组件</h4><p>这种方式可以通过 Vuex 或者 Event Bus 解决，另外如果你不怕麻烦的话，可以使用这种方式解决上述所有的通信情况</p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue_mixin_mixins</title>
      <link href="/2018/04/02/vue-mixin-mixins/"/>
      <url>/2018/04/02/vue-mixin-mixins/</url>
      
        <content type="html"><![CDATA[<h3 id="mixin-和-mixins-区别"><a href="#mixin-和-mixins-区别" class="headerlink" title="mixin 和 mixins 区别"></a>mixin 和 mixins 区别</h3><p>mixin  用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.mixin(&#123;</span><br><span class="line">    <span class="function"><span class="title">beforeCreate</span></span>() &#123;</span><br><span class="line">        // ...逻辑</span><br><span class="line">        // 这种方式会影响到每个组件的 beforeCreate 钩子函数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>虽然文档不建议我们在应用中直接使用  mixin，但是如果不滥用的话也是很有帮助的，比如可以全局混入封装好的  ajax  或者一些工具函数等等。</p><p>mixins  应该是我们最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过  mixins  混入代码，比如上拉下拉加载数据这种逻辑等等。</p><p>另外需要注意的是  mixins  混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并，具体可以阅读   文档。</p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react_lifecycle</title>
      <link href="/2018/03/27/react-lifecycle/"/>
      <url>/2018/03/27/react-lifecycle/</url>
      
        <content type="html"><![CDATA[<h3 id="React-组件生命周期"><a href="#React-组件生命周期" class="headerlink" title="React 组件生命周期"></a>React 组件生命周期</h3><p>组件的生命周期可分成三个状态：</p><pre>Mounting：已插入真实 DOMUpdating：正在被重新渲染Unmounting：已移出真实 DOM</pre><h4 id="生命周期的方法有："><a href="#生命周期的方法有：" class="headerlink" title="生命周期的方法有："></a>生命周期的方法有：</h4><h5 id="componentWillMount"><a href="#componentWillMount" class="headerlink" title="componentWillMount"></a>componentWillMount</h5><p>在渲染前调用,在客户端也在服务端。</p><h5 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a>componentDidMount</h5><p>在第一次渲染后调用，只在客户端。之后组件已经生成了对应的 DOM 结构，可以通过 this.getDOMNode()来进行访问。 如果你想和其他 JavaScript 框架一起使用，可以在这个方法中调用 setTimeout, setInterval 或者发送 AJAX 请求等操作(防止异步操作阻塞 UI)。</p><h5 id="componentWillReceiveProps"><a href="#componentWillReceiveProps" class="headerlink" title="componentWillReceiveProps"></a>componentWillReceiveProps</h5><p>在组件接收到一个新的 prop (更新后)时被调用。这个方法在初始化 render 时不会被调用。</p><h5 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h5><p>返回一个布尔值。在组件接收到新的 props 或者 state 时被调用。在初始化时或者使用 forceUpdate 时不被调用。<br>可以在你确认不需要更新组件时使用。</p><h5 id="componentWillUpdate"><a href="#componentWillUpdate" class="headerlink" title="componentWillUpdate"></a>componentWillUpdate</h5><p>在组件接收到新的 props 或者 state 但还没有 render 时被调用。在初始化时不会被调用。</p><h5 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate"></a>componentDidUpdate</h5><p>在组件完成更新后立即调用。在初始化时不会被调用。</p><h5 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount"></a>componentWillUnmount</h5><p>在组件从 DOM 中移除之前立刻被调用。</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>以下实例在 Hello 组件加载以后，通过 componentDidMount 方法设置一个定时器，每隔 100 毫秒重新设置组件的透明度，并重新渲染：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Hello extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">      super(props);</span><br><span class="line">      this.state = &#123;opacity: 1.0&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span></span>() &#123;</span><br><span class="line">    this.timer = setInterval(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">      var opacity = this.state.opacity;</span><br><span class="line">      opacity -= .05;</span><br><span class="line">      <span class="keyword">if</span> (opacity &lt; 0.1) &#123;</span><br><span class="line">        opacity = 1.0;</span><br><span class="line">      &#125;</span><br><span class="line">      this.setState(&#123;</span><br><span class="line">        opacity: opacity</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;.<span class="built_in">bind</span>(this), 100);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span></span> () &#123;</span><br><span class="line">    <span class="built_in">return</span> (</span><br><span class="line">      &lt;div style=&#123;&#123;opacity: this.state.opacity&#125;&#125;&gt;</span><br><span class="line">        Hello &#123;this.props.name&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Hello name=<span class="string">"world"</span>/&gt;,</span><br><span class="line">  document.body</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>以下实例初始化 state ， setNewnumber 用于更新 state。所有生命周期在 Content 组件中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">class Button extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">      super(props);</span><br><span class="line">      this.state = &#123;data: 0&#125;;</span><br><span class="line">      this.setNewNumber = this.setNewNumber.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">setNewNumber</span></span>() &#123;</span><br><span class="line">    this.setState(&#123;data: this.state.data + 1&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">      <span class="built_in">return</span> (</span><br><span class="line">         &lt;div&gt;</span><br><span class="line">            &lt;button onClick = &#123;this.setNewNumber&#125;&gt;INCREMENT&lt;/button&gt;</span><br><span class="line">            &lt;Content myNumber = &#123;this.state.data&#125;&gt;&lt;/Content&gt;</span><br><span class="line">         &lt;/div&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Content extends React.Component &#123;</span><br><span class="line">  <span class="function"><span class="title">componentWillMount</span></span>() &#123;</span><br><span class="line">      console.log(<span class="string">'Component WILL MOUNT!'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span></span>() &#123;</span><br><span class="line">       console.log(<span class="string">'Component DID MOUNT!'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  componentWillReceiveProps(newProps) &#123;</span><br><span class="line">        console.log(<span class="string">'Component WILL RECEIVE PROPS!'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  shouldComponentUpdate(newProps, newState) &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  componentWillUpdate(nextProps, nextState) &#123;</span><br><span class="line">        console.log(<span class="string">'Component WILL UPDATE!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidUpdate(prevProps, prevState) &#123;</span><br><span class="line">        console.log(<span class="string">'Component DID UPDATE!'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">componentWillUnmount</span></span>() &#123;</span><br><span class="line">         console.log(<span class="string">'Component WILL UNMOUNT!'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">      <span class="built_in">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;h3&gt;&#123;this.props.myNumber&#125;&lt;/h3&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">   &lt;div&gt;</span><br><span class="line">      &lt;Button /&gt;</span><br><span class="line">   &lt;/div&gt;,</span><br><span class="line">  document.getElementById(<span class="string">'example'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue_lifecycle</title>
      <link href="/2018/03/26/vue-lifecycle/"/>
      <url>/2018/03/26/vue-lifecycle/</url>
      
        <content type="html"><![CDATA[<h3 id="生命周期钩子函数"><a href="#生命周期钩子函数" class="headerlink" title="生命周期钩子函数"></a>生命周期钩子函数</h3><p>在  beforeCreate  钩子函数调用的时候，是获取不到  props  或者  data  中的数据的，因为这些数据的初始化都在  initState  中。</p><p>然后会执行  created  钩子函数，在这一步的时候已经可以访问到之前不能访问到的数据，但是这时候组件还没被挂载，所以是看不到的。</p><p>接下来会先执行  beforeMount  钩子函数，开始创建 VDOM，最后执行  mounted  钩子，并将 VDOM 渲染为真实 DOM 并且渲染数据。组件中如果有子组件的话，会递归挂载子组件，只有当所有子组件全部挂载完毕，才会执行根组件的挂载钩子。</p><p>接下来是数据更新时会调用的钩子函数  beforeUpdate  和  updated，这两个钩子函数没什么好说的，就是分别在数据更新前和更新后会调用。</p><p>另外还有  keep-alive  独有的生命周期，分别为  activated  和  deactivated 。用  keep-alive  包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行  deactivated  钩子函数，命中缓存渲染后会执行  actived  钩子函数。</p><p>最后就是销毁组件的钩子函数  beforeDestroy  和  destroyed。前者适合移除事件、定时器等等，否则可能会引起内存泄露的问题。然后进行一系列的销毁操作，如果有子组件的话，也会递归销毁子组件，所有子组件都销毁完毕后才会执行根组件的  destroyed  钩子函数。</p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>REACT_组件通信</title>
      <link href="/2018/03/25/react_fscom/"/>
      <url>/2018/03/25/react_fscom/</url>
      
        <content type="html"><![CDATA[<h3 id="父子组件通信"><a href="#父子组件通信" class="headerlink" title="父子组件通信"></a>父子组件通信</h3><p>父组件通过  props  传递数据给子组件，子组件通过调用父组件传来的函数传递数据给父组件，这两种方式是最常用的父子通信实现办法。这种父子通信方式也就是典型的单向数据流，父组件通过  props  传递数据，子组件不能直接修改  props， 而是必须通过调用父组件函数的方式告知父组件修改数据。</p><h3 id="兄弟组件通信"><a href="#兄弟组件通信" class="headerlink" title="兄弟组件通信"></a>兄弟组件通信</h3><p>对于这种情况可以通过共同的父组件来管理状态和事件函数。比如说其中一个兄弟组件调用父组件传递过来的事件函数修改父组件中的状态，然后父组件将状态传递给另一个兄弟组件。</p><h3 id="跨多层次组件通信"><a href="#跨多层次组件通信" class="headerlink" title="跨多层次组件通信"></a>跨多层次组件通信</h3><p>如果你使用 16.3 以上版本的话，对于这种情况可以使用 Context API。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 创建 Context，可以在开始就传入值</span><br><span class="line">const StateContext = React.createContext()</span><br><span class="line">class Parent extends React.Component &#123;</span><br><span class="line">  <span class="function"><span class="title">render</span></span> () &#123;</span><br><span class="line">    <span class="built_in">return</span> (</span><br><span class="line">      // value 就是传入 Context 中的值</span><br><span class="line">      &lt;StateContext.Provider value=<span class="string">'yck'</span>&gt;</span><br><span class="line">        &lt;Child /&gt;</span><br><span class="line">      &lt;/StateContext.Provider&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Child extends React.Component &#123;</span><br><span class="line">  <span class="function"><span class="title">render</span></span> () &#123;</span><br><span class="line">    <span class="built_in">return</span> (</span><br><span class="line">      &lt;ThemeContext.Consumer&gt;</span><br><span class="line">        // 取出值</span><br><span class="line">        &#123;context =&gt; (</span><br><span class="line">          name is &#123; context &#125;</span><br><span class="line">        )&#125;</span><br><span class="line">      &lt;/ThemeContext.Consumer&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>REACT_setState</title>
      <link href="/2018/03/22/setStarte/"/>
      <url>/2018/03/22/setStarte/</url>
      
        <content type="html"><![CDATA[<h3 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h3><p>setState 在 React 中是经常使用的一个 API，但是它存在一些的问题经常会导致初学者出错，核心原因就是因为这个 API 是异步的。首先  setState  的调用并不会马上引起  state  的改变，并且如果你一次调用了多个  setState ，那么结果可能并不如你期待的一样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">handle</span></span>() &#123;</span><br><span class="line">  // 初始化 `count` 为 0</span><br><span class="line">  console.log(this.state.count) // -&gt; 0</span><br><span class="line">  this.setState(&#123; count: this.state.count + 1 &#125;)</span><br><span class="line">  this.setState(&#123; count: this.state.count + 1 &#125;)</span><br><span class="line">  this.setState(&#123; count: this.state.count + 1 &#125;)</span><br><span class="line">  console.log(this.state.count) // -&gt; 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一，两次的打印都为 0，因为  setState  是个异步 API，只有同步代码运行完毕才会执行。setState  异步的原因我认为在于，setState  可能会导致 DOM 的重绘，如果调用一次就马上去进行重绘，那么调用多次就会造成不必要的性能损失。设计成异步的话，就可以将多次调用放入一个队列中，在恰当的时候统一进行更新过程。</p><p>第二，虽然调用了三次  setState ，但是  count  的值还是为 1。因为多次调用会合并为一次，只有当更新结束后  state  才会改变，三次调用等同于如下代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object.assign(</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  &#123; count: this.state.count + 1 &#125;,</span><br><span class="line">  &#123; count: this.state.count + 1 &#125;,</span><br><span class="line">  &#123; count: this.state.count + 1 &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>当然你也可以通过以下方式来实现调用三次  setState  使得  count  为 3</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">handle</span></span>() &#123;</span><br><span class="line">  this.setState((prevState) =&gt; (&#123; count: prevState.count + 1 &#125;))</span><br><span class="line">  this.setState((prevState) =&gt; (&#123; count: prevState.count + 1 &#125;))</span><br><span class="line">  this.setState((prevState) =&gt; (&#123; count: prevState.count + 1 &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你想在每次调用  setState  后获得正确的  state ，可以通过如下代码实现</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">handle</span></span>() &#123;</span><br><span class="line">    this.setState((prevState) =&gt; (&#123; count: prevState.count + 1 &#125;), () =&gt; &#123;</span><br><span class="line">        console.log(this.state)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react_Refs</title>
      <link href="/2018/01/05/react-Refs/"/>
      <url>/2018/01/05/react-Refs/</url>
      
        <content type="html"><![CDATA[<h3 id="React-Refs"><a href="#React-Refs" class="headerlink" title="React Refs"></a>React Refs</h3><p>React 支持一种非常特殊的属性 Ref ，你可以用来绑定到 render() 输出的任何组件上。</p><p>这个特殊的属性允许你引用 render() 返回的相应的支撑实例（ backing instance ）。这样就可以确保在任何时间总是拿到正确的实例。</p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>绑定一个 ref 属性到 render 的返回值上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input ref=<span class="string">"myInput"</span> /&gt;</span><br></pre></td></tr></table></figure><p>在其它代码中，通过 this.refs 获取支撑实例:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var input = this.refs.myInput;</span><br><span class="line">var inputValue = input.value;</span><br><span class="line">var inputRect = input.getBoundingClientRect();</span><br></pre></td></tr></table></figure><h4 id="完整实例"><a href="#完整实例" class="headerlink" title="完整实例"></a>完整实例</h4><p>你可以通过使用 this 来获取当前 React 组件，或使用 ref 来获取组件的引用，实例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class MyComponent extends React.Component &#123;</span><br><span class="line">  <span class="function"><span class="title">handleClick</span></span>() &#123;</span><br><span class="line">    // 使用原生的 DOM API 获取焦点</span><br><span class="line">    this.refs.myInput.focus();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">    //  当组件插入到 DOM 后，ref 属性添加一个组件的引用于到 this.refs</span><br><span class="line">    <span class="built_in">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> ref=<span class="string">"myInput"</span> /&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          <span class="built_in">type</span>=<span class="string">"button"</span></span><br><span class="line">          value=<span class="string">"点我输入框获取焦点"</span></span><br><span class="line">          onClick=&#123;this.handleClick.bind(this)&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;MyComponent /&gt;,</span><br><span class="line">  document.getElementById(<span class="string">'example'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
