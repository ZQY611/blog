{"meta":{"title":"个人博客","subtitle":"BCH","description":"bch_bk","author":"BCH","url":"http://blog.bochunhao.cn","root":"/"},"pages":[{"title":"categories","date":"2019-03-25T15:28:59.000Z","updated":"2019-03-25T15:32:55.259Z","comments":false,"path":"categories/index.html","permalink":"http://blog.bochunhao.cn/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-03-25T15:28:40.000Z","updated":"2019-03-25T15:30:17.149Z","comments":false,"path":"tags/index.html","permalink":"http://blog.bochunhao.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"cycle","slug":"cycle","date":"2019-03-25T15:27:01.000Z","updated":"2019-03-25T15:27:01.723Z","comments":true,"path":"2019/03/25/cycle/","link":"","permalink":"http://blog.bochunhao.cn/2019/03/25/cycle/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"es6_async_await","slug":"es6-async-await","date":"2019-03-25T15:07:49.000Z","updated":"2019-03-25T15:16:51.307Z","comments":true,"path":"2019/03/25/es6-async-await/","link":"","permalink":"http://blog.bochunhao.cn/2019/03/25/es6-async-await/","excerpt":"","text":"","categories":[],"tags":[{"name":"未知","slug":"未知","permalink":"http://blog.bochunhao.cn/tags/未知/"}]},{"title":"REACT_组件通信","slug":"react_fscom","date":"2018-03-25T14:25:58.000Z","updated":"2019-03-25T14:59:16.887Z","comments":true,"path":"2018/03/25/react_fscom/","link":"","permalink":"http://blog.bochunhao.cn/2018/03/25/react_fscom/","excerpt":"","text":"父子组件通信父组件通过 props 传递数据给子组件，子组件通过调用父组件传来的函数传递数据给父组件，这两种方式是最常用的父子通信实现办法。这种父子通信方式也就是典型的单向数据流，父组件通过 props 传递数据，子组件不能直接修改 props， 而是必须通过调用父组件函数的方式告知父组件修改数据。兄弟组件通信对于这种情况可以通过共同的父组件来管理状态和事件函数。比如说其中一个兄弟组件调用父组件传递过来的事件函数修改父组件中的状态，然后父组件将状态传递给另一个兄弟组件。跨多层次组件通信如果你使用 16.3 以上版本的话，对于这种情况可以使用 Context API。123456789101112131415161718192021222324// 创建 Context，可以在开始就传入值const StateContext = React.createContext()class Parent extends React.Component &#123; render () &#123; return ( // value 就是传入 Context 中的值 &lt;StateContext.Provider value='yck'&gt; &lt;Child /&gt; &lt;/StateContext.Provider&gt; ) &#125;&#125;class Child extends React.Component &#123; render () &#123; return ( &lt;ThemeContext.Consumer&gt; // 取出值 &#123;context =&gt; ( name is &#123; context &#125; )&#125; &lt;/ThemeContext.Consumer&gt; ); &#125;&#125;","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://blog.bochunhao.cn/tags/react/"}]},{"title":"REACT_setState","slug":"setStarte","date":"2018-03-22T12:33:57.000Z","updated":"2019-03-25T15:33:50.419Z","comments":true,"path":"2018/03/22/setStarte/","link":"","permalink":"http://blog.bochunhao.cn/2018/03/22/setStarte/","excerpt":"","text":"setStatesetState 在 React 中是经常使用的一个 API，但是它存在一些的问题经常会导致初学者出错，核心原因就是因为这个 API 是异步的。首先 setState 的调用并不会马上引起 state 的改变，并且如果你一次调用了多个 setState ，那么结果可能并不如你期待的一样。12345678handle() &#123; // 初始化 `count` 为 0 console.log(this.state.count) // -&gt; 0 this.setState(&#123; count: this.state.count + 1 &#125;) this.setState(&#123; count: this.state.count + 1 &#125;) this.setState(&#123; count: this.state.count + 1 &#125;) console.log(this.state.count) // -&gt; 0&#125; 第一，两次的打印都为 0，因为 setState 是个异步 API，只有同步代码运行完毕才会执行。setState 异步的原因我认为在于，setState 可能会导致 DOM 的重绘，如果调用一次就马上去进行重绘，那么调用多次就会造成不必要的性能损失。设计成异步的话，就可以将多次调用放入一个队列中，在恰当的时候统一进行更新过程。第二，虽然调用了三次 setState ，但是 count 的值还是为 1。因为多次调用会合并为一次，只有当更新结束后 state 才会改变，三次调用等同于如下代码123456Object.assign( &#123;&#125;, &#123; count: this.state.count + 1 &#125;, &#123; count: this.state.count + 1 &#125;, &#123; count: this.state.count + 1 &#125;,) 当然你也可以通过以下方式来实现调用三次 setState 使得 count 为 312345handle() &#123; this.setState((prevState) =&gt; (&#123; count: prevState.count + 1 &#125;)) this.setState((prevState) =&gt; (&#123; count: prevState.count + 1 &#125;)) this.setState((prevState) =&gt; (&#123; count: prevState.count + 1 &#125;))&#125; 如果你想在每次调用 setState 后获得正确的 state ，可以通过如下代码实现12345handle() &#123; this.setState((prevState) =&gt; (&#123; count: prevState.count + 1 &#125;), () =&gt; &#123; console.log(this.state) &#125;)&#125;","categories":[{"name":"react","slug":"react","permalink":"http://blog.bochunhao.cn/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"http://blog.bochunhao.cn/tags/react/"}]}]}