<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>mvvm | 个人博客 | BCH</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="theme-color" content="#3F51B5">
  
  
  <meta name="keywords" content="mvvm">
  <meta name="description" content="MVVM涉及面试题：什么是 MVVM？比之 MVC 有什么区别？  首先先申明一点，不管是 React 还是 Vue，它们都不是 MVVM 框架，只是有借鉴 MVVM 的思路。文中拿 Vue 举例也是为了更好地理解 MVVM 的概念。 接下来先说下 View 和 Model： View 很简单，就是用户看到的视图  Model 同样很简单，一般就是本地数据和数据库中的数据   基本上，我们写的产品">
<meta name="keywords" content="mvvm">
<meta property="og:type" content="article">
<meta property="og:title" content="mvvm">
<meta property="og:url" content="http://blog.bochunhao.cn/2018/10/26/mvvm/index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="MVVM涉及面试题：什么是 MVVM？比之 MVC 有什么区别？  首先先申明一点，不管是 React 还是 Vue，它们都不是 MVVM 框架，只是有借鉴 MVVM 的思路。文中拿 Vue 举例也是为了更好地理解 MVVM 的概念。 接下来先说下 View 和 Model： View 很简单，就是用户看到的视图  Model 同样很简单，一般就是本地数据和数据库中的数据   基本上，我们写的产品">
<meta property="og:locale" content="Chinese">
<meta property="og:updated_time" content="2019-03-26T08:38:26.020Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="mvvm">
<meta name="twitter:description" content="MVVM涉及面试题：什么是 MVVM？比之 MVC 有什么区别？  首先先申明一点，不管是 React 还是 Vue，它们都不是 MVVM 框架，只是有借鉴 MVVM 的思路。文中拿 Vue 举例也是为了更好地理解 MVVM 的概念。 接下来先说下 View 和 Model： View 很简单，就是用户看到的视图  Model 同样很简单，一般就是本地数据和数据库中的数据   基本上，我们写的产品">
  
    <link rel="alternative" href="/atom.xml" title="个人博客" type="application/atom+xml">
  
  <meta name="summary" content="bch_bk">
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="loading" class="active"></div>

  <nav id="menu" class="hide" >
   <div class="inner flex-row-vertical">
  <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
      <i class="icon icon-lg icon-close"></i>
  </a>
  <div class="brand-wrap">
    <div class="brand">
      <a href="/" class="avatar"><img src="/img/logos.jpeg"></a>
      <hgroup class="introduce">
        <h5 class="nickname">BCH</h5>
        <a href="mailto:17600280987@163.com" title="17600280987@163.com" class="mail">17600280987@163.com</a>
      </hgroup>
    </div>
  </div>
  <div class="scroll-wrap flex-col">
    <ul class="nav">
      
          <li class="waves-block waves-effect">
            <a href="/">
              <i class="icon icon-lg icon-home"></i>
              主页
            </a>
          </li>
      
          <li class="waves-block waves-effect">
            <a href="/categories">
              <i class="icon icon-lg icon-archives"></i>
              分类
            </a>
          </li>
      
          <li class="waves-block waves-effect">
            <a href="/tags">
              <i class="icon icon-lg icon-tags"></i>
              标签
            </a>
          </li>
      
          <li class="waves-block waves-effect">
            <a href="https://github.com/bch9479/blog" target="_blank">
              <i class="icon icon-lg icon-github"></i>
              Github
            </a>
          </li>
      
          <li class="waves-block waves-effect">
            <a href="https://weibo.com/5900743344/profile?rightmod=1&wvr=6&mod=personinfo" target="_blank">
              <i class="icon icon-lg icon-weibo"></i>
              微博
            </a>
          </li>
      
    </ul>

    <footer class="footer">
  <p>个人博客 &copy; 2019</p>
  <p style="color:#3F51B5;font-size: 16px;font-weight:bolder">
    不积跬步，无以至千里
  </p>
  <p style="color:#3F51B5;font-size: 16px;font-weight:bolder">
    不积小流，无以成江海
  </p>
</footer>

  </div>
</div>

  </nav>
  <main id="main">
    <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">mvvm</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input " autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
    </div>
</header>
<header class="content-header">
  <div class="container">
    <h1 class="author">mvvm</h1>
    <h5 class="subtitle">
        
            <time datetime="2018-10-26T13:59:31.000Z" itemprop="datePublished" class="page-time">
  2018-10-26
</time>


        
    </h5>
  </div>
</header>

    <div class="container body-wrap">
      <article id="post-mvvm" class="article article-type-post" itemprop="blogPost">
  <div class="post-meta flex-row">
    
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mvvm/">mvvm</a></li></ul>

  </div>
  <div class="post-body">
    <aside class="post-widget" id="post-widget">
       
      <nav class="post-toc-wrap" id="post-toc">
        <ol class="post-toc"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#MVVM"><span class="post-toc-number">1.</span> <span class="post-toc-text">MVVM</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Virtual-DOM"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">Virtual DOM</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#路由原理"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">路由原理</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Hash-模式"><span class="post-toc-number">1.2.1.</span> <span class="post-toc-text">Hash 模式</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#History-模式"><span class="post-toc-number">1.2.2.</span> <span class="post-toc-text">History 模式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#两种模式对比"><span class="post-toc-number">1.2.2.1.</span> <span class="post-toc-text">两种模式对比</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Vue-和-React-之间的区别"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">Vue 和 React 之间的区别</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#响应式原理"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">响应式原理</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Vue-组件挂载时添加响应式的过程。"><span class="post-toc-number">1.5.</span> <span class="post-toc-text">Vue 组件挂载时添加响应式的过程。</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Object-defineProperty-的缺陷"><span class="post-toc-number">1.6.</span> <span class="post-toc-text">Object.defineProperty 的缺陷</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#编译过程"><span class="post-toc-number">1.7.</span> <span class="post-toc-text">编译过程</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#优化-AST"><span class="post-toc-number">1.7.1.</span> <span class="post-toc-text">优化 AST</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#NextTick-原理分析"><span class="post-toc-number">1.7.2.</span> <span class="post-toc-text">NextTick 原理分析</span></a></li></ol></li></ol></li></ol>
      </nav>
      
    </aside>

    <div class="post-main">
      <div class="post-content" id="post-content" itemprop="postContent">
        <h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><pre>涉及面试题：什么是 MVVM？比之 MVC 有什么区别？</pre>

<p>首先先申明一点，不管是 React 还是 Vue，它们都不是 MVVM 框架，只是有借鉴 MVVM 的思路。文中拿 Vue 举例也是为了更好地理解 MVVM 的概念。</p>
<p>接下来先说下 View 和 Model：</p>
<pre>View 很简单，就是用户看到的视图

Model 同样很简单，一般就是本地数据和数据库中的数据
</pre>

<p>基本上，我们写的产品就是通过接口从数据库中读取数据，然后将数据经过处理展现到用户看到的视图上。当然我们还可以从视图上读取用户的输入，然后又将用户的输入通过接口写入到数据库中。但是，如何将数据展示到视图上，然后又如何将用户的输入写入到数据中，不同的人就产生了不同的看法，从此出现了很多种架构设计。</p>
<p>传统的 MVC 架构通常是使用控制器更新模型，视图从模型中获取数据去渲染。当用户有输入时，会通过控制器去更新模型，并且通知视图进行更新。</p>
<p>但是 MVC 有一个巨大的缺陷就是控制器承担的责任太大了，随着项目愈加复杂，控制器中的代码会越来越臃肿，导致出现不利于维护的情况。</p>
<p>在 MVVM 架构中，引入了  ViewModel  的概念。ViewModel 只关心数据和业务的处理，不关心 View 如何处理数据，在这种情况下，View 和 Model 都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可复用的逻辑放在一个 ViewModel 中，让多个 View 复用这个 ViewModel。</p>
<p>以 Vue 框架来举例:</p>
<pre>
ViewModel 就是组件的实例。
View 就是模板。
Model 的话在引入 Vuex 的情况下是完全可以和组件分离的。
</pre>

<p>除了以上三个部分，其实在 MVVM 中还引入了一个隐式的 Binder 层，实现了 View 和 ViewModel 的绑定。</p>
<p>同样以 Vue 框架来举例，这个隐式的 Binder 层就是 Vue 通过解析模板中的插值和指令从而实现 View 与 ViewModel 的绑定。</p>
<p>对于 MVVM 来说，其实最重要的并不是通过双向绑定或者其他的方式将 View 与 ViewModel 绑定起来，而是通过 ViewModel 将视图中的状态和用户的行为分离出一个抽象，这才是 MVVM 的精髓。</p>
<h4 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h4><pre>涉及面试题：什么是 Virtual DOM？为什么 Virtual DOM 比原生 DOM 快？</pre>

<p>大家都知道操作 DOM 是很慢的，为什么慢的原因已经在「浏览器渲染原理」章节中说过，这里就不再赘述了。<br>那么相较于 DOM 来说，操作 JS 对象会快很多，并且我们也可以通过 JS 来模拟 DOM</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const ul = &#123;</span><br><span class="line">  tag: <span class="string">'ul'</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    class: <span class="string">'list'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  children: &#123;</span><br><span class="line">    tag: <span class="string">'li'</span>,</span><br><span class="line">    children: <span class="string">'1'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码对应的 DOM 就是</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul class=<span class="string">'list'</span>&gt;</span><br><span class="line">  &lt;li&gt;1&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>
<p>那么既然 DOM 可以通过 JS 对象来模拟，反之也可以通过 JS 对象来渲染出对应的 DOM。当然了，通过 JS 来模拟 DOM 并且渲染对应的 DOM 只是第一步，难点在于如何判断新旧两个 JS 对象的最小差异并且实现局部更新  DOM。<br>首先 DOM 是一个多叉树的结构，如果需要完整的对比两颗树的差异，那么需要的时间复杂度会是 O(n ^ 3)，这个复杂度肯定是不能接受的。于是 React 团队优化了算法，实现了 O(n) 的复杂度来对比差异。 实现 O(n) 复杂度的关键就是只对比同层的节点，而不是跨层对比，这也是考虑到在实际业务中很少会去跨层的移动 DOM 元素。 所以判断差异的算法就分为了两步<br>首先从上至下，从左往右遍历对象，也就是树的深度遍历，这一步中会给每个节点添加索引，便于最后渲染差异<br>一旦节点有子元素，就去判断子元素是否有不同<br>在第一步算法中我们需要判断新旧节点的  tagName  是否相同，如果不相同的话就代表节点被替换了。如果没有更改  tagName  的话，就需要判断是否有子元素，有的话就进行第二步算法。<br>在第二步算法中，我们需要判断原本的列表中是否有节点被移除，在新的列表中需要判断是否有新的节点加入，还需要判断节点是否有移动。<br>举个例子来说，假设页面中只有一个列表，我们对列表中的元素进行了变更</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 假设这里模拟一个 ul，其中包含了 5 个 li</span><br><span class="line">[1, 2, 3, 4, 5]</span><br><span class="line">// 这里替换上面的 li</span><br><span class="line">[1, 2, 5, 4]</span><br></pre></td></tr></table></figure>
<p>从上述例子中，我们一眼就可以看出先前的  ul  中的第三个  li  被移除了，四五替换了位置。<br>那么在实际的算法中，我们如何去识别改动的是哪个节点呢？这就引入了  key  这个属性，想必大家在 Vue 或者 React 的列表中都用过这个属性。这个属性是用来给每一个节点打标志的，用于判断是否是同一个节点。<br>当然在判断以上差异的过程中，我们还需要判断节点的属性是否有变化等等。<br>当我们判断出以上的差异后，就可以把这些差异记录下来。当对比完两棵树以后，就可以通过差异去局部更新 DOM，实现性能的最优化。<br>另外再来回答「为什么 Virtual DOM 比原生 DOM 快」这个问题。首先这个问题得分场景来说，如果无脑替换所有的 DOM 这种场景来说，Virtual DOM 的局部更新肯定要来的快。但是如果你可以人肉也同样去局部替换 DOM，那么 Virtual DOM 必然没有你直接操作 DOM 来的快，毕竟还有一层 diff 算法的损耗。<br>当然了 Virtual DOM 提高性能是其中一个优势，其实最大的优势还是在于：</p>
<pre>将 Virtual DOM 作为一个兼容层，让我们还能对接非 Web 端的系统，实现跨端开发。
同样的，通过 Virtual DOM 我们可以渲染到其他的平台，比如实现 SSR、同构渲染等等。
实现组件的高度抽象化</pre>

<h4 id="路由原理"><a href="#路由原理" class="headerlink" title="路由原理"></a>路由原理</h4><pre>涉及面试题：前端路由原理？两种实现方式有什么区别？</pre>

<p>前端路由实现起来其实很简单，本质就是监听 URL 的变化，然后匹配路由规则，显示相应的页面，并且无须刷新页面。目前前端使用的路由就只有两种实现方式</p>
<pre>Hash 模式
History 模式</pre>

<h5 id="Hash-模式"><a href="#Hash-模式" class="headerlink" title="Hash 模式"></a>Hash 模式</h5><p><a href="http://www.test.com/#/" target="_blank" rel="noopener">www.test.com/#/</a>  就是 Hash URL，当  #  后面的哈希值发生变化时，可以通过  hashchange  事件来监听到 URL 的变化，从而进行跳转页面，并且无论哈希值如何变化，服务端接收到的 URL 请求永远是  <a href="http://www.test.com。" target="_blank" rel="noopener">www.test.com。</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(<span class="string">'hashchange'</span>, () =&gt; &#123;</span><br><span class="line">  // ... 具体逻辑</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Hash 模式相对来说更简单，并且兼容性也更好。</p>
<h5 id="History-模式"><a href="#History-模式" class="headerlink" title="History 模式"></a>History 模式</h5><p>History 模式是 HTML5 新推出的功能，主要使用  history.pushState  和  history.replaceState  改变 URL。<br>通过 History 模式改变 URL 同样不会引起页面的刷新，只会更新浏览器的历史记录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 新增历史记录</span><br><span class="line">history.pushState(stateObject, title, URL)</span><br><span class="line">// 替换当前历史记录</span><br><span class="line">history.replaceState(stateObject, title, URL)</span><br><span class="line">当用户做出浏览器动作时，比如点击后退按钮时会触发 popState 事件</span><br><span class="line">window.addEventListener(<span class="string">'popstate'</span>, e =&gt; &#123;</span><br><span class="line">  // e.state 就是 pushState(stateObject) 中的 stateObject</span><br><span class="line">  console.log(e.state)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h6 id="两种模式对比"><a href="#两种模式对比" class="headerlink" title="两种模式对比"></a>两种模式对比</h6><pre>
Hash 模式只可以更改  #  后面的内容，History 模式可以通过 API 设置任意的同源 URL
History 模式可以通过 API 添加任意类型的数据到历史记录中，Hash 模式只能更改哈希值，也就是字符串
Hash 模式无需后端配置，并且兼容性好。
History 模式在用户手动输入地址或者刷新页面的时候会发起 URL 请求，
        后端需要配置  index.html  页面用于匹配不到静态资源的时候
</pre>

<h4 id="Vue-和-React-之间的区别"><a href="#Vue-和-React-之间的区别" class="headerlink" title="Vue 和 React 之间的区别"></a>Vue 和 React 之间的区别</h4><p>Vue 的表单可以使用  v-model  支持双向绑定，相比于 React 来说开发上更加方便，当然了  v-model 其实就是个语法糖，本质上和 React 写表单的方式没什么区别。<br>改变数据方式不同，Vue 修改状态相比来说要简单许多，React 需要使用  setState  来改变状态，并且使用这个 API 也有一些坑点。并且 Vue 的底层使用了依赖追踪，页面更新渲染已经是最优的了，但是 React 还是需要用户手动去优化这方面的问题。<br>React 16 以后，有些钩子函数会执行多次，这是因为引入 Fiber 的原因，这在后续的章节中会讲到。<br>React 需要使用 JSX，有一定的上手成本，并且需要一整套的工具链支持，但是完全可以通过 JS 来控制页面，更加的灵活。Vue 使用了模板语法，相比于 JSX 来说没有那么灵活，但是完全可以脱离工具链，通过直接编写  render  函数就能在浏览器中运行。<br>在生态上来说，两者其实没多大的差距，当然 React 的用户是远远高于 Vue 的。<br>在上手成本上来说，Vue 一开始的定位就是尽可能的降低前端开发的门槛，然而 React 更多的是去改变用户去接受它的概念和思想，相较于 Vue 来说上手成本略高。</p>
<h4 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h4><p>Vue 内部使用了  Object.defineProperty()  来实现数据响应式，通过这个函数可以监听到  set  和  get  的事件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">var data = &#123; name: <span class="string">'yck'</span> &#125;</span><br><span class="line">observe(data)</span><br><span class="line"><span class="built_in">let</span> name = data.name // -&gt; get value</span><br><span class="line">data.name = <span class="string">'yyy'</span> // -&gt; change value</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> observe(obj) &#123;</span><br><span class="line">  // 判断类型</span><br><span class="line">  <span class="keyword">if</span> (!obj || typeof obj !== <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="built_in">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  Object.keys(obj).forEach(key =&gt; &#123;</span><br><span class="line">    defineReactive(obj, key, obj[key])</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> defineReactive(obj, key, val) &#123;</span><br><span class="line">  // 递归子属性</span><br><span class="line">  observe(val)</span><br><span class="line">  Object.defineProperty(obj, key, &#123;</span><br><span class="line">    // 可枚举</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    // 可配置</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    // 自定义函数</span><br><span class="line">    get: <span class="keyword">function</span> <span class="function"><span class="title">reactiveGetter</span></span>() &#123;</span><br><span class="line">      console.log(<span class="string">'get value'</span>)</span><br><span class="line">      <span class="built_in">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">set</span>: <span class="keyword">function</span> reactiveSetter(newVal) &#123;</span><br><span class="line">      console.log(<span class="string">'change value'</span>)</span><br><span class="line">      val = newVal</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码简单的实现了如何监听数据的  set  和  get  的事件，但是仅仅如此是不够的，因为自定义的函数一开始是不会执行的。只有先执行了依赖收集，才能在属性更新的时候派发更新，所以接下来我们需要先触发依赖收集。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;&#123;name&#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>在解析如上模板代码时，遇到    就会进行依赖收集。<br>接下来我们先来实现一个  Dep  类，用于解耦属性的依赖收集和派发更新操作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 通过 Dep 解耦属性的依赖和更新操作</span><br><span class="line">class Dep &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    this.subs = []</span><br><span class="line">  &#125;</span><br><span class="line">  // 添加依赖</span><br><span class="line">  addSub(sub) &#123;</span><br><span class="line">    this.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line">  // 更新</span><br><span class="line">  <span class="function"><span class="title">notify</span></span>() &#123;</span><br><span class="line">    this.subs.forEach(sub =&gt; &#123;</span><br><span class="line">      sub.update()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 全局属性，通过该属性配置 Watcher</span><br><span class="line">Dep.target = null</span><br></pre></td></tr></table></figure>
<p>以上的代码实现很简单，当需要依赖收集的时候调用  addSub，当需要派发更新的时候调用  notify。</p>
<h4 id="Vue-组件挂载时添加响应式的过程。"><a href="#Vue-组件挂载时添加响应式的过程。" class="headerlink" title="Vue 组件挂载时添加响应式的过程。"></a>Vue 组件挂载时添加响应式的过程。</h4><p>在组件挂载时，会先对所有需要的属性调用  Object.defineProperty()，然后实例化  Watcher，传入组件更新的回调。在实例化过程中，会对模板中的属性进行求值，触发依赖收集。<br>因为这一小节主要目的是学习响应式原理的细节，所以接下来的代码会简略的表达触发依赖收集时的操作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Watcher &#123;</span><br><span class="line">  constructor(obj, key, cb) &#123;</span><br><span class="line">    // 将 Dep.target 指向自己</span><br><span class="line">    // 然后触发属性的 getter 添加监听</span><br><span class="line">    // 最后将 Dep.target 置空</span><br><span class="line">    Dep.target = this</span><br><span class="line">    this.cb = cb</span><br><span class="line">    this.obj = obj</span><br><span class="line">    this.key = key</span><br><span class="line">    this.value = obj[key]</span><br><span class="line">    Dep.target = null</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">update</span></span>() &#123;</span><br><span class="line">    // 获得新值</span><br><span class="line">    this.value = this.obj[this.key]</span><br><span class="line">    // 调用 update 方法更新 Dom</span><br><span class="line">    this.cb(this.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是  Watcher  的简单实现，在执行构造函数的时候将  Dep.target  指向自身，从而使得收集到了对应的  Watcher，在派发更新的时候取出对应的  Watcher  然后执行  update  函数。<br>接下来，需要对  defineReactive  函数进行改造，在自定义函数中添加依赖收集和派发更新相关的代码。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> defineReactive(obj, key, val) &#123;</span><br><span class="line">  // 递归子属性</span><br><span class="line">  observe(val)</span><br><span class="line">  <span class="built_in">let</span> dp = new Dep()</span><br><span class="line">  Object.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    get: <span class="keyword">function</span> <span class="function"><span class="title">reactiveGetter</span></span>() &#123;</span><br><span class="line">      console.log(<span class="string">'get value'</span>)</span><br><span class="line">      // 将 Watcher 添加到订阅</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        dp.addSub(Dep.target)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">set</span>: <span class="keyword">function</span> reactiveSetter(newVal) &#123;</span><br><span class="line">      console.log(<span class="string">'change value'</span>)</span><br><span class="line">      val = newVal</span><br><span class="line">      // 执行 watcher 的 update 方法</span><br><span class="line">      dp.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上所有代码实现了一个简易的数据响应式，核心思路就是手动触发一次属性的 getter 来实现依赖收集。<br>现在我们就来测试下代码的效果，只需要把所有的代码复制到浏览器中执行，就会发现页面的内容全部被替换了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var data = &#123; name: <span class="string">'yck'</span> &#125;</span><br><span class="line">observe(data)</span><br><span class="line"><span class="keyword">function</span> update(value) &#123;</span><br><span class="line">  document.querySelector(<span class="string">'div'</span>).innerText = value</span><br><span class="line">&#125;</span><br><span class="line">// 模拟解析到 `&#123;&#123;name&#125;&#125;` 触发的操作</span><br><span class="line">new Watcher(data, <span class="string">'name'</span>, update)</span><br><span class="line">// update Dom innerText</span><br><span class="line">data.name = <span class="string">'yyy'</span></span><br></pre></td></tr></table></figure>
<h4 id="Object-defineProperty-的缺陷"><a href="#Object-defineProperty-的缺陷" class="headerlink" title="Object.defineProperty 的缺陷"></a>Object.defineProperty 的缺陷</h4><p>以上已经分析完了 Vue 的响应式原理，接下来说一点  Object.defineProperty  中的缺陷。<br>如果通过下标方式修改数组数据或者给对象新增属性并不会触发组件的重新渲染，因为  Object.defineProperty  不能拦截到这些操作，更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过重写函数的方式解决了这个问题。<br>对于第一个问题，Vue 提供了一个 API 解决</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> <span class="built_in">set</span> (target: Array&lt;any&gt; | Object, key: any, val: any): any &#123;</span><br><span class="line">  // 判断是否为数组且下标是否有效</span><br><span class="line">  <span class="keyword">if</span> (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123;</span><br><span class="line">    // 调用 splice 函数触发派发更新</span><br><span class="line">    // 该函数已被重写</span><br><span class="line">    target.length = Math.max(target.length, key)</span><br><span class="line">    target.splice(key, 1, val)</span><br><span class="line">    <span class="built_in">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  // 判断 key 是否已经存在</span><br><span class="line">  <span class="keyword">if</span> (key <span class="keyword">in</span> target &amp;&amp; !(key <span class="keyword">in</span> Object.prototype)) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    <span class="built_in">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  const ob = (target: any).__ob__</span><br><span class="line">  // 如果对象不是响应式对象，就赋值返回</span><br><span class="line">  <span class="keyword">if</span> (!ob) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    <span class="built_in">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  // 进行双向绑定</span><br><span class="line">  defineReactive(ob.value, key, val)</span><br><span class="line">  // 手动派发更新</span><br><span class="line">  ob.dep.notify()</span><br><span class="line">  <span class="built_in">return</span> val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于数组而言，Vue 内部重写了以下函数实现派发更新</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 获得数组原型</span><br><span class="line">const arrayProto = Array.prototype</span><br><span class="line"><span class="built_in">export</span> const arrayMethods = Object.create(arrayProto)</span><br><span class="line">// 重写以下函数</span><br><span class="line">const methodsToPatch = [ <span class="string">'push'</span>, <span class="string">'pop'</span>, <span class="string">'shift'</span>, <span class="string">'unshift'</span>, <span class="string">'splice'</span>, <span class="string">'sort'</span>, <span class="string">'reverse'</span> ]</span><br><span class="line">methodsToPatch.forEach(<span class="keyword">function</span> (method) &#123;</span><br><span class="line">  // 缓存原生函数 const original = arrayProto[method]</span><br><span class="line">  // 重写函数</span><br><span class="line">  def(arrayMethods, method, <span class="keyword">function</span> mutator (...args) &#123;</span><br><span class="line">    // 先调用原生函数获得结果</span><br><span class="line">    const result = original.apply(this, args) const ob = this.__ob__ <span class="built_in">let</span> inserted</span><br><span class="line">    // 调用以下几个函数时，监听新数据</span><br><span class="line">    switch (method) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'push'</span>: <span class="keyword">case</span> <span class="string">'unshift'</span>: inserted = args <span class="built_in">break</span> <span class="keyword">case</span> <span class="string">'splice'</span>: inserted = args.slice(2) <span class="built_in">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inserted) ob.observeArray(inserted)</span><br><span class="line">    // 手动派发更新</span><br><span class="line">    ob.dep.notify() <span class="built_in">return</span> result</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h4><p>想必大家在使用 Vue 开发的过程中，基本都是使用模板的方式。那么你有过「模板是怎么在浏览器中运行的」这种疑虑嘛？<br>首先直接把模板丢到浏览器中肯定是不能运行的，模板只是为了方便开发者进行开发。Vue 会通过编译器将模板通过几个阶段最终编译为  render  函数，然后通过执行  render  函数生成 Virtual DOM 最终映射为真实 DOM。<br>接下来我们就来学习这个编译的过程，了解这个过程中大概发生了什么事情。这个过程其中又分为三个阶段，分别为：<br>将模板解析为 AST</p>
<h5 id="优化-AST"><a href="#优化-AST" class="headerlink" title="优化 AST"></a>优化 AST</h5><p>将 AST 转换为  render  函数<br>在第一个阶段中，最主要的事情还是通过各种各样的正则表达式去匹配模板中的内容，然后将内容提取出来做各种逻辑操作，接下来会生成一个最基本的 AST 对象</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // 类型</span><br><span class="line">    <span class="built_in">type</span>: 1,</span><br><span class="line">    // 标签</span><br><span class="line">    tag,</span><br><span class="line">    // 属性列表</span><br><span class="line">    attrsList: attrs,</span><br><span class="line">    // 属性映射</span><br><span class="line">    attrsMap: makeAttrsMap(attrs),</span><br><span class="line">    // 父节点</span><br><span class="line">    parent,</span><br><span class="line">    // 子节点</span><br><span class="line">    children: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后会根据这个最基本的 AST 对象中的属性，进一步扩展 AST。<br>当然在这一阶段中，还会进行其他的一些判断逻辑。比如说对比前后开闭标签是否一致，判断根组件是否只存在一个，判断是否符合 HTML5 Content Model  规范等等问题。<br>接下来就是优化 AST 的阶段。在当前版本下，Vue 进行的优化内容其实还是不多的。只是对节点进行了静态内容提取，也就是将永远不会变动的节点提取了出来，实现复用 Virtual DOM，跳过对比算法的功能。在下一个大版本中，Vue 会在优化 AST 的阶段继续发力，实现更多的优化功能，尽可能的在编译阶段压榨更多的性能，比如说提取静态的属性等等优化行为。<br>最后一个阶段就是通过 AST 生成  render  函数了。其实这一阶段虽然分支有很多，但是最主要的目的就是遍历整个 AST，根据不同的条件生成不同的代码罢了。</p>
<h5 id="NextTick-原理分析"><a href="#NextTick-原理分析" class="headerlink" title="NextTick 原理分析"></a>NextTick 原理分析</h5><p>nextTick  可以让我们在下次 DOM 更新循环结束之后执行延迟回调，用于获得更新后的 DOM。<br>在 Vue 2.4 之前都是使用的 microtasks，但是 microtasks 的优先级过高，在某些情况下可能会出现比事件冒泡更快的情况，但如果都使用 macrotasks 又可能会出现渲染的性能问题。所以在新版本中，会默认使用 microtasks，但在特殊情况下会使用 macrotasks，比如 v-on。<br>对于实现 macrotasks ，会先判断是否能使用  setImmediate ，不能的话降级为  MessageChannel ，以上都不行的话就使用  setTimeout</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (typeof setImmediate !== <span class="string">'undefined'</span> &amp;&amp; isNative(setImmediate)) &#123;</span><br><span class="line">  macroTimerFunc = () =&gt; &#123;</span><br><span class="line">    setImmediate(flushCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">  typeof MessageChannel !== <span class="string">'undefined'</span> &amp;&amp;</span><br><span class="line">  (isNative(MessageChannel) ||</span><br><span class="line">    // PhantomJS</span><br><span class="line">    MessageChannel.toString() === <span class="string">'[object MessageChannelConstructor]'</span>)</span><br><span class="line">) &#123;</span><br><span class="line">  const channel = new MessageChannel()</span><br><span class="line">  const port = channel.port2</span><br><span class="line">  channel.port1.onmessage = flushCallbacks</span><br><span class="line">  macroTimerFunc = () =&gt; &#123;</span><br><span class="line">    port.postMessage(1)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  macroTimerFunc = () =&gt; &#123;</span><br><span class="line">    setTimeout(flushCallbacks, 0)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码很简单，就是判断能不能使用相应的 API。</p>
 
        <div class="post-reward">
          <a id="rewardBtn" href="javascript:;" class="post-reward-btn waves-effect waves-circle waves-light">赏</a>
        </div>
        

        <blockquote>
          <p>
            本文地址：
            <a href="http://blog.bochunhao.cn/2018/10/26/mvvm/" target="_blank" rel="external">http://blog.bochunhao.cn/2018/10/26/mvvm/</a>
          </p>
          <footer>
            <cite><a href="http://blog.bochunhao.cn" target="_blank" rel="external">@个人博客</a></cite>
          </footer>
        </blockquote>
      </div>
      
<nav class="post-nav">
  

  
    <div class="waves-block waves-effect next fr">
      <a href="/2018/10/03/webpack/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">webpack</h4>
      </a>
    </div>
  
</nav>

 
<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="mvvm" data-title="mvvm" data-url="http://blog.bochunhao.cn/2018/10/26/mvvm/index.html"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"ysblog"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>





    </div>
  </div>
</article>

<div id="reward" class="reward-lay">
    <a class="reward-off" id="rewardOff" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        感谢支持
        <i class="icon icon-quote-right"></i>
    </h3>
    <ul class="reward-items">
        
        <li>
            <img src="/img/vx.png" title="微信打赏二维码" alt="微信打赏二维码">
            <p>微信</p>
        </li>
        

        
        <li>
            <img src="/img/zfb.png" title="支付宝打赏二维码" alt="支付宝打赏二维码">
            <p>支付宝</p>
        </li>
        
    </ul>
</div>


    </div>
  </main>
<div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>

<script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>

<script src="/js/main.js"></script>



<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<script type="text/template" id="search-tpl">
<li class="item">
    <a href="/{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</script>

<script src="/js/search.js"></script>









</body>
</html>
